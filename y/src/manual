usage:
  [y banco fromCSV -outTable tabelaA selectInsert]
  [y banco conn,hash [select|selectInsert|selectCSV] [|select..]]
  [y banco conn,hash executeInsert]
  [y banco conn,hash execute [|execute..]]
  [y banco conn,hash createjobexecute]
  [y banco [connIn,hash|fileCSV,file] connOut,hash -outTable tabelaA [|trunc|createTable] [carga|createjobcarga]]
  [y banco executejob]
  [y banco buffer [|-n_lines 4000] [|-log buffer.log]]
  [y selectCSV]
  [y xlsxToCSV]
  [y token]
  [y gettoken]
  [y json]
  [y zip]
  [y gzip]
  [y gunzip]
  [y tar]
  [y untar]
  [y tarlist]
  [y echo]
  [y printf]
  [y cat]
  [y xor]
  [y md5]
  [y sha1]
  [y sha256]
  [y aes]
  [y base64]
  [y grep]
  [y wc -l]
  [y len]
  [y head]
  [y tail]
  [y cut]
  [y curl]
  [y [sed|tr]]
  [y n]
  [y rn]
  [y [bytesToInts|bi]]
  [y [intsToBytes|ib]]
  [y od]
  [y touch]
  [y rm]
  [y cp]
  [y mv]
  [y cd]
  [y iconv]
  [y tee]
  [y uniq]
  [y quebra]
  [y seq]
  [y add]
  [y awk print]
  [y dev_null]
  [y dev_in]
  [y scp]
  [y execSsh]
  [y ssh]
  [y sshinfo]
  [y sftp]
  [y serverRouter]
  [y httpServer]
  [y wget]
  [y pwd]
  [y find]
  [y ls]
  [y split]
  [y regua]
  [y link]
  [y os]
  [y date]
  [y cronometro]
  [y clear]
  [y cls]
  [y help]

Exemplos...

[y banco fromCSV -outTable tabelaA selectInsert]
    cat arquivo.csv | y banco fromCSV -outTable tabelaA selectInsert
[y banco conn,hash [select|selectInsert|selectCSV] [|select..]]
    echo "select 1 from dual" | y banco conn,hash select
    y banco conn,hash select "select 1 from dual"
    echo "select * from tabela1" | y banco conn,hash selectInsert
    cat select.sql | y banco conn,hash selectCSV
    y banco -conn conn.. selectInsert
[y banco conn,hash executeInsert]
    cat listaDeInsert.sql | y banco conn,hash executeInsert
    echo "insert into tabela1 values(1,2,3)" | y banco conn,hash executeInsert
    echo "insert into tabela1 values(1,2,3);" | y banco conn,hash executeInsert
[y banco conn,hash execute [|execute..]]
    echo "truncate table tabela1" | y banco conn,hash execute
    y banco conn,hash execute "drop table tabela1"
    cat blocoAnonimo | y banco conn,hash execute
[y banco conn,hash createjobexecute]
    echo "truncate table tabela1" | y banco conn,hash createjobexecute
[y banco [connIn,hash|fileCSV,file] connOut,hash -outTable tabelaA [|trunc|createTable] [carga|createjobcarga]]
    echo "select * from TABELA_AAA" | y banco connIn,hash connOut,hash -outTable TABELA_BBB carga
    echo "select * from TABELA_AAA" | y banco connIn,hash connOut,hash -outTable TABELA_BBB trunc carga
    echo "select * from TABELA_AAA" | y banco connIn,hash connOut,hash -outTable TABELA_BBB createTable carga
    y banco -fileCSV arquivo.csv connOut,hash -outTable TABELA_CCC carga
    y banco -fileCSV arquivo.csv connOut,hash -outTable TABELA_CCC trunc carga
    y banco -fileCSV arquivo.csv connOut,hash -outTable TABELA_CCC createTable carga
[y banco executejob]
    (
        echo "select * from TABELA_AAA" | y banco connIn,hash connOut,hash -outTable TABELA_BBB trunc createjobcarga
        echo "select * from TABELA_CCC" | y banco connIn,hash connOut,hash -outTable TABELA_CCC trunc createjobcarga
    ) | y banco executejob
[y banco buffer [|-n_lines 4000] [|-log buffer.log]]    
    echo "select * from TABELA1 | y banco conn,hash selectInsert | y banco buffer -n_lines 4000 -log buffer.log | y banco conn,hash executeInsert
[y selectCSV]
    y cat file.csv | y selectCSV "select * from this"
    y selectCSV -csv file.csv "select * from this"
    y selectCSV -csv file.csv -sql consulta.sql
[y xlsxToCSV]
    xlsxToCSV arquivo.xlsx mostraEstrutura
    xlsxToCSV arquivo.xlsx listaAbas
    xlsxToCSV arquivo.xlsx numeroAba 1
    xlsxToCSV arquivo.xlsx nomeAba Planilha1
    xlsxToCSV arquivo.xlsx exportAll
    obs: pegando a primeira aba => xlsxToCSV arquivo.xlsx numeroAba 1
[y xml]
    cat arquivo.xml | y xml mostraEstrutura
    xml arquivo.xml mostraEstrutura
    cat arquivo.xml | y xml mostraTags
[y token]
    y token value
[y gettoken]
    y gettoken hash
[y json]
   y cat file.json | y json mostraEstrutura
   y cat file.json | y json mostraTabela
   y cat file.json | y json "[elem for elem in data['items']]"
   y cat file.json | y json "[elem['id'] for elem in data['items']]"
   y cat file.json | y json "[elem['id'] for elem in data]"
   y cat file.json | y json list "[elem['id'] for elem in data]"
[y zip]
    y zip add File1.txt > saida.zip
    cat File1.txt | y zip add -name File1.txt > saida.zip
    y zip add /pasta1 > saida.zip
    y zip list arquivo.zip
    cat arquivo.zip | y zip list
    y zip extract entrada.zip
    cat entrada.zip | y zip extract
    y zip extract entrada.zip -out /destino
    cat entrada.zip | y zip extract -out /destino
    y zip extractSelected entrada.zip pasta1/unicoArquivoParaExtrair.txt -out /destino
    cat entrada.zip | y zip extractSelected pasta1/unicoArquivoParaExtrair.txt -out /destino
    y zip extractSelected entrada.zip pasta1/unicoArquivoParaExtrair.txt > /destino/unicoArquivoParaExtrair.txt
    cat entrada.zip | y zip extractSelected pasta1/unicoArquivoParaExtrair.txt > /destino/unicoArquivoParaExtrair.txt
    obs: se add pasta e a descricao de pasta tem "/" ou "\\" então o pacote terá o conteudo da pasta, caso contrário terá a pasta citada+conteudo.
[y gzip]
    cat arquivo | y gzip > arquivo.gz
[y gunzip]
    cat arquivo.gz | y gunzip > arquivo
[y tar]
    y tar in > test.tar
    y tar test.tar in
    obs: suporta arquivo com ateh 8 gigas
[y untar]
    y cat test.tar | y untar
    y untar test.tar
    y untar test.tar in/in2/only
[y tarlist]
    y tarlist test.tar
[y echo]
    echo a b c
    echo "a b c"
    echo "a*"
[y printf]
    echo a b c
    echo "a b c"
    obs: diferente do echo, o printf nao gera \n no final
    obs2: echo -n AA gera o mesmo efeito que, printf AA
[y cat]
    y cat arquivo
[y xor]
    y cat file | y xor 100
    y cat file | y xor 100
    obs: valor entre 0 e 255. Por padrao 100
[y md5]
    cat arquivo | y md5
[y sha1]
    cat arquivo | y sha1
[y sha256]
    cat arquivo | y sha256
[y aes]
    cat arquivo | y aes SENHA | y base64
    cat arquivo | y aes -e SENHA | y base64
    cat arquivo | y aes -d SENHA | y base64
    cat arquivo | y aes -e SENHA -md MD5 | y base64
    cat arquivo | y aes -e SENHA -md SHA256 | y base64
    cat arquivo | y aes -e SENHA -md SHA-256 | y base64
    cat arquivo | y aes -e SENHA -md MD5 -S AAAAAAAAAAAAAAAA | y base64
    obs: O comando "y aes -e SENHA -md MD5 -S AAAAAAAAAAAAAAAA" equivale à "openssl aes-256-cbc -e -k SENHA -md MD5 -S AAAAAAAAAAAAAAAA"
    obs2: O valor de salt(-S) deverá contér 16 hexas maiúsculos, ex: AAAAAAAAAAAAAAAA
    obs3: Se utilizar o salt na encriptacao, entao devera utilizar o mesmo salt na decriptacao
[y base64]
    cat arquivo | y base64
    cat arquivo | y base64 -d
    y base64 -e "texto"
    y base64 -d "YQ=="
    y printf "texto" | base64 -e 
    obs: -e para encode e -d para decode
[y grep]
    cat arquivo | y grep ^Texto$
    cat arquivo | y grep AB
    cat arquivo | y grep -i -v aa bb cc
[y wc -l]
    cat arquivo | y wc -l
[y len]
    cat arquivo | y len
    obs: echo aabaa | tr b "\n" | y len
    result: 2
            2
[y head]
    cat arquivo | y head
    cat arquivo | y head -30
[y tail]
    cat arquivo | y tail
    cat arquivo | y tail -30
[y cut]
    cat arquivo | y cut -c-10
    cat arquivo | y cut -c5-10
    cat arquivo | y cut -c5-
    cat arquivo | y cut -c5
    cat arquivo | y cut -c5-10,15-17
[y curl]
    echo '{"id":1}' | y curl \
        -H "Content-Type: application/json" \
        -H "other: other" \
        -X POST http://localhost:8080/v1/movies
    cat file | y curl \
        -H "Content-Type: application/json" \
        -X POST http://localhost:8080/v1/movies
    curl http://localhost:8080/v1/movies
    obs: -v => verbose
[y [sed|tr]]
    cat arquivo | y sed A B
    cat arquivo | y sed A B E F
    obs: sed com dois parametros é performatico e aceita por exemplo \n como quebra
[y n]
    cat arquivo | y n
    obs: modifica arquivo \r\n para \n(se ja tiver \n nao tem problema)
[y rn]
    cat arquivo | y rn
    obs: modifica arquivo \n para \r\n(se ja tiver \r\n nao tem problema)
[y [bytesToInts|bi]]
    cat arquivo | y bytesToInts
    cat arquivo | y bi
    cat arquivo | y bi -128
    obs entrada: arquivo binario
    obs saida: lista de numeros bytes(0..255)
    obs2 bi == bytesToInts
[y [intsToBytes|ib]]
    echo 55 | y intsToBytes
    cat arquivo | y intsToBytes
    cat arquivo | y ib
    y intsToBytes 20 20
    y ib 20 20
    obs entrada: lista de numeros bytes(0..255)
    obs saida: arquivo binario
    obs2 por conceito, os bytes variam entre -128..127, mas aqui usaremos 0..255
    obs3 ib == intsToBytes
[y od]
    cat arquivo | od
    cat arquivo | od -bc
    cat arquivo | od -bcr
    obs: -r mostra numero bytes
         -b octal bytes
         -c character
[y touch]
    y touch fileA
    y touch fileA -3600
    y touch fileA 60
    y touch fileA 20210128235959
    obs: 60(60 segundos a frente)
    obs2: -3600(3600 segundos atrás)
    obs3: 20210128235959(setando em 28/01/2021 23:59:59)
[y rm]
    y rm file1 file2
    y rm -R pasta
    y rm -R pasta1 file1
[y cp]
    y cp file1 file2
    y cp -R pasta1 pasta2
    obs: se a pasta2 nao existir entao é criado a cópia com o nome pasta2, se existir é copiado dentro da pasta(se dentro da pasta existir ai eh feito overwrite)
[y mv]
    y mv file1 file2
    y mv pasta1 pasta2
[y cd]
    y cd
    obs: equivalente a cd $HOME no linux e cd %userprofile% no windows
[y mkdir]
    y mkdir pasta1
[y iconv]
    y iconv -f UTF-8 -t ISO-8859-1 file
    cat file | y iconv -f UTF-8 -t ISO-8859-1 
    cat file | y i1
    cat file | y iconv -f ISO-8859-1 -t UTF-8
    cat file | y i2
    obs: tipos suportados: "ISO-8859-1","UTF-8","UTF-8BOM","UCS-2LE","UCS-2LEBOM"
    obs2: convert UTF-8 para ISO-8859-1(padrao windows, equivalente ao ANSI do notepad e equivalente ao windows-1252)
    obs3: BOM do UTF-8 em numerico => 239 187 191
    obs4: BOM do UCS-2LE em numerico => 255 254
[y tee]
    cat arquivo | y tee saida.txt
[y uniq]
    cat arquivo | y uniq
[y quebra]
    cat arquivo | y quebra
[y seq]
    y seq 1 10 2
    y seq 5 7
    y seq 9 -10
    y seq 2022-09-19 2022-11-19
    y seq 19/11/2022 19/09/2022
[y add]
    y add 2022-09-19
    y add 19/09/2022
[y awk]
    cat arquivo | y awk print 1 3 5,6
    cat arquivo | y awk print -1
    cat arquivo | y awk start AAA end BBB    
    cat arquivo | y awk start AAA
    cat arquivo | y awk end BBB    
    cat arquivo | y awk -v start AAA end BBB    
    cat arquivo | y awk -v start AAA
    cat arquivo | y awk -v end BBB    
    obs: "-v" é a negativa
    obs2: start e end pode ocorrer varias vezes no texto
    obs3: -1 significa o ultimo
[y dev_null]
    cat arquivo | y banco buffer -n_lines 4000 -log buffer.log | y dev_null
    cat arquivo | y banco buffer -n_lines 4000 -log buffer.log > /dev/null
[y dev_in]
    y dev_in | y banco buffer -n_lines 4000 -log buffer.log | y dev_null
    y dev_in | y banco buffer -n_lines 4000 -log buffer.log > /dev/null
    obs: ref. a dd if e dd of
[y scp]
    y scp file1 user,pass@servidor:file2
    y scp file1 user,pass@servidor:file2 22
    y scp user,pass@servidor:file1 file2
    y scp user,pass@servidor:file1 file2 22
    comando para windows nao testado abaixo:
    y scp user,pass@servidor:/c/temp file2 22
    obs: user,pass ou user
[y execSsh]
    y execSsh user,pass@servidor command
    y execSsh user,pass@servidor command 22
    obs: user,pass ou user
[y ssh]
    y ssh user,pass@servidor
    y ssh user,pass@servidor 22
    obs: user,pass ou user(dependendo da origem e destino windows buga)
[y sshinfo]
    y sshinfo
    y sshinfo 192.168.0.100
    y sshinfo 192.168.0.100 22
[y sftp]
    y sftp user,pass@servidor
    y sftp user,pass@servidor 22
    obs: user,pass ou user
[y serverRouter]
    y serverRouter [ipA] 8080 [ipB] 9090
    y serverRouter 192.168.0.100 8080 localhost 9090
    y serverRouter 192.168.0.100 8080 localhost 9090 show
    y serverRouter 192.168.0.100 8080 localhost 9090 showOnlySend
    y serverRouter 192.168.0.100 8080 localhost 9090 showOnlyReceive
    y serverRouter 192.168.0.100 8080 localhost 9090 showSimple
    y serverRouter localhost 8080 localhost 9090
    y serverRouter localhost 8080 localhost 9090 show
    y serverRouter localhost 8080 localhost 9090 showOnlySend
    y serverRouter localhost 8080 localhost 9090 showOnlyReceive
    y serverRouter localhost 8080 localhost 9090 showSimple
    obs:
        [ipA] -> Router -> [ipB]
        [ipA] conecta no router que conecta no [ipB]
[y httpServer]
    y httpServer
    obs: o comando acima irá criar um httpServer temporario com parametros padroes
    y httpServer localhost pagina_toke_zzz111 "Lista de arquivos" 8888 "/dir" "" ""
    parametros: host(pode ser ""), titulo_url, titulo, port, dir, endsWiths(ex: "","jar,zip"), ips_banidos(ex: "","8.8.8.8,4.4.4.4")
[y playlist]
    y playlist
    y playlist 192.168.0.100
    y playlist 192.168.0.100 8888
    obs: na pasta de musicas, criar o arquivo start_.bat contendo y playlist 192.168.0.100, no browser abrir http://192.168.0.100:8888/
[y wget]
    y wget -h
[y pwd]
    y pwd
[y find]
    y find
    y find .
    y find /
    y find . -mtime -1  # arquivos recentes de 1 dia para menos
    y find . -mtime 0.5 # arquivos recentes a mais de 12 horas
    obs: -L para considerar SymbolicLink, ex: y find -L /
[y ls]
    y ls
    y ls pasta1
    y ls "pas*"
[y sleep]
    y sleep
    y sleep 0.22 # 0.22 seconds
[y split]
    y cat fileA | y split -b 22
    y cat fileA | y split -l 22
    y cat fileA | y split --lines=22
    y cat fileA | y split --bytes=22
    y split --lines=22 --prefix=AA fileA # AAxxa
[y regua]
    y regua
    y regua 90
[y link]
    y link /opt/original original_linked
    y link c:\\tmp\\original original_linked
    y link a b
    obs: original_linked sendo o link criado que aponta para /opt/original
    internal command windows: mklink /j original_linked c:\\tmp\\original
    internal command nao windows: ln -s /opt/original original_linked
[y os]
    y os
    obs: exibe informacoes do sistema operacional[windows/mac/linux/unix]
[y date]
    y date
    y date "+%Y%m%d_%H%M%S"
    y date "+%d/%m/%Y %H:%M:%S:%N %Z %s"
[y uptime]
    y uptime
    y uptime -ms
[y cronometro]
    y cronometro
    y cronometro start
    y cronometro flag
    y cronometro end
    obs: "y cronometro" dispara o comando equivalente a flag a cada enter pressionado.
[y clear]
    y clear
    obs: alternativa y cls
[y cls]
    y cls
    obs: alternativa y clear
[y help]
    y help <command>
    y help router

Exemplo de conn: -conn "jdbc:oracle:thin:@//host_name:1521/service_name|login|senha"
Exemplo de conn: -conn "jdbc:oracle:thin:@host_name:1566:sid_name|login|senha"

Observações:
entrada de dados pode ser feito por |
export STATUS_FIM_Y=path/fim.log para receber a confirmação de fim de processamento de selectCSV
export COUNT_Y=path/count.log para receber a quantidade de linhas geradas no CSV(sem o header) do comando selectCSV
export CSV_SEP_Y="|" para utilizar um separador diferente, pode ser usado tanto em leitura de csv quanto gravação
export CSV_ONLYCHAR_Y="S" usado para nao imprimir aspas duplas em numericos, pode ser usado na gravação de csv, quanto a leitura de csv nao precisa, a leitura ja interpreta automaticamente isso
export FORMAT_DATA_Y="TZ" deixando a data 10/10/2010T10:10:10Z
export FORMAT_DATA_Y="UTC" deixando a data 10/10/2010 10:10:10 UTC
export FORMAT_DATA_Y="NATAL" toda data será na data do natal ex 25/12/2010 10:10:15
export FORMAT_DATA_Y="YYYY-MM-DD" 2010-07-07 12:12:12
export COM_SEPARADOR_FINAL_CSV_Y="S" ex: "a";"a"; o padrao seria "a";"a"
export SEM_HEADER_CSV_Y="S"

Dica: copiar o arquivo hash do token pra o nome do banco. cd $TOKEN_Y;cp 38b3492c4405f98972ba17c0a3dc072d servidor;
Dica2: vendo os tokens: grep ":" $TOKEN_Y/*
Dica3: vendo warnnings ORA: cat $ORAs_Y

alias no windows(criar arquivo c:\Windows\System32\y.bat com o conteudo abaixo):
@echo off
java -cp c:\\y;c:\\y\\ojdbc6.jar;c:\\y\\sqljdbc4-3.0.jar;c:\\y\\jsch-0.1.55.jar Y %1 %2 %3 %4 %5 %6 %7 %8 %9

alias no linux:
alias y='java -cp /y:/y/ojdbc6.jar:/y/sqljdbc4-3.0.jar:/y/jsch-0.1.55.jar Y'

