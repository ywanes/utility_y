/*
    curl https://www.datanucleus.org/downloads/maven2/oracle/ojdbc6/11.2.0.3/ojdbc6-11.2.0.3.jar > ojdbc6.jar
    curl https://repo.clojars.org/com/microsoft/sqljdbc4/3.0/sqljdbc4-3.0.jar > sqljdbc4-3.0.jar
    curl http://121.42.227.72:8081/nexus/content/groups/public/mysql/mysql-connector-java/8.0.26/mysql-connector-java-8.0.26.jar > mysql-connector-java-8.0.26.jar
    curl https://ufpr.dl.sourceforge.net/project/jsch/jsch.jar/0.1.55/jsch-0.1.55.jar > jsch-0.1.55.jar
    curl https://raw.githubusercontent.com/ywanes/utility_y/master/y/src/Y.java > Y.java
    javac -encoding UTF-8 -cp ojdbc6.jar:sqljdbc4-3.0.jar:mysql-connector-java-8.0.26.jar:jsch-0.1.55.jar:. Y.java
    javac -encoding UTF-8 -cp ojdbc6.jar;sqljdbc4-3.0.jar;mysql-connector-java-8.0.26.jar;jsch-0.1.55.jar;. Y.java
    alias y='java -Dfile.encoding=UTF-8 -cp /opt/y:/opt/y/ojdbc6.jar:/opt/y/sqljdbc4-3.0.jar:/opt/y/mysql-connector-java-8.0.26.jar:/opt/y/jsch-0.1.55.jar:. Y'
    y cls && java -Dfile.encoding=UTF-8 -cp c:\\y;c:\\y\\ojdbc6.jar;c:\\y\\sqljdbc4-3.0.jar;c:\\y\\mysql-connector-java-8.0.26.jar;c:\\y\\postgresql-42.7.5.jar;c:\\y\\jsch-0.1.55.jar Y.java
    java -XshowSettings 2>&1 | grep "file.encoding "
    configurando terminal windows cmd -> chcp 65001
    rc linux -> echo $?
    rc windows -> echo %ERRORLEVEL%
y.bat(c:/windows)
@echo off
(set \n=^^^

^

)
if "%1" equ "echo" (
echo %* | y trataEcho -ignore "Se Vc esta lendo esta msg, significa que ocorreu o bug de " na quantidade impar"
) else (
if "%1" equ "printf" (
echo %* | y trataPrintf -ignore "Se Vc esta lendo esta msg, significa que ocorreu o bug de " na quantidade impar"
) else (
java -Dfile.encoding=UTF-8 -Dline.separator=%\n% -cp c:\\y;c:\\y\\ojdbc6.jar;c:\\y\\sqljdbc4-3.0.jar;c:\\y\\mysql-connector-java-8.0.26.jar;c:\\y\\jsch-0.1.55.jar Y %1 %2 %3 %4 %5 %6 %7 %8 %9
)
)

cd0.bat(c:/windows)
@echo off
set argC=0
for %%x in (%*) do Set /A argC+=1
if "%argC%" equ "0" (
pushd %userprofile%
) else (
pushd %*
)

arquivo config.reg
Windows Registry Editor Version 5.00

[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Command Processor]
"Autorun"="doskey cd=cd0 $* && chcp 65001 && doskey cat=y cat $* && doskey printf=y printf $* && doskey sed=y sed $* && doskey ls=y ls $* && doskey lss=y lss $* && doskey pss=y pss $* && doskey du=y du $*"

Obs:
doskey grep=y grep nao funciona porque doskey nao funciona apos |

install daemon(cmd adm) // http://nssm.cc/download
y echo "y d -server" > D:\ProgramFiles\yd.bat
nssm install yd D:\ProgramFiles\yd.bat
nssm start yd
nssm status yd
nssm stop yd
nssm remove yd
nssm restart yd
y pss | y grep -server | y grep Y | y grep -v grep
depois de um tempo o comando de cima some?

créditos "ssh/scp/sftp/sshExec" https://ufpr.dl.sourceforge.net/project/jsch/jsch.jar/0.1.55/jsch-0.1.55.jar 
créditos https://github.com/is/jsch/tree/master/examples

Graalvm
#alias y='java -Dfile.encoding=UTF-8 -cp /opt/y:/opt/y/ojdbc6.jar:/opt/y/sqljdbc4-3.0.jar:/opt/y/mysql-connector-java-8.0.26.jar:/opt/y/jsch-0.1.55.jar:. Y'
#curl https://raw.githubusercontent.com/ywanes/utility_y/master/y/src/Y.java | y awk -v start REMOVED_GRAAL_START end REMOVED_GRAAL_END > Y.java
y cat D:/DADOSSSSS/Desktopsss/desktop/utility_y/utility_y/y/src/Y.java | y awk -v start REMOVED_GRAAL_START end REMOVED_GRAAL_END > Y.java
javac -encoding UTF-8 Y.java
native-image -Dfile.encoding=UTF-8 --no-fallback Y
y mv y.exe y2.exe
*/

//REMOVED_GRAAL_START
import com.jcraft.jsch.*;
//REMOVED_GRAAL_END
import java.awt.*;
import java.awt.GridBagConstraints;
import java.awt.Insets;
import java.awt.event.ComponentEvent;
import java.awt.event.ComponentListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.image.BufferedImage;
import java.io.*;
import java.lang.reflect.InvocationTargetException;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.net.*;
import java.net.ServerSocket;
import java.net.Socket;
import java.nio.ByteBuffer;
import java.nio.charset.Charset;
import java.security.MessageDigest;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.Statement;
import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.List;
import java.util.Random;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;
import java.util.zip.ZipInputStream;
import javax.swing.JPasswordField;
import javax.swing.JTextField;
import javax.swing.ProgressMonitor;
import java.net.HttpURLConnection;
import java.net.InetSocketAddress;
import java.net.Proxy;
import java.net.URL;
import java.net.URLConnection;
import java.nio.channels.ByteChannel;
import java.nio.channels.CancelledKeyException;
import java.nio.channels.ClosedByInterruptException;
import java.nio.channels.SelectableChannel;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.nio.charset.CharacterCodingException;
import java.nio.charset.CharsetDecoder;
import java.nio.charset.CodingErrorAction;
import java.nio.charset.StandardCharsets;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.attribute.PosixFilePermission;
import java.security.KeyManagementException;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Base64;
import java.util.Calendar;
import java.util.Collection;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.ListIterator;
import java.util.Locale;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.TimeZone;
import java.util.TreeMap;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.BiPredicate;
import java.util.function.Function;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.zip.DataFormatException;
import java.util.zip.Deflater;
import java.util.zip.Inflater;
import java.util.zip.ZipOutputStream;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLEngine;
import javax.net.ssl.SSLEngineResult;
import static javax.net.ssl.SSLEngineResult.HandshakeStatus.FINISHED;
import static javax.net.ssl.SSLEngineResult.HandshakeStatus.NEED_TASK;
import static javax.net.ssl.SSLEngineResult.HandshakeStatus.NEED_UNWRAP;
import static javax.net.ssl.SSLEngineResult.HandshakeStatus.NEED_WRAP;
import static javax.net.ssl.SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING;
import static javax.net.ssl.SSLEngineResult.Status.BUFFER_OVERFLOW;
import static javax.net.ssl.SSLEngineResult.Status.BUFFER_UNDERFLOW;
import static javax.net.ssl.SSLEngineResult.Status.CLOSED;
import static javax.net.ssl.SSLEngineResult.Status.OK;
import javax.net.ssl.SSLException;
import javax.net.ssl.SSLParameters;
import javax.net.ssl.SSLSession;
import javax.net.ssl.SSLSocket;
import javax.net.ssl.SSLSocketFactory;
import javax.sound.sampled.AudioFormat;
import javax.swing.JOptionPane;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JButton;
import java.awt.event.MouseAdapter;
import java.text.DecimalFormat;


@SuppressWarnings({"unchecked", "deprecation"})
public class Y extends Util{    
    public static String local_env=null;
    //public static String local_env="c:\\tmp";
    
    public static String linhaCSV=null;
    public static int ponteiroLinhaCSV=0;        
    public static int n_lines_buffer_DEFAULT=4000;        
    public String [] ORAs=new String[]{};
    public String [] suportIconv=new String[]{"ISO-8859-1","UTF-8","UTF-8BOM","UCS-2LE","UCS-2LEBOM"};
    public int [] BOM_UTF_8=new int[]{239,187,191};    
    public int [] BOM_UCS_2LE=new int[]{255,254};        
    
    // octal bytes
    public static String [] OD_BC_B=new String[]{ " 000"," 001"," 002"," 003"," 004"," 005"," 006"," 007"," 010"," 011",
        " 012"," 013"," 014"," 015"," 016"," 017"," 020"," 021"," 022"," 023"," 024"," 025"," 026"," 027"," 030"," 031",
        " 032"," 033"," 034"," 035"," 036"," 037"," 040"," 041"," 042"," 043"," 044"," 045"," 046"," 047"," 050"," 051",
        " 052"," 053"," 054"," 055"," 056"," 057"," 060"," 061"," 062"," 063"," 064"," 065"," 066"," 067"," 070"," 071",
        " 072"," 073"," 074"," 075"," 076"," 077"," 100"," 101"," 102"," 103"," 104"," 105"," 106"," 107"," 110"," 111",
        " 112"," 113"," 114"," 115"," 116"," 117"," 120"," 121"," 122"," 123"," 124"," 125"," 126"," 127"," 130"," 131",
        " 132"," 133"," 134"," 135"," 136"," 137"," 140"," 141"," 142"," 143"," 144"," 145"," 146"," 147"," 150"," 151",
        " 152"," 153"," 154"," 155"," 156"," 157"," 160"," 161"," 162"," 163"," 164"," 165"," 166"," 167"," 170"," 171",
        " 172"," 173"," 174"," 175"," 176"," 177"," 200"," 201"," 202"," 203"," 204"," 205"," 206"," 207"," 210"," 211",
        " 212"," 213"," 214"," 215"," 216"," 217"," 220"," 221"," 222"," 223"," 224"," 225"," 226"," 227"," 230"," 231",
        " 232"," 233"," 234"," 235"," 236"," 237"," 240"," 241"," 242"," 243"," 244"," 245"," 246"," 247"," 250"," 251",
        " 252"," 253"," 254"," 255"," 256"," 257"," 260"," 261"," 262"," 263"," 264"," 265"," 266"," 267"," 270"," 271",
        " 272"," 273"," 274"," 275"," 276"," 277"," 300"," 301"," 302"," 303"," 304"," 305"," 306"," 307"," 310"," 311",
        " 312"," 313"," 314"," 315"," 316"," 317"," 320"," 321"," 322"," 323"," 324"," 325"," 326"," 327"," 330"," 331",
        " 332"," 333"," 334"," 335"," 336"," 337"," 340"," 341"," 342"," 343"," 344"," 345"," 346"," 347"," 350"," 351",
        " 352"," 353"," 354"," 355"," 356"," 357"," 360"," 361"," 362"," 363"," 364"," 365"," 366"," 367"," 370"," 371",
        " 372"," 373"," 374"," 375"," 376"," 377"};
    // caracteres
    public static String [] OD_BC_C=new String[]{ "  \\0"," 001"," 002"," 003"," 004"," 005"," 006","  \\a","  \\b","  \\t",
        "  \\n","  \\v","  \\f","  \\r"," 016"," 017"," 020"," 021"," 022"," 023"," 024"," 025"," 026"," 027"," 030"," 031",
        " 032"," 033"," 034"," 035"," 036"," 037","    ","   !","   \"","   #","   $","   %","   &","   '","   (","   )",
        "   *","   +","   ,","   -","   .","   /","   0","   1","   2","   3","   4","   5","   6","   7","   8","   9",
        "   :","   ;","   <","   =","   >","   ?","   @","   A","   B","   C","   D","   E","   F","   G","   H","   I",
        "   J","   K","   L","   M","   N","   O","   P","   Q","   R","   S","   T","   U","   V","   W","   X","   Y",
        "   Z","   [","   \\","   ]","   ^","   _","   `","   a","   b","   c","   d","   e","   f","   g","   h","   i",
        "   j","   k","   l","   m","   n","   o","   p","   q","   r","   s","   t","   u","   v","   w","   x","   y"
            ,"   z","   {","   |","   }","   ~"," 177"," 200"," 201"," 202"," 203"," 204"," 205"," 206"," 207"," 210"
            ," 211"," 212"," 213"," 214"," 215"," 216"," 217"," 220"," 221"," 222"," 223"," 224"," 225"," 226"," 227"
            ," 230"," 231"," 232"," 233"," 234"," 235"," 236"," 237"," 240"," 241"," 242"," 243"," 244"," 245"," 246"
            ," 247"," 250"," 251"," 252"," 253"," 254"," 255"," 256"," 257"," 260"," 261"," 262"," 263"," 264"," 265"
            ," 266"," 267"," 270"," 271"," 272"," 273"," 274"," 275"," 276"," 277"," 300"," 301"," 302"," 303"," 304",
            " 305"," 306"," 307"," 310"," 311"," 312"," 313"," 314"," 315"," 316"," 317"," 320"," 321"," 322"," 323",
            " 324"," 325"," 326"," 327"," 330"," 331"," 332"," 333"," 334"," 335"," 336"," 337"," 340"," 341"," 342",
            " 343"," 344"," 345"," 346"," 347"," 350"," 351"," 352"," 353"," 354"," 355"," 356"," 357"," 360"," 361",
            " 362"," 363"," 364"," 365"," 366"," 367"," 370"," 371"," 372"," 373"," 374"," 375"," 376"," 377"};
    // 0...256
    public static String [] OD_BC_R=new String[]{"   0","   1","   2","   3","   4","   5","   6","   7","   8","   9",
        "  10","  11","  12","  13","  14","  15","  16","  17","  18","  19","  20","  21","  22","  23","  24","  25",
        "  26","  27","  28","  29","  30","  31","  32","  33","  34","  35","  36","  37","  38","  39","  40","  41",
        "  42","  43","  44","  45","  46","  47","  48","  49","  50","  51","  52","  53","  54","  55","  56","  57",
        "  58","  59","  60","  61","  62","  63","  64","  65","  66","  67","  68","  69","  70","  71","  72","  73",
        "  74","  75","  76","  77","  78","  79","  80","  81","  82","  83","  84","  85","  86","  87","  88","  89",
        "  90","  91","  92","  93","  94","  95","  96","  97","  98","  99"," 100"," 101"," 102"," 103"," 104"," 105",
        " 106"," 107"," 108"," 109"," 110"," 111"," 112"," 113"," 114"," 115"," 116"," 117"," 118"," 119"," 120"," 121",
        " 122"," 123"," 124"," 125"," 126"," 127"," 128"," 129"," 130"," 131"," 132"," 133"," 134"," 135"," 136"," 137",
        " 138"," 139"," 140"," 141"," 142"," 143"," 144"," 145"," 146"," 147"," 148"," 149"," 150"," 151"," 152"," 153",
        " 154"," 155"," 156"," 157"," 158"," 159"," 160"," 161"," 162"," 163"," 164"," 165"," 166"," 167"," 168"," 169",
        " 170"," 171"," 172"," 173"," 174"," 175"," 176"," 177"," 178"," 179"," 180"," 181"," 182"," 183"," 184"," 185",
        " 186"," 187"," 188"," 189"," 190"," 191"," 192"," 193"," 194"," 195"," 196"," 197"," 198"," 199"," 200"," 201",
        " 202"," 203"," 204"," 205"," 206"," 207"," 208"," 209"," 210"," 211"," 212"," 213"," 214"," 215"," 216"," 217",
        " 218"," 219"," 220"," 221"," 222"," 223"," 224"," 225"," 226"," 227"," 228"," 229"," 230"," 231"," 232"," 233",
        " 234"," 235"," 236"," 237"," 238"," 239"," 240"," 241"," 242"," 243"," 244"," 245"," 246"," 247"," 248"," 249",
        " 250"," 251"," 252"," 253"," 254"," 255"};
    
    
    int BARRA_R=13;     // \r
    int CHAR_R=114;     // r
    int BARRA_N=10;     // \n
    int CHAR_N=110;     // n
    
    int BARRA_0=0;      // \0
    int CHAR_0=48;      // 0
    int BARRA_A=7;      // \a
    int CHAR_A=97;      // a
    int BARRA_B=8;      // \b
    int CHAR_B=98;      // b
    int BARRA_T=9;      // \t
    int CHAR_T=116;     // t
    int BARRA_V=11;     // \v
    int CHAR_V=118;     // v
    int BARRA_F=12;     // \f
    int CHAR_F=102;     // f
    int CHAR_BARRA=92; // \\ => \
    
    public static void main(String[] args) {

/*
# criando tabela a com 400k registros
y banco conn,hash execute "drop table a"
y banco conn,hash execute "create table a ( C1 varchar2(3000), C2 varchar2(3000), C3 varchar2(3000) )"
y banco conn,hash execute "insert into a values('123456789','123456789','123456789')"
y echo "select a.* from a,(select level from dual connect by level <= 399999)" | y banco connIn,hash connOut,hash -outTable a carga
y banco conn,hash select "select count(1) from a"
# 34k linhas/s - table to table
# y banco $conn execute "create table a ( C1 varchar2(3000), C2 varchar2(3000), C3 varchar2(3000) )"
y banco conn,desktop execute "drop table b"
y banco conn,desktop execute "create table b as select * from a where rownum <= 1"
y banco conn,desktop selectInsert "select b.* from b,(select level from dual connect by level <= 160000)" | y banco buffer -n_line 500 -log buffer.log | y banco conn,desktop executeInsert
cat buffer.log
# y banco conn,desktop select "select count(1) from b"
# 65k linhas/s - lendo arquivo
y cat a a a | y banco buffer -n_lines 500 -log buffer.log | y dev_null
cat buffer.log
# 4k linhas/s - gravando arquivo
y cat a | y banco buffer -n_lines 500 -log buffer.log > aa
cat buffer.log
# 34k linhas/s - table to null               
y banco conn,desktop selectInsert "select * from a" | y banco buffer -n_lines 500 -log buffer.log | y dev_null
cat buffer.log
# 59k linhas/s - file to table
y banco conn,desktop execute "drop table b"
y banco conn,desktop execute "create table b as select * from a where rownum <= 1"
y cat b | y banco buffer -n_lines 500 -log buffer.log | y banco conn,desktop executeInsert
cat buffer.log
*/
        //teste
        //y serverRouter 192.168.0.100 8080 localhost 9090 show        
        //args=new String[]{"serverRouter","192.168.0.100","25565","192.168.0.200","25565","show"};        
        //args=new String[]{"serverRouter","192.168.0.100","25565","192.168.0.200","25565"};             
        
        //args=new String[]{"xlsxToCSV","C:\\tmp\\aa\\a.xlsx","nomeAba","Gestão de Mud (CITSD_change)"};                
        //args=new String[]{"xlsxToCSV","C:\\tmp\\aa\\a.xlsx","nomeAba","N A (AccountLeads)"};
        //args=new String[]{"xlsxToCSV","C:\\tmp\\aa\\a.xlsx","exportAll"};                                        
        
        //args=new String[]{"selectCSV_banco","-csv","c:\\tmp\\tmp\\a.csv","select CAMPO2, CAMPO2 from this"};                                        
        
        //args=new String[]{"xlsxToCSV","C:\\tmp\\aa\\a.xlsx","mostraEstrutura"};
        //args=new String[]{"xlsxToCSV","C:\\tmp\\aa\\a.xlsx","numeroAba","1"};
        //args=new String[]{"xml","C:\\tmp\\aa\\sheet438.xml","mostraTags"};        
        //args=new String[]{"xlsxToCSV","C:\\tmp\\tmp\\012020.xlsx","exportAll"};
        //args=new String[]{"xlsxToCSV","C:\\tmp\\tmp\\012020.xlsx","numeroAba","1"};        
        //args=new String[]{"xlsxToCSV","C:\\tmp\\tmp\\012020.xlsx","mostraEstrutura"};
        //args=new String[]{"find", "/"};
        //testOn(); args=new String[]{"json", "[elem for elem in data['items']]"};        
        //testOn(); args=new String[]{"json", "[elem for elem in data['b']]"};        
        //testOn(); args=new String[]{"json", "mostraEstrutura"};
        //testOn(); args=new String[]{"json", "mostraEstruturaDebug"};
        //testOn(); args=new String[]{"json", "mostraTabela"};
        //args=new String[]{"regua"};                
        //args=new String[]{"find", ".", "-mtime", "1"};                
        //args=new String[]{"date","+%m/%d/%Y","%H:%M:%S:%N","%Z","%s"};
        //args=new String[]{"curl","-v","https://www.youtube.com"};
        //args=new String[]{"curl","-v","http://dota.freeoda.com/100/"};
        
        new Y().go(args);
    }

    public void go(String[] args){    
        args=initEnvByParm(args);
        System.setProperty("https.protocols", "TLSv1.1");
        System.setProperty("line.separator", "\n");
        //REMOVED_GRAAL_START
        try_load_libraries();
        try_load_ORAs();	
        //REMOVED_GRAAL_END		

        if ( args.length == 0 ){
            System.err.println(      
                somente_mini("/y/manual")
            );
            return;
        }
        if ( args.length > 0 && args[0].equals("cotacao") ){
            cotacao(args);
            return;
        }
        if ( args.length > 0 && args[0].equals("var") )
            args=get_var();
        //REMOVED_GRAAL_START
        if ( args[0].equals("daemon") || args[0].equals("d") ){
            daemon(args);
            return;
        }
        //REMOVED_GRAAL_END
        if ( args[0].equals("take") ){
            if ( take(args) )
                return;
        }
        //REMOVED_GRAAL_START
        if ( args[0].equals("banco") ){            
            if ( args.length == 1 ){
                System.err.println(
                    somente_banco("/y/manual")
                );            
                return;
            }

            // fromCSV
            if ( args.length == 5 && args[1].equals("fromCSV") && args[2].equals("-outTable") && args[4].equals("selectInsert") ){
                selectInsert("","","",null,args[3],"");
                return;
            }
            
            // conn
            if ( args[1].equals("-conn") || ( args[1].startsWith("conn,") ) ){
                String [] ConnAppParm=getConnAppParm(args);

                if ( ConnAppParm == null ){
                    comando_invalido(args);
                    return;
                }

                String conn=ConnAppParm[0];
                String app=ConnAppParm[1];
                String parm=ConnAppParm[2];

                // comandos app
                if ( app.equals("select") ){
                    select(conn,parm);
                    return;
                }
                if ( app.equals("selectInsert") ){
                    selectInsert(conn,"",parm,null,"","");
                    return;
                }
                if ( app.equals("selectCSV") ){ // y banco
                    selectCSV_banco(conn,parm);
                    return;
                }
                if ( app.equals("executeInsert") ){
                    executeInsert(conn,System.in);
                    return;
                }
                if ( app.equals("execute") ){
                    execute(conn,parm);
                    return;
                }       
                if ( app.equals("createjobexecute") ){
                    try{
                        createjobexecute(conn);
                    }catch(Exception e){
                        System.err.println(e.toString());
                        System.exit(1);
                    }
                    return;
                }
            }
            // connIn/fileCSV
            if ( args[1].equals("-connIn") || args[1].startsWith("connIn,") || args[1].equals("-fileCSV") || args[1].startsWith("fileCSV,") ){
                String [] connIn_fileCSV_connOut_outTable_trunc_app=get_connIn_fileCSV_connOut_outTable_trunc_app(args);
                if ( connIn_fileCSV_connOut_outTable_trunc_app == null ){
                    comando_invalido(args);
                    return;
                }
                String connIn=connIn_fileCSV_connOut_outTable_trunc_app[0];
                String fileCSV=connIn_fileCSV_connOut_outTable_trunc_app[1];
                String connOut=connIn_fileCSV_connOut_outTable_trunc_app[2];
                String outTable=connIn_fileCSV_connOut_outTable_trunc_app[3];
                String trunc=connIn_fileCSV_connOut_outTable_trunc_app[4];
                String app=connIn_fileCSV_connOut_outTable_trunc_app[5];

                //[y banco connIn,hash connOut,hash outTable,tabelaA carga]
                //[y banco connIn,hash connOut,hash outTable,tabelaA trunc carga]
                //[y banco connIn,hash connOut,hash outTable,tabelaA createjobcarga]
                //[y banco connIn,hash connOut,hash outTable,tabelaA trunc createjobcarga]

                if ( app.equals("carga") )
                {
                    carga(connIn,fileCSV,connOut,outTable,trunc);
                    return;
                }
                if ( app.equals("createjobcarga") )
                {
                    try{
                        createjobcarga(connIn,fileCSV,connOut,outTable,trunc,app);
                    }catch(Exception e){
                        System.err.println(e.toString());
                        System.exit(1);
                    }
                    return;
                }
            }
            // executejob
            if ( args[1].equals("executejob") && args.length == 2 ){
                executejob();
                return;
            }
            // buffer
            if ( args[1].equals("buffer") 
                && (
                    ( args.length == 2 )
                    || ( args.length == 4 && args[2].equals("-n_lines") )
                    || ( args.length == 4 && args[2].equals("-log") )
                    || ( args.length == 6 && args[2].equals("-n_lines") && args[4].equals("-log") )
                )
            ){
                buffer(args);
                return;
            }

            comando_invalido(args);
            return;
        }
        
        if ( args[0].equals("selectCSV") ){ // selectCSV_texto
            try{
                selectCSV_texto(args);
                return;
            }catch(Exception e){
                System.err.println(e.toString());
                System.exit(1);
            }
        }
        
        if ( args[0].equals("xlsxToCSV") && args.length >= 3 ){
            //args=new String[]{"xlsxToCSV","teste.xlsx","mostraEstrutura"};
            //args=new String[]{"xlsxToCSV","teste.xlsx","listaAbas"};
            //args=new String[]{"xlsxToCSV","teste.xlsx","numeroAba","1"};
            //args=new String[]{"xlsxToCSV","teste.xlsx","nomeAba","A"};

            try{
                if ( new File(args[1]).exists() ){
                    if ( args.length == 3 && args[2].equals("mostraEstrutura") ){
                        xlsxToCSV(args[1],true,false,-1,"",System.out,false);
                        return;
                    }
                    if ( args.length == 3 && args[2].equals("listaAbas") ){
                        xlsxToCSV(args[1],false,true,-1,"",System.out,false);
                        for ( int i=0;i<xlsxToCSV_nomes.size();i++ )
                            System.out.println(xlsxToCSV_nomes.get(i));
                        return;
                    }
                    if ( args.length == 3 && args[2].equals("exportAll") ){
                        xlsxToCSV(args[1],false,true,-1,"",null,false);
                        ArrayList<String> bkp_lista=xlsxToCSV_nomes;
                        OutputStream out=null;
                        boolean suprimeHeader=false;
                        boolean config_SystemOuput=true;
                        String abaSequencial=get_abaSequencial(bkp_lista);
                        if ( abaSequencial != null ){
                            if ( config_SystemOuput ){
                                out=System.out;
                            }else{
                                System.out.println("exportando "+abaSequencial+".csv");
                                out=new FileOutputStream(abaSequencial+".csv");
                            }
                            for ( int i=0;i<bkp_lista.size();i++ ){
                                if ( i == 0)
                                    suprimeHeader=false;
                                else
                                    suprimeHeader=true;
                                xlsxToCSV(args[1],false,false,-1,bkp_lista.get(i),out,suprimeHeader);
                            }                            
                            if ( out != null ){
                                out.flush();
                                out.close();
                            }
                        }else{
                            for ( int i=0;i<bkp_lista.size();i++ ){
                                System.out.println("exportando("+(i+1)+"/"+bkp_lista.size()+") arquivo: "+bkp_lista.get(i)+".csv");
                                out=new FileOutputStream(bkp_lista.get(i)+".csv");
                                xlsxToCSV(args[1],false,false,-1,bkp_lista.get(i),out,false);
                                if ( out != null ){
                                    out.flush();
                                    out.close();
                                }
                            }
                        }
                        return;
                    }
                    if ( args.length == 4 && args[2].equals("numeroAba") ){
                        try{
                            xlsxToCSV(args[1],false,false,Integer.parseInt(args[3]),"",System.out,false);
                            return;
                        }catch(Exception e){}
                    }
                    if ( args.length == 4 && args[2].equals("nomeAba") && args[3].length() > 0 ){
                        xlsxToCSV(args[1],false,false,-1,args[3],System.out,false);
                        return;
                    }
                }
            }catch(Exception e){
                System.err.println("Erro, "+e.toString());
                System.exit(1);
            }
        }   
        //REMOVED_GRAAL_END
        if ( args[0].equals("xml") && ( args.length == 2 || args.length == 3 ) ){
            try{
                if ( args.length == 2 && args[1].equals("mostraEstrutura") ){
                    new XML().loadIs(System.in,true,false,null,false,null,false);
                    return;
                }            
                if ( args.length == 2 && args[1].equals("mostraTags") ){
                    new XML().loadIs(System.in,false,true,null,false,null,false);
                    return;
                }            
                if ( args.length == 3 && new File(args[1]).exists() && args[2].equals("mostraEstrutura") ){
                    FileInputStream is = new FileInputStream(args[1]);
                    new XML().loadIs(is,true,false,null,false,null,false);
                    is.close();                
                    return;
                }            
                if ( args.length == 3 && new File(args[1]).exists() && args[2].equals("mostraTags") ){
                    FileInputStream is = new FileInputStream(args[1]);
                    new XML().loadIs(is,false,true,null,false,null,false);
                    is.close();                
                    return;                
                }          
            }catch(Exception e){
                System.err.println(e.toString());
                System.exit(1);
            }
        }
        
        if ( args[0].equals("token") ){
            if ( args.length == 1 ){
                System.err.println("usage:"
                + "\n  [y token value]"
                + "\n  return hash"
                + "\n  [y gettoken hash]"
                + "\n  return value");
                return;
            }
            String dir_token=getenvtoken();
            if ( ! env_ok(dir_token) )
                return;
            String value=args[1];
            String hash=salvando_token(dir_token,value);
            if ( hash == null ){
                System.err.println("Não foi possível utilizar a pasta "+dir_token);
                return;
            }
            System.out.println(hash);
            return;
        }
        if ( args[0].equals("gettoken") ){
            if ( args.length == 1 ){
                System.err.println("usage:"
                + "\n  [y token value]"
                + "\n  return hash"
                + "\n  [y gettoken hash]"
                + "\n  return value");
                return;
            }
            String value=gettoken(args[1]);
            if ( value == null )
            {
                System.err.println("Não foi possível encontrar o token "+args[1]);
                return;
            }
            System.out.println(value);
            return;
        }
        
        if ( args[0].equals("json") && args.length > 1 ){
            String [] args2 = new String[args.length];            
            System.arraycopy(args, 0, args2, 0, args.length);
            args2=sliceParm(1,args2);
            
            Object [] objs = get_parms_json_listOn_noHeader_parm(args2);
            boolean listOn=(Boolean)objs[0];
            boolean noHeader=(Boolean)objs[1];
            String parm=(String)objs[2];

            if ( objs != null){
                boolean mostraTabela=parm.equals("mostraTabela");
                boolean mostraEstrutura=parm.equals("mostraEstrutura");            
                boolean mostraEstruturaDebug=parm.equals("mostraEstruturaDebug");
                String command=parm.contains("for elem in data")?parm:"";
                if ( !command.equals("") || mostraTabela || mostraEstrutura || mostraEstruturaDebug ){
                    new JSON(System.in, command, mostraTabela, mostraEstrutura, mostraEstruturaDebug,listOn, noHeader, System.out);
                    return;
                }
            }
        }
            
        /*
        y zip add File1.txt > saida.zip
        cat File1.txt | y zip add -name File1.txt > saida.zip
        y zip add /pasta1/pasta2 > saida.zip
        y zip add pasta2 -lvlStore > saida.zip
        y zip add pasta1 pasta2 file3 -lvlStore > saida.zip
        y zip list arquivo.zip
        cat arquivo.zip | y zip list
        y zip extract entrada.zip
        cat entrada.zip | y zip extract
        y zip extract entrada.zip -out /destino
        cat entrada.zip | y zip extract -out /destino
        y zip extractSelected entrada.zip pasta1/unicoArquivoParaExtrair.txt -out /destino
        cat entrada.zip | y zip extractSelected pasta1/unicoArquivoParaExtrair.txt -out /destino
        y zip extractSelected entrada.zip pasta1/unicoArquivoParaExtrair.txt > /destino/unicoArquivoParaExtrair.txt
        cat entrada.zip | y zip extractSelected pasta1/unicoArquivoParaExtrair.txt > /destino/unicoArquivoParaExtrair.txt
        obs: se add pasta e a descricao de pasta tem "/" ou "\\" então o pacote terá o conteudo da pasta, caso contrário terá a pasta citada+conteudo.
        */
        if ( args.length == 2 && args[0].equals("zip") && args[1].equals("add") ){
            System.err.println("Erro!\nComando sugerido:\necho a.txt | y zip add -name a.txt > a.zip");
            System.exit(1);            
        }
        if ( args[0].equals("zip") ){
            try{
                if ( args.length >= 3 && args[1].equals("add") ){
                    Object [] objs = get_parms_paths_virtualname_lvlStore(args);
                    if ( objs != null ){
                        String [] paths=(String [])objs[0];
                        String virtualname=(String)objs[1];
                        boolean lvlStore=(Boolean)objs[2];
                        zip_add_router(paths, virtualname, lvlStore, System.out, null);
                        return;
                    }
                }
                if ( args.length == 2 && args[1].equals("list") ){
                    zip_list(null);
                    return;
                }
                if ( args.length == 3 && args[1].equals("list") ){
                    zip_list(args[2]);
                    return;
                }                
                if ( args.length == 2 && args[1].equals("extract") ){
                    zip_extract(System.in, null,null,null);
                    return;
                }
                if ( args.length == 3 && args[1].equals("extract") ){
                    zip_extract(null, args[2],null,null);
                    return;
                }
                if ( args.length == 4 && args[1].equals("extract") && args[2].equals("-out")){
                    zip_extract(System.in, null,args[3],null);
                    return;
                }
                if ( args.length == 5 && args[1].equals("extract") && args[3].equals("-out")){
                    zip_extract(null, args[2],args[4],null);
                    return;
                }
                if ( args.length == 3 && args[1].equals("extractSelected") ){
                    zip_extract(System.in, null,null,args[2]);
                    return;
                }
                if ( args.length == 4 && args[1].equals("extractSelected") ){
                    zip_extract(null, args[2],null,args[3]);
                    return;
                }
                if ( args.length == 5 && args[1].equals("extractSelected") && args[3].equals("-out")){
                    zip_extract(System.in, null,args[4],args[2]);
                    return;
                }
                if ( args.length == 6 && args[1].equals("extractSelected") && args[4].equals("-out")){
                    zip_extract(null, args[2],args[5],args[3]);
                    return;
                }
            }catch(Exception e){
                System.err.println(e.toString());
                System.exit(1);
            }
        }
        if ( args[0].equals("gzip") ){
            gzip();
            return;
        }        
        if ( args[0].equals("gunzip") ){
            gunzip();
            return;
        }   
        if ( args[0].equals("tar") && args.length == 2 ){
            try{
                new Tar().tar(null, args[1]);
            }catch(Exception e){
                System.err.println(e.toString());
                System.exit(1);
            }
            return;
        }
        if ( args[0].equals("tar") && args.length == 3 ){
            try{
                new Tar().tar(args[1], args[2]);
            }catch(Exception e){
                System.err.println(e.toString());
                System.exit(1);
            }
            return;
        }
        if ( args[0].equals("untar") && args.length == 1 ){
            try{
                new Tar().untar(null, null);
            }catch(Exception e){
                System.err.println(e.toString());
                System.exit(1);
            }
            return;
        }
        if ( args[0].equals("untar") && args.length == 2 ){
            try{
                new Tar().untar(args[1], null);
            }catch(Exception e){
                System.err.println(e.toString());
                System.exit(1);
            }
            return;
        }
        if ( args[0].equals("untar") && args.length == 3 ){
            try{
                new Tar().untar(args[1], args[2]);
            }catch(Exception e){
                System.err.println(e.toString());
                System.exit(1);
            }
            return;
        }
        if ( args[0].equals("tarlist") && args.length == 2 ){
            try{
                new Tar().tarlist(args[1]);
            }catch(Exception e){
                System.err.println(e.toString());
                System.exit(1);
            }
            return;
        }
        if ( args[0].equals("echo") ){
            try{
                echo(args);
            }catch(Exception e){
                erroFatal(e);
            }            
            return;
        }      
        if ( args[0].equals("trataEcho") ){
            try{
                trataEcho();
            }catch(Exception e){
                erroFatal(e);
            }            
            return;
        }      
        if ( args[0].equals("trataPrintf") ){
            try{
                trataPrintf();
            }catch(Exception e){
                erroFatal(e);
            }            
            return;
        }      
        if ( args[0].equals("printf") ){
            try{
                printf(args, System.out);
            }catch(Exception e){
                erroFatal(e);
            }
            return;
        }              
        if ( args[0].equals("print") ){
            System.err.println("O correto nao seria printf?");
            System.exit(1);
        }   
        if ( args[0].equals("sdiff") && args.length >= 3 ){
            Object [] objs = get_parms_file1_file2_flagOnlyDiff(args);
            if ( objs == null ){
                comando_invalido(args);
                System.exit(0);
            }
            String file1=(String)objs[0];
            String file2=(String)objs[1];
            Boolean flag_enable_equal=!(Boolean)objs[2];
            File f=new File(file1);
            if ( f == null || !f.exists() || !f.isFile() )
                erroFatal("Arquivo " + args[1] + " não existe!");
            f=new File(file2);
            if ( f == null || !f.exists() || !f.isFile() )
                erroFatal("Arquivo " + args[2] + " não existe!");
            new Diff(file1, file2, flag_enable_equal, System.out);
            return;
        }
        if ( args[0].equals("progressBar") ){
            Boolean uniqLine=false;
            if ( args.length > 1 && args[1].equals("-uniqLine") )
                uniqLine=true;
            progressBar(System.in, uniqLine);
            return;
        }     
        if ( args[0].equals("xargs") ){
            xargs(args);
            return;
        }
        if ( args[0].equals("cat") ){
            cat(args);
            return;
        }
        if ( args[0].equals("sort") ){
            try{
                new ExternalSort(System.in, System.out);
            }catch(Exception e ){
                erroFatal(e);
            }
            return;
        }
        if ( args[0].equals("sorte") ){
            sorte();
            return;
        }
        if ( args[0].equals("iso") ){
            iso(args);
            return;
        }
        if ( args[0].equals("check_util") ){
            String [] verifys=check_util_list;
            if ( args.length > 1 )
                verifys=new String[]{args[1]};
            System.out.println("verificando...");
            System.out.flush();
            for ( int i=0;i<verifys.length;i++ ){
                String path=verifys[i].split(",")[0];
                System.out.print(path + " -> ");
                if ( check_util(path) )
                    System.out.println("OK!");
                else{
                    System.out.println("\nERRO - não foi possível verificar!");
                    return;
                }
            }
            return;
        }            
        if ( args[0].equals("juros") || args[0].equals("emprestimo") ){
            juros(args);
            return;
        }
        if ( args[0].equals("terminal") ){
            new yTerminal().init();
            return;
        }
        if ( args[0].equals("dnsDoHServer") && args.length == 4 ){
            // y dnsDoHServer 192.168.0.100 8080 https://dns.adguard.com/dns-query
            // https://192.168.0.100:8080/dns-query
            // falta implementar o https.. http nao funciona
            // o Google Chrome (e a maioria dos navegadores modernos) não aceita DNS sobre HTTPS (DoH) sem um certificado HTTPS válido
            // Não é possível usar dnsDoHServer sem certificado na máquina!
            // dando erro de certificado
            dnsDoHServer(args[1], Integer.parseInt(args[2]), args[3]);
            return;
        }        
        if ( args[0].equals("audio") || args[0].equals("vol") ){
            if ( args[0].equals("vol") )
                erroFatal("procure por:\ny help audio");
            audio(args);
            return;
        }
        if ( args[0].equals("isWindowsAdm") ){
            if ( !isWindows() )
                erroFatal("comando somente implementado para windows!");
            System.out.println(isWindowsAdm()?"sim":"nao");
            return;
        }
        //isWindowsAdm
        if ( args[0].equals("devices") ){
            if ( !isWindows() )
                erroFatal("comando implementado somente para windows!");
            devices(args);
            return;
        }        
        if ( args[0].equals("cep") && args.length > 1 ){
            cep(args);
            return;
        }
        if ( args[0].equals("meuip") ){
            meuip();
            return;
        }
        if ( args[0].equals("users") ){
            if ( !isWindows() )
                erroFatal("comando suportado somente para windows");
            System.out.println(getUsers());
            return;
        }
        if ( args[0].equals("disconnect") ){
            if ( !isWindows() )
                erroFatal("comando suportado somente para windows");
            if ( args.length > 1 && args[1].equals("seAtivoDesconectaLoop1Segundo"))
                disconnect(true);
            else
                disconnect(false);
            return;
        }
        if ( args.length > 1 && (args[0].equals("dns") || args[0].equals("host")) ){
            String name=args[1];
            String source_dns=null;
            if ( args.length > 2 )
                source_dns=args[2];
            if ( name.startsWith("http://" ) || name.startsWith("https://" ) ){
                try{
                    java.net.URL url=new java.net.URL("http://203.cloudns.cl:8000/");            
                    if ( source_dns == null )
                        System.out.println("execute o comando desse modo:\ny " + args[0] + " " + url.getHost());                  
                    else
                        System.out.println("execute o comando desse modo:\ny " + args[0] + " " + url.getHost() + " " + source_dns );
                }catch(Exception e){}
                return;
            }
            System.out.print(dns(name, source_dns));
            return;
        }
        if ( ( args[0].equals("overflix") || args[0].equals("of") ) && args.length > 1 ){
            if ( ! isWindows() )
                erroFatal("overflix implementado somente para o windows");            
            try{
                global_header="cookie: ips4_device_key=311a4bbe7ff5706d42ecc82e640ab727; ips4_member_id=178526; ips4_login_key=74e18a46894d354f5adfa7dc881de6d7;\r\n";                
                /*
                console browser
                document.cookie='ips4_device_key=311a4bbe7ff5706d42ecc82e640ab727';
                document.cookie='ips4_member_id=178526';
                document.cookie='ips4_login_key=74e18a46894d354f5adfa7dc881de6d7';                                
                while [ true ]; do y cls && y curl -H "cookie: ips4_device_key=311a4bbe7ff5706d42ecc82e640ab727; ips4_member_id=178526; ips4_login_key=74e18a46894d354f5adfa7dc881de6d7;" https://encontre.us/id-62616/ | y tr "'" "\n" | y grep .com/f/;  y curl https://mixdrop23.net/f/9wxdwkjof8o8zn | y grep "ALMOST THERE"; sleep 30; done
                */
                overflix(args);                
            }catch(Exception e){
                erroFatal(e);
            }
            return;
        }             
        if ( args[0].equals("connGui") ){
            new ConnGui();
            return;
        }
        if ( args[0].equals("lower") ){
            String line=null;
            while ( (line=readLine()) != null )
                System.out.println(line.toLowerCase());
            return;
        }     
        if ( args[0].equals("upper") ){
            String line=null;
            while ( (line=readLine()) != null )
                System.out.println(line.toUpperCase());
            return;
        }     
        if ( args[0].equals("removeAcentos") ){
            base_removeAcentos();
            return;
        }     
        if ( args[0].equals("xor") && args.length <= 3 ){
            try{
                if ( args.length <= 2 ){
                    int a=100;
                    if ( args.length == 2 )
                        a=Integer.parseInt(args[1]);
                    xor(a);                    
                }else{
                    xor_ofuscation(Integer.parseInt(args[1]), args[2]);
                }
                return;
            }catch(Exception e){}            
        }        
        if ( args[0].equals("md5") ){
            if ( args.length == 2 )
                System.out.println(digest("MD5", args[1]));
            else
                System.out.println(digest("MD5", null));
            return;
        }        
        if ( args[0].equals("sha1") ){
            if ( args.length == 2 )
                System.out.println(digest("SHA-1", args[1]));
            else
                System.out.println(digest("SHA-1", null));
            return;
        }        
        if ( args[0].equals("sha256") ){
            if ( args.length == 2 )
                System.out.println(digest("SHA-256", args[1]));
            else
                System.out.println(digest("SHA-256", null));
            return;
        }        
        if ( args[0].equals("aes") && args.length > 1 ){
            String[] senha_isEncoding_md_salt=get_senha_isEncoding_md_salt(args);
            if ( senha_isEncoding_md_salt != null ){
                aes(senha_isEncoding_md_salt[0],senha_isEncoding_md_salt[1].equals("S"),senha_isEncoding_md_salt[2],senha_isEncoding_md_salt[3]==null?null:hexTobytes(senha_isEncoding_md_salt[3]));
                return;
            }
        }        
        if ( args[0].equals("base64") 
            && ( 
                args.length == 1 
                || ( args.length == 2 && args[1].equals("-e") )
                || ( args.length == 2 && args[1].equals("-d") )
                || ( args.length == 3 && args[1].equals("-e") && args[2].length() > 0 )
                || ( args.length == 3 && args[1].equals("-d") && args[2].length() > 0 )
            )    
        ){
            try{
                if ( args.length == 1 ){
                    base64(System.in,System.out,true);
                    return;
                }
                boolean encoding=args[1].equals("-e");
                if ( args.length == 2 ){
                    base64(System.in,System.out,encoding);
                    return;
                }
                if ( args.length == 3 ){
                    System.out.println(
                        base64(args[2], encoding)
                    );
                    return;
                }
                System.err.println("Erro inesperado!");
                System.exit(1);
            }catch(Exception e){
                System.err.println(e.toString());
                System.exit(1);
            }
            return;
        }
        
        if ( args[0].equals("grep") ){
            grep(args);
            return;
        }        
        if ( args.length == 2 && args[0].equals("wc") && (args[1].equals("-l") || args[1].equals("-c") || args[1].equals("-w")) ){
            wc(args[1]);
            return;
        }       
        if ( args.length == 1 && args[0].equals("len")){
            len();
            return;
        }       
        if ( args[0].equals("head") 
            && (
                args.length == 1 
                || ( args.length == 2 && args[1].startsWith("-") && args[1].length() > 1 )
            ) 
        ){
            head(args);
            return;
        }
        if ( args[0].equals("tail") 
            && (
                args.length == 1 
                || ( args.length == 2 && args[1].startsWith("-") && args[1].length() > 1 )
            ) 
        ){
            tail(args);
            return;
        }
        if ( args[0].equals("cut") && args.length == 2 && args[1].startsWith("-c") && args[1].length() > 2 ){
            cut(args);
            return;
        }
        if ( args[0].equals("cors") ){            
            cors(args);
            return;
        }  
        if ( args[0].equals("yt") ){
            System.out.println("cd D:\\ProgramFiles && python3 yt-dlp/yt_dlp/__main__.py -o \"%(playlist_index)03d.%(title)s.%(ext)s\" http...");
            System.out.println("cd D:\\ProgramFiles && python3 yt-dlp/yt_dlp/__main__.py -o \"%(playlist_index)03d.%(album)s.%(title)s.%(ext)s\" http...");
            System.out.println("cd D:\\ProgramFiles && python3 yt-dlp/yt_dlp/__main__.py -o \"%(playlist)s.%(playlist_index)03d.%(title)s.%(ext)s\" http...");
            System.out.println("cd D:\\ProgramFiles && python3 yt-dlp/yt_dlp/__main__.py -o \"%(playlist_index)03d.%(title)s.%(ext)s\" --extract-audio --audio-format mp3 \"http...");
            System.out.println("cd \"D:\\ProgramFiles\\site\\series\\Raphael Ghanem\" && python3 D:/ProgramFiles/yt-dlp/yt_dlp/__main__.py -o \"%(playlist)s.%(upload_date)s.%(title)s.%(ext)s\" https://www.youtube.com/@raphaelghanem");
            return;
        }
        if ( args[0].equals("curl") ){
            String [] args2 = new String[args.length];            
            System.arraycopy(args, 0, args2, 0, args.length);
            args2=sliceParm(1,args2);
            Object [] objs = get_parms_curl_header_method_verbose_raw_host_limitRate_location(args2);
            if ( objs != null ){
                String header=(String)objs[0];
                String method=(String)objs[1];
                boolean verbose=(Boolean)objs[2];
                boolean raw=(Boolean)objs[3];
                String host=(String)objs[4];
                Long limitRate=(Long)objs[5];
                curl_flag_location=(Boolean)objs[6];

                if ( host != null ){
                    curl(System.out, header, method, verbose, raw, host, null, limitRate, null, null, null, null);
                    return;
                }
            }
        }
        if ( args[0].equals("curlJson") ){
            String [] args2 = new String[args.length];            
            System.arraycopy(args, 0, args2, 0, args.length);
            args2=sliceParm(1,args2);
            Object [] objsCurl = get_parms_curl_header_method_verbose_raw_host_limitRate_location(args2);
            if ( objsCurl != null ){
                String header=(String)objsCurl[0];
                String method=(String)objsCurl[1];
                boolean verbose=(Boolean)objsCurl[2];
                boolean raw=(Boolean)objsCurl[3];
                String host=(String)objsCurl[4];  
                Long limitRate=(Long)objsCurl[5];
                curl_flag_location=(Boolean)objsCurl[6];

                Object [] objs = get_parms_json_listOn_noHeader_parm(args2);
                if ( objs != null ){
                    boolean listOn=(Boolean)objs[0];
                    boolean noHeader=(Boolean)objs[1];
                    String parm=(String)objs[2];
                    if ( host != null ){
                        boolean mostraTabela=parm.equals("mostraTabela");
                        boolean mostraEstrutura=parm.equals("mostraEstrutura");            
                        boolean mostraEstruturaDebug=parm.equals("mostraEstruturaDebug");
                        String command=parm.contains("for elem in data")?parm:"";
                        if ( !command.equals("") || mostraTabela || mostraEstrutura || mostraEstruturaDebug ){
                            try{
                                final PipedInputStream pipedInputStream=new PipedInputStream();
                                final PipedOutputStream pipedOutputStream=new PipedOutputStream();
                                pipedInputStream.connect(pipedOutputStream);
                                Thread pipeWriter=new Thread(new Runnable() {
                                    public void run() {
                                        curl(pipedOutputStream, header, method, verbose, raw, host, null, limitRate, null, null, null, null);
                                    }
                                });
                                Thread pipeReader=new Thread(new Runnable() {
                                    public void run() {
                                        new JSON(pipedInputStream,command,mostraTabela,mostraEstrutura,mostraEstruturaDebug,listOn,noHeader,System.out);
                                    }
                                });
                                pipeWriter.start();
                                pipeReader.start();
                                pipeWriter.join();
                                pipeReader.join();
                                pipedOutputStream.flush();
                                pipedOutputStream.close();            
                                pipedInputStream.close();        
                            }catch(Exception e){
                                System.err.println("Erro, "+e.toString());
                            }            
                            return;
                        }
                    }
                }
            }
        }        
        if ( args[0].equals("sed") || args[0].equals("tr") ){
            if ( args.length == 3 ){
                sed(args);
                return;
            }
            if ( args.length%2 == 1 ){
                sedBasic(args);
                return;
            }
        }
        if ( args[0].equals("n") ){
            n();
            return;
        }
        if ( args[0].equals("rn") ){
            rn();
            return;
        }
        if ( args[0].equals("bytesToInts") || args[0].equals("bi") ){
            boolean dif_128=false;
            if ( args.length > 1 && args[1].equals("-128") )
                dif_128=true;
            bytesToInts(dif_128);
            return;
        }       
        if ( args[0].equals("intsToBytes") || args[0].equals("ib") ){
            intsToBytes(args);
            return;
        }    
        if ( args[0].equals("od") ){
            if ( args.length == 1 ){
                od("");
                return;
            }
            if ( args.length == 2 && ! args[1].equals("") ){
                if ( args[1].startsWith("-") && args[1].substring(1).replace("b","").replace("c","").replace("r","").equals("") ){
                    od(args[1].substring(1));
                    return;
                } 
                if ( args[1].replace("b","").replace("c","").replace("r","").equals("") ){
                    od(args[1]);
                    return;
                } 
            }
        }       
        if ( args[0].equals("touch") && args.length > 1 ){
            touch(args);
            return;
        }
        if ( args[0].equals("rm") && args.length > 1 ){
            rm(args);
            return;
        }
        if ( args[0].equals("cp") && args.length == 3 ){
            cp(new File(args[1]), new File(args[2]), false, true);
            return;
        }
        if ( args[0].equals("cp") && args.length == 4 && args[1].equals("-R")){
            cp(new File(args[2]), new File(args[3]), true, true);
            return;
        }
        if ( args[0].equals("mv") && args.length == 3){
            try{
                mv(new File(args[1]), new File(args[2]));
            }catch(Exception e){
                System.out.println("Erro, "+e.toString());
                System.exit(1);
            }
            return;
        }
        if ( args[0].equals("cd") ){
            cd();
            return;
        }
        if ( args[0].equals("mkdir") && args.length == 2 ){
            mkdir(new File(args[1]));
            return;
        }        
        if ( args[0].equals("M") || args[0].equals("m") )
        {
            if ( args.length == 1 ){
                System.out.println("Parametro inválido!");
                System.out.println("Modelo:");
                System.out.println("y M ClassePrincipal Caminho Senha");
                System.out.println("y M pacote1/ClassePrincipal Caminho Senha");
                return;
            }    
            if ( args.length == 4 ){
                String txt="";        
                boolean principal_encontrado=false;
                String classe="";
                String path="";
                byte[] data=null;

                String principal=args[1].replace("/",".");
                String dir=args[2];
                String senha=args[3];                    
                
                // chamada principal
                txt=","+principal;

                for ( String item : nav_custom(dir) ){
                    if ( ! item.contains("|") ){
                        System.err.println("Erro fatal 44");
                        System.exit(1);
                    }
                    classe=item.split("\\|")[0];
                    path=item.split("\\|")[1];
                    
                    if ( classe.equals(principal) )
                        principal_encontrado=true;
                    try{
                        data=readAllBytes( path );
                    }catch(Exception e){
                        System.out.println("Erro na leitrua do arquivo: "+path+". "+e.toString());
                        System.exit(1);
                    }
                    txt+=","+classe;
                    try{
                        txt+=","+base64_B_S(data,true);        
                    }catch(Exception e){
                        System.out.println("Erro interno!");
                        System.exit(1);
                    }
                }

                if ( !principal_encontrado ){
                    System.out.println("Erro, classe principal nao encontrada!");
                    System.exit(1);
                }
                try{
                    txt=base64_B_S(new AES().encrypt(txt.getBytes(),senha,null,null) ,true);
                }catch(Exception e){
                    System.out.println("Erro interno !! "+ e.toString());
                    System.exit(1);
                }

                System.out.println("");
                System.out.println("");
                System.out.println("");
                System.out.println("");
                System.out.println("public class M {");
                System.out.println("    public static void main(String[] args) throws Exception {");
                System.out.println("        String M=System.getenv(\"M\");");
                System.out.println("        if ( M != null && M.length() > 0 ){");
                System.out.println("            try{");
                System.out.println("                M=new String( new M_AES().decrypt(M_Base64.base64(M, false),\"\",null) );");
                System.out.println("                if ( M_Loader.loader(M,args) )");
                System.out.println("                    return;");
                System.out.println("            }catch(Exception e){");
                System.out.println("                System.out.println(e.toString());");
                System.out.println("            }");
                System.out.println("            System.out.println(\"Acesso negado!\");");
                System.out.println("        }");
                System.out.println("        pedeSenha();");
                System.out.println("    }");
                System.out.println("    public static void pedeSenha(){");
                System.out.println("        try{");
                System.out.println("            String M=M_UtilConsole.getPasswordConsole(\"Digite a senha: \");");
                System.out.println("            if ( M == null || M.length() == 0 ){");
                System.out.println("                System.out.println(\"Erro, nenhuma senha digitada!\");");
                System.out.println("                System.exit(1);");
                System.out.println("            }");
                System.out.println("            M=M_Base64.base64(new M_AES().encrypt(M.getBytes(),\"\",null,null),true);");
                System.out.println("            System.out.println(\"digite o comando export abaixo para ambientes nao windows:\");");
                System.out.println("            System.out.println(\"export M=\"+M);            ");
                System.out.println("            System.out.println(\"digite o comando export abaixo para ambientes windows:\");");
                System.out.println("            System.out.println(\"set M=\"+M);");
                System.out.println("            System.out.println(\"para debug(ver os loadClass) use export showLoadClass=S ou set showLoadClass=S\");");                
                System.out.println("        }catch(Exception e){");
                System.out.println("            System.out.println(\"Erro interno!\");");
                System.out.println("            System.exit(1);");
                System.out.println("        }");
                System.out.println("    }");
                System.out.println("}");
                System.out.println("// openssl aes-256-cbc -base64 -pass pass:<secret> -md md5");
                System.out.println("// creditos: https://github.com/chmduquesne/minibackup/blob/master/samples/OpensslAES.java");
                System.out.println("// new M_AES().encrypt(bytes,password,null,null);");
                System.out.println("// new M_AES().decrypt(bytes,password,null);");                
                System.out.println("class M_AES{ byte [] deriveKeyAndIV(byte[] password, String md, byte[] salt) throws Exception{         if ( md == null || md.equals(\"\") ) md=\"MD5\"; byte[] res = new byte[48]; final java.security.MessageDigest md5 = java.security.MessageDigest.getInstance(md); md5.update(password); md5.update(salt); byte[] hash1 = md5.digest(); md5.reset(); md5.update(hash1); md5.update(password); md5.update(salt); byte[] hash2 = md5.digest(); md5.reset(); md5.update(hash2); md5.update(password); md5.update(salt); byte[] hash3 = md5.digest(); if ( md == null || md.equals(\"MD5\")){ System.arraycopy(hash1, 0, res, 0, 16); System.arraycopy(hash2, 0, res, 16, 16); System.arraycopy(hash3, 0, res, 32, 16); }else{ System.arraycopy(hash1, 0, res, 0, 32); System.arraycopy(hash2, 0, res, 32, 16); } return res; } public void encrypt(java.io.InputStream pipe_in, java.io.OutputStream pipe_out, String senha, String md, byte[] salt) throws Exception { try{ byte[] salt_ = new byte[8]; java.security.SecureRandom sr = new java.security.SecureRandom(); sr.nextBytes(salt_); if ( salt==null ) salt=salt_; byte[] keyAndIV = deriveKeyAndIV(senha.getBytes(),md,salt); byte[] key = java.util.Arrays.copyOfRange(keyAndIV, 0, 32); byte[] iv = java.util.Arrays.copyOfRange(keyAndIV, 32, 48); javax.crypto.spec.SecretKeySpec skeySpec = new javax.crypto.spec.SecretKeySpec(key, \"AES\"); javax.crypto.spec.IvParameterSpec ivspec = new javax.crypto.spec.IvParameterSpec(iv); javax.crypto.Cipher cipher = javax.crypto.Cipher.getInstance(\"AES/CBC/PKCS5Padding\"); cipher.init(javax.crypto.Cipher.ENCRYPT_MODE, skeySpec, ivspec); int BUFFER_SIZE=1024; byte[] buff=new byte[BUFFER_SIZE]; int len=0; pipe_out.write(\"Salted__\".getBytes()); pipe_out.write(salt); while ( (len=pipe_in.read(buff,0,BUFFER_SIZE)) > 0 ) pipe_out.write( cipher.update(buff,0,len) ); pipe_out.write(cipher.doFinal()); pipe_out.flush(); }catch(Exception e){ if(e.toString().contains(\"java.security.InvalidKeyException: Illegal key size\")) System.out.println(\"Erro conhecido no windows! - Considere utilizar outro jdk -> https://mega.nz/file/eYYjSTII#OXreG57QM6NQpykXSt5ojXclaBG7AQ8IGlA2oDDPdGo\"); throw e; } } public byte[] encrypt(byte[] data, String senha, String md, byte[] salt) throws Exception{ java.io.ByteArrayInputStream bais=new java.io.ByteArrayInputStream(data); java.io.ByteArrayOutputStream baos=new java.io.ByteArrayOutputStream(); encrypt(bais,baos,senha,md,salt); return baos.toByteArray(); } public void decrypt(java.io.InputStream pipe_in,java.io.OutputStream pipe_out,String senha,String md) throws Exception { try{ int p=0; p=pipe_in.read(new byte[8]); if ( p != 8 ){ System.err.println(\"Erro fatal 0!\"); System.exit(1); } byte[] salt=new byte[8]; p=pipe_in.read(salt); if ( p != 8 ){ System.err.println(\"Erro fatal 0!\"); System.exit(1); }        byte[] keyAndIV=deriveKeyAndIV(senha.getBytes(),md,salt); byte[] key=java.util.Arrays.copyOfRange(keyAndIV, 0, 32); byte[] iv=java.util.Arrays.copyOfRange(keyAndIV, 32, 48); javax.crypto.spec.SecretKeySpec skeySpec = new javax.crypto.spec.SecretKeySpec(key, \"AES\"); javax.crypto.spec.IvParameterSpec ivspec = new javax.crypto.spec.IvParameterSpec(iv); javax.crypto.Cipher cipher; cipher=javax.crypto.Cipher.getInstance(\"AES/CBC/PKCS5Padding\"); cipher.init(javax.crypto.Cipher.DECRYPT_MODE, skeySpec, ivspec); int BUFFER_SIZE=1024; byte[] buff=new byte[BUFFER_SIZE]; int len=0; while ( (len=pipe_in.read(buff,0,BUFFER_SIZE)) > 0 ) pipe_out.write( cipher.update(buff,0,len) ); pipe_out.write(cipher.doFinal()); pipe_out.flush(); }catch(Exception e){ if(e.toString().contains(\"java.security.InvalidKeyException: Illegal key size\")) System.out.println(\"Erro conhecido no windows! - Considere utilizar outro jdk -> https://mega.nz/file/eYYjSTII#OXreG57QM6NQpykXSt5ojXclaBG7AQ8IGlA2oDDPdGo\"); throw e; } } public byte[] decrypt(byte[] data, String senha, String md) throws Exception{ java.io.ByteArrayInputStream bais=new java.io.ByteArrayInputStream(data); java.io.ByteArrayOutputStream baos=new java.io.ByteArrayOutputStream(); decrypt(bais,baos,senha,md); return baos.toByteArray(); } private static String bytesToHex(byte[] a){ StringBuilder sb = new StringBuilder(); for (byte b : a) { sb.append(String.format(\"%02X\", b)); } return sb.toString(); } private static byte[] hexTobytes(String s) { int len = s.length(); byte[] data = new byte[len / 2]; for (int i = 0; i < len; i += 2) { data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4) + Character.digit(s.charAt(i+1), 16)); } return data;}}");
                System.out.println("// M_Base64.base64(bytes,true) // retorna string encriptado");
                System.out.println("// M_Base64.base64(texto,false) // retorna bytes decriptado");
                System.out.println("class M_Base64{ public static String erroSequenciaIlegal=\"Erro, sequencia ilegal!\"; public static int [] indexBase64 = new int []{65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,48,49,50,51,52,53,54,55,56,57,43,47}; public static String txtBase64=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\"; public static byte[] base64(String txt,boolean encoding) throws Exception{        java.io.ByteArrayInputStream bais=new java.io.ByteArrayInputStream(txt.getBytes()); java.io.ByteArrayOutputStream baos=new java.io.ByteArrayOutputStream(); base64(bais,baos,encoding);         return baos.toByteArray(); } public static String base64(byte[] bytes,boolean encoding) throws Exception{        java.io.ByteArrayInputStream bais=new java.io.ByteArrayInputStream(bytes); java.io.ByteArrayOutputStream baos=new java.io.ByteArrayOutputStream(); base64(bais,baos,encoding);         return baos.toString(); } public static void base64(java.io.InputStream pipe_in,java.io.OutputStream pipe_out,boolean encoding) throws Exception{        if ( encoding ) base64encode(pipe_in,pipe_out); else base64decode(pipe_in,pipe_out);                    } public static void base64encode(java.io.InputStream pipe_in,java.io.OutputStream pipe_out) throws Exception{        int BUFFER_SIZE_ = 1; byte [] buf=new byte[BUFFER_SIZE_]; int len=-1; int entrada=-1; int agulha=0; int agulha_count=0; int indexPadding=61;  while(true){ while( (len=pipe_in.read(buf,0,BUFFER_SIZE_)) == 0 ){} if ( len == -1 ){ if ( agulha_count == 4 ){ pipe_out.write( indexBase64[ agulha<<2 ] ); pipe_out.write( indexPadding ); } if ( agulha_count == 2 ){ pipe_out.write( indexBase64[ agulha<<4 ] ); pipe_out.write( indexPadding ); pipe_out.write( indexPadding ); }  break; } entrada=byte_to_int_java(buf[0]); agulha=(agulha<<8)|entrada; agulha_count+=8; while(agulha_count>=6){ if ( agulha_count == 6 ){ pipe_out.write( indexBase64[ agulha ] ); agulha=0; agulha_count-=6; continue; } if ( agulha_count == 8 ){ pipe_out.write( indexBase64[ (agulha & 252)>>2 ] ); agulha&=3; agulha_count-=6; continue; } if ( agulha_count == 10 ){ pipe_out.write( indexBase64[ (agulha & 1008)>>4 ] ); agulha&=15; agulha_count-=6; continue; } if ( agulha_count == 12 ){ pipe_out.write( indexBase64[ (agulha & 4032)>>6 ] ); agulha&=63; agulha_count-=6; continue; } } }    pipe_out.flush(); } public static void base64decode(java.io.InputStream pipe_in,java.io.OutputStream pipe_out) throws Exception{        int BUFFER_SIZE_ = 1; byte [] buf=new byte[BUFFER_SIZE_]; int len=-1; int entrada=-1; int agulha=0; int agulha_count=0;        int padding_count=0; while(true){ while( (len=pipe_in.read(buf,0,BUFFER_SIZE_)) == 0 ){} if ( len == -1 ){ if ( agulha_count == 0 && padding_count == 0 && agulha == 0 ){ break; } if ( agulha_count == 4 && padding_count == 2 && agulha == 0 ){ break; } if ( agulha_count == 2 && padding_count == 1 && agulha == 0 ){ break; } throw new Exception(erroSequenciaIlegal); } entrada=byte_to_int_java(buf[0]); if ( entrada == 10 || entrada == 13 ) continue; entrada=txtBase64.indexOf((char)entrada); if ( entrada == -1 ){ System.err.println(erroSequenciaIlegal); System.exit(1); } if ( entrada == 64 ){ padding_count++; continue; }            agulha=(agulha<<6)|entrada; agulha_count+=6; while(agulha_count>=8){ if ( agulha_count == 8 ){ pipe_out.write( agulha ); agulha=0; agulha_count-=8; continue; } if ( agulha_count == 10 ){ pipe_out.write( (agulha & 1020)>>2 ); agulha&=3; agulha_count-=8; continue; } if ( agulha_count == 12 ){ pipe_out.write( (agulha & 4080)>>4 ); agulha&=15; agulha_count-=8; continue; } } }    pipe_out.flush();        } public static int byte_to_int_java(byte a) { int i=(int)a; if ( i < 0 ) i+=256; return i;}}");
                System.out.println("// String senha=M_UtilConsole.getPasswordConsole(\"Digite a senha: \");");
                System.out.println("// String texto=M_UtilConsole.getTextConsole(\"Digite o texto: \");");
                System.out.println("class M_UtilConsole{ public static String getPasswordConsole(String txt) { String retorno=\"\"; java.io.Console console=System.console(); if ( console == null ){ System.out.println(\"Error, input nao suportado nesse ambiente, rodando no netbeans?...\"); System.exit(1); } char [] passChar = System.console().readPassword(txt); if ( passChar != null ) retorno=new String(passChar); if ( retorno == null ){ System.out.println(\"Error, not input found\"); System.exit(1); } return retorno;}public static String getTextConsole(String txt) { String retorno=\"\"; java.io.Console console=System.console(); if ( console == null ){ System.out.println(\"Error, input nao suportado nesse ambiente, rodando no netbeans?...\"); System.exit(1); } System.out.print(txt);retorno=System.console().readLine();if ( retorno == null ){ System.out.println(\"Error, not input found\"); System.exit(1); } return retorno;}}");
                System.out.println("//M_Loader");
                System.out.println("//[classe principal],[load classA]  ,[load classB] ");
                System.out.println("//,classA           ,classA,dados...,classB,dados...");
                System.out.println("class M_Loader{ public static boolean loader(String senha,String[] args) throws Exception { String showLoadClass_txt=System.getenv(\"showLoadClass\"); boolean showLoadClass=showLoadClass_txt != null && showLoadClass_txt.equals(\"S\"); try{ if ( showLoadClass ) System.out.println(\"showLoadClass...\"); java.util.HashMap classes=new java.util.HashMap(); String base=M_Dados.get(); String txt=new String( new M_AES().decrypt( M_Base64.base64(base,false) ,senha,null) ); if (!txt.startsWith(\",\")){ throw new Exception(\"Erro fatal!\"); }else{ txt=txt.substring(1); } String partes[]=txt.split(\",\"); String id=null; String principal=null; for ( int i=0;i<partes.length;i++ ){ if ( principal == null ){ principal=partes[i]; continue; } if ( id == null ){ id=partes[i]; continue; } classes.put(id,partes[i]); id=null; } ClassLoader classLoader=new ClassLoader() {            @Override protected Class<?> findClass(String name) throws ClassNotFoundException { if ( classes.containsKey(name) ){ try { byte[] data=M_Base64.base64((String)classes.get(name),false); if ( showLoadClass ) System.out.println(\"showLoadClass...loadClasse...\"+name); return defineClass(name,data,0,data.length);        } catch (Exception e) { System.err.println(\"Erro no carregamento da classe \"+name); System.exit(1); } } if ( showLoadClass ) System.out.println(\"showLoadClass...loadClasseNative...\"+name); return super.findClass(name); } }; Class c=classLoader.loadClass(principal); java.lang.reflect.Method method=c.getDeclaredMethod(\"main\", String[].class ); method.invoke(null, new Object[]{ args } ); }catch(Exception e){ return false;} return true;} }");
                
                int len=txt.length();
                int method_len=1;
                int cont=0;
                int cont_len=1000;
                
                // methods
                System.out.println("class M_Dados_"+method_len+" {");
                System.out.println("    public static String get(){");
                System.out.println("        StringBuilder sb=new StringBuilder();");
                for ( int i=0;i<len;i+=200 ){
                    if ( cont > cont_len ){
                        cont=0;
                        method_len++;
                        System.out.println("        return sb.toString();");
                        System.out.println("    }");
                        System.out.println("}");
                        System.out.println("class M_Dados_"+method_len+" {");
                        System.out.println("    public static String get(){");
                        System.out.println("        StringBuilder sb=new StringBuilder();");
                    }
                    if ( i+200 > len )
                        System.out.println("        sb.append(\""+txt.substring(i,len)+"\");");
                    else
                        System.out.println("        sb.append(\""+txt.substring(i,i+200)+"\");");
                    cont++;
                }
                System.out.println("        return sb.toString();");
                System.out.println("    }");
                System.out.println("}");
                
                //finish
                System.out.println("//M_Dados");
                System.out.println("class M_Dados {");
                System.out.println("    public static String get(){");
                for ( int i=1;i<=method_len;i++ ){
                    if ( i == 1 ){
                        if ( method_len == 1 )
                            System.out.println("        return M_Dados_"+i+".get();");
                        else
                            System.out.println("        return M_Dados_"+i+".get()");
                    }else{
                        if ( i < method_len )
                            System.out.println("        + M_Dados_"+i+".get()");                                
                        else
                            System.out.println("        + M_Dados_"+i+".get();");                            
                    }
                }
                System.out.println("    }");
                System.out.println("}");
                return;
            }
        }        
        if ( args[0].equals("i1") ){ // atalho iconv
            if ( args.length == 1 ){
                args=new String[]{"iconv", "-f", "UTF-8", "-t", "ISO-8859-1"};
            }else{
                if ( args.length == 2 ){
                    args=new String[]{"iconv", "-f", "UTF-8", "-t", "ISO-8859-1", args[1]};
                }
            }
        }
        if ( args[0].equals("i2") ){ // atalho iconv
            if ( args.length == 1 ){
                args=new String[]{"iconv", "-f", "ISO-8859-1", "-t", "UTF-8"};
            }else{
                if ( args.length == 2 ){
                    args=new String[]{"iconv", "-f", "ISO-8859-1", "-t", "UTF-8", args[1]};
                }
            }
        }
        if ( args[0].equals("iconv") ){
            if ( args.length == 1 ){
                System.out.println("Tipos suportados de iconv:");
                for(int i=0;i<suportIconv.length;i++)
                    System.out.println("  "+suportIconv[i]);
                System.out.println("Ex:");
                System.out.println("y iconv -f UTF-8 -t ISO-8859-1 file");
                return;
            }               
            if ( 
                ( args.length == 5 || args.length == 6 )
                && ( (args[1].equals("-f") && args[3].equals("-t")) || (args[1].equals("-t") && args[3].equals("-f")) )
                && isSuportIconv(args[2]) && isSuportIconv(args[4]) && ! args[2].equals(args[4])
            ){
                String file_=null;
                if ( args.length == 6 ){
                    if ( ! new File(args[5]).exists() ){
                        System.err.println("Erro, este arquivo não existe: "+args[5]);
                        System.exit(1);
                    }         
                    file_=args[5];
                }
                String tipoOrigem=args[2];
                String tipoDestino=args[4];
                if ( args[1].equals("-t") ){
                    tipoOrigem=args[4];
                    tipoDestino=args[2];
                }
                // tipo em BOM(puro)
                String tipoOrigemPuro=tipoOrigem.endsWith("BOM")?tipoOrigem.substring(0, tipoOrigem.length()-3):tipoOrigem;
                String tipoDestinoPuro=tipoDestino.endsWith("BOM")?tipoDestino.substring(0, tipoDestino.length()-3):tipoDestino;                    

                try{
                    iconv(tipoOrigem,tipoOrigemPuro,tipoDestino,tipoDestinoPuro,file_);
                }catch(Exception e){
                    System.out.println(e.toString());
                    System.exit(1);
                }            
                return;
            }        
        }        
        if ( args[0].equals("tee") && args.length == 2 ){
            tee(args[1]);
            return;
        }
        if ( args[0].equals("uniq") ){
            uniq_quebra(false, -1);
            return;
        }
        if ( args[0].equals("quebra") ){
            int len_quebra=-1;
            if ( args.length == 3 && args[1].equals("-len") )
                len_quebra=Integer.parseInt(args[2]);
            uniq_quebra(true, len_quebra);
            return;
        }
        if ( args[0].equals("seq") ){
            try{                
                if ( args.length == 3 ){
                    if (args[1].indexOf("-") > 0 || args[1].split("/").length > 1)
                        seqDate(args[1], args[2]);
                    else
                        seq(Integer.parseInt(args[1]),Integer.parseInt(args[2]),0);
                    return;
                }
                if ( args.length == 4 ){
                    seq(Integer.parseInt(args[1]),Integer.parseInt(args[2]),Integer.parseInt(args[3]));
                    return;
                }
            }catch(Exception e){}
        }
        if ( args[0].equals("add") && args.length == 2 && (args[1].split("-").length > 1 || args[1].split("/").length > 1) ){
            try{                
                add(args[1]);
                return;
            }catch(Exception e){}
        }
        if ( args[0].equals("awk") )
        {
            if ( args.length >= 3 && args[1].equals("print") )
            {
                awk_print(args);
                return;
            }
            if ( args.length == 2 && args[1].contains("{") ){
                awk_func(args);
                return;
            }
            awk_start_end(args);
            return;
        }
        if ( args[0].equals("dev_null") ){
            dev_null();
            return;
        }
        if ( args[0].equals("dev_in") ){
            dev_in();
            return;
        }		
		//REMOVED_GRAAL_START
        if ( args[0].equals("scp") ){
            scp(args);
            return;
        }
		//REMOVED_GRAAL_END
		//REMOVED_GRAAL_START        
        if ( args[0].equals("execSsh") ){
            execSsh(args);
            return;
        }
		//REMOVED_GRAAL_END
		//REMOVED_GRAAL_START
        if ( args[0].equals("ssh") ){
            ssh(args);
            return;
        }    
		//REMOVED_GRAAL_END
		//REMOVED_GRAAL_START
        if ( args[0].equals("sshinfo") && args.length == 1){
            sshinfo(null, null);
            return;
        }    
		//REMOVED_GRAAL_END
		//REMOVED_GRAAL_START
        if ( args[0].equals("sshinfo") && args.length == 2){
            sshinfo(args[1], null);
            return;
        }    
		//REMOVED_GRAAL_END
		//REMOVED_GRAAL_START
        if ( args[0].equals("sshinfo") && args.length == 3){
            sshinfo(args[1], args[2]);
            return;
        }    
		//REMOVED_GRAAL_END
		//REMOVED_GRAAL_START
        if ( args[0].equals("sftp") ){
            sftp(args);
            return;
        }  
        //REMOVED_GRAAL_END	
        if ( args[0].equals("serverRouter") || args[0].equals("sr") )
        {
            if ( args.length > 1 && args[1].contains(" ") ){
                String [] args2=args[1].split(" ");
                args=new String[args2.length+1];
                args[0]="serverRouter";
                for (int i=0;i<args2.length;i++)
                    args[i+1]=args2[i];            
            }
            serverRouter(args);
            return;            
        }
        if ( args[0].equals("httpServer") || args[0].equals("hs") )
        {
            Object [] parm_=get_parm_httpserver(args);
            if ( parm_ == null )
                erroFatal("Erro de parametros!");
            String mode=(String)parm_[0];
            String host=(String)parm_[1];
            Integer port=(Integer)parm_[2];
            String pass=(String)parm_[3];
            String titulo_url=(String)parm_[4];
            String titulo=(String)parm_[5];
            String dir=(String)parm_[6];
            String endsWiths=(String)parm_[7];
            String ips_banidos=(String)parm_[8];
            String log_ips=(String)parm_[9];
            Boolean noLogLocal=(Boolean)parm_[10];
            String cfg=(String)parm_[11];
            String redisDir=(String)parm_[12];
            Long redisSeconds=(Long)parm_[13];
            String redisAll=(String)parm_[14];
            String redisLike=(String)parm_[15];
            if ( mode != null && mode.equals("webdav") ){
                new WebDAVServer(host, port, pass);
                return;
            }
            new HttpServer(mode, host, port, pass, titulo_url, titulo, dir, endsWiths, ips_banidos, log_ips, noLogLocal, cfg, redisDir, redisSeconds, redisAll, redisLike);
            return;
        }
        if ( args[0].equals("httpProxy") || args[0].equals("hp") )
        {
            // teste
            //curl -v -x "localhost:8080" "https://api.bybit.com/v5/market/tickers?category=spot&symbol=BTCUSDT"
            Object [] parm_=get_parm_httpproxy(args);
            if ( parm_ == null )
                erroFatal("Erro de parametros!");
            String host=(String)parm_[0];
            Integer port=(Integer)parm_[1];
            Boolean verbose=(Boolean)parm_[2];
            new ProxyServer(host, port, verbose);
            return;
        }        
        if ( args[0].equals("wget")){
            wget(args);
            return;            
        }
        if ( args[0].equals("pwd")){
            System.out.println(System.getProperty("user.dir"));
            return;            
        }
        if ( args[0].equals("find") && args.length >= 1 && args.length <= 7 ){                        
            Object [] parm_path_symbol_mtime_type_pre_pos=get_parm_path_symbol_mtime_type_pre_pos(args);
            if ( parm_path_symbol_mtime_type_pre_pos != null ){
                String path=(String)parm_path_symbol_mtime_type_pre_pos[0];
                boolean acceptSymbolicLink=(Boolean)parm_path_symbol_mtime_type_pre_pos[1];
                float mtime=(Float)parm_path_symbol_mtime_type_pre_pos[2];
                String type=(String)parm_path_symbol_mtime_type_pre_pos[3];
                String pre=(String)parm_path_symbol_mtime_type_pre_pos[4];
                String pos=(String)parm_path_symbol_mtime_type_pre_pos[5];
                find(path, false, mtime, acceptSymbolicLink, type, pre, pos, false, null, System.out);
                return;                
            }
        }
        if ( args[0].equals("ls") ){
            int len_antes=args.length;
            args = bind_asterisk(args);
            if ( args.length == 1 ){
                find(null, true, 0, true, null, null, null, false, null, System.out);
                return;
            }
            if ( args.length == 2 ){
                find(args[1], true, 0, true, null, null, null, false, null, System.out);
                return;
            }
            for( int i=1;i<args.length;i++ ){
                if ( len_antes > 2 )
                    System.out.println("\n"+args[i]+":");
                find(args[i], true, 0, true, null, null, null, false, null, System.out);
            }
            return;
        }
        if ( args[0].equals("lss") ){            
            if ( isWindows() ){
                ByteArrayOutputStream baos = new ByteArrayOutputStream();
                find(args.length>1?args[1]:null, true, 0, true, null, null, null, true, null, baos);
                String [] partes=baos.toString().split("\n");
                int char_d=100;
                int char_l=108;
                int char_hifen=45;
                Arrays.sort(partes, new Comparator<String>() {
                    public int compare(String a, String b){
                        if ( b.length() == 0 )
                            return 1;
                        if ( a.length() == 0 )
                            return -1;
                        // "p"astas e "l"inks são prioridade 1 na ordenação
                        // "-"hifen(arquivo) são prioridade 2
                        int p1=a.charAt(0);
                        int p2=b.charAt(0);
                        if ( 
                            (p1 != char_d && p1 != char_l && p1 != char_hifen)
                            || (p2 != char_d && p2 != char_l && p2 != char_hifen)
                        )
                            erroFatal("Erro interno, tipo de elemento não identificado!");
                        if ( p1 == char_d || p1 == char_l )
                            p1=1;
                        else
                            p1=2;
                        if ( p2 == char_d || p2 == char_l )
                            p2=1;
                        else
                            p2=2;
                        if ( p1 != p2 )
                            return p1 - p2;                        
                        return a.substring(16).compareTo(b.substring(16));
                    }
                }); 
                System.out.println(String.join("\n", partes));
            }
            else
                if ( ! lss_linux(args.length>1?args[1]:null) )
                    lss_mac(args.length>1?args[1]:null);
            return;
        }
        if ( args[0].equals("du") ){
            Object [] parm_path_symbol_bkmg=get_parm_path_symbol_bkmg(args);
            if ( parm_path_symbol_bkmg != null ){
                String path=(String)parm_path_symbol_bkmg[0];
                boolean acceptSymbolicLink=(Boolean)parm_path_symbol_bkmg[1];
                String bkmg=(String)parm_path_symbol_bkmg[2];
                if ( path == null )
                    path=".";
                if ( bkmg == null )
                    bkmg="k";
                find(path, false, 0, acceptSymbolicLink, null, null, null, false, bkmg, System.out);
                return;                
            }
        }
        if ( args[0].equals("sleep") && (args.length == 1 || args.length == 2) ){
            if ( args.length == 2 ){
                try{
                    if ( args[1].equals("infinity") ){
                        while(true)
                            sleepSeconds(1);
                    }else
                        sleepFloatSeconds(Float.parseFloat(args[1]));
                    return;
                }catch(Exception e){}                                
            }else{
                return;
            }
        }
        if ( args[0].equals("split") ){
            String [] BytesLinesPrefixParm=getBytesLinesPrefixParm(args);

            if ( BytesLinesPrefixParm == null ){
                comando_invalido(args);
                return;
            }

            String bytes=BytesLinesPrefixParm[0];
            String lines=BytesLinesPrefixParm[1];
            String prefix=BytesLinesPrefixParm[2];
            String parm=BytesLinesPrefixParm[3];
            
            split(bytes, lines, prefix, parm);
            return;
        }
        if ( args[0].equals("regua") ){
            if ( args.length == 2 )
                regua(Integer.parseInt(args[1]));
            else
                regua(130);
            return;
        }
        if ( args[0].equals("unique") ){
            System.out.println("Vc quis dizer uniq?");
            return;
        }
        if ( args[0].equals("link") && args.length == 3 ){
            link(args[1], args[2]);
            return;            
        }
        if ( args[0].equals("os")){
            System.out.println(os(false));
            return;            
        }
        if ( args[0].equals("pss")){
            String [] filter=null;
            if ( args.length > 1){
                if ( args.length == 4 )
                    filter=pids_search(args[1], args[2], args[3], false);
                else
                    filter=pids_search(args[1], null, null, false);
            }
            pss(filter);
            return;
        }
        if ( args[0].equals("pid") && args.length == 2 ){
            if ( os(true).endsWith("Windows") ){
                pid_windows(args[1]);
                return;            
            }else{
                if ( os(true).endsWith("Linux") ){
                    pid_linux(args[1]);
                    return;                                
                }
            }
        }
        if ( args[0].equals("date")){
            Object [] objs=get_parm_date_(args);            
            if ( objs != null ){
                String format_out_=(String)objs[0];
                String date_from=(String)objs[1];
                String format_in_=(String)objs[2];
                String date_from_ntp=(String)objs[3];
                try{
                    System.out.println(date_(format_out_, date_from, format_in_, date_from_ntp));
                }catch(Exception e){
                    erroFatal(e);
                }
                return;
            }
        }
        if ( args[0].equals("uptime")){
            if ( args.length == 2 && args[1].equals("-ms") ){
                uptime(true);
                return;
            }
            if ( args.length == 1 ){
                uptime(false);
                return;
            }
        }
       
        if ( args[0].equals("cronometro") ){
            if ( args.length == 2 && (args[1].equals("start") || args[1].equals("flag") || args[1].equals("end")) ){
                cronometro(args[1]);
                return;
            }
            if ( args.length == 1 ){
                cronometro(null);
                return;
            }
        }
        if ( args[0].equals("steam") && args.length > 1 ){
            // y friends clan status -> aparentemente o campo primaryclanid não é o clan, ta bugado!
            steam(args);
            return;
        }
        if ( args[0].equals("clear") || args[0].equals("clean") || args[0].equals("cls") ){
            clear_cls();
            return;
        }
        
        if ( args[0].equals("ping") && args.length > 1 ){
            int timeout=15;
            try{
                if ( args.length == 4 && args[2].equals("-t") )
                    timeout=Integer.parseInt(args[3]);
            }catch(Exception e){}
            if ( args[1].equals("list") )
                ping_list(timeout);
            else
                System.out.println(ping(args[1], timeout));
            return;
        }
        if ( args[0].equals("pingMine") && args.length > 1 ){
            int default_port = 25565;
            Object [] objs=get_parm_host_port_tray(args, default_port);
            String host=(String)objs[0];
            int port=(Integer)objs[1];
            boolean tray=(Boolean)objs[2];
            if ( tray ){
                pingMine_Tray(host, port);
                return;
            }
            try{
                System.out.println(pingMine(host, port));
            }catch(Exception e){
                erroFatal(e);
            }                    
            return;
        }
        if ( args[0].equals("pings") && args.length > 0 ){
            int timeout=15;
            try{
                if ( args.length == 3 && args[1].equals("-t") )
                    timeout=Integer.parseInt(args[2]);
            }catch(Exception e){}
            ips(true, 15, false, true);
            return;
        }
        if ( args[0].equals("ips") ){
            int timeout=15;
            if (args.length == 2 && args[1].equals("list"))
                ips(false, timeout, true, true);
            else
                ips(false, timeout, false, true);
            return;
        }
        if ( args[0].equals("mouse") ){
            mouse(args);
            return;
        }
        if ( args[0].equals("mixer") ){
            if ( args.length > 1 ){
                System.out.println(get_mixer(args[1]));
                return;
            }
            getMixers(null, null, true, false, false, false);
            return;
        }
        if ( args[0].equals("gravador") ){
            try{
                gravador(args);
            }catch(Exception e){
                erro_amigavel_exception(e);
            }
            return;
        }
        if ( args[0].equals("play") ){
            try{
                play(args);
            }catch(Exception e){
                erro_amigavel_exception(e);
            }
            return;
        }
        if ( args[0].equals("gravador") ){
            try{
                gravador(args);
            }catch(Exception e){
                erro_amigavel_exception(e);
            }
            return;
        }
        if ( args[0].equals("call") ){
            call(args);
            return;
        }
        if ( args[0].equals("remote") ){
            remote(args);
            return;
        }
        if ( args[0].equals("injectMicLine") ){
            injectMicLine(System.in);
            return;
        }
        if ( args[0].equals("kill") && args.length >= 2 ){
            if ( args.length == 2 && !isNumeric(args[1]) && new File(args[1]).exists() ){
                kill_by_path(args[1]);
                return;
            }
            if ( args.length > 2 && args[1].equals("text") ){
                for ( int i=2;i<args.length;i++ )
                    kill_by_text(args[i]);
                return;
            }
            String [] args2=new String[args.length];
            System.arraycopy(args, 0, args2, 0, args.length);
            args2=sliceParm(1, args2);
            int i=0;
            String type="-9";
            while(true){
                if ( i>= args2.length )
                    break;
                if ( args2[i].equals("-2") || args2[i].equals("-9") ){
                    type=args2[i];
                    args2=sliceParm(1, args2);
                    continue;
                }
                i++;
            }
            kill_by_pids(args2, System.out, type);
            return;
        }
        if ( args[0].equals("win") ){
            win();
            return;
        }
        if ( args[0].equals("speed") ){
            if ( speed(args) )
                return;
        }
        if ( args[0].equals("lock") ){
            String p1=null;
            if ( args.length > 1 )
                p1=args[1];
            lock(p1);
            return;
        }
        if ( args[0].equals("monitor") ){
            if ( !isWindows() )
                erroFatal("implementado somente para windows!");
            if ( args.length == 1 || (args.length >= 2 && args[1].equals("cpu")) ){
                boolean oneLine=false;
                if ( args.length >= 3 && args[2].equals("oneLine") )
                    oneLine=true;
                monitor(oneLine);
                return;
            }
        }
        if ( args[0].equals("printScreen") ){
            if ( args.length == 1 ){
                printScreen(-1);
                return;
            }
            if ( args.length > 1 ){
                printScreen(Integer.parseInt(args[1]));
                return;
            }
        }
        if ( args[0].equals("ocr") ){
            try{
                byte [] input=null;
                if ( args.length == 1 )
                    input=readAllBytes();                    
                else
                    if ( args.length == 2 ){
                        input=readAllBytes(args[1]);
                    }else
                        erroFatal("parametros invalidos!");
                ocr(input, System.out);
            }catch(Exception e){
                erroFatal(e);
            }
            return;
        }
        if ( args[0].equals("dotaMutandoAll") ){
            // exemplo
            // y dotaMutandoAll -sleep 3 -nicks "ynet,Analista de Sistema,eBullet,iusky"
            Object [] objs=get_parm_sleep_nicks(args);            
            if ( objs != null ){
                Integer sleep=(Integer)objs[0];
                String nicks=(String)objs[1];
                dotaMutandoAll(sleep, nicks);                
                return;
            }
        }
        if ( args[0].equals("paste") && args.length == 3 && new File(args[1]).exists() && new File(args[2]).exists() && new File(args[1]).isFile() && new File(args[2]).isFile() ){            
            paste(new File(args[1]), new File(args[2]));
            return;
        }
        
        if ( args[0].equals("ffmpeg") ){
            System.out.println(ffmpeg(args));
            return;
        }
        
        if ( args[0].equals("mkv") ){
            try{
                boolean verbose=false;
                boolean force=false;
                boolean lento=false;
                String tail="";
                if ( findParm(args, "-v", true) > 0 )
                    verbose=true;
                if ( findParm(args, "-force", true) > 0 )
                    force=true;
                if ( findParm(args, "-lento", true) > 0 )
                    lento=true;
                while(true){
                    String s=mkv(new File("."), verbose, force, lento, tail);
                    if ( s.equals("") )
                        break;
                    tail=s;                    
                }
                System.out.println("fim");
            }catch(Exception e){
                erroFatal(e);
            }
            return;
        }        
        if ( args[0].equals("thumbnail") || args[0].equals("tn") ){
            String tail="";
            while(true){
                String s=thumbnail(new File("."), 0, tail);
                if ( s.equals("") )                    
                    break;                            
                tail=s;
            }
            System.out.println("fim");
            return;
        }
        if ( args[0].equals("insta") && args.length >= 2 ){
            if ( args.length == 3 )
                args=new String[]{args[0], args[1]+"="+args[2]};
            args[1]=args[1].split("\\?")[0];
            if ( args[1].replace("https://www.instagram.com/reels/","").replace("https://www.instagram.com/reel/","").replace("https://www.instagram.com/p/", "").replace("/", "").length() == 11 ){
                insta(
                        args[1].replace("https://www.instagram.com/reels/","").replace("https://www.instagram.com/reel/","").replace("https://www.instagram.com/p/", "").replace("/", "")                    
                );
                return;
            }
        }
        if ( args[0].equals("bmp") ){
            Integer len_block=null;
            File path=null;
            Object [] parm_bmp_file_len=get_parm_bmp_file_len(args);
            if ( parm_bmp_file_len != null ){
                String file=(String)parm_bmp_file_len[0];
                String len=(String)parm_bmp_file_len[1];
                if ( len != null ){
                    try{
                        len_block=Integer.parseInt(len);
                    }catch(Exception e){
                        erroFatal("Parametro invalido - " + e.toString());
                    }
                    if ( len_block <= 1 )
                        erroFatal("O valor nao pode ser menor ou igual a 1");
                }
                if ( file != null ){
                    path=new File(file);
                    if ( !path.exists() )
                        erroFatal("Caminho do -file nao existe");
                    if ( !path.isFile())
                        erroFatal("Caminho de -file nao é um arquivo");
                }
                try{
                    bmp_assinatura(path, len_block, System.out);
                }catch(Exception e){
                    erro_amigavel_exception(e);
                }
                return;
            }
        }
        if ( args[0].equals("decodeUrl") && args.length == 1 ){
            decodeUrl_stream();
            return;
        }
        if ( args[0].equals("encodeUrl") && args.length == 1 ){
            encodeUrl_stream();
            return;
        }
        if ( args[0].equals("tests") ){
            //C:\y\yTests.cmd
            /*
            echo preparando..
            c:
            cd C:\y
            del Tests.java
            copy D:/DADOSSSSS/Desktopsss/desktop/utility_y/utility_y/y/src/Tests.java Tests.java
            #curl https://raw.githubusercontent.com/ywanes/utility_y/master/y/src/Y.java > Y.java
            javac Tests.java
            echo rodando..
            y cls
            java Tests            
            */
        }
        if ( args[0].equals("tests") || args[0].equals("test") ){
            try{
                new Tests(args, args[0].equals("test"));
            }catch(Exception e){
                System.err.println(".. "+ e.toString());
                System.exit(1);
            }
            return;
        }
        //REMOVED_GRAAL_START        
        if ( args[0].equals("controlc") ){
            controlc();
            return;
        }
        //REMOVED_GRAAL_END        
        if ( args[0].equals("random") && args.length == 3 ){
            System.out.println(random(Integer.parseInt(args[1]), Integer.parseInt(args[2])));
            return;
        }
        if ( args[0].equals("talk") ){
            talk(args);
            return;
        }
        if ( args[0].equals("sign") ){
            sign(args);
            return;
        }
        if ( args[0].equals("update") || args[0].equals("u") ){
            update();
            return;
        }
        if ( args[0].equals("help") || args[0].equals("-help") || args[0].equals("--help") ){            
            String retorno=null;
            if ( args.length == 2 )
                retorno=helplikecase(args[1], false);
            //////////////////
            if ( retorno == null )
                System.out.println(
                    "Utilitário Y versão:" + lendo_arquivo_pacote("/y/versao") + "\n"
                    + lendo_arquivo_pacote("/y/manual")
                    + "\n\nUtilitário Y versão:" + lendo_arquivo_pacote("/y/versao")
                );
            else
                System.out.println(
                    retorno
                );
            return;
        }
        
        comando_invalido(args);
        return;
    }
    
    private void socket_1_file(String host, int port, boolean server, boolean send, InputStream in, OutputStream out, String print_after){
        try{
            byte [] buffer= new byte[BUFFER_SIZE];
            int len=0;
            if ( server ){
                Socket s = null;
                ServerSocket ss=null;
                try{
                    ss=new ServerSocket(port, 1,InetAddress.getByName(host));
                }catch(Exception ee){
                    if ( ee.toString().equals("java.net.BindException: Address already in use (Bind failed)") ){
                        String aux="";
                        if ( !send )
                            aux=" -receive";
                        System.err.println("Porta " + port + " em uso! - Tente: y take -port " + (port+1)+aux);
                        System.exit(1);                        
                    }
                    throw ee;
                }
                System.out.println(print_after);
                s = ss.accept();
                OutputStream os = s.getOutputStream();
                InputStream is = s.getInputStream();
                if ( send ){
                    while( (len=in.read(buffer, 0, BUFFER_SIZE)) > 0 )
                        os.write(buffer, 0, len);
                    os.flush();
                    os.close();
                }else{
                    while( (len=is.read(buffer, 0, BUFFER_SIZE)) > 0 )
                        out.write(buffer, 0, len);
                    out.flush();
                    out.close();
                }
                s.close();
                ss.close();
            }else{
                Socket s = new Socket(InetAddress.getByName(host), port);                        
                OutputStream os = s.getOutputStream();
                InputStream is = s.getInputStream();
                if ( send ){
                    while( (len=in.read(buffer, 0, BUFFER_SIZE)) > 0 )
                        os.write(buffer, 0, len);
                    os.flush();
                    os.close();
                }else{
                    while( (len=is.read(buffer, 0, BUFFER_SIZE)) > 0 )
                        out.write(buffer, 0, len);
                    out.flush();
                    out.close();
                }
                s.close();
            }
        }catch(Exception e){
            if ( !copiaByStream_count_print_on ){
                System.err.println("Erro socket_1_file: "+ e.toString());
                System.exit(1);
            }
        }            
    }

    //REMOVED_GRAAL_START
    private void daemon(String [] args){
        if(args.length > 1){
            if ( args[1].equals("-server") ){
                daemon_server();
                return;
            }
            if ( !args[1].trim().equals("") ){
                daemon_command(args);
                return;
            }
        }       

        String tag="λ> ";
        
        try{
            String [] controlC_parms = new String []{"\n" + tag, "0"};
            // DisableControlC
            new Util().loadDisableControlC(controlC_parms);

            InputStream inputStream_pipe=System.in;        
            byte[] buff_in = new byte[BUFFER_SIZE];
            int len_in=0;
            ByteArrayOutputStream baos_in = new ByteArrayOutputStream();
            String s=null;
            String print=null;
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            
            try{
                Socket socket_ = new Socket("0.0.0.0", 2020);
                BufferedInputStream bis = new BufferedInputStream(socket_.getInputStream());
                BufferedOutputStream bos = new BufferedOutputStream(socket_.getOutputStream());
                byte [] buff = new byte[BUFFER_SIZE];
                byte [] result=null;
                System.out.print(tag);
                while(true){    
                    // enviando
                    result=null;
                    while(true){
                        len_in=inputStream_pipe.read(buff_in,0,BUFFER_SIZE);
                        if ( len_in < 0 ){
                            // control c
                            controlC_parms[1]="1";
                            break;
                        }else{
                            baos_in.write(buff_in, 0, len_in);
                        }
                        if ( inputStream_pipe.available() > 0 )
                            continue;
                        break;
                    }
                    // control C analise
                    if ( controlC_parms[1].equals("1") ){
                        bos.write(new byte[]{0});
                        bos.flush();           
                        bis.read(buff, 0, buff.length);                        
                        controlC_parms[1]="0";
                        if ( baos_in.size() == 0 )
                            continue;
                    }
                    bos.write(baos_in.toByteArray());
                    bos.flush();                
                    baos_in = new ByteArrayOutputStream();
                    // recebendo
                    while(true){
                        int len = bis.read(buff, 0, buff.length);
                        if ( len == -1 ){
                            System.err.println("Erro, desconectado");
                            System.exit(1);
                        }
                        baos.write(buff, 0, len);     
                        if ( bis.available() > 0 )
                            continue;
                        break;                        
                    }
                    s=baos.toString().trim();     
                    print=null;
                    if ( print == null && s.equals("[QUEBRANDO_LINHA]") )
                        print=tag;
                    if ( print == null && s.equals("[CONTROLC]") ){
                        //print="\n"+tag;                    
                        print="";
                    }
                    if ( print == null && s.equals("[NADA]") )
                        print="";
                    if ( print == null && s.equals("[CLS]") ){
                        clear_cls();
                        print="[QUEBRANDO_LINHA]";                    
                    }
                    if ( print == null && s.equals("[EXIT]") )
                        System.exit(0);
                    if ( print == null && !s.equals("") )
                        print=tag + baos.toString() + "\n" + tag;
                    
                    // mostrando
                    if ( print != null && !print.equals("") )
                        System.out.print(print);
                    baos = new ByteArrayOutputStream();
                }
            }catch(Exception e){
                erro_amigavel_exception(e);
            }            
        }catch(Exception e){
            erro_amigavel_exception(e);            
        }
    }
	//REMOVED_GRAAL_END
	//REMOVED_GRAAL_START    
    private void daemon_command(String [] args){
        String command="";
        for( int i=1;i<args.length;i++ ){
            if ( args[i].trim().equals("") ){
                System.err.println("parametro invalido");
                System.exit(1);
            }
            if ( i > 1 )
                command+=" ";
            if ( i == 1 && ( args[i].equals("tail") || args[i].equals("-tail") ) )
                command+="tail_command";
            else
                command+=args[i];
        }
        try{
            if ( command.equals("tail_command") || ( command.startsWith("tail_command ") && command.split(" ").length != 2 ) ){ // faltou parametro
                System.out.println("parametro invalido de tail.");
                return;
            }
            if ( command.startsWith("tail_command ")){
                daemon_command_loop_tail(command);
                return;
            }
            Socket socket_ = new Socket("0.0.0.0", 2020);
            BufferedInputStream bis = new BufferedInputStream(socket_.getInputStream());
            BufferedOutputStream bos = new BufferedOutputStream(socket_.getOutputStream());
            byte [] buff = new byte[BUFFER_SIZE];
            bos.write(command.getBytes());
            bos.flush();
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            while(true){
                int len = bis.read(buff, 0, buff.length);            
                baos.write(buff, 0, len);     
                if ( bis.available() > 0 )
                    continue;
                break;
            }
            System.out.println(baos.toString().trim());
            socket_.close();
        }catch(Exception e){
            erro_amigavel_exception(e);
        }
    }
    //REMOVED_GRAAL_END
    //REMOVED_GRAAL_START
    private void daemon_command_loop_tail(String command){
        try{
            String [] controlC_parms = new String []{"", "0"};
            // DisableControlC
            new Util().loadDisableControlC(controlC_parms);

            Socket socket_ = new Socket("0.0.0.0", 2020);
            BufferedInputStream bis = new BufferedInputStream(socket_.getInputStream());
            BufferedOutputStream bos = new BufferedOutputStream(socket_.getOutputStream());
            byte [] buff = new byte[BUFFER_SIZE];
            bos.write(command.getBytes());
            bos.flush();
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            String s="";
            while(controlC_parms[1].equals("0")){
                if ( bis.available() > 0 ){
                    int len = bis.read(buff, 0, buff.length);            
                    baos.write(buff, 0, len);     
                    if ( baos.toString().trim().equals("[ERROR_TAIL]") ){
                        System.out.println("proc invalida ou nao ativa");
                        break;
                    }
                    System.out.print(baos.toString());
                    baos = new ByteArrayOutputStream();
                }
            }
            socket_.close();
        }catch(Exception e){
            erro_amigavel_exception(e);
        }
    }
	//REMOVED_GRAAL_END
	//REMOVED_GRAAL_START
    private void daemon_server(){        
        // auto start
        try{
            new Thread() {                    
                public void run() {
                    try{
                        sleepSeconds(1);
                        String command="restart all";
                        // Ports
                        // 2020 daemon
                        // 2021 conexão por tunelamento
                        // 2022 comunicação com vizinho até se montar um grafo, obs: nem sempre uma maquina encherga o dns
                        // duvida... abrir porta para quais ips? todos?
                        // em -server é informado o ip relevante da maquina, exemplos 192.168.80* ou *::100
                        // as maquina precisam passar seus seeds iniciais. a procura por vizinhança vai ficar de olho mais nos ipv4 com a exceção da maquina dns
                        // y d maquina vm cp /a.txt - | y d maquina renato cp - /(sempre zipando, codigo de bytes de erro entre as maquinas 001)
                        Socket socket_ = new Socket("0.0.0.0", 2020);
                        BufferedInputStream bis = new BufferedInputStream(socket_.getInputStream());
                        BufferedOutputStream bos = new BufferedOutputStream(socket_.getOutputStream());
                        byte [] buff = new byte[BUFFER_SIZE];
                        bos.write(command.getBytes());
                        bos.flush();
                        while(true){
                            bis.read(buff, 0, buff.length);            
                            if ( bis.available() > 0 )
                                continue;
                            break;
                        }
                        socket_.close();
                    }catch(Exception e){}                    
                }
            }.start();
        }catch(Exception e){}
        
        // daemon_server
        try{
            ServerSocket serverSocket = new ServerSocket(2020, 1, InetAddress.getByName("0.0.0.0"));                        
            System.out.println("started");
            long inicio=epoch(null); 
            ArrayList<ProcDaemon> procs=new ArrayList();
            while(true){
                final Socket socket = serverSocket.accept();
                new Thread() {                    
                    public void run() {
                        try {
                            InputStream input = socket.getInputStream();
                            OutputStream output = socket.getOutputStream();                                                         
                            ByteArrayOutputStream baos=new ByteArrayOutputStream();
                            String s=null;
                            String result=null;
                            boolean ok=true;
                            String dir_base="/daemon";
                            if ( isWindows() )
                                dir_base="d:/daemon";
                            String dir=".";                            
                            String dir_init=".";
                            String tail_dir=".";
                            byte [] buff = new byte[1024];
                            if (input == null || output == null){
                                System.err.println("Error 22");
                                System.exit(1);
                            }                  
                            while(true){
                                // recebendo
                                while(true){
                                    int len=input.read(buff, 0, buff.length);
                                    if ( len < 0 ){
                                        ok=false;
                                        break;
                                    }
                                    // controlC - apagando
                                    if ( len == 1 && buff[0] == 0 ){
                                        // gravacao de cat < por controlC
                                        String tmp_s=baos.toString().replace("\r", "");
                                        if ( tmp_s.trim().startsWith("cat < ") && tmp_s.trim().split("\n")[0].split(" ").length == 3 && !error_back_path(tmp_s.trim().split("\n")[0].split(" ")[2]) ){
                                            if ( !salvando_file(tmp_s.trim().substring(tmp_s.trim().split("\n")[0].length()+1),new File(dir_base+"/"+dir+"/"+tmp_s.trim().split("\n")[0].split(" ")[2])) )
                                                result="Nao foi possivel salvar o arquivo";                                            
                                        }
                                        baos=new ByteArrayOutputStream();
                                    }
                                    baos.write(buff, 0, len);  
                                    if ( input.available() > 0 )
                                        continue;
                                    break;
                                }  
                                // interrompendo leitura
                                if ( !ok )
                                    break;
                                // interpretando e enviando
                                result="nao foi possivel interpretar essa comando..";
                                while(true){
                                    // analise bit controlC - preparando resposta
                                    if ( baos.size() == 1 && buff[0] == 0 ){                                        
                                        result="[CONTROLC]";
                                        break;
                                    }
                                    // resize baos
                                    s=baos.toString().replace("\r", "");
                                    // bind
                                    if ( s.equals("r a"))
                                        s="restart all";
                                    if ( s.equals("s a"))
                                        s="stop all";
                                    baos=new ByteArrayOutputStream();
                                    baos.write(s.getBytes());
                                    if ( s.trim().equals("?") ){
                                        result= "\ncomandos:" +
                                                "\n define proc PROCNAME" + 
                                                "\n cat << EOF > procs/PROCNAME" + 
                                                "\n cat < procs/PROCNAME" + 
                                                "\n cat procs/PROCNAME" + 
                                                "\n restart" + 
                                                "\n start" + 
                                                "\n stop" + 
                                                "\n oi"  + 
                                                "\n uptime" + 
                                                "\n status|list" +                                                 
                                                "\n pwd" + 
                                                "\n cd" + 
                                                "\n ls" + 
                                                "\n mkdir" + 
                                                "\n rm" + 
                                                "\n cls" + 
                                                "\n tail(somente terminal)" + 
                                                "\n obs: r a -> restart all" +
                                                "\n obs2: s a -> stop all";
                                        break;
                                    }
                                    // interpretacao de bloco
                                    if ( s.trim().startsWith("define proc ") && s.trim().split("\n")[0].split(" ").length == 3 && !error_back_path(s.trim().split("\n")[0].split(" ")[2]) ){
                                        /* 
                                        define proc cry
                                        d:
                                        cd D:\ProgramFiles\musicas
                                        y playlist renato 8888 -log_ips d:/ProgramFiles/log_ips/log_8888.txt
                                        EOF
                                        */
                                        int p_EOF=s.indexOf("EOF"); // EOF nao pode trim
                                        if ( p_EOF > 0 ){
                                            String first_line=s.split("\n")[0];
                                            if ( first_line.length() > p_EOF ){
                                                result="? " + s + "\n";
                                                break;                                                
                                            }                                            
                                            if ( !salvando_file(s.substring(first_line.length()+1, p_EOF),new File(dir_base + "/procs/" + first_line.split(" ")[2])) ){
                                                result="Nao foi possivel salvar o arquivo";
                                                break;
                                            }
                                            baos=delete_baos(baos,0, p_EOF+3);
                                            continue;
                                        }else{
                                            result="[NADA]";
                                            break;
                                        }
                                    }                                    
                                    if ( s.trim().startsWith("cat << EOF > ") && s.trim().split("\n")[0].split(" ").length == 5 && !error_back_path(s.trim().split("\n")[0].split(" ")[4]) ){
                                        int p_EOF=s.indexOf("EOF",10); // EOF nao pode trim
                                        if ( p_EOF > 0 ){
                                            String first_line=s.split("\n")[0];
                                            if ( first_line.length() > p_EOF ){
                                                result="? " + s + "\n";
                                                break;                                                
                                            }                                            
                                            if ( !salvando_file(s.substring(first_line.length()+1, p_EOF),new File(dir_base + "/" + dir + "/" + first_line.split(" ")[4])) ){
                                                result="Nao foi possivel salvar o arquivo";
                                                break;
                                            }
                                            baos=delete_baos(baos,0, p_EOF+3);
                                            continue;
                                        }else{
                                            result="[NADA]";
                                            break;
                                        }
                                    }
                                    if ( s.trim().startsWith("cat < ") && s.trim().split("\n")[0].split(" ").length == 3 && !error_back_path(s.trim().split("\n")[0].split(" ")[2]) ){
                                        result="[NADA]";
                                        break;
                                    }
                                    if ( s.trim().startsWith("cat ") && s.trim().split(" ").length == 2 && !error_back_path(s.trim().split("\n")[0].split(" ")[1]) ){
                                        if ( !new File(dir_base+"/"+dir+"/"+s.trim().split(" ")[1]).exists() )                                            
                                            result="arquivo nao encontrado";
                                        else{
                                            if ( !new File(dir_base+"/"+dir+"/"+s.trim().split(" ")[1]).isFile() )
                                                result="esse elemanto nao eh um arquivo";
                                            else
                                                result="\n"+lendo_arquivo(dir_base+"/"+dir+"/"+s.trim().split(" ")[1]);
                                        }
                                        break;
                                    }
                                    if ( ( s.trim().startsWith("start ") || s.trim().startsWith("restart ") ) && s.trim().split(" ").length == 2 && !error_back_path(s.trim().split(" ")[1]) ){
                                        String results="";
                                        boolean restart=false;
                                        if ( s.trim().startsWith("restart ") )
                                            restart=true;
                                        String nome=s.trim().split(" ")[1];
                                        String [] nomes=new String []{nome}; 
                                        if ( nome.equals("all") )
                                            nomes=new File(dir_base+"/procs").list();
                                        for ( int z=0;z<nomes.length;z++ ){
                                            nome=nomes[z];
                                            if ( !new File(dir_base+"/procs/" + nome).exists() ){
                                                results+=nome + " - proc nao encontrada\n";
                                                continue;
                                            }
                                            if ( isWindows() && !nome.endsWith(".bat") ){
                                                results+=nome + " - nome invalido para uma proc windows\n";
                                                continue;
                                            }                                                                                        
                                            if ( restart ){                   
                                                kill_by_text(" -ignore DAEMON" + nome + " ");
                                            }                                            
                                            boolean jaEmUso=false;
                                            for ( int i=0;i<procs.size();i++ ){
                                                if ( procs.get(i).nome.equals(nome) ){
                                                    if ( restart )
                                                        procs.remove(i);
                                                    else
                                                        jaEmUso=true;
                                                    break;
                                                }
                                            }
                                            if ( jaEmUso ){
                                                results+=nome + " - proc ja esta em execucao\n";
                                                continue;
                                            }         
                                            if ( isWindows() )
                                                procs.add(new ProcDaemon(nome, new String[]{"cmd", "/c", dir_base+"/procs/" + nome}));
                                            else
                                                procs.add(new ProcDaemon(nome, new String[]{dir_base+"/procs/" + nome}));                                            
                                            if ( restart )
                                                results+=nome + " restartado\n";                                            
                                            else
                                                results+=nome + " startado\n";                                            
                                        }
                                        result=results.trim();
                                        result=formata_tabular_palavra(result);
                                        break;
                                    }
                                    if ( s.trim().startsWith("stop ") && s.trim().split(" ").length == 2 && !error_back_path(s.trim().split(" ")[1]) ){
                                        String results="";
                                        String nome=s.trim().split(" ")[1];
                                        String [] nomes=new String []{nome}; 
                                        if ( nome.equals("all") )
                                            nomes=new File(dir_base+"/procs").list();
                                        for ( int z=0;z<nomes.length;z++ ){
                                            nome=nomes[z];
                                            boolean jaEmUso=false;
                                            result=nome + " ??";
                                            for ( int i=0;i<procs.size();i++ )
                                                if ( procs.get(i).nome.equals(nome) ){
                                                    //procs.get(i).t.join(); stop thread not work
                                                    procs.remove(i);
                                                    jaEmUso=true;
                                                    result=nome + " stopado";
                                                    break;
                                                }
                                            if ( !jaEmUso )
                                                result=nome + " nao esta em execucao";
                                            if ( kill_by_text(" -ignore DAEMON" + nome + " ") )
                                                result=nome + " stopado";
                                            results+=result+"\n";
                                        }
                                        result=results.trim();
                                        break;
                                    }
                                    if ( s.trim().equals("oi") ){
                                        result="oie";
                                        break;
                                    }
                                    if ( s.trim().equals("uptime") ){
                                        result=seconds_to_string(epoch(null)-inicio,"format1");
                                        break;
                                    }
                                    if ( s.trim().equals("status") || s.trim().equals("list") ){
                                        String [] itens=new File(dir_base+"/procs").list();
                                        String s_="";
                                        for ( int i=0;i<itens.length;i++ ){
                                            if ( isWindows() && !itens[i].endsWith(".bat") ){
                                                s_+=itens[i] + " nomeIrregularParaProcWindows\n";
                                            }
                                            String status="ProntoParaIniciar";
                                            for ( int j=0;j<procs.size();j++ )
                                                if ( procs.get(j).nome.equals(itens[i]) ){
                                                    status=procs.get(j).get_status();
                                                    break;
                                                }
                                            s_+=itens[i] + " " + status + "\n";
                                        }
                                        if ( s_.equals("") )
                                            s_ = "nenhum item encontrado\n";
                                        result=s_.trim();
                                        result=formata_tabular_palavra(result);
                                        break;
                                    }
                                    if ( s.trim().startsWith("status ") && s.trim().split(" ").length == 2 && !error_back_path(s.trim().split(" ")[1]) ){
                                        if ( isWindows() && !s.trim().split(" ")[1].endsWith(".bat") ){
                                            result="nome irregular para proc windows -> " + s.trim().split(" ")[1];
                                            break;
                                        }
                                        String status="";
                                        for ( int i=0;i<procs.size();i++ )
                                            if ( procs.get(i).nome.equals(s.trim().split(" ")[1]) ){
                                                status=get_status_proc(procs.get(i));
                                                break;
                                            }
                                        if ( status.equals("") )
                                            result="proc nao encontrada ou parada";
                                        else
                                            result=status;
                                        break;
                                    }
                                    if ( s.trim().equals("pwd") ){
                                        result=dir;
                                        break;
                                    }
                                    if ( s.trim().equals("cd") ){
                                        tail_dir=dir;
                                        dir=dir_init;
                                        result="";
                                        break;
                                    }
                                    if ( s.trim().equals("cd .") ){
                                        tail_dir=dir;
                                        result="";
                                        break;
                                    }
                                    if ( s.trim().equals("cd ..") ){
                                        tail_dir=dir;
                                        int p=dir.lastIndexOf("/");
                                        if ( p > 0 )
                                            dir=dir.substring(0, p);
                                        result="";
                                        break;
                                    }
                                    if ( s.trim().equals("cd /") ){
                                        tail_dir=dir;
                                        dir=".";
                                        result="";
                                        break;
                                    }
                                    if ( s.trim().equals("cd -") ){
                                        String aux=tail_dir;
                                        tail_dir=dir;
                                        dir=aux;
                                        result="";
                                        break;
                                    }
                                    if ( s.trim().startsWith("cd ") && s.trim().split(" ").length == 2 && !error_back_path(s.trim().split(" ")[1]) ){
                                        String path=s.trim().substring(3);
                                        if ( error_back_path(path) )
                                            result="Error back path";
                                        else{
                                            if ( new File(dir_base + "/" + path).exists() ){
                                                tail_dir=dir;
                                                dir+="/" + path;
                                                result="";
                                            }else
                                                result="Pasta nao encontrada";
                                        }
                                        break;
                                    }
                                    if ( s.trim().equals("ls") || s.trim().equals("lss") || s.trim().equals("ls -ltr") ){
                                        File [] files=new File(dir_base+"/"+dir).listFiles();
                                        String s_="";
                                        for ( int i=0;i<files.length;i++ ){
                                            if ( ! s_.equals("") )
                                                s_+="\n";
                                            if ( files[i].isDirectory() )
                                                s_+="d ";
                                            else
                                                s_+="- ";
                                            s_+=files[i].getName();
                                        }
                                        result=s_;
                                        if ( !result.equals("") )
                                            result="\n"+result;
                                        break;
                                    }
                                    if ( ( s.trim().startsWith("ls ") || s.trim().startsWith("lss ") ) && s.trim().split(" ").length == 2 && !error_back_path(s.trim().split(" ")[1]) ){
                                        if ( !new File(dir_base+"/"+dir+"/"+s.trim().split(" ")[1]).exists() ){
                                            result="Diretorio corrente nao existe";
                                            break;
                                        }
                                        if ( !new File(dir_base+"/"+dir+"/"+s.trim().split(" ")[1]).exists() )
                                            result="nao existe essa pasta";
                                        else{
                                            String [] itens=new File(dir_base+"/"+dir+"/"+s.trim().split(" ")[1]).list();
                                            String s_="";
                                            for ( int i=0;i<itens.length;i++ ){
                                                if ( ! s_.equals("") )
                                                    s_+="\n";
                                                s_+=itens[i];
                                            }
                                            if ( s_.equals("") )
                                                result="[QUEBRANDO_LINHA]";
                                            else
                                                result="\n"+s_;
                                        }                                            
                                        break;
                                    }
                                    if ( s.trim().startsWith("mkdir ") && s.trim().split(" ").length == 2 && !error_back_path(s.trim().split(" ")[1]) ){
                                        String s_=s.trim().split(" ")[1];
                                        if ( new File(dir_base+"/"+dir+"/"+s_).exists() ){
                                            result="essa pasta ja existe";
                                        }else{
                                            if ( !new File(dir_base+"/"+dir+"/"+s_).mkdir() ){
                                                result="nao foi possivel criar essa pasta";
                                            }else{
                                                result="";
                                            }
                                        }
                                        break;
                                    }
                                    if ( s.trim().startsWith("rm ") && s.trim().split(" ").length == 2 && !error_back_path(s.trim().split(" ")[1]) ){
                                        String s_=s.trim().split(" ")[1];
                                        if ( !new File(dir_base+"/"+dir+"/"+s_).exists() )
                                            result="essa pasta ja existe";
                                        else{
                                            if ( !new File(dir_base+"/"+dir+"/"+s_).delete() )
                                                result="Nao foi possivel deletar";
                                            else
                                                result="";                                                
                                        }
                                        break;
                                    }
                                    if ( s.trim().equals("exit") ){
                                        result="[EXIT]";
                                        break;
                                    }
                                    if ( s.trim().equals("cls") ){
                                        result="[CLS]";
                                        break;
                                    }
                                    if ( s.trim().equals("tail") || s.trim().startsWith("tail ") ){
                                        result="tail nao permitido por aqui, tente: y d " + s.trim() + " (fora do daemon)";
                                        break;
                                    }
                                    if ( s.trim().startsWith("tail_command ") && s.trim().split(" ").length == 2 && !error_back_path(s.trim().split(" ")[1]) ){
                                        ProcDaemon pd=null;
                                        for ( int i=0;i<procs.size();i++ )
                                            if ( procs.get(i).nome.equals(s.trim().split(" ")[1]) ){
                                                pd=procs.get(i);
                                                break;
                                            }
                                        if ( pd == null ){
                                            result="[ERROR_TAIL]";
                                            break;
                                        }
                                        Long pos=0L;
                                        while(true){ //resposta infinita                                            
                                            byte[] out_aux = pd.get_out_n(pos);
                                            if ( out_aux == null )
                                                continue;
                                            pos++;
                                            if ( out_aux.length == 0 )
                                                continue;
                                            output.write(out_aux);
                                            output.flush();                                            
                                        }
                                    }
                                    if ( s.trim().equals("") ){ // s.equals("") pode ser resultado dos processamentos de bloco
                                        result="";
                                        break;
                                    }
                                    result="? " + s.trim();
                                    break;
                                }
                                // enviando   
                                if ( result.equals("") )
                                    result="[QUEBRANDO_LINHA]";
                                output.write(result.getBytes());
                                output.flush();
                                if ( !result.equals("[NADA]") )
                                    baos=new ByteArrayOutputStream();
                            }
                        }catch (Exception e) {
                            if ( e.toString().startsWith("java.net.SocketException: ") ){
                                System.out.println("warnning.. desconectado.");
                                return;
                            }
                            System.out.println("Erro ao executar servidor:" + e.toString());
                            return;
                        }
                    }
                }.start();
            }
        }catch(Exception e){
            erro_amigavel_exception(e);
        }
    }
    //REMOVED_GRAAL_END
	
    public String formata_tabular_palavra(String a){
        String [] frases=a.split("\n");
        int [] lens=new int[50];
        String result="";
        int limit=10000;
        for ( int i=0;i<frases.length;i++ ){
            String [] palavras=frases[i].split(" ");
            for ( int j=0;j<palavras.length;j++ )
                if ( palavras[j].length() > lens[j] )
                    lens[j] = palavras[j].length();            
        }
        for ( int i=0;i<frases.length;i++ ){
            String [] palavras=frases[i].split(" ");
            String frase="";
            for ( int j=0;j<palavras.length;j++ ){
                while(palavras[j].length() < lens[j] && limit-- > 0)
                    palavras[j]+=" ";
                frase+=palavras[j]+" ";
            }
            result+=frase.trim()+"\n";            
        }
        return result.trim();
    }
    public String get_status_proc(ProcDaemon p){
        String result="";
        try{
            result+="Stauts:\n";
            result+="out: \n" + p.get_out() + "\n";
            result+="err: \n" + p.get_err() + "\n";
            result+="\nErro run: " + p.erro + "\n";
        }catch(Exception e){
            return "erro fatal 2244";
        }
        return result;
    }

    @SuppressWarnings({"unchecked", "deprecation"})
    class ProcDaemon{
        public String nome=null;
        public String [] command=null;
        public Thread t=null;
        public int status=0; // 0 parado, 1 rodando, 2 finalizado
        long n_out=0;
        public String erro="";
        public LinkedHashMap hm_out=new LinkedHashMap();
        public ArrayList list_err=new ArrayList();
        public String get_out(){
            try{
                ByteArrayOutputStream baos=new ByteArrayOutputStream();
                Object [] keys=hm_out.keySet().toArray();
                for ( int i=0;i<keys.length;i++ ){
                    Long key = (Long)keys[i];
                    baos.write((byte[])hm_out.get(key));
                }            
                return baos.toString();
            }catch(Exception e){}
            return null;
        }
        public byte[] get_out_n(Long n){
            try{                
                Object [] keys=hm_out.keySet().toArray();
                if ( keys.length == 0 )
                    return null;
                Long first=(Long)keys[0];
                if ( first > n )
                    return new byte[]{};
                return (byte[])hm_out.get(n);
            }catch(Exception e){}
            return null;
        }
        public String get_err(){
            try{
                ByteArrayOutputStream baos=new ByteArrayOutputStream();
                for( int i=0;i<list_err.size();i++ )
                    baos.write((byte[])list_err.get(i));
                return baos.toString();            
            }catch(Exception e){}
            return "";
        }
        public String get_status(){
            if ( status == 0 )
                return "Iniciando";
            if ( status == 1 )
                return "Rodando";
            if ( status == 2 )
                return "Parado";
            return "StatusDesconhecido";
        }
        public ProcDaemon(String nome_, String [] command_){
            if ( !isWindows() && command_.length == 1 && new File(command_[0]).exists() && new File(command_[0]).isFile() )
                chmod_777(command_[0]);
            nome=nome_;
            command=command_;
            t=new Thread(new Runnable() {
                public void run() {
                    status=0;
                    try{
                        status=1;
                        Process proc = Runtime.getRuntime().exec(command);
                        int len=0;
                        byte[] b=new byte[1024];
                        ByteArrayOutputStream baos_in = null;
                        ByteArrayOutputStream baos_out = null;
                        while ( (len=proc.getInputStream().read(b, 0, b.length)) != -1 ){
                            baos_in = new ByteArrayOutputStream();
                            baos_in.write(b, 0, len);
                            hm_out.put(n_out++,baos_in.toByteArray());
                            if ( hm_out.size() > 100 ){
                                long n=(long)hm_out.keySet().toArray()[0];
                                hm_out.remove(n);
                            }
                        }
                        while ( (len=proc.getErrorStream().read(b, 0, b.length)) != -1 ){
                            baos_out = new ByteArrayOutputStream();
                            baos_out.write(b, 0, len);
                            list_err.add(baos_out.toByteArray());
                            if ( list_err.size() > 100 )
                                list_err.remove(0);
                        }                        
                    }catch(Exception e){
                        erro=e.toString();
                    }
                    status=2;
                }
            });
            t.start();            
        }
    }
    
    private boolean error_back_path(String a){
        if ( a.startsWith("/") || a.endsWith("/") || a.contains("\\") )
            return true;
        String [] partes=a.split("/");
        for ( int i=0;i<partes.length;i++ )
            if ( partes[i].equals(".") || partes[i].equals("..") )
                return true;
        return false;
    }

    private void cotacao(String [] args){                
        if ( args.length == 2 ){
            String tail="-";
            curl_flag_suprimir_stderr=true;
            int falhas=0;
            while(true){
                cotacao_load();
                if ( !cotacao_load_assets.containsKey(args[1]) )
                    erroFatal("asset " + args[1] + " não encontrada!");
                String s=format_ponto( (String)cotacao_load_assets.get(args[1]), 3);                
                if ( s.trim().equals(".00000000") || s.trim().equals(".000") ){
                    // falha
                    if ( falhas++ > 3 )
                        erroFatal("ocorreram varias falhas ao tentar ler origem!");
                    sleepSeconds(60);
                    continue;
                }else{
                    falhas=0;
                    s=s.replace(".00000000", "");
                }
                if ( !tail.equals(s) )
                    System.out.println( s );
                tail=s;
                sleepSeconds(60);
            }
        }else{
            cotacao_load();
            System.out.println("USDT_BRL   " + lpad(format_ponto( ((String)cotacao_load_assets.get("USDT_BRL")), 3), 12," ") );
            System.out.println("BTC_USDT   " + lpad(format_ponto( ((String)cotacao_load_assets.get("BTC_USDT")), 3), 12," ") );
            System.out.println("BTC_BRL    " + lpad(format_ponto( ((String)cotacao_load_assets.get("BTC_BRL")), 3), 12," ") );
            System.out.println("TRUMP_USDT " + lpad(format_ponto( ((String)cotacao_load_assets.get("TRUMP_USDT")), 3), 12," ") );
            System.out.println("TRUMP_BRL  " + lpad(format_ponto( ((String)cotacao_load_assets.get("TRUMP_BRL")), 3), 12," ") );                    
        }
    }
    
    HashMap cotacao_load_assets=null;
    private void cotacao_load(){
        if ( cotacao_load_assets == null )
            cotacao_load_assets=new HashMap();
        String aux="";
        String source="bybit";
        source="binance";
        String USDT_BRL=null;
        if ( source.equals("bybit") ){
            aux=curl_string("https://api.bybit.com/v5/market/tickers?category=spot");        
            USDT_BRL=cotacao_bybit(aux, "\"USDTBRL\"", "\"lastPrice\"");
            cotacao_load_assets.put("USDT_BRL", USDT_BRL);
            cotacao_load_assets.put("BTC_USDT", cotacao_bybit(aux, "\"BTCUSDT\"", "\"lastPrice\""));
            cotacao_load_assets.put("BTC_BRL", cotacao_bybit(aux, "\"BTCBRL\"", "\"lastPrice\""));
        }
        if ( source.equals("binance") ){
            aux=curl_string("https://api.binance.com/api/v3/ticker/price");        
            USDT_BRL=cotacao_binance(aux, "\"USDTBRL\"", "\"price\"");
            cotacao_load_assets.put("USDT_BRL", USDT_BRL);
            cotacao_load_assets.put("BTC_USDT", cotacao_binance(aux, "\"BTCUSDT\"", "\"price\""));
            cotacao_load_assets.put("BTC_BRL", cotacao_binance(aux, "\"BTCBRL\"", "\"price\""));
        }
        try{
            aux=curl_string("https://api.kucoin.com/api/v1/market/orderbook/level1?symbol=TRUMP-USDT");
            String TRUMP_USDT=cotacao_kucoin(aux);
            cotacao_load_assets.put("TRUMP_USDT", TRUMP_USDT);
            cotacao_load_assets.put("TRUMP_BRL", Float.parseFloat(TRUMP_USDT)*Float.parseFloat(USDT_BRL)+"");
        }catch(Exception e){}
    }
    
    public String cotacao_bybit(String a, String b, String c){
        String s="";
        int p1=a.indexOf(b);
        String [] partes=null;
        if ( p1 > 0 ){
            p1=a.indexOf(c, p1+1);
            if ( p1 > 0 ){
                s=a.substring(p1, p1+30);
                partes=s.split("\"");
                return partes[3];
            }
        }        
        return "";
    }
    
    public String cotacao_binance(String a, String b, String c){
        String s="";
        int p1=a.indexOf(b);
        String [] partes=null;
        if ( p1 > 0 ){
            p1=a.indexOf(c, p1+1);
            if ( p1 > 0 ){
                s=a.substring(p1, p1+30);
                partes=s.split("\"");
                return partes[3];
            }
        }        
        return "";
    }
    
    public String cotacao_kucoin(String a){
        String [] partes=a.split("\"");
        if ( partes.length > 33 && partes[13].equals("price") )
            return partes[15];
        return "";
    }
    
    private String [] get_var(){
        String varLine=getEnv("var");
        if ( varLine == null )
            erroFatal("VarEnv var não encontrada!");
        varLine=autoFormataAspas(varLine);
        ArrayList<String> lista=new ArrayList<String>();
        boolean started=false;
        String s="";        
        for ( int i=0;i<varLine.length();i++ ){
            if ( varLine.substring(i, i+1).equals("\"") 
            ){
                started=!started;
                if ( !started ){
                    lista.add(s);
                    s="";                    
                }
                continue;
            }            
            if ( started )
                s+=varLine.substring(i, i+1);
        }
        return lista.toArray(new String [lista.size()]);        
    }
    
    private String autoFormataAspas(String a){
        String s="";
        int stage=0; // 0 livre, 1 start_aspas, 2 start_char
        int tag=0; // 0 aspas, 1 char, 2 space
        for(int i=0;i<a.length();i++){
            String t=a.substring(i, i+1);
            // get tag
            if (t.equals("\""))
                tag=0;
            else{
                if (t.equals(" "))
                    tag=2;
                else
                    tag=1;
            }
            // pre add
            if (stage == 0 && tag == 1){
                s+="\"";
            }
            if (stage == 2 && tag == 2){
                s+="\"";
            }
            // add
            s+=t;
            // set stage 0
            if(
                (stage == 1 && tag == 0)
                || (stage == 2 && tag == 2)
            ){
               stage=0;
               continue;
            }
            // set stage 1
            if((stage == 0 && tag == 0)){
               stage=1;
               continue;
            }
            // set stage 2
            if((stage == 0 && tag == 1)){
               stage=2;
               continue;
            }
        }
        if ( stage != 0 )
            s+="\"";
        return s;
    }
    
    
    private boolean take(String [] args){
        Object [] objs=get_parm_ip_port_server_send_pass_paths(args);
        if ( objs == null )
            return false;
        String ip=(String)objs[0];
        int port=(Integer)objs[1];
        boolean server=(Boolean)objs[2];
        boolean send=(Boolean)objs[3];
        String pass=(String)objs[4];
        String [] paths=(String [])objs[5];
        String print_after=null;
        
        if ( send ){
            valida_paths(paths);
            if ( paths.length == 1 && paths[0].equals(".") ){
                File f_ = new File(".");
                if ( f_.listFiles().length == 0 ){
                    System.err.println("Diretorio vazio!");
                    System.exit(1);
                }                
            }
        }
        if ( server ){
            if ( ip == null )
                ip=get_ip();
            if ( pass == null ){
                pass = random(0, 9999) + "";
            }
        }
        if ( ip == null ){
            System.err.println("Nenhum ip foi encontrado!");
            System.exit(1);
        }                
        if ( port == -1 )
            port = 222;
        if ( pass == null ){
            System.err.println("Senha nao encontrada!");
            System.exit(1);
        }
        if ( server )
            if ( !send )
                print_after="# cliente command:\n# y take -client -ip " + ip + " -port " + port + " -pass " + pass + " -send";
            else
                print_after="# cliente command:\n# y take -client -ip " + ip + " -port " + port + " -pass " + pass;
       
        take(ip, port, server, send, pass, print_after, paths);
        return true;
    }
    
    private void take(String ip, int port, boolean server, boolean send, String pass, String print_afer, String [] paths){                
        try{        
            final PipedOutputStream pos1=new PipedOutputStream();
            final PipedInputStream pis1=new PipedInputStream();
            final PipedOutputStream pos2=new PipedOutputStream();
            final PipedInputStream pis2=new PipedInputStream();
            Thread step1 = null;
            Thread step2 = null;
            Thread step3 = null;
            
            pis1.connect(pos1);
            pis2.connect(pos2);

            if ( send ){            
                step1=new Thread(new Runnable() {
                    public void run() {
                        try{
                            zip_add_router(paths, "", true, pos1, "enviando - ");
                            pos1.flush();
                            pos1.close();
                        }catch(Exception e){
                            System.err.println("Erro zip - " + e.toString());
                            System.exit(1);
                        }
                    }
                });

                step2=new Thread(new Runnable() {
                    public void run() {
                        try{
                            new AES().encrypt(pis1,pos2, pass, null,null);
                            pos2.flush();
                            pos2.close();
                        }catch(Exception e){                            
                            System.err.println("Erro aes - " + e.toString());
                            System.exit(1);
                        }
                    }
                });

                step3=new Thread(new Runnable() {
                    public void run() {
                        socket_1_file(ip, port, server, send, pis2, null, print_afer);                        
                    }
                });
            }
            if ( !send ){
                step3=new Thread(new Runnable() {
                    public void run() {
                        try{
                            socket_1_file(ip, port, server, send, null, pos1, print_afer);
                            pos1.flush();
                            pos1.close();
                        }catch(Exception e){
                            System.err.println("Erro socket_1_file - " + e.toString());
                            System.exit(1);
                        }                            
                    }
                });

                step2=new Thread(new Runnable() {
                    public void run() {
                        try{
                            new AES().decrypt(pis1,pos2, pass,null);
                            pos2.flush();
                            pos2.close();
                        }catch(Exception e){                                     
                            if ( e.toString().equals("java.io.IOException: Read end dead") ){
                                if ( !copiaByStream_count_print_on ){
                                    System.err.println("Senha invalida!");
                                    System.exit(1);
                                }
                            }else{
                                System.err.println("Erro aes - " + e.toString());
                                System.exit(1);
                            }
                            
                        }
                    }
                });

                step1=new Thread(new Runnable() {
                    public void run() {
                        try{
                            zip_extract(pis2, null,null,null);                            
                            System.out.println("");
                        }catch(Exception e){
                            System.err.println("Erro extract zip - " + e.toString());
                            System.exit(1);
                        }
                    }
                });
            }
            
            step1.start();
            step2.start();
            step3.start();

            step1.join();
            step2.join();
            step3.join();            
            print_cursor_speed(0, null, "\nFim!", false, null);
        }catch(Exception e){
            System.err.println("Erro, "+e.toString());
            System.exit(1);
        }            
    }
    
    public String [] getConnAppParm(String [] args){
        
        //[y banco -conn ... select]
        //[y banco -conn ... select select..]
        //[y banco -conn ... selectInsert]
        //[y banco -conn ... selectInsert select..]
        //[y banco -conn ... selectCSV_banco]
        //[y banco -conn ... selectCSV_banco select..]
        //[y banco -conn ... executeInsert]
        //[y banco -conn ... execute]
        //[y banco -conn ... execute execute..]
        //[y banco conn,hash select]
        //[y banco conn,hash select select..]
        //[y banco conn,hash selectInsert]
        //[y banco conn,hash selectInsert select..]
        //[y banco conn,hash selectCSV_banco]
        //[y banco conn,hash selectCSV_banco select..]
        //[y banco conn,hash executeInsert]
        //[y banco conn,hash execute]
        //[y banco conn,hash execute execute..]

        String value_=""; // tmp
        
        String conn="";
        String app="";
        String parm="";
        
        if ( args.length > 0 && args[0].equals("banco") )
            args=sliceParm(1,args);

        if ( args.length > 0 && args[0].startsWith("conn,") )
        {
            value_=gettoken(args[0].split(",")[1]);
            if ( value_ == null )
            {
                System.err.println("Não foi possível encontrar o token "+args[0].split(",")[1]);
                return null;
            }
            conn=value_;
            if ( ! conn.contains(":")){
                try{
                    conn=base64_S_S(conn,false);
                }catch(Exception e){}
            }
            conn=conn.replace("\n","");
            args=sliceParm(1,args);
        }
        
        if ( conn.equals("") && args.length > 1 && args[0].equals("-conn") )
        {
            conn=args[1];
            args=sliceParm(2,args);
        }
        
        if ( args.length > 0 )
        {
            app=args[0];
            args=sliceParm(1,args);
        }
        
        if ( args.length > 0 )
        {
            parm=args[0];
            args=sliceParm(1,args);
        }
        
        if ( conn.equals("") || app.equals("") ) // parm é opcional
            return null;
            
        return new String[]{conn,app,parm};
    }
    
    public String [] get_connIn_fileCSV_connOut_outTable_trunc_app(String [] args){
        //[y banco connIn,hash connOut,hash outTable,tabelaA carga]
        //[y banco connIn,hash connOut,hash outTable,tabelaA trunc carga]
        //[y banco connIn,hash connOut,hash outTable,tabelaA createjobcarga]
        //[y banco connIn,hash connOut,hash outTable,tabelaA trunc createjobcarga]
        String value_=""; // tmp
        
        String connIn="";
        String fileCSV="";
        String connOut="";
        String outTable="";
        String trunc="";
        String createTable=""; // o valor irá para trunc
        String app="";       
        
        if ( args.length > 0 && args[0].equals("banco") )
            args=sliceParm(1,args);
        
        if ( args.length > 0 && args[0].startsWith("connIn,") )
        {
            value_=gettoken(args[0].split(",")[1]);
            if ( value_ == null )
            {
                System.err.println("Não foi possível encontrar o token "+args[0].split(",")[1]);
                return null;
            }
            connIn=value_;
            args=sliceParm(1,args);
        }
        
        if ( connIn.equals("") && args.length > 1 && args[0].equals("-connIn") )
        {
            connIn=args[1];
            args=sliceParm(2,args);
        }
        
        if ( args.length > 0 && args[0].startsWith("fileCSV,") )
        {
            value_=gettoken(args[0].split(",")[1]);
            if ( value_ == null )
            {
                System.err.println("Não foi possível encontrar o token "+args[0].split(",")[1]);
                return null;
            }
            fileCSV=value_;
            args=sliceParm(1,args);
        }
        
        if ( connIn.equals("") && args.length > 1 && args[0].equals("-fileCSV") )
        {
            fileCSV=args[1];
            args=sliceParm(2,args);
        }
        
        if ( args.length > 0 && args[0].startsWith("connOut,") )
        {
            value_=gettoken(args[0].split(",")[1]);
            if ( value_ == null )
            {
                System.err.println("Não foi possível encontrar o token "+args[0].split(",")[1]);
                return null;
            }
            connOut=value_;
            args=sliceParm(1,args);
        }
        
        if ( args.length > 1 && connOut.equals("") && args[0].equals("-connOut") )
        {
            connOut=args[1];
            args=sliceParm(2,args);
        }
        
        if ( args.length > 0 && args[0].startsWith("outTable,") )
        {
            value_=gettoken(args[0].split(",")[1]);
            if ( value_ == null )
            {
                System.err.println("Não foi possível encontrar o token "+args[0].split(",")[1]);
                return null;
            }
            outTable=value_;
            args=sliceParm(1,args);
        }
        
        if ( outTable.equals("") && args.length > 1 && args[0].equals("-outTable") )
        {
            outTable=args[1];
            args=sliceParm(2,args);
        }
        
        if ( args.length > 0 && args[0].equals("trunc") ){
            trunc="S";
            args=sliceParm(1,args);
        }
        
        if ( args.length > 0 && args[0].equals("createTable") ){
            createTable="CREATETABLE";
            args=sliceParm(1,args);
        }
        
        if ( args.length == 1 ){
            app=args[0];
            args=sliceParm(1,args);
        }
        
        if ( ! trunc.equals("") && ! createTable.equals("") )
            return null;
        if ( ! createTable.equals("") )
            trunc=createTable;
        if ( trunc.equals("") )
            trunc="N";
        if ( (connIn.equals("") && fileCSV.equals("")) || (!connIn.equals("") && !fileCSV.equals("")) )
            return null;
        if ( connOut.equals("") || outTable.equals("") || trunc.equals("") || app.equals("") )
            return null;

        return new String[]{connIn,fileCSV,connOut,outTable,trunc,app};
    }
        
    public ArrayList<String> get_v_i_txt(String [] args){
        String v="N";
        String i="N";
        String txt="";
        ArrayList<String> lista=new ArrayList<String>();
        
        if ( args.length > 0 && args[0].equals("grep") )
            args=sliceParm(1,args);
        
        // parametros -v -i
        if ( args.length > 2 && args[0].equals("-v") && args[1].equals("-i") ){
            v="S";
            i="S";
            args=sliceParm(2,args);
        }else{
            if ( args.length > 2 && args[0].equals("-i") && args[1].equals("-v") ){
                i="S";
                v="S";
                args=sliceParm(2,args);
            }else{
                if ( args.length > 1 && args[0].equals("-v") ){
                    v="S";
                    args=sliceParm(1,args);
                }else{
                    if ( args.length > 1 && args[0].equals("-i") ){
                        i="S";
                        args=sliceParm(1,args);
                    }
                }
            }            
        }

        lista.add(v);
        lista.add(i);

        while(args.length > 0){
            String starting="N";
            String ending="N";
            
            txt=args[0];
            if ( i.equals("S") )
                txt=txt.toUpperCase();
            
            if ( txt.startsWith("^") ){
                txt=txt.substring(1);
                starting="S";
            }
            if ( txt.endsWith("$") ){
                txt=txt.substring(0,txt.length()-1);
                ending="S";
            }  
            lista.add(starting);
            lista.add(ending);
            lista.add(txt);
            args=sliceParm(1,args);
        }
        return lista;
    }
    
    public Object[] get_csvFile_sqlFile_sqlText_outJson(String[] args) {
        String csvFile="";
        String sqlFile="";
        String sqlText="";
        Boolean outJson=false;
        
        args=sliceParm(1,args);
        while ( args.length > 0 ){
            if ( args.length > 1 && args[0].equals("-csv") ){
                csvFile=args[1];
                args=sliceParm(2,args);
                continue;
            }
            if ( args.length > 1 && args[0].equals("-sql") ){
                sqlFile=args[1];
                args=sliceParm(2,args);
                continue;
            }
            if ( args.length > 0 && args[0].equals("-outJson") ){
                outJson=true;
                args=sliceParm(1,args);
                continue;
            }            
            if ( args.length > 0 && sqlText.equals("") ){
                sqlText=args[0];
                args=sliceParm(1,args);
                continue;
            }
            if ( args.length > 0 )
                return null;
        }
        
        if ( sqlFile.equals("") && sqlText.equals("") )
            return null;
        if ( !sqlFile.equals("") && !sqlText.equals("") )
            return null;
        
        return new Object[]{csvFile, sqlFile, sqlText, outJson};        
    }
    
    public String [] get_senha_isEncoding_md_salt(String [] args){
        String senha=null;
        String isEncoding="S";
        String md=null;
        String salt=null;
        
        if ( args.length > 0 && args[0].equals("aes") )
            args=sliceParm(1,args);
                
        if ( args.length > 0 && ( args[0].equals("-e") || args[0].equals("-d") ) ){
            if ( args[0].equals("-e") )
                isEncoding="S";
            if ( args[0].equals("-d") )
                isEncoding="N";
            args=sliceParm(1,args);
        }

        if ( args.length > 0 ){
            senha=args[0];
            args=sliceParm(1,args);
        }
        
        if ( args.length > 1 && args[0].equals("-md") ){            
            if ( args[1].toUpperCase().equals("MD5") || args[1].toUpperCase().equals("SHA256") || args[1].toUpperCase().equals("SHA-256") ){
                args=sliceParm(1,args);
                md=args[0].toUpperCase();
                args=sliceParm(1,args);
                if ( md.equals("SHA256") )
                    md="SHA-256";
            }
        }
        
        if ( args.length > 1 && args[0].equals("-S") ){
            args=sliceParm(1,args);
            salt=args[0];
            args=sliceParm(1,args);
            if ( salt.length() != 16 || !isHex(salt) ){
                System.err.println("Erro, conteudo hex do Salt inválido: "+salt);
                System.exit(1);
            }
        }

        if ( args.length > 0 ){
            return null;
        }
        if ( senha==null )
            return null;
        
        return new String[]{senha,isEncoding,md,salt};        
    }
            
    private boolean isHex(String a){
        String tmp="0123456789ABCDEF";
        for ( int i=0;i<a.length();i++ )
            if ( tmp.indexOf(a.substring(i,i+1)) == -1 )
                return false;
        return true;
    }
    private boolean isNumeric(String a){
        String tmp="0123456789";
        for ( int i=0;i<a.length();i++ )
            if ( tmp.indexOf(a.substring(i,i+1)) == -1 )
                return false;
        return true;
    }
    
    private String[] getNegativaStartEnd(String[] args) {
        String negativa="N";        
        String start=null;
        String end=null;
        
        if ( args.length > 0 && args[0].equals("awk") ){
            args=sliceParm(1,args);
        }
        
        if ( args.length > 0 && args[0].equals("-v") ){
            negativa="S";        
            args=sliceParm(1,args);
        }

        if ( args.length > 1 && args[0].equals("start") ){
            start=args[1];
            args=sliceParm(2,args);
        }
        
        if ( args.length > 1 && args[0].equals("end") ){
            end=args[1];
            args=sliceParm(2,args);
        }

        if ( args.length > 0 ){
            return null;
        }
        
        if ( start == null && end == null ){
            return null;
        }
        
        return new String[]{negativa,start,end};        
    }
    
    public void select(String conn,String parm){
        String parm_=parm;
        
        Connection con=null;
        Statement stmt=null;
        ResultSet rs=null;

        // configuracao TZ UTC NATAL
        String dataT=" ";
        String dataZ=" ";
        boolean flag_natal=false;
        String format_data=getEnv("FORMAT_DATA_Y");
        if ( format_data != null && format_data.equals("TZ") ){
            dataT="T";
            dataZ="Z";
        }
        if ( format_data != null && format_data.equals("UTC") )
            dataZ=" UTC";
        if ( format_data != null && format_data.equals("NATAL") )
            flag_natal=true;

        try{            
            con = getcon(conn);
            if ( con == null ){
                System.err.println("Não foi possível se conectar!!" );
                return;
            }
            
            if ( parm.equals("") ){
                String line;
                while( (line=readLine()) != null )
                    parm+=line+"\n";
                closeLine();
            }
            parm=removePontoEVirgual(parm);

            stmt = con.createStatement();
            rs=null;
            ResultSetMetaData rsmd;
            ArrayList<String> campos=new ArrayList<String>();
            ArrayList<Integer> tipos=new ArrayList<Integer>();
            StringBuilder sb=null;
            String tmp="";

            rs=stmt.executeQuery(parm);
            rsmd=rs.getMetaData();

            for ( int i=1;i<=rsmd.getColumnCount();i++ )
            {
                campos.add(rsmd.getColumnName(i));                
                tipos.add(rsmd.getColumnType(i));
            }

            while ( rs.next() ){
                sb=new StringBuilder();
                for ( int i=0;i<campos.size();i++ ){
                    tmp=rs.getString(campos.get(i));
                    if ( tmp == null  ){
                        if ( i == campos.size()-1 )
                        {
                            sb.append("null");
                        }else{
                            sb.append("null\t");
                        }
                        continue;
                    }
                    if ( tipo_cadastrado(tipos.get(i)) ){
                        if ( banco_tipo_numerico(tipos.get(i)) && tmp.startsWith("."))
                            tmp="0"+tmp;
                        if ( tipos.get(i) == 93 ) // DATA
                            if ( flag_natal )
                                tmp="25/12/"+tmp.substring(0, 4)+dataT+tmp.substring(11, 19)+dataZ;                                
                            else
                                tmp=tmp.substring(8, 10)+"/"+tmp.substring(5, 7)+"/"+tmp.substring(0, 4)+dataT+tmp.substring(11, 19)+dataZ;
                        //tmp=tmp.replace("'","''"); // nao usado no select
                        if ( i == campos.size()-1 ){
                            sb.append(tmp);
                        }else{
                            sb.append(tmp);
                            sb.append("\t");
                        }
                        continue;
                    }
                    throw new Exception("tipo desconhecido:"+tipos.get(i) + " -> " + rs.getString(campos.get(i)) );
                }
                System.out.println(sb.toString());
            }                 
        }
        catch(Exception e)
        {            
            System.err.println("Erro: "+e.toString()+" -> "+parm_);
        }
        close(rs,stmt,con);
    }

    public void selectInsert(String conn,String fileCSV,String parm, PipedOutputStream out,String table,String nemVouExplicar){ // table opcional
        if ( ! conn.equals("") )
        {
            pipeSelectInsertConn(conn,fileCSV,parm, out,table,nemVouExplicar);            
        }else{
            pipeSelectInsertCSV(conn,fileCSV,parm, out,table,nemVouExplicar);
        }        
    }
    
    public void pipeSelectInsertConn(String conn,String fileCSV,String parm, PipedOutputStream out,String table,String nemVouExplicar){ // table opcional
        Connection con=null;
        Statement stmt=null;
        ResultSet rs=null;

        // configuracao TZ UTC NATAL
        String dataT=" ";
        String dataZ=" ";
        boolean flag_natal=false;
        String format_data=getEnv("FORMAT_DATA_Y");
        if ( format_data != null && format_data.equals("TZ") ){
            dataT="T";
            dataZ="Z";
        }
        if ( format_data != null && format_data.equals("UTC") )
            dataZ=" UTC";
        if ( format_data != null && format_data.equals("NATAL") )
            flag_natal=true;
        
        int countCommit=0;
        try{
            con = getcon(conn);
            if ( con == null ){
                System.err.println("Não foi possível se conectar!!" );
                return;
            }

            if ( parm.equals("") ){
                String line;
                while( (line=readLine()) != null )
                    parm+=line+"\n";
                closeLine();
            }
            
            parm=removePontoEVirgual(parm);

            stmt = con.createStatement();
            rs=null;
            ResultSetMetaData rsmd;
            ArrayList<String> campos=new ArrayList<String>();
            ArrayList<Integer> tipos=new ArrayList<Integer>();
            StringBuilder sb=null;
            String tmp="";            

            rs=stmt.executeQuery(parm);
            rsmd=rs.getMetaData();
            if ( table.equals("") )
                table=getTableByParm(parm);

            for ( int i=1;i<=rsmd.getColumnCount();i++ )
            {
                campos.add(rsmd.getColumnName(i));
                tipos.add(rsmd.getColumnType(i));
            }

            while ( rs.next() ){
                sb=new StringBuilder();
                for ( int i=0;i<campos.size();i++ ){
                    tmp=rs.getString(campos.get(i));

                    if ( tmp == null  ){
                        if ( i == campos.size()-1 )
                        {
                            sb.append("''");
                        }else{
                            sb.append("'',");
                        }
                        continue;
                    }
                    if ( tipo_cadastrado(tipos.get(i)) ){
                        if ( banco_tipo_numerico(tipos.get(i)) && tmp.startsWith("."))
                            tmp="0"+tmp;
                        if ( tipos.get(i) == 93 ) // DATA
                            if ( flag_natal )
                                tmp="to_date('25/12/"+tmp.substring(0, 4)+dataT+tmp.substring(11, 19)+dataZ+"','DD/MM/YYYY HH24:MI:SS')";
                            else
                                tmp="to_date('"+tmp.substring(8, 10)+"/"+tmp.substring(5, 7)+"/"+tmp.substring(0, 4)+dataT+tmp.substring(11, 19)+dataZ+"','DD/MM/YYYY HH24:MI:SS')";
                        if ( tmp.length() <= 4000 ){
                            if ( tipos.get(i) == 93 ){ // DATA
                                sb.append(tmp);
                            }else{
                                sb.append("'");
                                sb.append(tmp.replace("'","''"));
                                sb.append("'");
                            }
                        }else{
                            tmp=formatacaoInsertClobComAspetas(tmp);
                            sb.append(tmp);
                        }
                        if ( i != campos.size()-1 )
                            sb.append(",");
                        continue;
                    }
                    close(rs,stmt,con);
                    throw new Exception("tipo desconhecido:"+tipos.get(i) + " -> " + rs.getString(campos.get(i)) );
                }                
                if ( out == null )
                    System.out.println("insert into "+table+" values("+ sb.toString()+");");
                else
                    out.write( ("insert into "+table+" values("+ sb.toString()+");\n").getBytes() );
                if ( countCommit++ >= 10000 ){
                    if ( out == null )
                        System.out.println("commit;");
                    else
                        out.write("commit;\n".getBytes());
                    countCommit=0;
                }
            }
        }
        catch(Exception e)
        {
            System.err.println("Erro: "+e.toString()+" -> "+parm);
            close(rs,stmt,con);
            System.exit(1);
        }        
        close(rs,stmt,con);        
    }
    
    public void pipeSelectInsertCSV(String conn,String fileCSV,String parm, PipedOutputStream out,String table,String nemVouExplicar){ // table opcional        
        
        /*
        Estrutura CSV padrao:
        
        HEADER_CAMPO1;BB;CC;3;4;5;
        11;;";;""""""11';;";55;55;55
        11;;";;""""""11';;";55;55;55
        11;;";;""""""11';;";55;55;55;
        33;44
        33;44
        33;44;44;44;44;44;44;44;44;44;44;44;44;44;44;44
        33;44;44;44;44;44;44;44;44;44;44;44;44;44;44;44
        obs: campos além do headr nao serão considerados
        */
        
        int countCommit=0;
        try{
            if ( ! fileCSV.equals("") )
                readLine(fileCSV);
            String line;
            String [] camposCSV=null;
            int qntCamposCSV=0;
            String valorColuna=null;
            StringBuilder sb=null;
            
            while ( (line=readLine()) != null ){
                if ( qntCamposCSV == 0 )
                {
                    camposCSV=getCamposCSV(line);
                    qntCamposCSV=camposCSV.length;
                    if ( ! nemVouExplicar.equals("") ){
                        String create=getCreateByCamposCSV(camposCSV,table);
                        if ( ! execute(nemVouExplicar, create) )
                            return;                                        
                    }
                    continue;
                }
                if ( line.trim().equals("") && qntCamposCSV > 1 )
                    break;
                sb=new StringBuilder();
                readColunaCSV(line); // set linhaCSV para poder usar readColunaCSV e init
                for ( int i=0;i<qntCamposCSV;i++ ){                    
                    if ( linhaCSV != null ){
                        valorColuna=readColunaCSV();
                        if ( valorColuna == null )
                            linhaCSV=null; // nao precisar ler mais nada    
                    }
                    if ( valorColuna == null )
                        sb.append("''");
                    else
                        sb.append("'"+valorColuna.replace("'","''").replace("\"\"","\"")+"'");
                    if ( i != qntCamposCSV-1 )
                        sb.append(",");                        
                }                
                if ( out == null )
                    System.out.println("insert into "+table+" values("+ sb.toString()+");");
                else
                    out.write( ("insert into "+table+" values("+ sb.toString()+");\n").getBytes() );
                if ( countCommit++ >= 10000 ){
                    if ( out == null )
                        System.out.println("commit;");
                    else
                        out.write("commit;\n".getBytes());
                    countCommit=0;
                }
            }
            closeLine();
        }
        catch(Exception e)
        {
            if ( ! fileCSV.equals("") )
                System.err.println("Erro: "+e.toString());
            else
                System.err.println("Erro: "+e.toString()+" file:"+fileCSV);
            System.exit(1);
        }        
        
    }
    
    public String [] selectCSV_camposName=null;
    public String [] selectCSV_camposValue=null;
    public String [] selectCSV_camposNameSaida=null;
    public String [] selectCSV_camposNameSaidaAlias=null;    
    public String [] selectCSV_tratativasWhere=null; 
    public long selectCSV_rownum=1;
    public String selectCSV_header=null;
    public boolean selectCSV_headerPrinted=false;
    public boolean outJson=false;
    public grammarsWhere gw=null;
    public long sqlCount = 0;
    public long sqlLimit = -1;
    public String csv_sep_output=",";
    public void selectCSV_texto(String[] args) throws Exception {
        Object [] csvFile_sqlFile_sqlText=get_csvFile_sqlFile_sqlText_outJson(args);
        if ( csvFile_sqlFile_sqlText == null ){
            comando_invalido(args);
            return;
        }
        
        String csvFile=(String)csvFile_sqlFile_sqlText[0];
        String sqlFile=(String)csvFile_sqlFile_sqlText[1];
        String sqlText=(String)csvFile_sqlFile_sqlText[2];
        outJson=(Boolean)csvFile_sqlFile_sqlText[3];
        OutputStream out=System.out;
        if ( !sqlFile.equals("") ){
            String line=null;
            sqlText="";
            readLineB(sqlFile);
            while ( (line=readLineB()) != null )
                sqlText+=line+" ";
            closeLineB();
        }

        if ( sqlText.equals("") ){ // trava de segurança
            comando_invalido(args);
            return;
        }
        
        selectCSV_texto(csvFile, sqlFile, sqlText, outJson, System.in, out);
    }
    
    // usar mais de uma ver essa funcao pode dar muita dor de cabeça. tem muito parametro statico
    // ao rodar pela segunda vez ou mais o header nao aparece! bug.     
    public void selectCSV_texto(String csvFile, String sqlFile, String sqlText, Boolean outJson, InputStream is, OutputStream out) throws Exception {                
        // init
        separadorCSVCache=null;  
        selectCSV_rownum=1;
        //////////////////
        // bug y cls && y u && y steam friends clan status
        //System.out.println("selectCSV_header " + selectCSV_header + " selectCSV_headerPrinted " + selectCSV_headerPrinted);        
        //linhaCSV=null;
        //ponteiroLinhaCSV=0;                
        //selectCSV_header=null;
        //selectCSV_headerPrinted=false;
        //gw=null;
        
        try{
            if ( csvFile == null )
                csvFile="";
            if ( ! csvFile.equals("") )
                readLine(csvFile);
            else
                readLine(is);            
            String line;            
            int qntCamposCSV=0;
            String valorColuna=null;
                
            while ( (line=readLine()) != null ){                
                if ( qntCamposCSV == 0 ){ // tratando header                   
                    // automatic change CSV_SEP_Y ; to ,
                    if ( line.contains(",") && !line.contains(";") && ( getEnv("CSV_SEP_Y") == null || getEnv("CSV_SEP_Y").equals(";") ) )
                        setEnv("CSV_SEP_Y", ",");
                    selectCSV_camposName=getCamposCSV(line);
                    for(int i=0;i<selectCSV_camposName.length;i++)
                        selectCSV_camposName[i]=selectCSV_camposName[i].replace(" ","_").replaceAll("[^\\x00-\\x7F]", "");
                    qntCamposCSV=selectCSV_camposName.length;
                    selectCSV_camposValue=new String[selectCSV_camposName.length];
                    interpretaSqlParaSelectCSV(sqlText);
                    
                    StringBuilder sb=new StringBuilder();
                    for ( int i=0;i<selectCSV_camposNameSaidaAlias.length;i++ ){                    
                        sb.append("\"");
                        sb.append(selectCSV_camposNameSaidaAlias[i]);
                        sb.append("\"");
                        if ( i < selectCSV_camposNameSaidaAlias.length-1 )
                            sb.append(csv_sep_output);
                    }
                    sb.append("\n");
                    selectCSV_header=sb.toString();                                        
                    continue;
                }
                
                if ( line.trim().equals("") && qntCamposCSV > 1 )
                    break;
                
                readColunaCSV(line); // set linhaCSV para poder usar readColunaCSV e init
                for ( int i=0;i<qntCamposCSV;i++ )
                    selectCSV_camposValue[i]=null;
                for ( int i=0;i<qntCamposCSV;i++ )
                    if ( (selectCSV_camposValue[i]=readColunaCSV()) == null )
                        break;
                processaRegistroSqlParaSelectCSV(out, sqlText);                
            }
            closeLine();
            if( outJson ){
                if ( sqlCount == 0 )
                    out.write("[ ]\n".getBytes());
                else
                    out.write("]\n".getBytes());
            }
        }
        catch(Exception e)
        {
            if ( ! csvFile.equals("") )
                System.err.println("Erro: "+e.toString()+" file:"+csvFile);
            else
                System.err.println("Erro: "+e.toString());
            System.exit(1);
        }    
        out.flush();
        out.close();
    }

    // comando "y banco selectCSV_banco"(nao confundir com "y selectCSV_banco")
    public void selectCSV_banco(String conn,String parm){
        
        boolean onlychar=false;
        String onlychar_=getEnv("CSV_ONLYCHAR_Y");
        if ( onlychar_ != null && onlychar_.equals("S") )
            onlychar=true;
        boolean com_separador_final=false;
        String com_separador_final_=getEnv("COM_SEPARADOR_FINAL_CSV_Y");
        if ( com_separador_final_ != null && com_separador_final_.equals("S") )
            com_separador_final=true;
        boolean semHeader=false;
        String semHeader_=getEnv("SEM_HEADER_CSV_Y");
        if ( semHeader_ != null && semHeader_.equals("S") )
            semHeader=true;
        
                
        // configuracao TZ UTC NATAL YYYY-MM-DD
        String dataT=" ";
        String dataZ=" ";
        boolean flag_natal=false;
        boolean flag_ymd=false;
        String format_data=getEnv("FORMAT_DATA_Y");
        if ( format_data != null && format_data.equals("TZ") ){
            dataT="T";
            dataZ="Z";
        }
        if ( format_data != null && format_data.equals("UTC") )
            dataZ=" UTC";
        if ( format_data != null && format_data.equals("NATAL") )
            flag_natal=true;
        if ( format_data != null && format_data.equals("YYYY-MM-DD") )
            flag_ymd=true;
        
        Connection con=null;
        Statement stmt=null;
        ResultSet rs=null;
        long count=0;
        String parm_=parm;
        
        try{
            con = getcon(conn);
            if ( con == null ){
                System.err.println("Não foi possível se conectar!!" );
                return;
            }

            if ( parm.equals("") ){
                String line;
                while( (line=readLine()) != null )
                    parm+=line+"\n";                
                closeLine();
            }
            parm=removePontoEVirgual(parm);

            stmt = con.createStatement();
            rs=null;
            ResultSetMetaData rsmd;
            ArrayList<String> campos=new ArrayList<String>();
            ArrayList<Integer> tipos=new ArrayList<Integer>();
            StringBuilder sb=null;
            String tmp="";
            String table="";
            String header="";
            String first_detail="";
            boolean first=true;

            rs=stmt.executeQuery(parm);
            rsmd=rs.getMetaData();
            table=getTableByParm(parm);

            for ( int i=1;i<=rsmd.getColumnCount();i++ )
            {
                campos.add(rsmd.getColumnName(i));
                tipos.add(rsmd.getColumnType(i));
            }

            while ( rs.next() ){
                sb=new StringBuilder();
                for ( int i=0;i<campos.size();i++ ){
                    tmp=rs.getString(campos.get(i));

                    if ( tmp == null  ){
                        if ( first )
                        {
                            if ( i == campos.size()-1 && !com_separador_final ){
                                header+="\""+campos.get(i)+"\"";
                                first_detail+="\"\"";
                            }else{
                                header+="\""+campos.get(i)+"\""+getSeparadorCSV();
                                first_detail+="\"\""+getSeparadorCSV();
                            }
                        }else{
                            sb.append("\"\"");
                            sb.append(getSeparadorCSV());
                        }
                        continue;
                    }
                    if ( tipo_cadastrado(tipos.get(i)) ){
                        if ( banco_tipo_numerico(tipos.get(i)) && tmp.startsWith(".") )
                            tmp="0"+tmp;
                        if ( tipos.get(i) == 93 ) // DATA
                            if ( flag_natal )
                                tmp="25/12/"+tmp.substring(0, 4)+dataT+tmp.substring(11, 19)+dataZ;
                            else
                                if ( flag_ymd )
                                    tmp=tmp.substring(0, 4)+"-"+tmp.substring(5, 7)+"-"+tmp.substring(8, 10)+dataT+tmp.substring(11, 19)+dataZ;
                                else
                                    tmp=tmp.substring(8, 10)+"/"+tmp.substring(5, 7)+"/"+tmp.substring(0, 4)+dataT+tmp.substring(11, 19)+dataZ;
                        // o csv suporta ".."".." mas para ficar mais simples o comando abaixo tira o "
                        tmp=tmp.replace("\"","").replace("\n","");
                        tmp=tmp.trim();
                        
                        if ( first )
                        {
                            if ( i == campos.size()-1 && !com_separador_final ){
                                header+="\""+campos.get(i)+"\"";
                                if ( onlychar && banco_tipo_numerico(tipos.get(i)) ){
                                    first_detail+=tmp;
                                }else{
                                    first_detail+="\""+tmp+"\"";
                                }
                            }else{
                                header+="\""+campos.get(i)+"\""+getSeparadorCSV();
                                if ( onlychar && banco_tipo_numerico(tipos.get(i)) ){
                                    first_detail+=tmp+getSeparadorCSV();
                                }else{
                                    first_detail+="\""+tmp+"\""+getSeparadorCSV();
                                }
                            }
                        }else{
                            // nao imprime delimitador em onlychar e tipos.get(i) == 2
                            if ( onlychar && banco_tipo_numerico(tipos.get(i)) ){
                            }else{
                                sb.append("\"");
                            }
                            sb.append(tmp);
                            if ( onlychar && banco_tipo_numerico(tipos.get(i)) ){
                            }else{
                                sb.append("\"");
                            }
                            if ( i == campos.size()-1 && !com_separador_final ){
                            }else{
                                sb.append(getSeparadorCSV());
                            }
                        }
                        continue;
                    }
                    close(rs,stmt,con);
                    throw new Exception("tipo desconhecido:"+tipos.get(i) + " -> " + rs.getString(campos.get(i)) );
                }

                if ( first ){
                    first=false;
                    if ( !semHeader )
                        System.out.println(header);
                    System.out.println(first_detail);
                    count++;
                    continue;
                }

                System.out.println(sb.toString());                
                count++;
            }        
        }
        catch(Exception e){
            System.err.println("Erro: "+e.toString()+" -> "+parm_);
            close(rs,stmt,con);
            System.exit(1);
        }   
        close(rs,stmt,con);
        try_finish_and_count(count);
    }

    public void executeInsert(String conn, InputStream pipe){        
        Connection con=null;
        Statement stmt=null;
        ResultSet rs=null;
        
        boolean par=true;
        String line="";
        StringBuilder sb=null;
        boolean ok=true;
        
        int limiteAgulha=50000; // all.length();
        String initial_sb=" insert all";
        String final_sb=" select * from dual";
        
        String ii;
        StringBuilder all=new StringBuilder(initial_sb);
        ArrayList<String> cover=new ArrayList<String>();

        String command="";
        boolean achou=false;
        
        readLineB(pipe, null, null);
        
        try{
            con = getcon(conn);
            if ( con == null ){
                System.err.println("Não foi possível se conectar!!" );
                return;
            }
            con.setAutoCommit(false);
            stmt = con.createStatement();

            while( (line=readLineB()) != null ){
                if ( par && line.trim().equals("") )
                    continue;
                if ( par ){
                    if ( line.trim().startsWith("commit") || line.trim().startsWith("COMMIT") )
                    {
                        try{  
                            ii=removePontoEVirgual(line);
                            stmt.execute(ii);
                        }catch(Exception e){
                            System.err.println("Erro: "+e.toString()+" -> "+line);
                            close(rs,stmt,con);
                            System.exit(1);
                        }
                        continue;
                    }
                    if ( startingInsert(line) )
                    {
                        if ( par=countParAspeta(par,line) ){
                            try{
                                ii=removePontoEVirgual(line);                                
                                if ( all.length() >= limiteAgulha ){
                                    all.append(ii.substring(6));
                                    cover.add(ii);
                                    all.append(final_sb);
                                    try{
                                        stmt.execute(all.toString());
                                    }catch(Exception e){
                                        // repescagem
                                        for(String iii : cover){
                                            try{
                                                stmt.execute(iii);
                                            }catch(Exception ee){
                                                achou=false;
                                                for ( String ora : ORAs ){
                                                    if ( ee.toString().contains(ora) ){
                                                        System.out.println("Warnning: "+iii);
                                                        ok=false;
                                                        achou=true;
                                                        break;
                                                    }
                                                }
                                                if ( ! achou ){
                                                    command=iii;
                                                    throw ee;
                                                }
                                            }                                            
                                        }
                                    }
                                    
                                    all=null;                                    
                                    all=new StringBuilder(initial_sb);
                                    cover=null;
                                    cover=new ArrayList<String>();
                                }else{
                                    all.append(ii.substring(6));
                                    cover.add(ii);
                                }
                                
                            }catch(Exception e){
                                System.err.println("Erro: "+e.toString()+" -> "+line);
                                close(rs,stmt,con);
                                System.exit(1);
                            }
                            continue;
                        }else{
                            sb=null;// forçando limpeza de memoria
                            sb=new StringBuilder(line);
                        }
                        continue;
                    }
                    close(rs,stmt,con);
                    throw new Exception("Erro, linha inesperada:" +line);
                }else{
                    if ( par=countParAspeta(par,line) ){
                        try{
                            sb.append("\n");
                            sb.append(removePontoEVirgual(line));
                            ii=sb.toString();
                            if ( all.length() >= limiteAgulha ){
                                all.append(ii.substring(6));
                                cover.add(ii);
                                all.append(final_sb);
                                
                                try{
                                    stmt.execute(all.toString());
                                }catch(Exception e){
                                    // repescagem
                                    for(String iii : cover){
                                        try{
                                            stmt.execute(iii);
                                        }catch(Exception ee){
                                            achou=false;
                                            for ( String ora : ORAs ){
                                                if ( ee.toString().contains(ora) ){
                                                    System.out.println("Warnning: "+iii);
                                                    ok=false;
                                                    achou=true;
                                                    break;
                                                }
                                            }
                                            if ( ! achou ){
                                                command=iii;
                                                throw ee;
                                            }
                                        }                                            
                                    }
                                }
                                    
                                all=null;                                
                                all=new StringBuilder(initial_sb);
                                cover=null;
                                cover=new ArrayList<String>();
                            }else{
                                all.append(ii.substring(6));
                                cover.add(ii);
                            }
                            
                        }catch(Exception e){
                            System.err.println("Erro: "+e.toString()+" -> "+line);
                            close(rs,stmt,con);
                            System.exit(1);
                        }
                        continue;
                    }else{
                        sb.append("\n");
                        sb.append(line);
                    }
                }
            }
            if ( ! all.toString().equals(initial_sb) ){
                all.append(final_sb);
                
                try{
                    stmt.execute(all.toString());
                }catch(Exception e){
                    // repescagem
                    for(String iii : cover){
                        try{
                            stmt.execute(iii);
                        }catch(Exception ee){
                            achou=false;
                            for ( String ora : ORAs ){
                                if ( ee.toString().contains(ora) ){
                                    System.out.println("Warnning: "+iii);
                                    ok=false;
                                    achou=true;
                                    break;
                                }
                            }
                            if ( ! achou ){
                                command=iii;
                                close(rs,stmt,con);
                                throw ee;
                            }
                        }                                            
                    }
                }

                all=null;
                cover=null;
            }
            close(rs,stmt,con);
        }catch(Exception e){
            if ( ! command.equals(""))
                System.err.println("Erro: "+e.toString().replace("\n","")+" -> "+command);                
            else
                System.err.println("Erro: "+e.toString());
            close(rs,stmt,con);
            System.exit(1);
        }   
        if ( ok )
            System.out.println("OK");
        close(rs,stmt,con);
        closeLineB();                
    }

    public boolean execute(String conn,String parm){
        Connection con=null;
        Statement stmt=null;
        ResultSet rs=null;
        
        try{
            con = getcon(conn);
            if ( con == null ){
                System.err.println("Não foi possível se conectar!!" );
                return false;
            }

            if ( parm.equals("") ){
                String line;
                while( (line=readLine()) != null )
                    parm+=line+"\n";   
                closeLine();
            }

            if ( ! parm.trim().toUpperCase().startsWith("DECLARE") )
                parm=removePontoEVirgual(parm);
            
            stmt = con.createStatement();
            if ( stmt.execute(parm) )
                System.out.println("OK");
            else
                System.out.println("OK"); //OK mesmo
        }
        catch(Exception e)
        {
            System.err.println("Erro: "+e.toString()+" -> "+parm);
            close(rs,stmt,con);
            System.exit(1);
            return false;
        }        
        close(rs,stmt,con);
        return true;
    }

    public void buffer(String [] args){
        if ( args.length == 2 ){
            buffer(n_lines_buffer_DEFAULT,null);
            return;
        }
        if ( args.length == 4 && args[2].equals("-n_lines") ){
            buffer(tryConvertNumberPositiveByString(n_lines_buffer_DEFAULT,args[3]),null);
            return;
        }
        if ( args.length == 4 && args[2].equals("-log") ){
            buffer(n_lines_buffer_DEFAULT,args[3]);
            return;
        }
        if ( args.length == 6 && args[2].equals("-n_lines") && args[4].equals("-log") ){
            buffer(tryConvertNumberPositiveByString(n_lines_buffer_DEFAULT,args[3]),args[5]);
            return;
        }
    }
            
    public void buffer(final int n_lines_buffer,String caminhoLog_){
        try{     
            final List<String> lista=Collections.synchronizedList(new ArrayList<String>());
            
            final boolean [] finishIn=new boolean[]{false};
            final long [] countLinhasIn=new long []{0,0,0}; // 0-> contador;1-> contador informado; 2-> contador desligado
            final long [] countLinhasOut=new long []{0,0,0}; // 0-> contador;1-> contador informado; 2-> contador desligado
            final int sizeMaskSpeedCount=6;
            final int sizeMaskBufferCount=(n_lines_buffer+"").length();
            final String [] caminhoLog=new String[]{caminhoLog_};
            final PrintWriter [] out=new PrintWriter[1];
            final SimpleDateFormat formatter = new SimpleDateFormat("dd/MM/yyyy HH:mm:ss");  
            
            // abrindo arquivo
            if ( caminhoLog[0] != null )
            {
                try{                    
                    out[0]=new PrintWriter(caminhoLog[0], "UTF-8");                    
                }catch(Exception e){
                    caminhoLog[0]=null;
                }
            }

            // thread log
            if ( caminhoLog[0] != null )
            {
                new Thread() {
                    public void run() {
                        try{
                            long time1=System.currentTimeMillis();                        
                            long time2=time1;                            
                            long countIn;
                            long countOut;

                            out[0].println(formatter.format(new Date()) + " - start");
                            out[0].flush();
                            while(true)
                            {
                                time2=System.currentTimeMillis();
                                if ( countLinhasIn[2] == 1 && countLinhasOut[2] == 1 ){ // fim
                                    break;
                                }
                                if ( time2 >= time1+1000 )
                                {
                                    time1=time2;                                    
                                    countIn=0;
                                    countOut=0;
                                    
                                    if ( countLinhasIn[1] == 0 ){
                                        countIn=countLinhasIn[0];
                                        countLinhasIn[1]=countIn;
                                    }
                                    if ( countLinhasOut[1] == 0 ){
                                        countOut=countLinhasOut[0];
                                        countLinhasOut[1]=countOut;
                                    }
                                    out[0].println( formatter.format(new Date()) + " - linhas/s[in]: " + lpad(countIn,sizeMaskSpeedCount," ") + " - linhas/s[out]: " + lpad(countOut,sizeMaskSpeedCount," ") + " - buffer: " + lpad(lista.size(),sizeMaskBufferCount," ") );
                                    out[0].flush();
                                }
                                sleepMillis(100);
                            }
                        }catch(Exception e){
                            caminhoLog[0]=null;
                        }
                    }
                }.start();  
            }

            // thread in
            new Thread() {
                public void run() {
                    String line;
                    while( true ){
                        if ( lista.size() < n_lines_buffer )
                        {
                            if ( (line=readLine()) != null )
                            {
                                lista.add(line);
                                if ( caminhoLog[0] != null )
                                    contabiliza(countLinhasIn);
                            }else{
                                finishIn[0]=true;
                                break;
                            }
                        }
                    }
                    closeLine();
                    countLinhasIn[2]=1;
                }
            }.start();        
            
            // saida
            while( true ){
                if ( finishIn[0] ){
                    while(lista.size() > 0){
                        System.out.println(lista.get(0));
                        lista.remove(0);
                        if ( caminhoLog[0] != null )
                            contabiliza(countLinhasOut);
                    }
                    countLinhasOut[2]=1;
                    break;
                }
                if (lista.size() > 0){
                    System.out.println(lista.get(0));
                    lista.remove(0);
                    if ( caminhoLog[0] != null )
                        contabiliza(countLinhasOut);
                }  
            }

            // fechando arquivo
            if ( caminhoLog[0] != null )
            {
                try{
                    out[0].println(formatter.format(new Date()) + " - end");
                    out[0].flush();
                    out[0].close();                    
                }catch(Exception e){
                    System.out.println(e.toString());
                }
            }
            
        }catch(Exception e){
            System.out.println(e.toString());
        }
    }
    
    public void contabiliza(long [] countLinhas){
        if ( countLinhas[1] > 0 )
        {
            countLinhas[0]-=countLinhas[1];
            if ( countLinhas[0] < 0 )
                countLinhas[0]=0;
            countLinhas[1]=0;                
        }
        countLinhas[0]++;
    }
    
    public String format_ponto(String a, int len){
        return format_ponto_virgula(a, len, ".");
    }
    public String format_virgula(String a, int len){
        return format_ponto_virgula(a, len, ",");
    }
    public String format_ponto_virgula(String a, int len, String ponto_virgula){
        String b="";
        String c="";
        if ( ! a.contains(ponto_virgula) ){
            b=a;
        }else{
            String [] partes=a.split(ponto_virgula.equals(".")?"\\.":ponto_virgula);
            if ( partes.length > 2 || partes.length == 0 )
                erroFatal("Erro interno!");
            if ( partes.length == 2 ){
                b=partes[0];
                c=partes[1];
            }else
                b=partes[0];
        }
        int limit=1000;
        while(c.length()<len && limit-->0){
            c+="0";
        }
        return b+ponto_virgula+c;
    }    

    public String gettoken(String hash){
        
        String dir_token=getenvtoken();
        if ( ! env_ok(dir_token) )
            return null;
        return lendo_token(dir_token,hash);
    }

    public String apresentacao(String [] programas)
    {
        String retorno="";
        for ( int i=0;i<programas.length;i++ )
            retorno+="\n  [" + programas[i] + "]";
        return "usage:"+retorno;
    }
    public boolean env_ok(String dir_token)
    {
        if ( dir_token == null ){
            System.err.println("Para usar o token é necessário ter a variável de ambiente TOKEN_Y definida, ex export TOKEN_Y=/home/user/.token_y");
            return false;
        }
        File f = new File(dir_token);
        if ( ! f.exists() ){
            if ( ! f.mkdir() ){
                System.err.println("Não foi possível utilizar/criar a pasta "+dir_token);
                return false;
            }
        }
        if ( ! f.isDirectory() ){
            System.err.println("O caminho "+dir_token+" não é um diretório");
            return false;

        }
        return true;
    }
    public String salvando_token(String dir_token,String value){
        dir_token=fix_caminho(dir_token);
        String md5=digest_text(value,"MD5");
        if(salvando_file(value+"\n",new File(dir_token+md5)))
            return md5;
        return null;
    }
    public String lendo_token(String dir_token,String md5){
        dir_token=fix_caminho(dir_token);
        if ( ! new File(dir_token+md5).exists() )
            return null;
        return lendo_arquivo(dir_token+md5);
    }

    public Connection loadJar_getConnection(String url, String user, String password) throws Exception{
        if ( url.startsWith("jdbc:postgresql:") )
            return loadJar_getConnection("postgresql-42.7.5.jar", "org.postgresql.Driver", "https://artifacts-oss.talend.com/nexus/content/groups/public/org/postgresql/postgresql/42.7.5/", url, user, password);
        return null;
    }
    public Connection loadJar_getConnection(String jar, String className, String indexOfdown, String url, String user, String password) throws Exception{
        String outJar="";
        if ( isWindows() )
            outJar="C:\\y\\"+jar;
        else
            outJar="/opt/y/"+jar;
        if ( !new File(outJar).exists() ){
            if ( isWindows() )
                System.err.println("warming... comando pendente!!\ncurl \"" + indexOfdown + jar + "\" > \" " + outJar + "\"");
            else
                System.err.println("warming... comando pendente!!\ncurl " + indexOfdown + jar + "\" > \" " + outJar + "\"");
            return null;
        }
        loadJar(outJar);
        Class cls = loadJar_classLoader.loadClass(className);
        java.sql.Driver d=(java.sql.Driver)cls.getDeclaredConstructor().newInstance();
        java.util.Properties info = new java.util.Properties();
        info.put("user", user);
        info.put("password", password);
        Connection con=d.connect(url, info);                    
        return con;
    }

    public static ClassLoader loadJar_classLoader=new ClassLoader() {            
        @Override protected Class<?> findClass(String name) throws ClassNotFoundException { 
            //System.out.println("finding... " + name);
            if ( classes.containsKey(name) ){ 
                try { 
                    byte[] data=(byte [])classes.get(name);
                    return defineClass(name,data,0,data.length);        
                }catch(Exception e){ 
                    System.err.println("Erro no carregamento da classe "+name); 
                    System.exit(1); 
                } 
            } 
            return super.findClass(name); 
        } 
    };                    

    static String loadJar_mainManifest=null;
    static java.util.HashMap classes=new java.util.HashMap();
    private void loadJar(String path) throws Exception{
        loadJar_mainManifest=null;
        java.util.jar.JarFile jarFile = new java.util.jar.JarFile(path);
        java.util.Enumeration<java.util.jar.JarEntry> e = jarFile.entries();
        while (e.hasMoreElements()) {
            java.util.jar.JarEntry je = e.nextElement();
            if(je.getName().equals("META-INF/MANIFEST.MF") ){
                byte [] bytes=getBytesInputStream(jarFile.getInputStream(je));
                loadJar_mainManifest=loadJar_getMainClassName(new String(bytes));
                continue;
            }
            if(je.isDirectory() || !je.getName().endsWith(".class")){
                continue;
            }        
            String key=je.getName().replace("/",".");
            key=key.substring(0,key.length()-6);
            byte [] value=getBytesInputStream(jarFile.getInputStream(je));
            //System.out.println("put: " + key);
            classes.put(key, value);
        }        
    }    

    public String loadJar_getMainClassName(String a){
        String [] partes=a.split("\r\n");
        for ( int i=0;i<partes.length;i++ ){
            if ( partes[i].startsWith("Main-Class: ") ){
                String [] partes2=partes[i].split(" ");
                if ( partes2.length == 2 )
                    return partes2[1];
            }
        }
        return null;
    }


    
	//REMOVED_GRAAL_START
    public void try_load_libraries(){
        try{
            Class.forName("oracle.jdbc.OracleDriver");
        }catch (Exception e){
            System.err.println("Não foi possível carregar a biblioteca Oracle");
            System.exit(1);
        }            
        try{
            Class.forName("com.microsoft.sqlserver.jdbc.SQLServerDriver");
        }catch (Exception e){
            System.err.println("Não foi possível carregar a biblioteca SQL Server");
            System.exit(1);
        }        
        try{
            /*
            //Class.forName("org.postgresql.util.PGJDBCMain");
            java.io.File jarFile = new java.io.File("C:\\y\\postgresql-42.7.5B.jar");
            java.net.URL jarUrl = jarFile.toURI().toURL();
            java.net.URLClassLoader classLoader = new java.net.URLClassLoader(new java.net.URL[]{jarUrl});            
            Class<?> loadedClass = classLoader.loadClass("org.postgresql.util.PGJDBCMain");
            System.out.println("Class loaded successfully: " + loadedClass.getName());
            //loadedClass.getDeclaredConstructor().newInstance();
            //classLoader.loadClass("org.postgresql.util.PGJDBCMain");
            */
            
            /*
            loadJar("C:\\y\\postgresql-42.7.5B.jar", true);
            System.out.println("");
            try {Thread.sleep(1000);} catch (InterruptedException e) { }  
            if ( loadJar_mainManifest != null )
                loadJar_load(new String[]{loadJar_mainManifest}, true);
            */
            //Class.forName("org.postgresql.Driver");
            
            /*
            File jarFile = new File("C:\\y\\postgresql-42.7.5B.jar");
            URL jarUrl = jarFile.toURI().toURL();
            URLClassLoader customClassLoader = new URLClassLoader(new URL[]{jarUrl});
            Class<?> loadedClass = Class.forName("org.postgresql.util.PGJDBCMain", true, customClassLoader);
            */
            
            /*
            File file = new File("C:\\y\\postgresql-42.7.5B.jar");
            URL url = file.toURI().toURL();
            URLClassLoader classLoader = new URLClassLoader(new URL[]{url});
            Class<?> loadedClass = classLoader.loadClass("org.postgresql.util.PGJDBCMain");
            Object instance = loadedClass.getDeclaredConstructor().newInstance();
            */
            //Class cls=Class.forName("org.postgresql.util.PGJDBCMain2");
            //cls.getDeclaredConstructor().newInstance();
            
            /*
            File newClasspathEntry = new File("C:\\y\\postgresql-42.7.5B.jar");
            URL newClasspathUrl = newClasspathEntry.toURI().toURL();
            ClassLoader currentClassLoader = Thread.currentThread().getContextClassLoader();
            URLClassLoader newClassLoader = new URLClassLoader(
                new URL[]{newClasspathUrl}, // Novo caminho a ser adicionado
                currentClassLoader          // ClassLoader pai (para herdar o classpath existente)
            );
            Thread.currentThread().setContextClassLoader(newClassLoader);
            String className = "org.postgresql.util.PGJDBCMain"; // Nome totalmente qualificado da classe
            Class<?> loadedClass = newClassLoader.loadClass(className);
            Object instance = loadedClass.getDeclaredConstructor().newInstance();
            */
            
            //cd c:\y && cls && compila2 && y banco "conn,nuvem" select "select 1"
            // nao precisa
            //Class.forName("org.postgresql.util.PGJDBCMain");
            //Class.forName("org.postgresql.Driver");
            
            //https://github.com/pgjdbc/pgjdbc/blob/master/pgjdbc/src/main/java/org/postgresql/Driver.java
        }catch (Exception e){
            // comentar depois
            //System.out.println(e.toString());
            /*
            if ( isWindows() )
                System.err.println("warming... comando pendente!!\ncurl \"https://artifacts-oss.talend.com/nexus/content/groups/public/org/postgresql/postgresql/42.7.5/postgresql-42.7.5.jar\" > \"c:\\y\\postgresql-42.7.5.jar\"");
            else
                System.err.println("warming... comando pendente!!\ncurl https://artifacts-oss.talend.com/nexus/content/groups/public/org/postgresql/postgresql/42.7.5/postgresql-42.7.5.jar > /opt/y/postgresql-42.7.5.jar");
            */
        }                
    }	
	//REMOVED_GRAAL_END
	//REMOVED_GRAAL_START
    public void try_load_ORAs() {        
        ORAs=lendo_arquivo_pacote("/y/ORAs").split("\n");
        
        try{
            String caminho=getEnv("ORAs_Y");
            if ( ! new File(caminho).exists() ) return;
            ArrayList<String> lista=new ArrayList<String>();
            String line;

            readLine(caminho);
            while ((line = readLine()) != null)
                lista.add(line);
            closeLine();

            if ( lista.size() > 0 )
            {
                ORAs=new String[lista.size()];
                for ( int i=0;i<lista.size();i++ )
                    ORAs[i]=lista.get(i);
            }
        }catch (Exception e){
            //try_load_ORAs
        }
    }
    //REMOVED_GRAAL_END
	
    public String fix_caminho(String caminho){
        if ( ! caminho.endsWith("/") && caminho.contains("/") )
            return caminho+"/";
        if ( ! caminho.endsWith("\\") && caminho.contains("\\") )
            return caminho+"\\";
        return caminho;
    }
    public String getenvtoken(){
        if ( local_env != null && new File(local_env).exists() )
            return local_env;
        return getEnv("TOKEN_Y");
    }

    public String getTableByParm(String parm){
        String retorno="";
        try{
            retorno=parm.toUpperCase().replace(")"," ").replace("\n"," ").replace(","," ").replace("*"," ").split("FROM ")[1].split(" ")[0].trim();
            if ( retorno.length() == 0 )
                return "";
        }catch(Exception e){
            return "";
        }
        return retorno;
    }
            
    public String removePontoEVirgual(String txt){
        String retorno=RTRIM(txt);
        if ( retorno.endsWith(";") )
            return retorno.substring(0,retorno.length()-1);
        return retorno;
    }

    public boolean startingInsert(String txt){
        txt=LTRIM(txt);
        return txt.startsWith("insert") || txt.startsWith("INSERT");
    }

    public boolean countParAspeta(boolean par,String txt){        
        int p=0;
        int len=txt.length();
        while(true){
            p=txt.indexOf("'",p);
            if ( p == -1 )
                return par;
            else{
                par=!par;
                p++;
                if ( p >= len )
                    return par;
            }            
        }
    }

    public String LTRIM(String txt){
        return txt.replaceAll("^\\s+","");
    }

    public String RTRIM(String txt){
        return txt.replaceAll("\\s+$","");
    }
    
    public Connection getcon(String stringcon){
        if ( stringcon.startsWith("jdbc:sqlserver") ){
            //SQLServer            
            try {      
                //Class.forName("com.microsoft.sqlserver.jdbc.SQLServerDriver");
                return DriverManager.getConnection(stringcon);
            } catch (Exception x) {
                System.err.println("Erro na conexão:"+x.toString());
            }
        }else{
            //Oracle
            if ( stringcon.split("\\|").length != 3){
                System.err.println("Erro na conexão: Login e senha não encontrado!");
                return null;
            }else{
                String par = stringcon.split("\\|")[0];
                String user = stringcon.split("\\|")[1];
                String pass = stringcon.split("\\|")[2];
                String erro=null;
                try {
                    //Class.forName("oracle.jdbc.OracleDriver");                    
                    return DriverManager.getConnection(par, user, pass);                    
                } catch (Exception x) {  
                    erro=x.toString();                    
                }
                try{
                    Connection conn=loadJar_getConnection(par, user, pass);                    
                    if ( conn != null )
                        return conn;                    
                }catch(Exception e){
                    System.err.println("Erro na conexão:: "+e.toString());
                    return null;
                }
                System.err.println("Erro na conexão:"+erro);
            }
        }
        return null;
    }
    
    private void zip_add_router(String [] paths, String virtual_name, boolean isLvlStore, OutputStream out, String pre_line_print_on) throws Exception {
        this.virtual_name = virtual_name;                
        zip_output = new java.util.zip.ZipOutputStream(out);   
        if ( isLvlStore )
            zip_output.setLevel(ZipOutputStream.STORED);        
        valida_paths(paths);
        zip_add(paths, pre_line_print_on);
        zip_output.closeEntry();
        zip_output.flush();
        zip_output.close();        
    }

    private void valida_paths(String [] paths){
        for ( int i=0; i<paths.length; i++ )
            if ( ! new File(paths[i]).exists() ){
                System.err.println("Erro, esse conteudo nao existe: "+paths[i]);
                System.exit(1);
            }
    }
    
    private java.util.zip.ZipOutputStream zip_output=null;
    private ArrayList<String> zip_elementos=null;
    private ArrayList<Long> zip_elementos_lastModified=null;
    private String virtual_name;
    private void zip_add(String [] paths, String pre_line_print_on) throws Exception {
        int len;
        java.util.zip.ZipEntry e=null;
        if ( paths.length == 0 ){            
            e=new java.util.zip.ZipEntry(virtual_name);
            zip_output.putNextEntry(e);
            byte[] buf = new byte[BUFFER_SIZE];                                    
            while ((len = readBytes(buf)) > -1){
                zip_output.write(buf, 0, len);
                if ( pre_line_print_on != null )
                    print_cursor_speed(len, pre_line_print_on, null, true, null);
            }
            closeBytes();
        }else{
            for ( int i_=0; i_<paths.length;i_++ ){
                File elem=new File(paths[i_]);
                if ( elem.isFile() ){            
                    e=new java.util.zip.ZipEntry(elem.getName());
                    e.setTime(elem.lastModified());
                    zip_output.putNextEntry(e);
                    readBytes(elem);
                    byte[] buf = new byte[BUFFER_SIZE];                                    
                    long size_alert=-1;
                    long size=0;
                    size_alert = elem.length() + 1024*1024*100; // acima de 100MB do planejado
                    while ((len = readBytes(buf)) > -1){
                        zip_output.write(buf, 0, len);
                        if ( pre_line_print_on != null )
                            print_cursor_speed(len, pre_line_print_on, null, true, null);
                        size+=len;
                        if ( elem != null && size > size_alert ){
                            System.err.println("Erro, sistema anti loop ativado!");
                            System.exit(1);
                        }
                    }
                    closeBytes();
                }else{
                    zip_elementos=new ArrayList<String>();            
                    zip_elementos_lastModified=new ArrayList<Long>();            
                    if ( !paths[i_].startsWith("/") && !paths[i_].contains(":") ) // verifica se é relative path
                        zip_navega(elem,paths[i_]+"/");
                    else
                        zip_navega(elem,"");
                    int len_cache=zip_elementos.size();
                    for ( int i=0;i<len_cache;i++ ){
                        e=new java.util.zip.ZipEntry( zip_elementos.get(i) );
                        e.setTime(zip_elementos_lastModified.get(i));
                        zip_output.putNextEntry(e);
                        if ( ! zip_elementos.get(i).endsWith("/") ){                    
                            File tmp = new File(zip_elementos.get(i));
                            long size_alert=tmp.length() + 1024*1024*100; // acima de 100MB do planejado
                            long size=0;
                            readBytes(tmp);
                            byte[] buf = new byte[BUFFER_SIZE];                        
                            while ((len = readBytes(buf)) > -1){
                                zip_output.write(buf, 0, len);                
                                if ( pre_line_print_on != null )
                                    print_cursor_speed(len, pre_line_print_on, null, true, null);
                                size+=len;
                                if ( elem != null && size > size_alert ){
                                    System.err.println("Erro, sistema anti loop ativado!!");
                                    System.exit(1);
                                }
                            }
                            closeBytes();            
                        }
                    }
                }  
            }
        }
    }
    
    private void zip_navega(File a, String caminho) {
        java.io.File[] filhos=a.listFiles();
        if ( filhos == null ) return;
        for ( int i=0;i<filhos.length;i++ ){
            if ( filhos[i].isFile() ){
                zip_elementos.add(caminho+filhos[i].getName());
                zip_elementos_lastModified.add(filhos[i].lastModified());
            }
            if ( filhos[i].isDirectory() && !filhos[i].getName().equals(".") && !filhos[i].getName().equals("..") ){
                zip_elementos.add(caminho+filhos[i].getName()+"/");
                zip_elementos_lastModified.add(filhos[i].lastModified());
                zip_navega(filhos[i],caminho+filhos[i].getName()+"/");
            }
        }
    }
    
    private void zip_list(String a) throws Exception {
        valida_paths(new String[]{a});
        if ( a == null ){
            ZipInputStream zis=new ZipInputStream(System.in);
            ZipEntry entry=null;
            while( (entry=zis.getNextEntry()) != null ){
                System.out.println(entry.getName());
            }
        }else{
            ZipFile zipFile = new ZipFile(a);
            Enumeration<? extends ZipEntry> entries = zipFile.entries();
            while(entries.hasMoreElements()){
                ZipEntry entry = entries.nextElement();            
                System.out.println(entry.getName());
            }                
        }
    }

    private int zip_extract_count_encontrados=0;
    private void zip_extract(InputStream in, String name_file_zip, String pre_dir, String filtro) throws Exception {
        zip_extract_count_encontrados=0;
        if ( filtro != null && filtro.endsWith("/") ){
            System.err.println("Erro, o item selecionado não pode ser uma pasta!: "+filtro);
            System.exit(1);
        }
        if ( pre_dir != null ){
            pre_dir=pre_dir.trim();
            if ( pre_dir.length() == 0 ){
                System.err.println("Erro, preenchimento incorreto de pasta!");
                System.exit(1);
            }
            File pasta_=new File(pre_dir);
            if ( ! pasta_.exists() ){
                System.err.println("Erro, a pasta "+pre_dir+ " não existe!");
                System.exit(1);
            }else{
                if ( ! pasta_.isDirectory() ){
                    System.err.println("Erro, o caminho a seguir não é uma pasta: "+pre_dir);
                    System.exit(1);
                }
            }
            pre_dir=pre_dir.replace("\\","/");
            if ( !pre_dir.endsWith("/") )
                pre_dir+="/";
        }else
            pre_dir="";
        if ( name_file_zip != null )
            valida_paths(new String[]{name_file_zip});
        if ( name_file_zip == null ){
            ZipInputStream zis=new ZipInputStream(in);
            ZipEntry entry=null;
            while( (entry=zis.getNextEntry()) != null ){                                
                if ( entry.getName().endsWith("/") ){
                    zip_extract_grava(pre_dir,entry.getName(),null,filtro, entry.getTime());
                }else{
                    zip_extract_grava(pre_dir,entry.getName(),zis,filtro, entry.getTime());
                }
            }
        }else{
            ZipFile zipFile = new ZipFile(name_file_zip);
            Enumeration<? extends ZipEntry> entries = zipFile.entries();
            while(entries.hasMoreElements()){
                ZipEntry entry = entries.nextElement();            
                if ( entry.getName().endsWith("/") ){
                    zip_extract_grava(pre_dir,entry.getName(),null,filtro,entry.getTime());
                }else{
                    zip_extract_grava(pre_dir,entry.getName(),zipFile.getInputStream(entry),filtro,entry.getTime());
                }
            }                
        }
        if ( filtro != null && zip_extract_count_encontrados == 0 ){
            System.err.println("Erro, elemento "+filtro+" não encontrado!");
            System.exit(1);
        }
    }

    private void zip_extract_grava(String pre_dir, String name, InputStream is,String filtro, long lastModified) throws Exception {
        String [] partes=name.split("/");
        String dir="";
        File tmp=null;
        boolean out_console=false;
        if ( filtro != null && pre_dir.equals("") )
            out_console=true;
        for ( int i=0;i<partes.length;i++ ){
            if ( i == partes.length-1 ){
                if ( is == null ){
                    dir+=partes[i]+"/";
                    if ( filtro != null && filtro.indexOf(dir) == -1 )
                        continue;
                    if ( ! out_console ){
                        tmp=new File(pre_dir+dir);
                        if ( tmp.exists() ){
                            if ( !tmp.isDirectory() ){
                                System.err.println("Erro, não é possível utilizar o caminho a seguir como pasta: "+pre_dir+dir);
                                System.exit(1);
                            }
                        }else{
                            tmp.mkdir();
                            tmp.setLastModified(lastModified);
                        }
                    }
                }else{
                    dir+=partes[i];
                    if ( filtro != null && filtro.indexOf(dir) == -1 )
                        continue;
                    if ( ! out_console ){
                        tmp=new File(pre_dir+dir);
                        if ( tmp.exists() ){
                            if ( tmp.isDirectory() ){
                                System.err.println("Erro, não é possível utilizar o caminho a seguir como arquivo: "+pre_dir+dir);
                                System.exit(1);
                            }
                        }
                    }
                    if ( filtro == null ){
                        tmp=new File(pre_dir+dir);
                        copiaByStream(is, new FileOutputStream(tmp), dir);
                        tmp.setLastModified(lastModified);
                    }else{
                        if ( filtro.equals(dir) ){
                            zip_extract_count_encontrados++;
                            if ( out_console ){
                                copiaByStream(is, System.out, null);
                            }else{
                                tmp=new File(pre_dir+dir);
                                copiaByStream(is, new FileOutputStream(tmp), dir);
                                tmp.setLastModified(lastModified);
                            }
                        }
                    }
                }
            }else{
                dir+=partes[i]+"/";
                if ( filtro != null && filtro.indexOf(dir) == -1 )
                    continue;
                if ( ! out_console ){
                    tmp=new File(pre_dir+dir);
                    if ( tmp.exists() ){
                        if ( !tmp.isDirectory() ){
                            System.err.println("Erro, não é possível utilizar o caminho a seguir como pasta: "+pre_dir+dir);
                            System.exit(1);
                        }
                    }else{
                        tmp.mkdir();
                        tmp.setLastModified(lastModified);
                    }
                }
            }
        }
    }
    
    public void gzip()
    {
        try{            
            byte[] buf = new byte[BUFFER_SIZE];            
            java.util.zip.GZIPOutputStream out = new java.util.zip.GZIPOutputStream(System.out);
            int len;
            while ((len = readBytes(buf)) > -1)
                out.write(buf, 0, len);
            out.finish();  
            closeBytes();
        }catch(Exception e){
            System.out.println(e.toString());
        }
    }
    
    public void gunzip()
    {
        try{            
            byte[] buf = new byte[BUFFER_SIZE];
            java.util.zip.GZIPInputStream out = new java.util.zip.GZIPInputStream(System.in);
            int len;
            while ((len = out.read(buf)) > -1)
                System.out.write(buf, 0, len);            
        }catch(Exception e){
            System.out.println(e.toString());
        }
    }
    
    public void trataEcho() throws Exception{ // pode bugar o UTF-8, ex usando caracter chines 一
        String [] args = bind_asterisk(new String[]{"echo", readString().substring(5).trim()});
        ByteArrayOutputStream baos=new ByteArrayOutputStream();
        printf(args, baos);
        String result=baos.toString();
        if ( 
            (result.startsWith("'") && result.endsWith("'"))
            || (result.startsWith("\"") && result.endsWith("\""))
        )
            System.out.println(result.substring(1, result.length()-1));
        else
            System.out.println(result);
    }
            
    public void echo(String [] args) throws Exception{
        args = bind_asterisk(args);        
        printf(args, System.out);
        System.out.write("\n".getBytes());
    }

    public void trataPrintf() throws Exception{
        String [] args = bind_asterisk(new String[]{"printf", readString().substring(7).trim()});
        ByteArrayOutputStream baos=new ByteArrayOutputStream();
        printf(args, baos);
        String result=baos.toString();
        if ( 
            (result.startsWith("'") && result.endsWith("'"))
            || (result.startsWith("\"") && result.endsWith("\""))
        )
            System.out.print(result.substring(1, result.length()-1));
        else
            System.out.print(result);        
    }
            
    public static String [] printf_cor_name=      new String[]{"VERDE", "VERMELHO", "AZUL", "BRANCO"};
    public static int    [] printf_cor_name_id=   new int   []{32,      31,         34,     97};
    public static String [] printf_cor_bg_name=   new String[]{"CINZA", "BRANCO"};
    public static int    [] printf_cor_bg_name_id=new int   []{100,     107};
    public void printf(String [] args, OutputStream os) throws Exception{
        // correção bug windows
        if ( args.length == 2 && ( args[1].startsWith("[COR") || args[1].startsWith("\"[COR") ) ){
            if ( args[1].contains(" ") )
                args=new String []{"printf", args[1].split(" ")[0].replaceAll("\"", ""), args[1].split(" ")[1]};
            else
                args[1]=args[1].replaceAll("\"", "");
        }
        
        if ( args.length == 2 && args[1].equals("[COR]") ){
            printf_list_cor(os);
            return;
        }
        if ( args.length > 2 && (                
            args[1].equals("[COR]")
            || ( args[1].startsWith("[COR/") && args[1].endsWith("]") && args[1].substring(1, args[1].length()-1).split("/").length <= 3 ) 
        )){
            String cor="";
            String cor_nada="[m";
            String [] partes=args[1].substring(1, args[1].length()-1).split("/");
            if ( partes.length == 1 )
                cor=cor_nada;                
            else
                if ( partes.length == 2 ){
                    int p=findParm(printf_cor_name, partes[1], true);
                    if ( p == -1 )
                        erroFatal("Não foi possível interpretar " + args[1]);
                    cor="[" + printf_cor_name_id[p] + "m";                    
                }else{
                    int p=findParm(printf_cor_name, partes[1], true);
                    if ( p == -1 )
                        erroFatal("Não foi possível interpretar " + args[1]);
                    int p2=findParm(printf_cor_bg_name, partes[2], true);
                    if ( p2 == -1 )
                        erroFatal("Não foi possível interpretar " + args[1]);
                    cor="[" + printf_cor_bg_name_id[p2] + ";" + printf_cor_name_id[p] + "m";
                }
            args=removeParm(1, args); // remove parm cor
            printf_cor(cor, os);            
        }
        String result="";
        if ( args.length > 1 )
            result=args[1];
        for ( int i=2;i<args.length;i++ )
            result+=" "+args[i];        
        os.write(result.getBytes());
    }
    public void printf_list_cor(OutputStream os) throws Exception{
        printf_cor("[m", os);
        for ( int i=0;i<printf_cor_name.length;i++ ){
            printf_cor("[" + printf_cor_name_id[i] + "my printf [COR/" + printf_cor_name[i] + "] oi", os);
            printf_cor("[m", os);
            os.write("\n".getBytes());
        }
        for ( int i=0;i<printf_cor_name.length;i++ ){
            for ( int j=0;j<printf_cor_bg_name.length;j++ ){
                if ( printf_cor_name[i].equals(printf_cor_bg_name[j]) )
                    continue;
                printf_cor("[" + printf_cor_bg_name_id[j] + ";" + printf_cor_name_id[i] + "my printf [COR/" + printf_cor_name[i] + "/" + printf_cor_bg_name[j] + "] oi", os);
                printf_cor("[m", os);
                os.write("\n".getBytes());
            }
        }
        printf_cor("[my printf [COR] \" \"", os);
        os.write("\n".getBytes());
    }
    public void printf_cor(String cor, OutputStream os) throws Exception{
        byte [] bytes=new byte[]{(byte)27};
        int limit=1000;
        while(limit-->0 && cor.length() > 0){
            bytes=addParm((byte)cor.charAt(0), bytes);
            cor=cor.substring(1);                        
        }
        os.write(bytes);
    }
    private void cursorUp(int n){
        try{
            System.out.write(new byte[]{(byte)27});
        }catch(Exception e){
            erroFatal(e);
        }
        System.out.print("[");
        System.out.print(n);
        System.out.print("F");
    }
    
    public void progressBar(InputStream is, Boolean uniqLine) {
        readLine(is,"UTF-8",null);
        String line="";
        ArrayList lista=new ArrayList<String>();
        int carro=0;
        boolean fullDisplay=false;
        while( (line=readLine()) != null ){
            if ( line.equals("done") ){
                System.out.println("");
                System.out.flush();
                return;
            }
            if(uniqLine)
                System.out.print(progressBarFormat80(line, false));
            else{
                line=progressBarFormat80(line, true);
                carro=progressBarFormat80_numeroCarro;
                while(carro+1 > lista.size()){
                    System.out.println("");
                    lista.add("");
                }
                lista.set(carro, line);   
                if ( fullDisplay ){
                    cursorUp(lista.size());
                    for(int i=0;i<lista.size();i++)
                        System.out.println(lista.get(i));                 
                }else{
                    cursorUp(lista.size()-carro);
                    for(int i=carro;i<lista.size();i++)
                        System.out.println(lista.get(i));                 
                }
            }
            System.out.flush();
        }
        System.out.println("");
        System.out.flush();
    }
    
    private int progressBarFormat80_numeroCarro=0;
    private String progressBarFormat80_spaces="                                                                                                                                                                ";    
    private String progressBarFormat80(String a, Boolean hasCarro){
        int _80=130;
        a=a.trim();
        if ( hasCarro ){
            int p=a.indexOf(" ");
            try{
                progressBarFormat80_numeroCarro=Integer.parseInt(a.split(" ")[0])-1;
            }catch(Exception e){
                erroFatal("\n\nprogressBar Error!\nComando inválido: " + a);
            }
            if ( p > -1 )
                a=a.substring(p+1);
            else
                return "\r"+progressBarFormat80_spaces;
        }
        if ( a.length() > _80 )
            a=a.substring(0, _80-3) + "...";
        else{
            if ( a.length() < _80 )
                a=a+progressBarFormat80_spaces.substring(0, _80-a.length());
        }
        return "\r"+a;
    }
            
    public void xargs(String [] args){
        args = sliceParm(1, args);
        if ( args.length == 0 )
            erroFatal("Erro de parametro!");
        ArrayList<String> lista_in=readAllLines();
        boolean achou=false;
        for ( int i=0;i<args.length;i++ ){
            if ( args[i].contains("{}") ){
                achou=true;
                break;
            }                
        }
        if ( !achou )
            args = addParm("{}", args);
        for ( int i=0;i<lista_in.size();i++ ){
            String [] command=new String[args.length];
            for ( int j=0;j<args.length;j++ )
                command[j]=args[j].replace("{}", lista_in.get(i));
            new Y().go(command);
        }
    }        
    
    public void sorte(){
        // ref. https://privatekeyfinder.io/bitcoin-puzzle/
        // D:\ProgramFiles\cuBitCrack
        // cuBitCrack.exe --keyspace 4:7 -c 19ZewH8Kk1PDbSNdJ97FP4EiCjTRaZMZQA
        // iniciar randomicamente o inicio do range caso o rango for maior e 1 milhao, essa parte é muito importante
        // consulta se premio ja foi resgatado https://blockchain.info/balance?active=19ZewH8Kk1PDbSNdJ97FP4EiCjTRaZMZQA
        // anotar cache caso premio ja foi resgatado
        // https://www.blockchain.com/pt/explorer/addresses/btc/19ZewH8Kk1PDbSNdJ97FP4EiCjTRaZMZQA
        // o runtimeexec tem que dar output em tempo real, usar esse comando antes de chamar: flag_real_time_output=true;
        // obs; puzzle de 1 a 160. formula range: 2^(n-1)..(2^n)-1
        // obs2: o premio em bitcoin é o numero do puzzle dividido por 10.         
        for ( int i=0;i<160;i++ )
            System.out.println(sorte_puzzle_n(i+1));
    }
    
    java.security.SecureRandom sorte_puzzle_n_random=null;
    String sorte_puzzle_n_keys_c="1BgGZ9tcN4rm9KBzDn7KprQz87SZ26SAMH,1CUNEBjYrCn2y1SdiUMohaKUi4wpP326Lb,19ZewH8Kk1PDbSNdJ97FP4EiCjTRaZMZQA,1EhqbyUMvvs7BfL8goY6qcPbD6YKfPqb7e,1E6NuFjCi27W5zoXg8TRdcSRq84zJeBW3k,1PitScNLyp2HCygzadCh7FveTnfmpPbfp8,1McVt1vMtCC7yn5b9wgX1833yCcLXzueeC,1M92tSqNmQLYw33fuBvjmeadirh1ysMBxK,1CQFwcjw1dwhtkVWBttNLDtqL7ivBonGPV,1LeBZP5QCwwgXRtmVUvTVrraqPUokyLHqe,1PgQVLmst3Z314JrQn5TNiys8Hc38TcXJu,1DBaumZxUkM4qMQRt2LVWyFJq5kDtSZQot,1Pie8JkxBT6MGPz9Nvi3fsPkr2D8q3GBc1,1ErZWg5cFCe4Vw5BzgfzB74VNLaXEiEkhk,1QCbW9HWnwQWiQqVo5exhAnmfqKRrCRsvW,1BDyrQ6WoF8VN3g9SAS1iKZcPzFfnDVieY,1HduPEXZRdG26SUT5Yk83mLkPyjnZuJ7Bm,1GnNTmTVLZiqQfLbAdp9DVdicEnB5GoERE,1NWmZRpHH4XSPwsW6dsS3nrNWfL1yrJj4w,1HsMJxNiV7TLxmoF6uJNkydxPFDog4NQum,14oFNXucftsHiUMY8uctg6N487riuyXs4h,1CfZWK1QTQE3eS9qn61dQjV89KDjZzfNcv,1L2GM8eE7mJWLdo3HZS6su1832NX2txaac,1rSnXMr63jdCuegJFuidJqWxUPV7AtUf7,15JhYXn6Mx3oF4Y7PcTAv2wVVAuCFFQNiP,1JVnST957hGztonaWK6FougdtjxzHzRMMg,128z5d7nN7PkCuX5qoA4Ys6pmxUYnEy86k,12jbtzBb54r97TCwW3G1gCFoumpckRAPdY,19EEC52krRUK1RkUAEZmQdjTyHT7Gp1TYT,1LHtnpd8nU5VHEMkG2TMYYNUjjLc992bps,1LhE6sCTuGae42Axu1L1ZB7L96yi9irEBE,1FRoHA9xewq7DjrZ1psWJVeTer8gHRqEvR,187swFMjz1G54ycVU56B7jZFHFTNVQFDiu,1PWABE7oUahG2AFFQhhvViQovnCr4rEv7Q,1PWCx5fovoEaoBowAvF5k91m2Xat9bMgwb,1Be2UF9NLfyLFbtm3TCbmuocc9N1Kduci1,14iXhn8bGajVWegZHJ18vJLHhntcpL4dex,1HBtApAFA9B2YZw3G2YKSMCtb3dVnjuNe2,122AJhKLEfkFBaGAd84pLp1kfE7xK3GdT8,1EeAxcprB2PpCnr34VfZdFrkUWuxyiNEFv,1L5sU9qvJeuwQUdt4y1eiLmquFxKjtHr3E,1E32GPWgDyeyQac4aJxm9HVoLrrEYPnM4N,1PiFuqGpG8yGM5v6rNHWS3TjsG6awgEGA1,1CkR2uS7LmFwc3T2jV8C1BhWb5mQaoxedF,1NtiLNGegHWE3Mp9g2JPkgx6wUg4TW7bbk,1F3JRMWudBaj48EhwcHDdpeuy2jwACNxjP,1Pd8VvT49sHKsmqrQiP61RsVwmXCZ6ay7Z,1DFYhaB2J9q1LLZJWKTnscPWos9VBqDHzv,12CiUhYVTTH33w3SPUBqcpMoqnApAV4WCF,1MEzite4ReNuWaL5Ds17ePKt2dCxWEofwk,1NpnQyZ7x24ud82b7WiRNvPm6N8bqGQnaS,15z9c9sVpu6fwNiK7dMAFgMYSK4GqsGZim,15K1YKJMiJ4fpesTVUcByoz334rHmknxmT,1KYUv7nSvXx4642TKeuC2SNdTk326uUpFy,1LzhS3k3e9Ub8i2W1V8xQFdB8n2MYCHPCa,17aPYR1m6pVAacXg1PTDDU7XafvK1dxvhi,15c9mPGLku1HuW9LRtBf4jcHVpBUt8txKz,1Dn8NF8qDyyfHMktmuoQLGyjWmZXgvosXf,1HAX2n9Uruu9YDt4cqRgYcvtGvZj1rbUyt,1Kn5h2qpgw9mWE5jKpk8PP4qvvJ1QVy8su,1AVJKwzs9AskraJLGHAZPiaZcrpDr1U6AB,1Me6EfpwZK5kQziBwBfvLiHjaPGxCKLoJi,1NpYjtLira16LfGbGwZJ5JbDPh3ai9bjf4,16jY7qLJnxb7CHZyqBP8qca9d51gAjyXQN,18ZMbwUFLMHoZBbfpCjUJQTCMCbktshgpe,13zb1hQbWVsc2S7ZTZnP2G4undNNpdh5so,1BY8GQbnueYofwSuFAT3USAhGjPrkxDdW9,1MVDYgVaSN6iKKEsbzRUAYFrYJadLYZvvZ,19vkiEajfhuZ8bs8Zu2jgmC6oqZbWqhxhG,19YZECXj3SxEZMoUeJ1yiPsw8xANe7M7QR,1PWo3JeB9jrGwfHDNpdGK54CRas7fsVzXU,1JTK7s9YVYywfm5XUH7RNhHJH1LshCaRFR,12VVRNPi4SJqUTsp6FmqDqY5sGosDtysn4,1FWGcVDK3JGzCC3WtkYetULPszMaK2Jksv,1J36UjUByGroXcCvmj13U6uwaVv9caEeAt,1DJh2eHFYQfACPmrvpyWc8MSTYKh7w9eRF,1Bxk4CQdqL9p22JEtDfdXMsng1XacifUtE,15qF6X51huDjqTmF9BJgxXdt1xcj46Jmhb,1ARk8HWJMn8js8tQmGUJeQHjSE7KRkn2t8,1BCf6rHUW6m3iH2ptsvnjgLruAiPQQepLe,15qsCm78whspNQFydGJQk5rexzxTQopnHZ,13zYrYhhJxp6Ui1VV7pqa5WDhNWM45ARAC,14MdEb4eFcT3MVG5sPFG4jGLuHJSnt1Dk2,1CMq3SvFcVEcpLMuuH8PUcNiqsK1oicG2D,1Kh22PvXERd2xpTQk3ur6pPEqFeckCJfAr,1K3x5L6G57Y494fDqBfrojD28UJv4s5JcK,1PxH3K1Shdjb7gSEoTX7UPDZ6SH4qGPrvq,16AbnZjZZipwHMkYKBSfswGWKDmXHjEpSf,19QciEHbGVNY4hrhfKXmcBBCrJSBZ6TaVt,1L12FHH2FHjvTviyanuiFVfmzCy46RRATU,1EzVHtmbN4fs4MiNk3ppEnKKhsmXYJ4s74,1AE8NzzgKE7Yhz7BWtAcAAxiFMbPo82NB5,17Q7tuG2JwFFU9rXVj3uZqRtioH3mx2Jad,1K6xGMUbs6ZTXBnhw1pippqwK6wjBWtNpL,19eVSDuizydXxhohGh8Ki9WY9KsHdSwoQC,15ANYzzCp5BFHcCnVFzXqyibpzgPLWaD8b,18ywPwj39nGjqBrQJSzZVq2izR12MDpDr8,1CaBVPrwUxbQYYswu32w7Mj4HR4maNoJSX,1JWnE6p6UN7ZJBN7TtcbNDoRcjFtuDWoNL,1KCgMv8fo2TPBpddVi9jqmMmcne9uSNJ5F,1CKCVdbDJasYmhswB6HKZHEAnNaDpK7W4n,1PXv28YxmYMaB8zxrKeZBW8dt2HK7RkRPX,1AcAmB6jmtU6AiEcXkmiNE9TNVPsj9DULf,1EQJvpsmhazYCcKX5Au6AZmZKRnzarMVZu,1CMjscKB3QW7SDyQ4c3C3DEUHiHRhiZVib,18KsfuHuzQaBTNLASyj15hy4LuqPUo1FNB,15EJFC5ZTs9nhsdvSUeBXjLAuYq3SWaxTc,1HB1iKUqeffnVsvQsbpC6dNi1XKbyNuqao,1GvgAXVCbA8FBjXfWiAms4ytFeJcKsoyhL,12JzYkkN76xkwvcPT6AWKZtGX6w2LAgsJg,1824ZJQ7nKJ9QFTRBqn7z7dHV5EGpzUpH3,18A7NA9FTsnJxWgkoFfPAFbQzuQxpRtCos,1NeGn21dUDDeqFQ63xb2SpgUuXuBLA4WT4,174SNxfqpdMGYy5YQcfLbSTK3MRNZEePoy,1NLbHuJebVwUZ1XqDjsAyfTRUPwDQbemfv,1MnJ6hdhvK37VLmqcdEwqC3iFxyWH2PHUV,1KNRfGWw7Q9Rmwsc6NT5zsdvEb9M2Wkj5Z,1PJZPzvGX19a7twf5HyD2VvNiPdHLzm9F6,1GuBBhf61rnvRe4K8zu8vdQB3kHzwFqSy7,17s2b9ksz5y7abUm92cHwG8jEPCzK3dLnT,1GDSuiThEV64c166LUFC9uDcVdGjqkxKyh,1Me3ASYt5JCTAK2XaC32RMeH34PdprrfDx,1CdufMQL892A69KXgv6UNBD17ywWqYpKut,1BkkGsX9ZM6iwL3zbqs7HWBV7SvosR6m8N,1PXAyUB8ZoH3WD8n5zoAthYjN15yN5CVq5,1AWCLZAjKbV1P7AHvaPNCKiB7ZWVDMxFiz,1G6EFyBRU86sThN3SSt3GrHu1sA7w7nzi4,1MZ2L1gFrCtkkn6DnTT2e4PFUTHw9gNwaj,1Hz3uv3nNZzBVMXLGadCucgjiCs5W9vaGz,1Fo65aKq8s8iquMt6weF1rku1moWVEd5Ua,16zRPnT8znwq42q7XeMkZUhb1bKqgRogyy,1KrU4dHE5WrW8rhWDsTRjR21r8t3dsrS3R,17uDfp5r4n441xkgLFmhNoSW1KWp6xVLD,13A3JrvXmvg5w9XGvyyR4JEJqiLz8ZySY3,16RGFo6hjq9ym6Pj7N5H7L1NR1rVPJyw2v,1UDHPdovvR985NrWSkdWQDEQ1xuRiTALq,15nf31J46iLuK1ZkTnqHo7WgN5cARFK3RA,1Ab4vzG6wEQBDNQM1B2bvUz4fqXXdFk2WT,1Fz63c775VV9fNyj25d9Xfw3YHE6sKCxbt,1QKBaU6WAeycb3DbKbLBkX7vJiaS8r42Xo,1CD91Vm97mLQvXhrnoMChhJx4TP9MaQkJo,15MnK2jXPqTMURX4xC3h4mAZxyCcaWWEDD,13N66gCzWWHEZBxhVxG18P8wyjEWF9Yoi1,1NevxKDYuDcCh1ZMMi6ftmWwGrZKC6j7Ux,19GpszRNUej5yYqxXoLnbZWKew3KdVLkXg,1M7ipcdYHey2Y5RZM34MBbpugghmjaV89P,18aNhurEAJsw6BAgtANpexk5ob1aGTwSeL,1FwZXt6EpRT7Fkndzv6K4b4DFoT4trbMrV,1CXvTzR6qv8wJ7eprzUKeWxyGcHwDYP1i2,1MUJSJYtGPVGkBCTqGspnxyHahpt5Te8jy,13Q84TNNvgcL3HJiqQPvyBb9m4hxjS3jkV,1LuUHyrQr8PKSvbcY1v1PiuGuqFjWpDumN,18192XpzzdDi2K11QVHR7td2HcPS6Qs5vg,1NgVmsCCJaKLzGyKLFJfVequnFW9ZvnMLN,1AoeP37TmHdFh8uN72fu9AqgtLrUwcv2wJ,1FTpAbQa4h8trvhQXjXnmNhqdiGBd1oraE,14JHoRAdmJg3XR4RjMDh6Wed6ft6hzbQe9,19z6waranEf8CcP8FqNgdwUe1QRxvUNKBG,14u4nA5sugaswb6SZgn5av2vuChdMnD9E5,1NBC8uXJy1GiJ6drkiZa1WuKn51ps7EPTv";
    public String sorte_puzzle_n(int puzzle_n){ // 1 até 160        
        if ( puzzle_n < 1 || puzzle_n > 160 )
            erroFatal("puzzle_n invalido: " + puzzle_n);
        if ( sorte_puzzle_n_random == null )
            sorte_puzzle_n_random=new java.security.SecureRandom();
        java.math.BigInteger i=java.math.BigInteger.TWO.pow(puzzle_n-1);
        java.math.BigInteger f=java.math.BigInteger.TWO.pow(puzzle_n).subtract(java.math.BigInteger.ONE);
        java.math.BigInteger r=i.add(new java.math.BigInteger(puzzle_n-1, sorte_puzzle_n_random));
        return "puzzle " + puzzle_n + " random " + r.toString(16) + " inicio " + i.toString(16) + " fim " + f.toString(16) + " key " + sorte_puzzle_n_keys_c.split(",")[puzzle_n-1];
    }
    
    public void cat(String [] args)
    {
        try{
            String catEof_tag_flagAppend=null;
            // cat EOF
            if ( args.length == 3 && (catEof_tag_flagAppend=getCatEof_tag_flagAppend(args[1])) != null ){
                if ( !isWindows() )
                    erroFatal("Esse comando só esta liberado para windows!");
                /*
                o linux não consegue interpretar corretamente o comando abaixo de exemplo basico
                y cat
                a
                b
                c
                */
                String tag=catEof_tag_flagAppend.split(",")[0];
                boolean append=catEof_tag_flagAppend.split(",")[1].equals("true");
                File outputFile = new File(args[2]);
                PushbackInputStream pbis = new PushbackInputStream(System.in, tag.length());
                //BufferedReader pbis = new BufferedReader(new InputStreamReader(System.in));
                ByteArrayOutputStream baos = new ByteArrayOutputStream();
                byte[] tagBytes = tag.getBytes();
                int matchPos = 0;
                int b;
                while ((b = pbis.read()) != -1) {
                    baos.write(b);
                    if (b == tagBytes[matchPos]) {
                        matchPos++;
                        if (matchPos == tagBytes.length) {
                            byte[] data = baos.toByteArray();
                            byte[] finalData = new byte[data.length - tagBytes.length];
                            System.arraycopy(data, 0, finalData, 0, finalData.length);
                            try (FileOutputStream fos = new FileOutputStream(outputFile, append)) {
                                fos.write(finalData);
                            }
                            break;
                        }
                    } else {
                        matchPos = 0;
                    }
                } 
                return;
            }
            
            // cat > ou >> file1.txt
            if ( args.length == 3 && (args[1].equals(">") || args[1].equals(">>")) ){
                boolean append=args[1].equals(">>");
                File outputFile = new File(args[2]);                
                String [] controlC_parms = new String []{"\n", "0"};
                new Util().loadDisableControlC(controlC_parms);
                InputStream inputStream_pipe=System.in;      
                ByteArrayOutputStream baos=new ByteArrayOutputStream();
                int len=0;
                byte [] buff = new byte[BUFFER_SIZE];
                while(true){
                    if ( controlC_parms[1].equals("1") ){
                        salvando_file(baos.toByteArray(), outputFile, append);
                        break;
                    }
                    if ( inputStream_pipe.available() <= 0 )
                        continue;
                    len=inputStream_pipe.read(buff,0,BUFFER_SIZE);
                    baos.write(buff, 0, len);
                }                   
                return;
            }
            
            // FILE
            if ( args.length > 1 ){
                for ( int i=1;i<args.length;i++ )
                {
                    if ( ! new File(args[i]).exists() ){
                        System.err.println("Erro, este arquivo não existe: "+args[i]);
                        return;
                    }
                }
                for ( int i=1;i<args.length;i++ )
                {                
                    byte[] buf = new byte[BUFFER_SIZE];            
                    FileInputStream fis = new FileInputStream(args[i]);
                    int len;
                    while ((len = fis.read(buf)) > -1)
                        System.out.write(buf, 0, len);            
                    fis.close();
                }
                return;
            }
            
            // stdin/stdout
            InputStream inputStream_pipe=System.in;
            byte[] buf = new byte[BUFFER_SIZE];
            int len=0;
            while( (len=inputStream_pipe.read(buf,0,BUFFER_SIZE)) > 0 ){
                System.out.write(buf, 0, len);
            }
            System.out.flush();
            System.out.close();
            
        }catch(Exception e){
            System.err.println("Erro, "+e.toString());
        }
    }
    
    public String getCatEof_tag_flagAppend(String a){
        //"<<EOF>" -> EOF,false
        //"<<EEOOFF>>" -> EEOOFF,true
        if ( a.contains(",") || a.contains(" ") || a.contains("/") || a.contains("\\") )
            return null;
        if ( !a.startsWith("<<") || a.substring(2).contains("<") )
            return null;
        if ( a.endsWith(">>") && a.replaceAll(">", "").length() == a.length()-2 )
            return a.replaceAll("<", "").replaceAll(">", "")+",true";
        if ( a.endsWith(">") && a.replaceAll(">", "").length() == a.length()-1 )
            return a.replaceAll("<", "").replaceAll(">", "")+",false";
        return null;
    }
    
    public void iso(String [] args){
        try{
            Object [] objs=get_parms_iso_source_flagMake(args);
            if ( objs == null )
                erroFatal("Erro de parametros!");
            String iso=(String)objs[0];
            String source=(String)objs[1];
            Boolean flagMake=(Boolean)objs[2];
            if ( flagMake ){
                if ( !new File(source).exists() )
                    erroFatal("Pasta não encontrada:" + source);
                if ( !new File(source).isDirectory() )
                    erroFatal("Esse caminho não é uma pasta:" + source);
                if (    !check_util("D:/ProgramFiles/iso/efisys.bin") 
                     || !check_util("D:/ProgramFiles/iso/etfsboot.com") 
                     || !check_util("D:/ProgramFiles/iso/oscdimg.exe") 
                )
                    erroFatal("Erro no carregamento!");        
                String dir="D:/ProgramFiles/iso";
                if ( !new File(dir).exists() )
                    dir="C:/ProgramFiles/iso";
                String etfsboot=dir+"/etfsboot.com";
                String etfsboot_try=new File(source).getCanonicalPath()+"\\boot\\etfsboot.com";
                String efisys=dir+"/efisys.bin";
                String efisys_try=new File(source).getCanonicalPath()+"\\efi\\microsoft\\boot\\efisys.bin";
                if ( new File(efisys_try).exists() )
                    efisys=efisys_try;                
                if ( new File(etfsboot_try).exists() )
                    etfsboot=etfsboot_try;                
                runtimeExec(null, new String[]{dir+"/oscdimg", "-lISO", "-m", "-o", "-u2", 
                    "-udfver102", "-bootdata:2#p0,e,b"+etfsboot+"#pEF,e,b"+efisys, source, iso}, null, null, false);
                System.out.println("fim");
            }else{
                if ( !new File(iso).exists() )
                    erroFatal("Arquivo não encontrado: " + iso);
                if ( new File(source).exists() ){
                    if ( !new File(source).isDirectory() )
                        erroFatal("Esse caminho precisa ser uma pasta: " + source);
                }else{
                    if ( !new File(source).mkdir() )
                        erroFatal("Não foi possível criar a pasta: " + source);
                }            
                if ( !check_util("D:/ProgramFiles/7z/7z.exe") || !check_util("D:/ProgramFiles/7z/7z.dll") )
                    erroFatal("Erro no carregamento!");
                String dir="D:/ProgramFiles/7z";
                if ( !new File(dir).exists() )
                    dir="C:/ProgramFiles/7z";
                runtimeExec(null, new String[]{"cmd", "/c", dir+"/7z", "x", "-y", "-o"+source, iso}, null, null, false);
                if ( runtimeExecError != null && !runtimeExecError.equals("") )
                    System.err.println(runtimeExecError);
                else
                    System.out.println("fim");
            }
        }catch(Exception e){
            erroFatal(e);
        }
    }    
    public void juros(String [] args){
        Object [] objs=get_parms_modelo_valor_jurosAM_jurosAA_parcelas(args);
        if ( objs == null )
            erroFatal("Erro de parametros!");
        String modelo=(String)objs[0];
        Double valor=(Double)objs[1];
        Double jurosAM=(Double)objs[2];
        Double jurosAA=(Double)objs[3];
        Integer parcelas=(Integer)objs[4];
        if ( modelo.equals("price") ){
            new TabelaPrice(valor, jurosAM, jurosAA, parcelas);
            return;
        }
        if ( modelo.equals("sac") ){
            new TabelaSAC(valor, jurosAM, jurosAA, parcelas);
            return;
        }
        erroFatal("sistema de emprestimo não reconhecido: " + modelo);
    }
    public void dnsDoHServer(String host, int port, String dns){
        /*
        // quase
        // modelo com certificado, ainda dando problema
        // https://localhost:8443/dns-query
        // certificado.cer MIIDhTCCAm2gAwIBAgIEFJaHCTANBgkqhkiG9w0BAQsFADBzMQswCQYDVQQGEwJCUjEQMA4GA1UECBMHTXlTdGF0ZTEPMA0GA1UEBxMGTXlDaXR5MRcwFQYDVQQKEw5NeU9yZ2FuaXphdGlvbjEUMBIGA1UECxMLRGV2ZWxvcG1lbnQxEjAQBgNVBAMTCWxvY2FsaG9zdDAeFw0yNTAzMjExOTQ2MjlaFw0yNjAzMjExOTQ2MjlaMHMxCzAJBgNVBAYTAkJSMRAwDgYDVQQIEwdNeVN0YXRlMQ8wDQYDVQQHEwZNeUNpdHkxFzAVBgNVBAoTDk15T3JnYW5pemF0aW9uMRQwEgYDVQQLEwtEZXZlbG9wbWVudDESMBAGA1UEAxMJbG9jYWxob3N0MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAgfSb236uEDMYI5hfp+UFwR8WPzOMiYDsdjo9KZmUiqztCfBIv42YvcREYbG2EqPh+XPCV6QWsTQqVA8Vih4mfigEa3I14KJ/iYON/jbzUhzQtf1/y0TWJNXgwpg2M6aLR6uCDS6JNbMFvzEBgiYVD86dRo0n/H8wbPf6qBsNdhCNRTpLBGKeQqnNXNVYR9rDDgwhAFlz/SlvtEKWO5L2/mLSpvdg3XXjOSpW13MX5A0wISr9v3ApNClNXesnQz8TlAw4qeRk02O/bw7OaRWK/ssaggDnm0ksTV23QtbvvtqIWl7vePbFdAl6GJRzGVUDGqibuEC73rEu/CGKx64XawIDAQABoyEwHzAdBgNVHQ4EFgQUETILYovPidK9QxJt04IQCufcyX8wDQYJKoZIhvcNAQELBQADggEBAGjgsthlDJ4K6YUS/8JaMy8Voj6MYLc4d1kQERX8DHmngQoG24Epnek8b6if9eY4i+6Q8ohsc9f/XhooOzHRATj7iBxROH2EPMb7PGXaQUt9Xxely5MC7R5B4jIKf8c/QVR0rIxkL/79sIX6gOyOBGuGx9JuHJ3DWIWHM8UoOZCS4g8/tsiSAk5QU/iNIpmRGz77Rdh8s9ygd2l/zNTg9eDbKELWx+BHlqlDVifDsVJIsOI5CU/epaCVlAM3OcZJVt5JOahUxF6IbVU8rYZJXte/48mZr3pCxthRVtF6ZIN/1Eul508fkaXxd5hVebKBZ5+rJKmbD3eyQj14Hh+2bAk=
        // password pass2word
        // keytool -genkeypair -alias dohserver -keyalg RSA -keysize 2048 -validity 365 -keystore dohserver.keystore -storepass pass2word -keypass pass2word -dname "CN=localhost, OU=Development, O=MyOrganization, L=MyCity, ST=MyState, C=BR"

        import javax.net.ssl.*;
        import java.io.*;
        import java.net.*;
        import java.security.KeyStore;
        import java.nio.charset.StandardCharsets;

        public class DoHServer {
            public DoHServer() throws Exception {
                // Configura o SSLContext com o keystore
                char[] password = "pass2word".toCharArray(); // Senha do keystore
                KeyStore keyStore = KeyStore.getInstance("JKS");
                try (InputStream keyStoreStream = new FileInputStream("C:\\tmp\\tmp\\dohserver.keystore")) {
                    keyStore.load(keyStoreStream, password);
                }

                KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance("SunX509");
                keyManagerFactory.init(keyStore, password);

                SSLContext sslContext = SSLContext.getInstance("TLS");
                sslContext.init(keyManagerFactory.getKeyManagers(), null, null);

                // Cria o SSLServerSocket
                SSLServerSocketFactory socketFactory = sslContext.getServerSocketFactory();
                try (SSLServerSocket serverSocket = (SSLServerSocket) socketFactory.createServerSocket(8443)) {
                    System.out.println("Servidor DoH rodando em https://localhost:8443/dns-query");

                    while (true) {
                        try (SSLSocket clientSocket = (SSLSocket) serverSocket.accept()) {
                            handleClient(clientSocket);
                        } catch (Exception e) {
                            e.printStackTrace();
                        }
                    }
                }
            }

            private static void handleClient(SSLSocket clientSocket) throws IOException {
                // Usa InputStream para ler bytes da solicitação HTTP
                InputStream in = clientSocket.getInputStream();
                OutputStream out = clientSocket.getOutputStream();

                // Lê a primeira linha da solicitação HTTP
                BufferedReader reader = new BufferedReader(new InputStreamReader(in));
                String requestLine = reader.readLine();
                if (requestLine != null && requestLine.startsWith("POST /dns-query")) {
                    // Lê os cabeçalhos HTTP
                    int contentLength = 0;
                    String header;
                    while ((header = reader.readLine()) != null && !header.isEmpty()) {
                        if (header.startsWith("Content-Length:")) {
                            contentLength = Integer.parseInt(header.substring("Content-Length:".length()).trim());
                        }
                    }

                    // Lê o corpo da solicitação (consulta DNS)
                    byte[] dnsQuery = new byte[contentLength];
                    int bytesRead = 0;
                    while (bytesRead < contentLength) {
                        bytesRead += in.read(dnsQuery, bytesRead, contentLength - bytesRead);
                    }

                    // Processa a consulta DNS
                    byte[] dnsResponse = sendDnsQuery(dnsQuery);

                    // Envia a resposta HTTP
                    String httpResponse = "HTTP/1.1 200 OK\r\n" +
                            "Content-Type: application/dns-message\r\n" +
                            "Content-Length: " + dnsResponse.length + "\r\n" +
                            "Connection: close\r\n\r\n";
                    out.write(httpResponse.getBytes(StandardCharsets.UTF_8));
                    out.write(dnsResponse);
                } else {
                    // Retorna erro para métodos não suportados
                    String httpResponse = "HTTP/1.1 405 Method Not Allowed - " + requestLine + "\r\n" +
                            "Connection: close\r\n\r\n";
                    out.write(httpResponse.getBytes(StandardCharsets.UTF_8));
                }

                out.flush();
            }

            // Método para enviar uma consulta DNS via UDP
            private static byte[] sendDnsQuery(byte[] dnsQuery) throws IOException {
                try (DatagramSocket socket = new DatagramSocket()) {
                    socket.setSoTimeout(5000); // Timeout de 5 segundos

                    // Endereço do resolvedor DNS (Google DNS)
                    InetAddress dnsServer = InetAddress.getByName("8.8.8.8");
                    int dnsPort = 53;

                    // Envia a consulta DNS
                    DatagramPacket queryPacket = new DatagramPacket(dnsQuery, dnsQuery.length, dnsServer, dnsPort);
                    socket.send(queryPacket);

                    // Recebe a resposta DNS
                    byte[] buffer = new byte[1024];
                    DatagramPacket responsePacket = new DatagramPacket(buffer, buffer.length);
                    socket.receive(responsePacket);

                    // Retorna a resposta DNS
                    byte[] responseData = new byte[responsePacket.getLength()];
                    System.arraycopy(responsePacket.getData(), 0, responseData, 0, responsePacket.getLength());
                    return responseData;
                }
            }
        }        
        */
        try{
            ServerSocket serverSocket = new ServerSocket(port, 1,InetAddress.getByName(host));
            String host_display="http://" + host + ":" + port;
            if (host.contains(":"))
                host_display="http://[" + host + "]:" + port;
            System.out.println("Service opened: " + host_display);
            while (true) {
                Socket clientSocket = serverSocket.accept();
                new Thread(new DoHServerRunnable(clientSocket, dns)).start();
            }
        }catch(Exception e){
            erroFatal(e);
        }
    }
    public void audio(String [] args){
        if ( !isWindows() )
            erroFatal("comando somente para windows!");
        Object [] objs=get_parms_vol_mute_setvol_setmute_program_mutingWhileProgramInPrincipalMonitor(args);
        if ( objs == null )
            erroFatal("Erro de parametros!");
        Boolean vol=(Boolean)objs[0];
        Boolean mute=(Boolean)objs[1];
        String setvol=(String)objs[2];
        String setmute=(String)objs[3];
        String program=(String)objs[4];
        String mutingWhileProgramInPrincipalMonitor=(String)objs[5];
        String template="Add-Type -TypeDefinition @'\n" +
            "using System.Runtime.InteropServices;\n" +
            "[Guid(\"5CDF2C82-841E-4546-9722-0CF74078229A\"), InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]\n" +
            "interface IAudioEndpointVolume {\n" +
            "  // f(), g(), ... are unused COM method slots. Define these if you care\n" +
            "  int f(); int g(); int h(); int i();\n" +
            "  int SetMasterVolumeLevelScalar(float fLevel, System.Guid pguidEventContext);\n" +
            "  int j();\n" +
            "  int GetMasterVolumeLevelScalar(out float pfLevel);\n" +
            "  int k(); int l(); int m(); int n();\n" +
            "  int SetMute([MarshalAs(UnmanagedType.Bool)] bool bMute, System.Guid pguidEventContext);\n" +
            "  int GetMute(out bool pbMute);\n" +
            "}\n" +
            "[Guid(\"D666063F-1587-4E43-81F1-B948E807363F\"), InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]\n" +
            "interface IMMDevice {\n" +
            "  int Activate(ref System.Guid id, int clsCtx, int activationParams, out IAudioEndpointVolume aev);\n" +
            "}\n" +
            "[Guid(\"A95664D2-9614-4F35-A746-DE8DB63617E6\"), InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]\n" +
            "interface IMMDeviceEnumerator {\n" +
            "  int f(); // Unused\n" +
            "  int GetDefaultAudioEndpoint(int dataFlow, int role, out IMMDevice endpoint);\n" +
            "}\n" +
            "[ComImport, Guid(\"BCDE0395-E52F-467C-8E3D-C4579291692E\")] class MMDeviceEnumeratorComObject { }\n" +
            "public class Audio {\n" +
            "  static IAudioEndpointVolume Vol() {\n" +
            "    var enumerator = new MMDeviceEnumeratorComObject() as IMMDeviceEnumerator;\n" +
            "    IMMDevice dev = null;\n" +
            "    Marshal.ThrowExceptionForHR(enumerator.GetDefaultAudioEndpoint(/*eRender*/ 0, /*eMultimedia*/ 1, out dev));\n" +
            "    IAudioEndpointVolume epv = null;\n" +
            "    var epvid = typeof(IAudioEndpointVolume).GUID;\n" +
            "    Marshal.ThrowExceptionForHR(dev.Activate(ref epvid, /*CLSCTX_ALL*/ 23, 0, out epv));\n" +
            "    return epv;\n" +
            "  }\n" +
            "  public static float Volume {\n" +
            "    get {float v = -1; Marshal.ThrowExceptionForHR(Vol().GetMasterVolumeLevelScalar(out v)); return v;}\n" +
            "    set {Marshal.ThrowExceptionForHR(Vol().SetMasterVolumeLevelScalar(value, System.Guid.Empty));}\n" +
            "  }\n" +
            "  public static bool Mute {\n" +
            "    get { bool mute; Marshal.ThrowExceptionForHR(Vol().GetMute(out mute)); return mute; }\n" +
            "    set { Marshal.ThrowExceptionForHR(Vol().SetMute(value, System.Guid.Empty)); }\n" +
            "  }\n" +
            "}\n" +
            "'@\n" +
            "\n"; // se remover essa quebra de linha extra da pau!!
        String text="?";
        if ( program != null ){
            if ( vol )
                erroFatal("mostrar volume não implementado!");
            if ( mute )
                erroFatal("mostrar mute não implementado!");
            if ( setvol != null || setmute != null ){
                if ( setvol != null )
                    text="nircmd setappvolume \"" + program + "\" " + setvol;
                if ( setmute != null ){
                    if ( !setmute.equals("true") && !setmute.equals("false") )
                        erroFatal("comando invalido!");
                    if ( setmute.equals("true") )
                        text="nircmd muteappvolume \"" + program + "\" 1";
                    else
                        text="nircmd muteappvolume \"" + program + "\" 0";
                }
            }
            String s=runtimeExec(text, null, null, text.getBytes(), null);
            if ( s == null || s.equals("") ){
                if ( runtimeExecError != null && !runtimeExecError.equals("") ){
                    if ( runtimeExecError.contains("nircmd") )
                        erroFatal("Erro, não foi encontrado o programa nircmd(e coloque na pasta programfiles), baixe ele aqui: https://github.com/ywanes/utility_y/tree/master/y/utils_exe");
                    erroFatal("Erro, comando invalido...\n\n"+runtimeExecError);
                }
            }
        }else{
            if ( mutingWhileProgramInPrincipalMonitor != null ){
                try{
                    Boolean in_out=null;
                    Boolean in_out_tail=null;
                    while(true){
                        Integer[] xyrgb=robotMouseGetXYAndRGB();
                        // altera volume geral do windows:
                        // nircmd.exe setsysvolume 10000
                        in_out = xyrgb[0] >= 0 && xyrgb[0] <= 1920 && xyrgb[1] >= 0 && xyrgb[1] <= 1080;
                        if ( in_out_tail == null || in_out != in_out_tail ){
                            String lbl="";
                            text="";
                            if ( !in_out ){//muta
                                lbl="mutou na coordenada x:"+xyrgb[0]+" y:"+xyrgb[1];
                                text="nircmd muteappvolume \"" + mutingWhileProgramInPrincipalMonitor + "\" 1";
                            }else{
                                lbl="desmutou na coordenada x:"+xyrgb[0]+" y:"+xyrgb[1];
                                text="nircmd muteappvolume \"" + mutingWhileProgramInPrincipalMonitor + "\" 0";
                            }
                            runtimeExec(text, null, null, text.getBytes(), null);
                            if ( runtimeExecError != null && !runtimeExecError.equals("") ){
                                if ( runtimeExecError.contains("nircmd") )
                                    erroFatal("Erro, não foi encontrado o programa nircmd(e coloque na pasta programfiles), baixe ele aqui: https://github.com/ywanes/utility_y/tree/master/y/utils_exe");
                                erroFatal("Erro, comando invalido...\n\n"+runtimeExecError);
                            }else{
                                System.out.println(lbl);
                            }
                        }                        
                        robotMouseSleep(0.1F);                
                        in_out_tail=in_out;
                    }
                }catch(Exception e){
                    erroFatal(e);
                }
            }else{
                if ( vol )
                    text=template+"[Audio]::Volume";
                if ( mute )
                    text=template+"[Audio]::Mute";
                if ( setvol != null || setmute != null ){
                    if ( !isWindowsAdm() )
                        erroFatal("Erro, vc precisa ser adm para comandos do tipo set!");
                    if ( setvol != null )
                        text=template+"[Audio]::Volume = " + setvol.replace(",", ".");
                    if ( setmute != null ){
                        if ( !setmute.equals("true") && !setmute.equals("false") )
                            erroFatal("comando invalido!");
                        setmute="$"+setmute;
                        text=template+"[Audio]::Mute = " + setmute;
                    }
                }                    
                String s=runtimeExec(null, new String[]{"powershell", "-noprofile", "-c", "-"}, null, text.getBytes(), null);
                if ( s == null || s.equals("") ){
                    if ( runtimeExecError != null && !runtimeExecError.equals("") )
                        erroFatal("Erro, comando invalido...\n\n"+runtimeExecError);
                }
                if ( !s.trim().equals("") ){
                    s=s.replace(",", ".").replace("True", "true").replace("False", "false").trim();
                    if ( s.startsWith("0.") )
                        s=format_float(Float.parseFloat(s), 5);
                    System.out.println(s);
                }            
            }
        }
    }
    public void devices(String [] args){
        args=sliceParm(1, args);
        System.out.println(get_devices(args));
    }
    public String get_devices(String [] filtros){
        // exemplo filtros
        // new String []{"-classe", "AudioEndpoint", "-classe", "Net"}
        String s=runtimeExec("pnputil /enum-devices", null, null, null, true);
        if ( runtimeExecError != null && !runtimeExecError.equals("") )
            return runtimeExecError;        
        String [] partes=s.split("\n");
        String parcial="";
        String retorno="";
        boolean achou=false;
        if ( filtros.length%2 == 1 )
            erroFatal("erro interno, preenchimento de filtro incorreto!");
        for ( int i=0;i<partes.length;i++ ){
            if ( partes[i].equals("Utilitário PnP da Microsoft") )
                continue;            
            if ( partes[i].equals("") ){
                if ( achou || filtros.length == 0 )
                    retorno+=parcial;
                achou=false;
                parcial="\n";
                continue;
            }
            int p=partes[i].indexOf(":");
            if ( p == -1 )
                erroFatal("não foi possível interpretar a linha: " + partes[i]);
            String s1=partes[i].substring(0, p);
            String s2=partes[i].substring(p+1).trim();
            if ( s1.equals("ID da Instância") ){
                parcial+="id         : " + s2+"\n";
                for ( int j=0;j<filtros.length;j+=2 ){
                    if ( filtros[j].equals("-id") && filtros[j+1].equals(s2) ){
                        achou=true;
                        break;
                    }
                }
                continue;
            }
            if ( s1.equals("Descrição do Dispositivo") ){
                parcial+="nome       : " + s2+"\n";
                for ( int j=0;j<filtros.length;j+=2 ){
                    if ( filtros[j].equals("-nome") && filtros[j+1].equals(s2) ){
                        achou=true;
                        break;
                    }
                }
                continue;
            }
            if ( s1.equals("Nome da Classe") ){
                parcial+="classe     : " + s2+"\n";
                for ( int j=0;j<filtros.length;j+=2 ){
                    if ( filtros[j].equals("-classe") && filtros[j+1].equals(s2) ){
                        achou=true;
                        break;
                    }
                }
                continue;
            }
            if ( s1.equals("GUID de Classe") ){
                parcial+="guid       : " + s2+"\n";
                for ( int j=0;j<filtros.length;j+=2 ){
                    if ( filtros[j].equals("-guid") && filtros[j+1].equals(s2) ){
                        achou=true;
                        break;
                    }
                }
                continue;
            }
            if ( s1.equals("Nome do Fabricante") ){
                parcial+="fabricante : " + s2+"\n";
                for ( int j=0;j<filtros.length;j+=2 ){
                    if ( filtros[j].equals("-fabricante") && filtros[j+1].equals(s2) ){
                        achou=true;
                        break;
                    }
                }
                continue;
            }
            if ( s1.equals("Status") ){
                parcial+="status     : " + s2+"\n";
                for ( int j=0;j<filtros.length;j+=2 ){
                    if ( filtros[j].equals("-status") && filtros[j+1].equals(s2) ){
                        achou=true;
                        break;
                    }
                }
                continue;
            }
            if ( s1.equals("Nome do Driver") ){
                parcial+="drive      : " + s2+"\n";
                for ( int j=0;j<filtros.length;j+=2 ){
                    if ( filtros[j].equals("-drive") && filtros[j+1].equals(s2) ){
                        achou=true;
                        break;
                    }
                }
                continue;
            }
        }
        if ( !parcial.equals("") && (achou || filtros.length == 0) )
            retorno+=parcial;
        
        return retorno;
    }    
    public void cep(String [] args){        
        args=sliceParm(1, args);
        String parm=String.join(" ", args);
        String parm2=parm.replaceAll("\\.", "").replaceAll("-", "");
        String s="";
        if ( isNumeric(parm2) ){
            s=curl_string("https://viacep.com.br/ws/" + parm2 + "/json/");
            if ( curl_error != null || curl_response_status == 400 )
                System.out.println("Não foi possíver encontrar!");
            else
                System.out.println(s);
        }else{
            parm=parm.trim();
            if ( !parm.startsWith("/") || parm.endsWith("/") || parm.split("/").length != 4 )
                erroFatal("preenchimento incorreto!");
            s=curl_string("https://viacep.com.br/ws" + parm.replace(" ", "%20") + "/json/");
            if ( curl_error != null || curl_response_status == 400 )
                System.out.println("Não foi possíver encontrar!");
            else
                System.out.println(s);
        }
    }        
    public String getUsers(){
        return runtimeExec(null, new String[]{"query", "user"}, null, null, null);
    }
    public String getUserAtivo(String a){        
        String [] partes=a.split("\n");
        for ( int i=0;i<partes.length;i++ ){
            partes[i]=partes[i].trim();
            int limit=1000;
            while(partes[i].contains("  ") && limit-->0 )
                partes[i]=partes[i].replace("  "," ");
            String [] partes2=partes[i].split(" ");
            if ( partes2[3].equals("Ativo") )
                return partes2[2];
        }
        return null;
    }
    public void meuip(){
        System.out.print(
            //alternativa https://api.ipify.org ipv4
            //            https://api64.ipify.org ipv6
            //            ipinfo.io
            //            ipinfo.io/ip
            //            ifconfig.me
            curl_string("https://checkip.amazonaws.com/").trim()
        );
    }
    public void disconnect(boolean seAtivoDesconectaLoop1Segundo){
        if ( seAtivoDesconectaLoop1Segundo ){
            while(true){
                String id=getUserAtivo(getUsers());
                if ( id != null )
                    runtimeExec(null, new String[]{"tsdiscon", id}, null, null, null);
                sleepSeconds(2);                
            }
        }else{
            String id=getUserAtivo(getUsers());
            if ( id != null )
                runtimeExec(null, new String[]{"tsdiscon", id}, null, null, null);
            System.out.println("disconnected!!");
        }
    }
    public String dns(String domain, String dnsServer){
        // System.out.print(dns("example.com", "8.8.8.8"));
        if ( dnsServer == null )
            dnsServer="8.8.8.8";
        String [] servidorName=new String[]{null};
        String s=dns(domain, dnsServer, 53, 0x0001, 4, true, servidorName) +
               dns(domain, "8.8.8.8", 53, 0x001C, 16, true, servidorName);
        if ( s.length() > 0 )
            s="ServidorDnsUtilizado: "+servidorName[0]+"\n\n"+s;
        return s;
    }
    public String dns(String domain, String dnsServer, int dnsPort, int type_, int len_type, boolean modoResumido, String [] servidorName){
        // ipv4 -> type_ 0x0001 len_type 4
        // ipv6 -> type_ 0x001C len_type 16
        try {
            int BUFFER_SIZE = 1024;        
            java.net.DatagramSocket socket = new java.net.DatagramSocket();
            socket.setSoTimeout(5000);
            byte[] query = dns_buildDNSQuery(domain, type_);
            java.net.InetAddress serverAddress = java.net.InetAddress.getByName(dnsServer);
            if ( servidorName[0] == null || isMaskIp(servidorName[0]) )
                servidorName[0]=serverAddress.getHostName();
            java.net.DatagramPacket packet = new java.net.DatagramPacket(query, query.length, serverAddress, dnsPort);
            socket.send(packet);
            byte[] responseBuffer = new byte[BUFFER_SIZE];
            java.net.DatagramPacket responsePacket = new java.net.DatagramPacket(responseBuffer, responseBuffer.length);
            socket.receive(responsePacket);
            String s=dns_processDNSResponse(responsePacket.getData(), responsePacket.getLength(), type_, len_type, modoResumido);
            socket.close();
            return s;
        } catch (java.net.SocketTimeoutException e) {
            System.err.println("Timeout: Nenhuma resposta recebida do servidor DNS.");
            System.exit(1);
        } catch (Exception e) {
            System.err.println("Erro de comunicação: " + e.getMessage());
            System.exit(1);
        }        
        return "";
    }
    public boolean isMaskIp(String a){
        String filter=".:0123456789";
        int len=a.length();
        for ( int i=0;i<len;i++ ){
            if ( !filter.contains(a.substring(i, i+1)) )
                return false;                
        }
        return true;
                
    }
    public byte[] dns_buildDNSQuery(String domain, int type_) {
        java.nio.ByteBuffer buffer = java.nio.ByteBuffer.allocate(1024);
        buffer.putShort((short) 0x1234); // ID (aleatório)
        buffer.putShort((short) 0x0100); // Flags (query padrão)
        buffer.putShort((short) 1);      // QDCOUNT (1 pergunta)
        buffer.putShort((short) 0);      // ANCOUNT (0 respostas)
        buffer.putShort((short) 0);      // NSCOUNT (0 autoritativas)
        buffer.putShort((short) 0);      // ARCOUNT (0 adicionais)
        for (String part : domain.split("\\.")) {
            buffer.put((byte) part.length()); // Tamanho do rótulo
            buffer.put(part.getBytes());      // Rótulo
        }
        buffer.put((byte) 0); // Fim do domínio
        buffer.putShort((short) type_);
        buffer.putShort((short) 0x0001); // Classe IN (0x0001)
        byte[] query = new byte[buffer.position()];
        buffer.flip();
        buffer.get(query);
        return query;
    }
    public String dns_processDNSResponse(byte[] response, int length, int type_, int len_type, boolean modoResumido) throws Exception {
        String s="";
        java.nio.ByteBuffer buffer = java.nio.ByteBuffer.wrap(response, 0, length);
        int id = buffer.getShort() & 0xFFFF;
        int flags = buffer.getShort() & 0xFFFF;
        int qdCount = buffer.getShort() & 0xFFFF;
        int anCount = buffer.getShort() & 0xFFFF;
        int nsCount = buffer.getShort() & 0xFFFF;
        int arCount = buffer.getShort() & 0xFFFF;
        dns_skipQuestionSection(buffer);
        for (int i = 0; i < anCount + nsCount + arCount; i++) {
            String name = dns_readName(buffer, response);
            int type = buffer.getShort() & 0xFFFF;
            int dnsClass = buffer.getShort() & 0xFFFF;
            long ttl = buffer.getInt() & 0xFFFFFFFFL;
            int rdLength = buffer.getShort() & 0xFFFF;
            if (type == type_){
                byte[] ipBytes = new byte[len_type];
                buffer.get(ipBytes);
                java.net.InetAddress ipAddress = java.net.InetAddress.getByAddress(ipBytes);
                if ( modoResumido )
                    s+=format_zeros_ipv6(ipAddress.getHostAddress())+"\n";
                else
                    s+=ipAddress.getHostAddress()+"\n";
            }else{    
                /*
                if (type == 0x0006) { // Tipo SOA
                    System.out.println("Resposta SOA encontrada:");
                    System.out.println("Nome: " + name);
                    System.out.println("Tipo: SOA (0x0006)");
                    System.out.println("Classe: " + dnsClass);
                    System.out.println("TTL: " + ttl);
                    System.out.println("Comprimento dos dados: " + rdLength);

                    // Lê os dados SOA
                    String mname = dns_readName(buffer, response);
                    String rname = dns_readName(buffer, response);
                    long serial = buffer.getInt() & 0xFFFFFFFFL;
                    long refresh = buffer.getInt() & 0xFFFFFFFFL;
                    long retry = buffer.getInt() & 0xFFFFFFFFL;
                    long expire = buffer.getInt() & 0xFFFFFFFFL;
                    long minimum = buffer.getInt() & 0xFFFFFFFFL;

                    System.out.println("MNAME: " + mname);
                    System.out.println("RNAME: " + rname);
                    System.out.println("Serial: " + serial);
                    System.out.println("Refresh: " + refresh);
                    System.out.println("Retry: " + retry);
                    System.out.println("Expire: " + expire);
                    System.out.println("Minimum: " + minimum);
                }
                else
                {
                */
                    buffer.position(buffer.position() + rdLength);
                //}
            }
        }
        return s;
    }
    public String format_zeros_ipv6(String a){
        if ( !a.contains(":") )
            return a;
        int limit=200;
        while(limit--> 0){
            int len=a.length();
            if ( a.contains("::") )
                a=a.replaceFirst("::0:","::");
            else
                a=a.replaceFirst(":0:","::");
            if ( a.length() >= len )
                break;                
        }
        return a;
    }
    public void dns_skipQuestionSection(java.nio.ByteBuffer buffer) {
        while (true) {
            int length = buffer.get() & 0xFF;
            if (length == 0) break;
            buffer.position(buffer.position() + length);
        }
        buffer.getShort(); // Tipo
        buffer.getShort(); // Classe
    }
    private String dns_readName(java.nio.ByteBuffer buffer, byte[] response) {
        StringBuilder name = new StringBuilder();
        int length;
        while ((length = buffer.get() & 0xFF) != 0) {
            if ((length & 0xC0) == 0xC0) { // Ponteiro
                int offset = ((length & 0x3F) << 8) | (buffer.get() & 0xFF);
                return name + dns_readNameFromOffset(response, offset);
            } else { // Rótulo normal
                if (name.length() > 0) name.append('.');
                byte[] label = new byte[length];
                buffer.get(label);
                name.append(new String(label));
            }
        }
        return name.toString();
    }
    private String dns_readNameFromOffset(byte[] response, int offset) {
        StringBuilder name = new StringBuilder();
        int length;
        while ((length = response[offset++] & 0xFF) != 0) {
            if ((length & 0xC0) == 0xC0) { // Ponteiro
                int newOffset = ((length & 0x3F) << 8) | (response[offset] & 0xFF);
                return name + dns_readNameFromOffset(response, newOffset);
            } else { // Rótulo normal
                if (name.length() > 0) name.append('.');
                byte[] label = new byte[length];
                System.arraycopy(response, offset, label, 0, length);
                name.append(new String(label));
                offset += length;
            }
        }
        return name.toString();
    }        
    public String overflix_busca(String [] args){
        String s="";
        if ( args.length == 0 )
            erroFatal("Erro de parametro no overflix_busca!");
        String url="https://encontre.us/pesquisar/?p=" + String.join("+", args);
        String html=curl_string(url);        
        String [] partes=regex_matcher("<div class=\'videoboxGridview\'>", "</main>", html, true); 
        if ( partes.length != 1 )
            return "";
        partes[0]=partes[0].replace("\n","");
        partes=partes[0].split("<div id=\"collview\">");
        for ( int i=0;i<partes.length;i++ ){
            if ( !partes[i].contains("<a href=") )
                continue;
            String [] a=regex_matcher("<a href='", "</a>", partes[i], true); 
            String [] b=regex_matcher("<span class=\"capa-info capa-audio\">", "</span>", partes[i], true); 
            String [] c=regex_matcher("<span class=\"capa-info capa-quali\">", "</span>", partes[i], true); 
            String [] d=regex_matcher("<span class=\"y\">", "</span>", partes[i], true); 
            String [] e=regex_matcher("<span class=\"t\">", "</span>", partes[i], true); 
            if ( a.length >= 2 && b.length >= 1 && c.length >= 1 && d.length >= 1 && e.length >= 1 ){
                String [] f=a[1].split(("'") );
                if ( f.length == 4){
                    s+="y overflix " + 
                            lpad(f[0], 92, " ") + " - " +
                            f[3].substring(1).trim() + " - " +
                            b[0] + " - " +
                            c[0] + " - " +
                            d[0] + " - " +
                            e[0] +
                            "\n";
                }else
                    erroFatal("Não foi possivel decodigicar::\n" + partes[i]);
            }else
                erroFatal("Não foi possivel decodigicar:\n" + partes[i]);
        }
        return s;
    }
    
    public String superflixapi_busca(String [] args){
        String s="";
        if ( args.length == 0 )
            erroFatal("Erro de parametro!");
        String search=String.join("%20", args);
        String separator="<div class=\"item fbox fbox_space_between fbox_align_center\">";
        String nenhum="Nenhum filme encontrado";
        for ( int i=1;i<20;i++ ){
            String html=curl_string("https://superflixapi.dev/filmes/?search="+search+"&sort=&paged="+i);
            //System.out.println("i: " + i);
            if ( html.contains(nenhum) ){
                break;
            }
            String [] partes=regex_matcher("<div id=\"contentList\">", "<div class=\"clearfix\"></div>", html, true); 
            if ( partes.length < 1 )
                break;
            partes=partes[0].split("<div class=\"poster\">");                        
            for ( int j=0;j<partes.length;j++ ){
                String [] partes_A=regex_matcher("<span class=\"title\">", "</span>", partes[j], true); 
                String [] partes_B=regex_matcher("<span class=\"year\">", "</span>", partes[j], true); 
                String [] partes_C=regex_matcher("href=\"", "\"", partes[j], true); 
                if ( partes_A.length > 0 && partes_B.length > 0 && partes_C.length > 0 ){
                    if ( partes_C[0].endsWith("/filme/") )
                        continue;
                    s+="y overflix " + lpad(partes_C[0],92," ") + " - " + partes_A[0] + " - " + partes_B[0]+"\n";
                }
            }
        }
        return s;
    }
        
    public void superflixapi_buscaOld(String [] args_){
        String [] args=new String[args_.length];
        System.arraycopy(args_, 0, args, 0, args_.length);
        args=sliceParm(2, args);
        if ( args.length == 0 )
            erroFatal("Erro de parametro!");
        String search=String.join("+", args);
        String separator="<div class=\"item fbox fbox_space_between fbox_align_center\">";
        String nenhum="Nenhum filme foi encontrado";
        String s="";
        for ( int i=1;i<20;i++ ){
            String html=curl_string("https://superflixapi.dev/filmes/?search="+search+"&sort=&paged="+i);
            if ( html.contains(nenhum) || !html.contains(separator) )
                break;
            String [] partes=html.split(separator);
            partes=sliceParm(1, partes);
            for ( int j=0;j<partes.length;j++ ){
                String [] partes_=regex_matcher("<a href=\"", "</a>", partes[j], true); 
                if ( partes_.length == 0 )
                    erroFatal("Erro interno 1!" + partes[j]);
                String [] partes_B=partes_[0].split("\""); 
                if ( partes_B.length == 0 )
                    erroFatal("Erro interno 2!"+partes[j]);
                String [] partes_C=partes_[0].split("</span>"); 
                if ( partes_B.length < 2 )
                    erroFatal("Erro interno 3!"+partes[j]);                
                s+="y overflix "+partes_B[0]+" - "+partes_C[1]+"\n";
            }
        }
        if ( !s.equals("") )
            System.out.print(s);
    }
    
    public void superflixapi(String url){        
        // get video id
        String videoid="";
        String h="";
        String disk="";
        String audio="";
        String _32A="";
        String _32B="";
        String html="";
        String [] partes=null;
        String id="";
        String titulo="";
        String resolucao="";
        String tryresolucao="";
        String dir="D:\\ProgramFiles\\site\\filmes\\";
        String filme="";
        // check ffmpeg
        if ( !isFfmpeg() )
            erroFatal("Não foi possível encontrar o componente ffempeg.exe");
        
        // get config
        html=curl_string(url);        
        if ( curl_response_status == 200 ){
            partes=regex_matcher("<title>", "</title>", html, true);
            if ( partes.length > 0 ){
                titulo=partes[0];
                if ( titulo.startsWith("SuperFlix API - ") )
                    titulo=titulo.substring("SuperFlix API - ".length()).trim();
                if ( titulo.lastIndexOf("(") > 0 )
                    titulo=titulo.substring(0, titulo.lastIndexOf("(")).trim();
                titulo=fixNameFile(titulo.trim());
                filme=dir+titulo+".mp4";
                if ( new File(filme).exists() ){
                    System.out.println("skip "+filme);
                    return;
                }
                partes=regex_matcher("data-id=", ">", html, true);
                if ( partes.length > 0 ){
                    videoid=partes[0].substring(1, partes[0].length()-1);
                    html=curl_string("https://superflixapi.dev/api?action=getPlayer&video_id="+videoid);            
                    if ( curl_response_status == 200 ){
                        partes=regex_matcher("\"video_url\":\"", "\"", html, true);
                        if ( partes.length > 0 ){
                            h=partes[0].replace("\\/", "/");
                            if ( !h.startsWith("https://brbeast.com/video/") )
                                erroFatal("host não implementado ou quebrado: "+h);
                            if ( h.startsWith("https://brbeast.com/video/") ){
                                html=curl_string(h);        
                                if ( curl_response_status == 200 ){
                                    int p1=html.indexOf("|||");
                                    if ( p1 > 0 ){
                                        int p2=html.indexOf("'", p1);
                                        if ( p2 > 0 ){
                                            partes=html.substring(p1, p2).split("\\|");
                                            for ( int i=0;i<partes.length;i++ ){
                                                if ( disk.equals("") && partes[i].startsWith("disk") ){
                                                    disk=partes[i];
                                                    continue;
                                                }
                                                if ( _32A.equals("") && partes[i].length() == 32 ){
                                                    _32A=partes[i];
                                                    continue;
                                                }
                                                if ( _32B.equals("") && partes[i].length() == 32 ){
                                                    _32B=partes[i];
                                                    continue;
                                                }
                                            }
                                            String [] _32_versions=new String[]{_32A, _32B};
                                            String [] audios=new String[]{"por", "und", "eng"};
                                            for ( int i=0;i<_32_versions.length;i++ ){
                                                for ( int j=0;j<audios.length;j++ ){
                                                    if ( !id.equals("") )
                                                        continue;
                                                    curl_string("https://gambino10.com/cdn/down/"+disk+"/"+_32_versions[i]+"/Audio/audio_" + audios[j] + "_0.html");        
                                                    if ( curl_response_status == 200 ){
                                                        id=disk+"/"+_32_versions[i];
                                                        audio=audios[j];
                                                    }
                                                }
                                            }
                                            if ( audio.equals("eng") )
                                                erroFatal("Abortado. Filme somente em inglês.");
                                            if ( audio.equals("") )
                                                erroFatal("Erro, audio diferente do implementado... será necessário investigar.");
                                            String [] videos=new String[]{"720p", "480p", "360p", "1080p"};
                                            for ( int i=0;i<videos.length;i++ ){
                                                if ( !resolucao.equals("") )
                                                    continue;
                                                curl_string("https://gambino10.com/cdn/down/"+id+"/Video/"+videos[i]+"/"+videos[i]+"_000.html");        
                                                if ( curl_response_status == 200 )
                                                    resolucao=videos[i];

                                            }
                                            superflixapi_not_if(9, resolucao);
                                        }
                                        superflixapi_not_if(8, resolucao);
                                    }
                                    superflixapi_not_if(7, resolucao);
                                }
                                superflixapi_not_if(6, resolucao);
                            }
                            superflixapi_not_if(5, resolucao);
                        }                        
                        superflixapi_not_if(4, resolucao);
                    }
                    superflixapi_not_if(3, resolucao);
                }
                superflixapi_not_if(2, resolucao);
            }
            superflixapi_not_if(1, resolucao);
        }
        if ( !resolucao.equals("") ){
            preparaPath(filme, true, 0);
            superflixapi(id, resolucao, audio, titulo, filme); 
        }
    }
    
    public void superflixapi(String id, String resolucao, String audio, String titulo, String filme){        
        try{
            String wav_name=System.getenv("tmp")+"\\"+titulo+".wav";
            String mp4_name=System.getenv("tmp")+"\\"+titulo+".mp3";            
            
            FileOutputStream fos_audio=new FileOutputStream(wav_name);
            FileOutputStream fos_video=new FileOutputStream(mp4_name);

            int slots=12;
            int count_audio=0;
            int count_audio_request=0;
            int count_video=0;
            int count_video_request=0;
            Boolean [] running=new Boolean[]{true};
            Boolean [] finish_audio=new Boolean[]{false};
            Boolean [] finish_video=new Boolean[]{false};
            Boolean [] types_audio=new Boolean[slots];
            byte [][] matrix=new byte[slots][1024*1024*10];
            Integer [] lens=new Integer[slots];
            Integer [] seqs=new Integer[slots];
            String [] commands=new String[slots];
            Integer [] steps=new Integer[slots]; // 0-nada 1-prontoParaTrabalhar 2-pacotePronto
            Thread [] workers=new Thread[slots];
            
            //init
            for ( int i=0;i<slots;i++ ){
                lens[i]=0;
                commands[i]="";
                steps[i]=0;
                types_audio[i]=false;
                seqs[i]=0;
            }
            
            //worker
            for ( int i=0;i<slots;i++ ){
                final int i_=i;
                workers[i]=new Thread(){
                    final int n=i_;                    
                    final Y y_=new Y();
                    public void run() {
                        while(running[0]){
                            if ( steps[n] == 1 ){
                                byte [] tmp=y_.curl_bytes(commands[n]);
                                if ( y_.curl_response_status == 200 ){
                                    lens[n]=tmp.length;
                                    System.arraycopy(tmp, 0, matrix[n], 0, tmp.length);
                                    if ( lens[n] == 0 ){
                                        //System.err.println("warning.. len 0");        
                                        continue;
                                    }
                                    steps[n]=2;
                                    continue;
                                }
                                if ( y_.curl_response_status == 404 ){
                                    if ( types_audio[n] )
                                        finish_audio[0]=true;
                                    else
                                        finish_video[0]=true;
                                    lens[n]=0;
                                    steps[n]=0;
                                    continue;
                                }
                                erroFatal("Ocorreu um erro na leitura da url: " + commands[n] + " - status:"+y_.curl_response_status);        
                            }
                            sleepMillis(100);
                        }
                    }
                };
                workers[i].start();
            }
            
            long count_bytes_audio=0;
            long count_bytes_video=0;
            // manager
            while(true){
                // coletando ordens
                for ( int i=0;i<slots;i++ ){
                    if ( steps[i] == 2 ){
                        if ( types_audio[i] && seqs[i] == count_audio_request ){
                            fos_audio.write(matrix[i], 0, lens[i]);
                            count_bytes_audio+=lens[i];
                            System.out.print("\rdownloading.. audio.. "+bytes_to_text(count_bytes_audio)+"                ");
                            steps[i]=0;
                            count_audio_request++;
                            continue;
                        }
                        if ( !types_audio[i] && seqs[i] == count_video_request ){
                            fos_video.write(matrix[i], 0, lens[i]);
                            count_bytes_video+=lens[i];
                            System.out.print("\rdownloading.. video.. "+bytes_to_text(count_bytes_video)+"                ");
                            steps[i]=0;
                            count_video_request++;
                            continue;
                        }
                    }
                }                
                // inserindo ordens
                for ( int i=0;i<slots;i++ ){
                    // inserindo audio
                    if ( steps[i] == 0 && !finish_audio[0] ){
                        commands[i]="https://gambino" + get_gambino_audio_n() + ".com/cdn/down/" + id + "/Audio/audio_" + audio + "_" + count_audio + ".html";
                        seqs[i]=count_audio;
                        count_audio++;
                        types_audio[i]=true;
                        steps[i]=1;
                        continue;
                    }
                    // inserindo video                    
                    if ( steps[i] == 0 && !finish_video[0] ){
                        commands[i]="https://gambino" + get_gambino_video_n() + ".com/cdn/down/" + id + "/Video/" + resolucao + "/" + resolucao + "_" + lpad(count_video + "", 3, "0") + ".html";
                        seqs[i]=count_video;
                        count_video++;
                        types_audio[i]=false;
                        steps[i]=1;
                        continue;
                    }
                }
                // check saida
                if ( finish_audio[0] && finish_video[0] ){
                    boolean finish_all=true;                    
                    for ( int i=0;i<slots;i++ ){
                        if ( steps[i] != 0 ){
                            finish_all=false;
                            break;
                        }
                    }
                    if ( finish_all )
                        break;
                }
                // sleep
                sleepMillis(100);
            }
            
            running[0]=false;
            for ( int i=0;i<slots;i++ )
                workers[i].join();

            fos_audio.flush();
            fos_video.flush();
            fos_audio.close();
            fos_video.close();

            runtimeExec("ffmpeg -i \""+mp4_name+"\" -i \""+wav_name+"\" -c:v copy -c:a aac \"" + filme + "\"", null, null, null, null);
            new File(mp4_name).delete();
            new File(wav_name).delete();
            System.out.print("\r                                                                              ");
            if ( runtimeExecError.contains("\n[aac ") ){
                System.out.println("\nFim");
            }else{
                System.out.println("Erro: "+ runtimeExecError);
            }
        }catch(Exception e){
            erroFatal(e);
        }
    }
    
    public static int gambino_audio_n=13;
    public int get_gambino_audio_n(){
        gambino_audio_n++;
        if ( gambino_audio_n > 13 )
            gambino_audio_n=1;
        return gambino_audio_n;
    }
    
    public static int gambino_video_n=13;
    public int get_gambino_video_n(){
        gambino_video_n++;
        if ( gambino_video_n > 13 )
            gambino_video_n=1;
        return gambino_video_n;
    }
    
    public void superflixapi_not_if(int n, String resolucao){
        if (resolucao.equals(""))
            System.out.println("unknow "+n);
    }
    
    multiCurl overflix_multi=null;
    public void overflix(String [] args) throws Exception{             
        Object [] objs = get_parms_url_verbose_onlyLink_onlyPreLink_vToken_o_tags_outPath_getScriptRenameBySkipIn(args);
        
        if ( objs == null )
            erroFatal("parametros invalidos!");
        String url=(String)objs[0];
        Boolean verbose=(Boolean)objs[1];
        Boolean onlyLink=(Boolean)objs[2];
        Boolean onlyPreLink=(Boolean)objs[3];
        Boolean vToken=(Boolean)objs[4];
        String o_force_out=(String)objs[5];
        Boolean tags=(Boolean)objs[6];
        String outPath=(String)objs[7];
        getScriptRenameBySkip_in=(String)objs[8];
        
        if ( url.startsWith("https://superflixapi.dev/filme/") ){
            superflixapi(url);
            return;
        }
        overflix_nav(url, verbose, onlyLink, onlyPreLink, vToken, null, null, null, o_force_out, tags, outPath, null, null);
        
        if ( overflix_multi != null ){
            overflix_multi.wait_numeroDeTrabalhoIgualOuMenor(0);            
            sleepSeconds(2);
        }
        if ( !overflix_error.equals("")  )
            System.out.println(overflix_error);
        if ( skiping_hide_count > 0  )
            System.out.println("skips ocultados:"+skiping_hide_count);
        if ( getScriptRenameBySkip_in != null ){
            String [] partes=getScriptRenameBySkip_out.split("\n");
            String [] partes_grupo_serie=getScriptRenameBySkip_in.split(",");
            int [] partes_grupo_serie_int=new int[partes_grupo_serie.length];
            for ( int i=0;i<partes_grupo_serie.length;i++ )
                partes_grupo_serie_int[i]=Integer.parseInt(partes_grupo_serie[i]);
            int n_episodios=0;
            for ( int i=0;i<partes_grupo_serie_int.length;i++ )
                n_episodios+=partes_grupo_serie_int[i];
            if ( partes.length != n_episodios ){
                System.err.println("Numero de episodios skip está diferente de numero de episodios informados por parametros. " + partes.length + "/" + n_episodios );
                System.exit(0);
            }
            String [] partes_novos=new String[partes.length];
            getScriptRenameBySkip_populaPartesNovos(partes, partes_novos, partes_grupo_serie_int);
            for ( int i=0;i<partes.length;i++ )
                System.out.println("y mv \""+partes[i]+"\" \""+partes_novos[i]+"\"");
        }
        System.exit(0);
    }
    
    public String overflix_error="";
    public boolean skiping_show=true;
    public int skiping_hide_count=0;
    public String getScriptRenameBySkip_in=null;
    public String getScriptRenameBySkip_out="";
    public boolean overflix_interative=false;
    //
    public void overflix_nav(String url, Boolean verbose, Boolean onlyLink, Boolean onlyPreLink, Boolean vToken, 
                             String titulo_serie, String titulo_filme, Boolean cam, String o_force_out, Boolean tags, String outPath,
                             Integer temporada_S, Integer temporada_E) throws Exception{
        // teste
        // y overflix "https://overflix.bar/assistir-meu-malvado-favorito-4-dublado-online-36169/"
        // y overflix "https://overflix.bar/assistir-rick-e-morty-dublado-online-3296/"
        // y overflix "https://overflix.bar/assistir-rick-e-morty-dublado-online-3296/?temporada=2"
        // y overflix "https://encontre.us/assistir-prometheus-dublado-online-1012/"
        
        overflix_verbose(verbose, tags, url);
            
        String html=overflix_custom_curl(url);
        /*
        if ( curl_response_status == 301 ){
            url=curl_response_location;
            html=overflix_custom_curl(url);
        }
        */        
        if ( curl_response_status != 200 ){
            overflix_error+="Erro:\nURL: " + url+"\nStatus: "+ curl_response_status+"\nText:\n" + html+"\n";
            return;            
        }
        
        String [] partes=null;

        // nivel 1 filme
        partes=regex_matcher("<div class=\"assistir\"><a href=\"", "\"><i", html, true);        
        if ( partes.length > 0 ){
            if ( html.split("cWidgetContainer")[0].contains("\">CAM</span>") )
                cam=true;
            for ( int i=0;i<partes.length;i++ ){ // sempre pega 1
                overflix_verbose(verbose, tags, "TAG:1");
                overflix_nav(partes[i], verbose, onlyLink, onlyPreLink, vToken, titulo_serie, titulo_filme, cam, o_force_out, tags, outPath, temporada_S, temporada_E);
            }
            return;
        }
        
        // https://overflix.bar/assistir-rick-e-morty-dublado-online-3296/?temporada=11
        // nivel 1 serie        
        partes=regex_matcher("</i><a href=\"", "\">", html, true);
        if ( partes.length > 0 ){
            // pegando titulo serie
            overflix_verbose(verbose, tags, "TAG:2");
            if ( titulo_serie == null ){
                String [] tmp=null;
                tmp=regex_matcher("<span class=\"titulo\">", "<", html, true);
                if ( tmp.length > 0 )
                    titulo_serie=fixNameFile(tmp[0].trim());
                if ( titulo_serie == null ){
                    tmp=regex_matcher("<small>", "</small>", html, true);
                    if ( tmp.length > 0 )
                        titulo_serie=fixNameFile(tmp[0]);
                }
                if ( titulo_serie.contains("\n") ){
                    overflix_error+="nao foi possivel pegar o titulo serie de " + url + ":\n" + html+"\n";
                    return;
                }
            }
            int temporada=1;
            if ( url.contains("?temporada=") )
                temporada=Integer.parseInt(url.split("=")[1]);            
            // chamando itens da temporada
            for ( int i=0;i<partes.length;i++ ){
                overflix_verbose(verbose, tags, "TAG:3");
                overflix_nav(partes[i], verbose, onlyLink, onlyPreLink, vToken, titulo_serie, titulo_filme, cam, o_force_out, tags, outPath, temporada, i+1);
            }
            // chamando proximas temporadas
            if ( !url.contains("?temporada=") ){
                // chama todas as temporadas
                url+="?temporada=1";
                int next_temporada=temporada+1;
                while ( html.contains("load("+next_temporada+")") ){
                    overflix_verbose(verbose, tags, "TAG:4");
                    url=url.split("=")[0]+"="+next_temporada;
                    overflix_nav(url, verbose, onlyLink, onlyPreLink, vToken, titulo_serie, titulo_filme, cam, o_force_out, tags, outPath, temporada_S, temporada_E);
                    next_temporada=Integer.parseInt(url.split("=")[1])+1;
                }
            }
            return;
        }
        
        // nivel 2 filme e serie
        partes=regex_matcher("<a href=\"", "\"", html.replace("'","\""), true); 
        if ( partes.length > 0 && !url.contains("/f/") ){            
            overflix_verbose(verbose, tags, "TAG:5->"+String.join(",", partes));
            
            if ( titulo_filme == null ){
                String [] tmp=null;
                tmp=regex_matcher("<span class=\"titulo\">", "<", html, true);
                if ( tmp.length > 0 )
                    titulo_filme=fixNameFile(tmp[0].trim());
                if ( titulo_filme == null ){
                    tmp=regex_matcher("<small>", "</small>", html, true);
                    if ( tmp.length > 0 )
                        titulo_serie=fixNameFile(tmp[0]);
                }
                if ( titulo_filme.contains("\n") ){
                    overflix_error+="nao foi possivel pegar o titulo filme de " + url + ":\n" + html+"\n";
                    return;
                }
            }
            
            String prefix=url.substring(0, url.indexOf("/", 9));
            for ( int i=0;i<partes.length;i++ ){
                if ( !partes[i].startsWith("/em") && !partes[i].startsWith("https://mixdrop.") && !partes[i].contains("/f/") ){
                    overflix_verbose(verbose, tags, "TAG:6 - " + partes[i]);
                    continue;                
                }
                overflix_verbose(verbose, tags, "TAG:6");
                if ( partes[i].startsWith("https://mixdrop.") ){
                    overflix_verbose(verbose, tags, "TAG:601");
                    partes[i]=partes[i].replaceAll("https://mixdrop.sb/", "https://mixdrop.ps/");
                    overflix_nav(partes[i], verbose, onlyLink, onlyPreLink, vToken, titulo_serie, titulo_filme, cam, o_force_out, tags, outPath, temporada_S, temporada_E);
                }else{
                    if ( partes[i].contains("/f/") ){
                        overflix_verbose(verbose, tags, "TAG:602");
                        overflix_nav(partes[i], verbose, onlyLink, onlyPreLink, vToken, titulo_serie, titulo_filme, cam, o_force_out, tags, outPath, temporada_S, temporada_E);
                    }else{
                        overflix_verbose(verbose, tags, "TAG:603");
                        overflix_nav(prefix+partes[i], verbose, onlyLink, onlyPreLink, vToken, titulo_serie, titulo_filme, cam, o_force_out, tags, outPath, temporada_S, temporada_E);
                    }
                }
                return;
            }
            if ( tags )
                overflix_error+="Não foi possível resolver a url:: " + url+"\nhtml:\n"+html+"\n";
            else
                overflix_error+="Não foi possível resolver a url::: " + url+"\n";
            return;
        }
        
        // nivel 3 filme e serie
        String mix=null;
        String suffix="?download";
        if ( 
            ( url.startsWith("https://mixdrop.") || url.contains("/f/") )
            && !url.endsWith("?download") 
        ){
            mix=url+suffix;
        }else{
            partes=regex_matcher("window.location.href=\"", "\"", html, true); 
            if ( partes.length > 0 ){
                overflix_verbose(verbose, tags, "TAG:7");                
                for ( int i=0;i<partes.length;i++ ){                
                    mix=partes[i]+suffix;                
                    break;
                }
                if ( mix == null ){
                    overflix_error+="Não foi possível resolver a url:::: " + url+"\n";            
                    return;
                }
            }
        }
        
        // use mix
        if ( mix != null ){
            overflix_verbose(verbose, tags, "TAG:8");
            overflix_nav(mix, verbose, onlyLink, onlyPreLink, vToken, titulo_serie, titulo_filme, cam, o_force_out, tags, outPath, temporada_S, temporada_E);
            return;
        }
        
        // nivel 4 filme e serie
        if ( url.contains("/f/") && url.endsWith("?download") ){
            // pegando titulo
            overflix_verbose(verbose, tags, "TAG:9");
            String titulo="?";
            partes=regex_matcher("<b title=\"", "\"", html, true); 
            if ( html.contains("<h2>WE ARE SORRY</h2>") ){
                overflix_error+="Arquivo não mais disponível no mixdrop, url: " + url+"\n";
                if ( getScriptRenameBySkip_in != null )
                    getScriptRenameBySkip_out+="?"+url+"?\n";                
                return;
            }
            if ( partes.length > 0 ){
                titulo=partes[0].trim().replace("-dublado-www.encontrei.tv", "").replace(".Dublado.", ".");
                if ( temporada_S != null && temporada_E != null )
                    titulo=titulo_serie + " S" + lpad(temporada_S, 2, "0") + "E" + lpad(temporada_E, 2, "0") + titulo.substring(titulo.lastIndexOf("."));                
                else{
                    if ( titulo_filme != null ){
                        int pos=titulo.lastIndexOf(".");
                        if ( pos > -1 )
                            titulo=titulo_filme+titulo.substring(pos);
                    }
                }
            }else{
                overflix_error+="Erro, titulo não encontrado na url: " + url+"\n";
                return;
            }
            String dir="D:\\ProgramFiles\\site\\filmes\\";
            if ( cam != null && cam )
                titulo="cam-"+titulo;
            if ( titulo_serie != null ){
                dir="D:\\ProgramFiles\\site\\series\\"+titulo_serie+"\\";
                detect_changed_struct_folder(dir, titulo);
            }
            String out=dir+titulo;
            if ( outPath != null )
                out=outPath+"\\"+titulo;
            if ( o_force_out != null )
                out=o_force_out;
            
            File f=new File(out);
            boolean needDownload = !f.exists() || f.length() < 1024*1024;
            String s="Token";
            if ( onlyPreLink 
                 || ( !onlyPreLink && !onlyLink && !needDownload )
            ){ 
                // skip token
            }else{
                if ( url.equals("") ){
                    overflix_error+="url vazia!\n";
                    return;
                }
                //s=getTokenIE_old(vToken, url);
                //s=getTokenTESTCAFE_old(vToken, url);                
                if ( overflix_interative && url.endsWith("?download") && url.contains(".com/f/") ){
                    s=capturarTokenDoChrome(url + "&name=interative");
                }else{
                    for ( int i=0;i<2;i++ ){
                        s=getTokenPuppeteer(url);
                        if ( s != null && s.trim().length() > 0 )
                            break;
                    }
                }
            }
            if ( s != null && s.trim().length() > 0 )
                s=s.trim();
            else{
                if ( runtimeExecError.trim().equals("") ){
                    overflix_error+="não foi possível solucionar pelo token.. pegue o arquivo pela url: " + url + " file: \"" + out+"\"\n";
                    return;
                }else{
                    overflix_error+="Error script token: " + runtimeExecError+"\n";
                    return;
               }
            }
            overflix_verbose(verbose, tags, "curl \"" + s + "\" > \"" + out + "\"");
            if ( onlyLink || onlyPreLink ){
                System.out.println("curl \"" + s + "\" > \"" + out + "\"");
            }else{                
                if ( needDownload ){
                    if ( overflix_multi == null )
                        overflix_multi=new multiCurl();                    
                    overflix_multi.addCurl(s,out);
                    overflix_multi.wait_numeroDeTrabalhoIgualOuMenor(2);
                    skiping_show=false;
                }else{
                    if ( skiping_show ){
                        System.out.println("skip " + out);
                        if ( getScriptRenameBySkip_in != null )
                            getScriptRenameBySkip_out+=out+"\n";
                    }else
                        skiping_hide_count++;
                }
            }            
            return;
        }
        overflix_error+="Não foi possível resolver a url =>  "+ url;
        return;
    }
    
    public String capturarTokenDoChrome(String url) throws java.io.IOException, java.util.concurrent.ExecutionException, java.lang.InterruptedException {
        int porta = 222;
        java.util.concurrent.CompletableFuture<String> resultado = new java.util.concurrent.CompletableFuture<>();
        com.sun.net.httpserver.HttpServer servidor = com.sun.net.httpserver.HttpServer.create(
            new java.net.InetSocketAddress(porta), 0
        );
        servidor.createContext("/", exchange -> {
            String query = exchange.getRequestURI().getQuery();
            byte[] resposta = "Capturado. Retorne ao Java.".getBytes();
            exchange.sendResponseHeaders(200, resposta.length);
            java.io.OutputStream os = exchange.getResponseBody();
            os.write(resposta);
            os.close();
            resultado.complete(query);
        });

        servidor.start();
        new java.lang.ProcessBuilder("cmd", "/c", "start", "chrome", "\""+url+"\"").start();
        try {
            return resultado.get();
        } finally {
            servidor.stop(0);
        }
    }
    
    public void detect_changed_struct_folder(String path, String item){
        File f=new File(path);
        if ( f.exists() && f.isDirectory() ){
            File [] lista=f.listFiles();
            if ( lista.length > 0 ){
                boolean achou=false;
                for ( int i=0;i<lista.length;i++ ){
                    if ( lista[i].getName().contains("S01E01") || lista[i].getName().contains("S01E02") || lista[i].getName().contains("S01E03") || lista[i].getName().contains("S01E04") ){
                        achou=true;
                        break;
                    }
                }
                if ( !achou )
                    erroFatal("Trava de mudança de estrutura!\nA pasta \"" + f.getAbsolutePath() + "\" contém arquivo mas nenhum contém o S1E1!\nFormate a pasta!\nArquivo esperado: \"" + f.getAbsolutePath()+"\\"+item + "\"");
            }
        }
    }
    
    public String overflix_custom_curl(String url){
        return curl_string_retry(url, 10, 10, new int[]{500, 525});
    }
            
    public void overflix_verbose(boolean verbose, boolean tags, String a){
        if ( a.startsWith("TAG") && !tags )
            return;
        if ( verbose )
            System.out.println(a);
    }
    
    public String getTokenPuppeteer(String url) throws Exception{
        String script="""
                      const puppeteer = require('puppeteer');
                      
                      // Função de delay compatível
                      function delay(ms) {
                          return new Promise(resolve => setTimeout(resolve, ms));
                      }
                      
                      /**
                       * Executa o processo completo
                       */
                      async function getVideoUrl(myUrl) {
                          let browser = null;
                          
                          try {
                              // Configuração do Puppeteer
                              browser = await puppeteer.launch({
                                  headless: true,
                                  args: [
                                      '--no-sandbox',
                                      '--disable-setuid-sandbox',
                                      '--disable-web-security',
                                      '--disable-blink-features=AutomationControlled'
                                  ]
                              });
                      
                              const page = await browser.newPage();
                              
                              // Configurações stealth
                              await page.evaluateOnNewDocument(() => {
                                  Object.defineProperty(navigator, 'webdriver', { get: () => undefined });
                              });
                      
                              await page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36');
                              await page.setViewport({ width: 1920, height: 1080 });
                      
                              // Navega para a URL fornecida (vai seguir redirects automaticamente)
                              await page.goto(myUrl, { 
                                  waitUntil: 'networkidle2',
                                  timeout: 60000 
                              });
                      
                              await delay(3000);
                      
                              // Pega o CSRF token da própria página (já após o redirect)
                              const csrfToken = await page.evaluate(() => {
                                  const meta = document.querySelector('meta[name="csrf"]');
                                  return meta ? meta.getAttribute('content') : null;
                              });
                      
                              if (!csrfToken) {
                                  throw new Error('CSRF token não encontrado');
                              }
                      
                              // Verifica se jQuery está disponível, se não, injeta
                              const hasJquery = await page.evaluate(() => typeof $ !== 'undefined');
                              if (!hasJquery) {
                                  await page.addScriptTag({url: 'https://code.jquery.com/jquery-3.6.0.min.js'});
                                  await delay(1000);
                              }
                      
                              // Executa o processo reCAPTCHA usando a URL atual (após redirect)
                              const videoUrl = await page.evaluate(async (csrfToken) => {
                                  return new Promise((resolve, reject) => {
                                      // Função loadRecaptcha
                                      function loadRecaptcha() {
                                          return new Promise((resolve, reject) => {
                                              if (window.grecaptcha) {
                                                  resolve();
                                                  return;
                                              }
                                              
                                              const script = document.createElement('script');
                                              script.src = 'https://www.google.com/recaptcha/api.js?render=6LetXaoUAAAAAB6axgg4WLG9oZ_6QLTsFXZj-5sd';
                                              script.async = true;
                                              script.defer = true;
                                              
                                              script.onload = () => {
                                                  const checkLoad = setInterval(() => {
                                                      if (window.grecaptcha) {
                                                          clearInterval(checkLoad);
                                                          resolve();
                                                      }
                                                  }, 100);
                                              };
                                              
                                              script.onerror = reject;
                                              document.head.appendChild(script);
                                          });
                                      }
                      
                                      loadRecaptcha().then(() => {
                                          grecaptcha.ready(function() {
                                              grecaptcha.execute("6LetXaoUAAAAAB6axgg4WLG9oZ_6QLTsFXZj-5sd", {action: "download"})
                                              .then(function(token) {
                                                  if (!token) {
                                                      reject('Token reCAPTCHA vazio');
                                                      return;
                                                  }
                                                  
                                                  // Usa a URL atual da página (após redirect)
                                                  $.post(window.location.href, {
                                                      csrf: csrfToken,
                                                      token: token, 
                                                      a: "genticket"
                                                  })
                                                  .done(function(response) {
                                                      if (response && response.url) {
                                                          resolve(response.url);
                                                      } else {
                                                          reject('Resposta sem URL');
                                                      }
                                                  })
                                                  .fail(reject);
                                              })
                                              .catch(reject);
                                          });
                                      }).catch(reject);
                                  });
                              }, csrfToken);
                      
                              return videoUrl;
                      
                          } catch (error) {
                              throw error;
                          } finally {
                              if (browser) {
                                  await browser.close();
                              }
                          }
                      }
                      
                      /**
                       * Função principal
                       */
                      async function main() {
                          // Verifica se a URL foi fornecida
                          if (process.argv.length < 3) {
                              process.exit(1);
                          }
                      
                          const myUrl = process.argv[2];
                      
                          try {
                              // Executa o processo completo
                              const videoUrl = await getVideoUrl(myUrl);
                              
                              // Mostra APENAS a URL no output
                              console.log(videoUrl);
                              
                          } catch (error) {
                              process.exit(1);
                          }
                      }
                      
                      // Executa o script
                      main();                      
        """;
        
        String alert_puppeteer="puppeteer nao encontrado!, instale ele com npm install puppeteer na pasta C:/npm_puppeteer";
        if ( !new File("C:/npm_puppeteer").exists() )
            throw new Exception(alert_puppeteer);
        String s=runtimeExec(null, new String[]{"cmd", "/c", "node", "-", url},new File("C:/npm_puppeteer"), script.getBytes(), null);
        if ( runtimeExecError != null && !runtimeExecError.equals("") ){
            if ( runtimeExecError.contains("Cannot find module 'puppeteer") )
                throw new Exception(alert_puppeteer);
            throw new Exception("erro: \n" + runtimeExecError);
        }
        return s.trim();
    }
    
    public String getTokenTESTCAFE_old(Boolean enable_visible, String url) throws Exception{
        String script="import { Selector, ClientFunction } from 'testcafe';\n" +
        "\n" +
        "fixture('Executar Script reCAPTCHA')\n" +
        "    .page('"+url+"'); // Substitua pela URL do seu site\n" +
        "\n" +
        "test('Obter token reCAPTCHA e enviar requisição', async t => {\n" +
        "    // 1. Carregar a API do reCAPTCHA se não estiver presente\n" +
        "    await t.eval(() => {\n" +
        "        if (typeof grecaptcha === 'undefined') {\n" +
        "            const script = document.createElement('script');\n" +
        "            script.src = 'https://www.google.com/recaptcha/api.js?render=6LetXaoUAAAAAB6axgg4WLG9oZ_6QLTsFXZj-5sd';\n" +
        "            document.head.appendChild(script);\n" +
        "        }\n" +
        "    });\n" +
        "\n" +
        "    // 2. Executar o script principal\n" +
        "    const result = await ClientFunction(() => {\n" +
        "        return new Promise((resolve) => {\n" +
        "            // Verifica se o reCAPTCHA está carregado\n" +
        "            const checkRecaptcha = () => {\n" +
        "                if (typeof grecaptcha !== 'undefined' && \n" +
        "                    typeof grecaptcha.ready !== 'undefined' &&\n" +
        "                    typeof grecaptcha.execute !== 'undefined') {\n" +
        "                    \n" +
        "                    grecaptcha.ready(function() {\n" +
        "                        grecaptcha.execute(\"6LetXaoUAAAAAB6axgg4WLG9oZ_6QLTsFXZj-5sd\", {action: \"download\"})\n" +
        "                            .then(function(token) {\n" +
        "                                const csrf = document.querySelector('meta[name=\"csrf\"]').content;\n" +
        "                                \n" +
        "                                // Usando fetch ao invés de jQuery\n" +
        "                                fetch(window.location.href, {\n" +
        "                                    method: 'POST',\n" +
        "                                    headers: {\n" +
        "                                        'Content-Type': 'application/x-www-form-urlencoded',\n" +
        "                                    },\n" +
        "                                    body: `csrf=${csrf}&token=${token}&a=genticket`\n" +
        "                                })\n" +
        "                                .then(response => response.json())\n" +
        "                                .then(data => resolve(data.url));\n" +
        "                            });\n" +
        "                    });\n" +
        "                } else {\n" +
        "                    setTimeout(checkRecaptcha, 100);\n" +
        "                }\n" +
        "            };\n" +
        "            \n" +
        "            checkRecaptcha();\n" +
        "        });\n" +
        "    })();\n" +
        "\n" +
        "    // 3. Exibir o resultado\n" +
        "    await t.expect(result).ok('O token foi gerado e a requisição foi enviada com sucesso');\n" +
        "    console.log('URL obtida:', result);\n" +
        "});";
        
        script="import { Selector, ClientFunction } from 'testcafe';\n" +
        "\n" +
        "fixture('Executar Script reCAPTCHA')\n" +
        "    .page('"+url+"');\n" +
        "\n" +
        "test('Obter token reCAPTCHA e enviar requisição', async t => {\n" +
        "    // 1. Carregar a API do reCAPTCHA se não estiver presente\n" +
        "    await t.eval(() => {\n" +
        "        if (typeof grecaptcha === 'undefined') {\n" +
        "            const script = document.createElement('script');\n" +
        "            script.src = 'https://www.google.com/recaptcha/api.js?render=6LetXaoUAAAAAB6axgg4WLG9oZ_6QLTsFXZj-5sd';\n" +
        "            document.head.appendChild(script);\n" +
        "        }\n" +
        "    });\n" +
        "\n" +
        "    // 2. Executar o script principal com 4 tentativas\n" +
        "    let result = null;\n" +
        "    let attempts = 0;\n" +
        "    const maxAttempts = 4;\n" +
        "\n" +
        "    while (attempts < maxAttempts && !result) {\n" +
        "        attempts++;\n" +
        "        console.log(`Tentativa ${attempts} de ${maxAttempts} para resolver o captcha...`);\n" +
        "\n" +
        "        try {\n" +
        "            result = await ClientFunction(() => {\n" +
        "                return new Promise((resolve, reject) => {\n" +
        "                    // Verifica se o reCAPTCHA está carregado\n" +
        "                    const checkRecaptcha = () => {\n" +
        "                        if (typeof grecaptcha !== 'undefined' && \n" +
        "                            typeof grecaptcha.ready !== 'undefined' &&\n" +
        "                            typeof grecaptcha.execute !== 'undefined') {\n" +
        "                            \n" +
        "                            grecaptcha.ready(function() {\n" +
        "                                grecaptcha.execute(\"6LetXaoUAAAAAB6axgg4WLG9oZ_6QLTsFXZj-5sd\", {action: \"download\"})\n" +
        "                                    .then(function(token) {\n" +
        "                                        const csrfMeta = document.querySelector('meta[name=\"csrf\"]');\n" +
        "                                        if (!csrfMeta) {\n" +
        "                                            reject('Meta tag CSRF não encontrada');\n" +
        "                                            return;\n" +
        "                                        }\n" +
        "                                        \n" +
        "                                        const csrf = csrfMeta.content;\n" +
        "                                        \n" +
        "                                        // Usando fetch ao invés de jQuery\n" +
        "                                        fetch(window.location.href, {\n" +
        "                                            method: 'POST',\n" +
        "                                            headers: {\n" +
        "                                                'Content-Type': 'application/x-www-form-urlencoded',\n" +
        "                                            },\n" +
        "                                            body: `csrf=${csrf}&token=${token}&a=genticket`\n" +
        "                                        })\n" +
        "                                        .then(response => {\n" +
        "                                            if (!response.ok) {\n" +
        "                                                throw new Error(`HTTP error! status: ${response.status}`);\n" +
        "                                            }\n" +
        "                                            return response.json();\n" +
        "                                        })\n" +
        "                                        .then(data => {\n" +
        "                                            if (data && data.url) {\n" +
        "                                                resolve(data.url);\n" +
        "                                            } else {\n" +
        "                                                reject('Resposta não contém URL');\n" +
        "                                            }\n" +
        "                                        })\n" +
        "                                        .catch(error => reject(`Erro na requisição: ${error.message}`));\n" +
        "                                    })\n" +
        "                                    .catch(error => reject(`Erro ao executar reCAPTCHA: ${error.message}`));\n" +
        "                            });\n" +
        "                        } else {\n" +
        "                            setTimeout(checkRecaptcha, 500); // Aumentado para 500ms\n" +
        "                        }\n" +
        "                    };\n" +
        "                    \n" +
        "                    // Timeout para evitar loop infinito\n" +
        "                    setTimeout(() => reject('Timeout ao carregar reCAPTCHA'), 10000);\n" +
        "                    checkRecaptcha();\n" +
        "                });\n" +
        "            })();\n" +
        "\n" +
        "            console.log(`Captcha resolvido na tentativa ${attempts}`);\n" +
        "            break; // Sai do loop se bem-sucedido\n" +
        "\n" +
        "        } catch (error) {\n" +
        "            console.log(`Tentativa ${attempts} falhou:`, error.message || error);\n" +
        "            \n" +
        "            // Aguarda um tempo antes da próxima tentativa (backoff exponencial)\n" +
        "            const waitTime = Math.pow(2, attempts) * 1000; // 2s, 4s, 8s, etc.\n" +
        "            console.log(`Aguardando ${waitTime/1000} segundos antes da próxima tentativa...`);\n" +
        "            await t.wait(waitTime);\n" +
        "            \n" +
        "            // Tenta recarregar a página na última tentativa se ainda falhar\n" +
        "            if (attempts === maxAttempts - 1) {\n" +
        "                console.log('Recarregando página para última tentativa...');\n" +
        "                await t.eval(() => location.reload());\n" +
        "                await t.wait(3000); // Aguarda a página carregar\n" +
        "            }\n" +
        "        }\n" +
        "    }\n" +
        "\n" +
        "    // 3. Verifica se obteve resultado\n" +
        "    if (result) {\n" +
        "        await t.expect(result).ok('O token foi gerado e a requisição foi enviada com sucesso');\n" +
        "        console.log('URL obtida:', result);\n" +
        "    } else {\n" +
        "        throw new Error(`Falha ao resolver captcha após ${maxAttempts} tentativas`);\n" +
        "    }\n" +
        "});";

        File f = File.createTempFile("meu-arquivo-temporario", ".js");
        String path=f.getAbsolutePath();
        FileWriter fw=new FileWriter(f);
        fw.write(script);
        fw.flush();
        fw.close();
        String [] commands=null;
        String s="";
        
        String navegador_testcafe="chrome";
        navegador_testcafe="firefox";
        
        ////////test
        //enable_visible=true;
        
        if ( enable_visible )
            commands=new String[]{"cmd", "/c", "testcafe", navegador_testcafe, path};
        else
            commands=new String[]{"cmd", "/c", "testcafe", navegador_testcafe+":headless", path};
        s=runtimeExec(null, commands, null, null, null);
        if ( runtimeExecError != null && !runtimeExecError.equals("") )
            throw new Exception("erro: programa testcafe não encontrado!\ninstale ele:npm install -g testcafe\n" + runtimeExecError);
        String [] partes=s.split("\n");
        int p=findParm(partes, "URL obtida: ", false);
        if ( p > -1 )
            return partes[p].substring("URL obtida: ".length());
        return "";
    }
    
    public String getTokenIE_old(Boolean enable_visible, String url){
        try{
            String [] result=new String[]{""};
            Thread t=new Thread(new Runnable() {
                public void run() {
                    try{
                        String s="Token";
                        String _visible="$false";
                        String _quit="$ie.Parent.Quit();";
                        if ( enable_visible ){
                            _visible="$true";
                            _quit="";
                        }
                        String text="$ie = New-Object -ComObject 'internetExplorer.Application'\n" +
                            "$ie.Visible=" + _visible + "\n" +                    
                            "$ie.ParsedHtml\n" +
                            "$ie.Navigate(\"" + url + "\");\n" +
                            "while($ie.Busy -eq $true){sleep -Milliseconds 100;}\n"+
                            "$ie.Document.ParentWindow.ExecScript('s=\"0\"', \"javascript\")\n" +           
                            "$ie.Document.ParentWindow.ExecScript('grecaptcha.ready(function() {grecaptcha.execute(\"6LetXaoUAAAAAB6axgg4WLG9oZ_6QLTsFXZj-5sd\", {action: \"download\"}).then(function(c){n=$(\"meta[name=csrf]\").attr(\"content\");$.post(\"\", {csrf: n,token: c,a: \"genticket\"},function(d){console.log(d.url);s=d.url;})});});', \"javascript\")\n" +
                            "while($ie.Document.ParentWindow.GetType().InvokeMember(\"s\", 4096, $Null, $IE.Document.parentWindow, $Null) -eq 0){sleep -Milliseconds 100;}\n" +
                            "echo $ie.Document.ParentWindow.GetType().InvokeMember(\"s\", 4096, $Null, $IE.Document.parentWindow, $Null);\n" + 
                            _quit + "\n" + 
                            ""; 
                        //taskkill /im iexplore.exe /f
                        s=runtimeExec(null, new String[]{"powershell", "-noprofile", "-c", "-"}, null, text.getBytes(), null);
                        if ( s == null )
                            s="";
                        int limitLoop=1;                
                        while ( s.trim().length() == 0 && limitLoop-->0 ){
                            text="$ie = New-Object -ComObject 'internetExplorer.Application'\n" +
                            "$ie.Visible=" + _visible + "\n" +                    
                            "$ie.ParsedHtml\n" +
                            "$ie.Navigate(\"" + url + "\");\n" +
                            "while($ie.Busy -eq $true){sleep -Milliseconds 100;}\n"+
                            "$ie.Document.ParentWindow.ExecScript('document.getElementsByClassName(\"btn btn3 download-btn\")[0].click();', \"javascript\");\n" +
                            "sleep -Milliseconds 1000;\n" +
                            "$ie.Document.ParentWindow.ExecScript('document.getElementsByClassName(\"btn btn3 download-btn\")[0].click();', \"javascript\");\n" +
                            "sleep -Milliseconds 1000;\n" +
                            "$ie.Document.ParentWindow.ExecScript('document.getElementsByClassName(\"btn btn3 download-btn\")[0].click();', \"javascript\");\n" +
                            "sleep -Milliseconds 1000;\n" +
                            "$ie.Document.ParentWindow.ExecScript('s=\"0\"', \"javascript\")\n" +           
                            "$ie.Document.ParentWindow.ExecScript('grecaptcha.ready(function() {grecaptcha.execute(\"6LetXaoUAAAAAB6axgg4WLG9oZ_6QLTsFXZj-5sd\", {action: \"download\"}).then(function(c){n=$(\"meta[name=csrf]\").attr(\"content\");$.post(\"\", {csrf: n,token: c,a: \"genticket\"},function(d){console.log(d.url);s=d.url;})});});', \"javascript\")\n" +
                            "while($ie.Document.ParentWindow.GetType().InvokeMember(\"s\", 4096, $Null, $IE.Document.parentWindow, $Null) -eq 0){sleep -Milliseconds 100;}\n" +
                            "echo $ie.Document.ParentWindow.GetType().InvokeMember(\"s\", 4096, $Null, $IE.Document.parentWindow, $Null);\n" + 
                            _quit + "\n" + 
                            "";                     
                            s=runtimeExec(null, new String[]{"powershell", "-noprofile", "-c", "-"}, null, text.getBytes(), null);
                            sleepSeconds(1);
                        }    
                        if ( s == null )
                            s="";
                        result[0]=s;
                    }catch(Exception e){
                        result[0]="";
                    }                    
                }
            });
            t.start();
            for ( int i=0;i<15;i++ ){
                if ( !t.isAlive() ){
                    try{
                        return result[0];
                    }catch(Exception e){}
                }
                sleepSeconds(1);
            }
            try{    
                t.interrupt();
            }catch(Exception e){}
        }catch(Exception e){}
        return "";
    }

    public void getScriptRenameBySkip_populaPartesNovos(String [] partes, String [] partes_novos, int [] partes_grupo_serie_int){
        int serie=1;
        int episodio=1;
        int count=0;
        while ( partes_grupo_serie_int.length > 0 ){
            if ( partes_grupo_serie_int[0] == 0 )
                erroFatal("Erro inesperado 34252");
            partes_grupo_serie_int[0]--;
            partes_novos[count++]="S"+serie+"E"+(episodio++);
            if ( partes_grupo_serie_int[0] == 0 ){
                partes_grupo_serie_int=sliceParm(1, partes_grupo_serie_int);
                serie++;
                episodio=1;
            }
        }
        for ( int i=0;i<partes.length;i++ ){
            // pega serie name
            String [] estrutura=partes[i].split("\\\\");
            if ( partes[i].startsWith("?") ){ // bypass "<h2>WE ARE SORRY</h2>"
                partes_novos[i]="?";
                continue;
            }
            if ( estrutura.length <= 1 )
                erroFatal("Caminho incorreto: " + partes[i]);
            String serie_name=estrutura[estrutura.length-2];
            String extensao=estrutura[estrutura.length-1].split("\\.")[estrutura[estrutura.length-1].split("\\.").length-1];
            estrutura[estrutura.length-1]=serie_name+" "+partes_novos[i]+"."+extensao;
            partes_novos[i]=String.join("\\", estrutura);
        }
    }
    
    public int tryConvertNumberPositiveByString(int n_lines_buffer,String value){
        try{
            int tmp=Integer.parseInt(value);
            if ( tmp >= 0 )
                return tmp;
        }catch(Exception e){
            System.out.println(e.toString());
        }
        return n_lines_buffer;
    }
    
    public void grep(String [] args)
    {
        boolean print=false;
        String line_bkp="";
        String line="";

        ArrayList<Boolean> lista_starting=new ArrayList<Boolean>();
        ArrayList<Boolean> lista_ending=new ArrayList<Boolean>();
        ArrayList<String> lista_txt=new ArrayList<String>();
        
        ArrayList<String> lista=get_v_i_txt(args);
        if ( lista == null ){
            comando_invalido(args);
            return;
        }
        boolean v_=lista.get(0).equals("S");
        boolean i_=lista.get(1).equals("S");
        
        for ( int i=2;i<lista.size();i+=3 ){
            lista_starting.add(lista.get(i).equals("S"));
            lista_ending.add(lista.get(i+1).equals("S"));
            lista_txt.add(lista.get(i+2));
        }
        
        if ( i_ )
            lista_txt.set(0,lista_txt.get(0).toUpperCase());
        
        try {            
            while ( (line=line_bkp=readLine()) != null ) {
                print=false;
                if ( i_ )
                    line=line.toUpperCase();
                for ( int i=0;i<lista_txt.size();i++ ){
                    if ( lista_txt.get(i).equals("") && lista_starting.get(i) && lista_ending.get(i) ){ // ^$
                        if (line.equals("")){
                            print=true;
                            break;
                        }else
                            continue;
                    }
                    if ( !lista_starting.get(i) && !lista_ending.get(i) && line.contains(lista_txt.get(i)) ){
                        print=true;
                        break;
                    }
                    if ( lista_starting.get(i) && !lista_ending.get(i) && line.startsWith(lista_txt.get(i)) ){
                        print=true;
                        break;
                    }
                    if ( !lista_starting.get(i) && lista_ending.get(i) && line.endsWith(lista_txt.get(i)) ){
                        print=true;
                        break;
                    }
                    if ( lista_starting.get(i) && lista_ending.get(i) && line.startsWith(lista_txt.get(i)) && line.endsWith(lista_txt.get(i)) ){
                        print=true;
                        break;
                    }
                }
                
                if ( v_ )
                    print=!print;
                
                if ( print )
                    System.out.println(line);
            }
            closeLine();
        }catch(Exception e){
            System.out.println(e.toString()+" - "+line_bkp);
        }
    }
    
    public void base_removeAcentos(){
        String line=null;
        while ( (line=readLine()) != null ){
            System.out.println(removeAcentos(line));
            System.out.flush();
        }
    }
    
    public String removeAcentos(String str) {
        return java.text.Normalizer.normalize(str, java.text.Normalizer.Form.NFD).replaceAll("[^\\p{ASCII}]", "");
    }    
    
    public void wc(String parm){
        if ( parm.equals("-l") ){
            try{
                InputStream inputStream_pipe=System.in;
                byte[] buf = new byte[BUFFER_SIZE];
                int count=0;
                int len=0;
                byte[] n_="\n".getBytes();
                while( (len=inputStream_pipe.read(buf,0,BUFFER_SIZE)) > 0 ){
                    for ( int i=0;i<len;i++ )
                        if (buf[i] == n_[0])
                            count++;
                }
                System.out.println(count);
                return;
            }catch(Exception e){
                System.err.println(e.toString());
                System.exit(1);
            }
        }
        if ( parm.equals("-w") ){
            String t=null;
            String notWord="\n\r\t ";
            boolean word_in=false;
            long count=0;
            while( (t=read1String()) != null ){
                if(word_in){
                    if(notWord.indexOf(t) > -1){
                        word_in=false;
                        count++;
                    }
                }else{
                    if(notWord.indexOf(t) == -1){
                        word_in=true;
                    }
                }
            }
            if(word_in)
                count++;
            System.out.println(count);
            return;
        }        
        if ( parm.equals("-c") ){
            String t=null;
            long count=0;
            while( (t=read1String()) != null )
                count++;
            System.out.println(count);
            return;
        }        
    }

    public void len()
    {
        try{
            InputStream inputStream_pipe=System.in;
            byte[] buf = new byte[BUFFER_SIZE];            
            int len=0;
            int count=0;
            byte[] n_="\n".getBytes();
            byte[] r_="\r".getBytes();
            boolean any=false;
            while( (len=inputStream_pipe.read(buf,0,BUFFER_SIZE)) > 0 ){
                any=true;
                for ( int i=0;i<len;i++ ){
                    if (buf[i] == n_[0]){
                        System.out.println(count);
                        count=0;
                    }else{
                        if (buf[i] != r_[0])
                            count++;
                    }
                }
            }
            if ( count > 0 || !any )
                System.out.println(count);            
        }catch(Exception e){
            System.err.println(e.toString());
            System.exit(1);
        }
    }
    
    public void head(String [] args)
    {
        long p;
        String line;
        long count=0;
        
        try{
            if ( args.length == 1 )
                p=10;
            else
                p=Long.parseLong(args[1].substring(1));
        }catch(Exception e){
            comando_invalido(args);
            return;
        }
        
        try {
            while ( (line=readLine()) != null ) {
                if ( ++count <= p )
                    System.out.println(line);
                else{
                    closeLine();
                    break;
                }
            }
            closeLine();
        }catch(Exception e){
            System.out.println(e.toString());
        }
    }
            
    public void tail(String [] args)
    {                
        int p;
        String line;
        ArrayList<String> lista=new ArrayList<String>();
        
        try{
            if ( args.length == 1 )
                p=10;
            else
                p=Integer.parseInt(args[1].substring(1));
        }catch(Exception e){
            comando_invalido(args);
            return;
        }
        
        try {
            while ( (line=readLine()) != null ) {
                lista.add(line);
                if ( lista.size() > p )
                    lista.remove(0);
            }
            closeLine();
            for ( int i=0;i<lista.size();i++ ){
                System.out.println(lista.get(i));
            }
            lista=null;
        }catch(Exception e){
            System.out.println(e.toString());
        }
    }
    
    public void talk(String [] args){
        // https://ttsmp3.com/
        // https://speechma.com/
        try{
            Object [] objs = get_parms_msg_lang_list_copy_tts_stt(args);
            if ( objs == null ){
                comando_invalido(args);
                System.exit(0);
            }
            String msg=(String)objs[0];
            String lang=(String)objs[1];
            Boolean list=(Boolean)objs[2];
            String copy=(String)objs[3];
            Boolean tts=(Boolean)objs[4];
            Boolean stt=(Boolean)objs[5];
            Boolean modeB=(Boolean)objs[6];
            String [] modelos_stt=new String[]{
                "English/en",
                "Chinese/cn",
                "Russian/ru",
                "French/fr",
                "German/de",
                "Spanish/es",
                "Portugues/pt",
                "Italian/it",
                "Japanses/ja",
                "Korean/ko"
            };
            String dir_modelo="D:/ProgramFiles/IA-vosk-model/";
            if ( tts ){ // textToSpeech
                if ( list ){                        
                    java.util.regex.Matcher matcher = java.util.regex.Pattern.compile("<option[\\s\\S]*?</option>").matcher(curl_string("https://ttsmp3.com/"));
                    String p1="";
                    String p2="";
                    while ( matcher.find() ){
                        String [] p=matcher.group().replaceAll("<", "|").replaceAll(">", "|").split("\\|");            
                        p1=p[2].split("/")[0].trim();
                        p2=p[1].split("'")[1];
                        System.out.println(p1.replaceAll(" ", "_") + "_" + p2);
                    }              
                    return;
                }
                if ( lang == null )
                    lang="Brazilian_Portuguese_Ricardo";
                else{
                    if ( !lang.contains("_") )
                        erroFatal("-lang inválida: " + lang + "\nVeja as langs validas pelo comando abaixo:\ny talk -tts list" );                    
                }
                if ( msg == null ){
                    while( (msg=readLine()) != null ){
                        System.err.println(":.. " + msg);
                        if ( 
                            msg.contains("LOG (VoskAPI:") 
                            || msg.contains(" Traceback (most recent call last)")
                        ){
                            continue;
                        }
                        if ( modeB ){                            
                            if ( msg.lastIndexOf("-") > -1 )
                                msg=msg.substring(msg.lastIndexOf("-")+2);
                            String[] numbers = msg.split(" ");
                            byte[] bytes = new byte[numbers.length];
                            for (int i = 0; i < numbers.length; i++)
                                bytes[i] = (byte) Integer.parseInt(numbers[i]);
                            msg = new String(bytes, StandardCharsets.UTF_8);                           
                            System.out.println(msg);                        
                        }
                        talk_msg(msg, lang, copy);                        
                    }
                }else{
                    msg=msg.trim();
                    talk_msg(msg, lang, copy);
                }
                return;
            }
            if ( stt ){ // speechToText
                if ( list ){                        
                    String [] pastas=new String []{};
                    File f=new File(dir_modelo);
                    if ( f.exists() )
                        pastas=f.list();
                    for ( int i=0;i<modelos_stt.length;i++ ){
                        String tmp=modelos_stt[i];
                        String nome=tmp.split("/")[0];
                        String sigla=tmp.split("/")[1];
                        String aux="";
                        if ( findParm(pastas, sigla, true) == -1 )
                            aux=" #nao instalado!";
                        System.out.println(nome+aux);
                    }
                    return;
                }
                String sigla="?";
                if ( lang == null ){
                    lang="Portugues";                
                    sigla="pt";
                }else{
                    if ( lang.contains("_") )
                        erroFatal("-lang inválida: " + lang + "\nVeja as langs validas pelo comando abaixo:\ny talk -stt list" );                    
                }
                if ( lang != null ){
                    boolean achou=false;
                    String [] pastas=new String []{};
                    File f=new File(dir_modelo);
                    if ( f.exists() )
                        pastas=f.list();
                    for ( int i=0;i<modelos_stt.length;i++ ){
                        String tmp=modelos_stt[i];
                        String _nome=tmp.split("/")[0];
                        String _sigla=tmp.split("/")[1];
                        if ( lang.equals(_nome) ){
                            sigla=_sigla;
                            File _f=new File(dir_modelo+_sigla);
                            if ( !_f.exists() )
                                erroFatal("O Modelo "+_nome+" pasta "+_sigla+" não está instalado!\nVeja abaixo as instruções para baixar, o modelo abaixo é para Portuguese\nsite: https://alphacephei.com/vosk/models\nmodelo small: vosk-model-small-pt-0.3\ndestino no pc em formato de pasta: "+dir_modelo+"pt\nObs: recomendado baixar o modelo do tipo small!!");
                            if ( !_f.isDirectory() )
                                erroFatal("Erro, esse caminho não é uma pasta:\n"+dir_modelo+_sigla);
                            achou=true;
                            break;
                        }
                    }
                    if ( !achou )
                        erroFatal("Modelo inválido: " + lang);
                }                    
                
                String text_modeB="print(parcial)";
                if ( modeB ){
                    text_modeB="""
bytes_utf8 = parcial.encode('utf-8')
            bytes_str = ' '.join(str(b) for b in bytes_utf8)
            print(f"{parcial} - {bytes_str}")""";
                }
                
                String command="""
from vosk import Model, KaldiRecognizer
from vosk import Model, KaldiRecognizer
import pyaudio
import json
import sys
import io

sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8', errors='replace')
sys.stderr = io.TextIOWrapper(sys.stderr.buffer, encoding='utf-8', errors='replace')
# https://alphacephei.com/vosk/models
# BR -> vosk-model-small-pt-0.3
model = Model("d:/template")
recognizer = KaldiRecognizer(model, 16000)

mic = pyaudio.PyAudio()
stream = mic.open(rate=16000, channels=1, format=pyaudio.paInt16, input=True, frames_per_buffer=8192*2)
stream.start_stream()

while True:
    data = stream.read(4096, exception_on_overflow=False)
    if recognizer.AcceptWaveform(data):
        text=json.loads(recognizer.Result()).get("text", "")
        if text != '' and text != parcial:
            parcial=text
        if parcial != '':
            print(parcial)
            sys.stdout.flush()
    else:
        parcial=json.loads(recognizer.PartialResult()).get("parcial", "")
                        
""".replace("d:/template", dir_modelo+sigla).replace("print(parcial)", text_modeB);
                
                if ( new File(dir_modelo+sigla+"/rescore").exists() ) // fix bug in Portugues e German
                    mv(new File(dir_modelo+sigla+"/rescore"), new File(dir_modelo+sigla+"/rescore2"));
                flag_real_time_output=true;

                String retorno=runtimeExec(null, new String[]{"python3"}, null, command.getBytes(), false);
                if ( retorno == null || retorno.equals("") ){
                    if ( runtimeExecError.contains("from vosk import Model") )
                        erroFatal("é preciso instalar o vosk primeiro!\npip install vosk");
                    if ( runtimeExecError.contains("does not contain model files") )
                        erroFatal("Esse modelo não está instalado!\nsite: https://alphacephei.com/vosk/models\nmodelo small: vosk-model-small-pt-0.3\ndestino no pc em formato de pasta: "+dir_modelo+"pt\n"+runtimeExecError);
                    System.out.println("Erro: " + runtimeExecError);
                }
                return;
            }
            erroFatal("Erro interno 34322334123");
        }catch(Exception e){
            erroFatal(e);
        }
    }
    
    public void talk_msg(String msg, String lang, String copy){
        try{
            if ( msg.equals("") )
                erroFatal("Erro, Texto em branco!");
            String dir="/ProgramFiles";
            if ( isWindows() ){
                dir="d:/ProgramFiles";
                if ( !new File(dir).exists() || !new File(dir).isDirectory() )
                    dir="c:/ProgramFiles";
                if ( !new File(dir).exists() || !new File(dir).isDirectory() )
                    new File(dir).mkdir();
            }
            if ( !new File(dir).exists() || !new File(dir).isDirectory() )
                erroFatal("Não foi possivel encontrar a pasta " + dir);
            if ( !new File(dir+"/talk").exists() )
                new File(dir+"/talk").mkdir();
            if ( !new File(dir+"/talk/"+lang).exists() )
                new File(dir+"/talk/"+lang).mkdir();
            String sha1=digest_text(msg, "SHA1");
            String pre=sha1.substring(0,3);
            if ( !new File(dir+"/talk/"+lang+"/"+pre).exists() )
                new File(dir+"/talk/"+lang+"/"+pre).mkdir();
            if ( !new File(dir+"/talk/"+lang+"/"+pre+"/"+sha1+".txt").exists() )
                salvando_file(msg, new File(dir+"/talk/"+lang+"/"+pre+"/"+sha1+".txt"));
            if ( !new File(dir+"/talk/"+lang+"/"+pre+"/"+sha1+".mp3").exists() ){
                String lang_="";
                if ( lang.split("_").length == 2 )
                    lang_=lang.split("_")[1];
                if ( lang.split("_").length == 3 )
                    lang_=lang.split("_")[2];
                String msg_=encodeUrl(msg);
                String url_="https://ttsmp3.com/makemp3_new.php"; // Limit: ~375 words or 3,000 characters / day
                String data_="msg="+msg_+"&lang="+lang_+"&source=ttsmp3";
                ByteArrayOutputStream baos=new ByteArrayOutputStream();
                curl(baos, "", "POST", false, false, url_, new ByteArrayInputStream(data_.getBytes()), null, null, null, null, null);
                String s=baos.toString();
                if ( !s.contains("\"Error\":") )
                    erroFatal("Resposta inesperada do servidor: " + s);
                if ( !s.contains("\"Error\":0") )
                    erroFatal("Erro na resposta do servidor: " + s);
                s=s.substring(s.length()-38, s.length()-38+32);
                curl(new FileOutputStream(dir+"/talk/"+lang+"/"+pre+"/"+sha1+".mp3"), "", "GET", false, false, "https://ttsmp3.com/created_mp3/" + s + ".mp3", null, null, null, null, null, null);
            }
            if ( !new File(dir+"/talk/"+lang+"/"+pre+"/"+sha1+".wav").exists() ){
                runtimeExec(null, new String[]{"ffmpeg","-i",sha1+".mp3",sha1+".wav"}, new File(dir+"/talk/"+lang+"/"+pre), null, null); 
                if ( runtimeExecError != null && !runtimeExecError.contains("size=") )
                    erroFatal(runtimeExecError);
            }
            play(null, dir+"/talk/"+lang+"/"+pre+"/"+sha1+".wav", null, false, true, false, null);
            if ( copy != null ){
                java.nio.file.Files.copy(
                        java.nio.file.Paths.get(dir+"/talk/"+lang+"/"+pre+"/"+sha1+".wav"), 
                        java.nio.file.Paths.get(copy), 
                        java.nio.file.StandardCopyOption.REPLACE_EXISTING
                );
                java.nio.file.Files.copy(
                        java.nio.file.Paths.get(dir+"/talk/"+lang+"/"+pre+"/"+sha1+".txt"), 
                        java.nio.file.Paths.get(copy+".txt"), 
                        java.nio.file.StandardCopyOption.REPLACE_EXISTING
                );
            }
        }catch(Exception e){
            erroFatal(e);
        }                    
    }
    
    public void sign(String [] args){
        String spec="secp256r1";
        String algo="SHA256withECDSA";
        Object [] obj = get_parms_sign(args);
        if ( obj == null )
            erroFatal("Parametros invalidos");
        String msg=(String)obj[0];
        String pass=(String)obj[1];
        Boolean verify=(Boolean)obj[2];
        String publicKey=(String)obj[3];
        String signature=(String)obj[4];

        if ( verify )
            verify_sign(msg, publicKey, signature, algo);
        else{
            signing(msg, pass, spec, algo);
        }      
    }
    
    public void verify_sign(String msg, String _publicKey, String signature, String algo){
        try{
            java.security.Signature ecdsaVerify = java.security.Signature.getInstance(algo);
            java.security.spec.EncodedKeySpec publicKeySpec = new java.security.spec.X509EncodedKeySpec(java.util.Base64.getDecoder().decode(_publicKey));
            java.security.KeyFactory keyFactory = java.security.KeyFactory.getInstance("EC");
            java.security.PublicKey publicKey = keyFactory.generatePublic(publicKeySpec);
            ecdsaVerify.initVerify(publicKey);
            ecdsaVerify.update(msg.getBytes("UTF-8"));
            boolean result = ecdsaVerify.verify(java.util.Base64.getDecoder().decode(signature));
            System.out.println(result);
        }catch(Exception e){
            erroFatal(e);
        }
    }
    
    public void signing(String msg, String pass, String spec, String algo){
        try{
            java.security.spec.ECGenParameterSpec ecSpec = new java.security.spec.ECGenParameterSpec(spec);
            java.security.KeyPairGenerator g = java.security.KeyPairGenerator.getInstance("EC");
            g.initialize(ecSpec, new java.security.SecureRandom(pass.getBytes()));
            java.security.KeyPair keypair = g.generateKeyPair();
            java.security.PublicKey _publicKey = keypair.getPublic();
            java.security.PrivateKey privateKey = keypair.getPrivate();        
            java.security.Signature ecdsaSign = java.security.Signature.getInstance(algo);
            ecdsaSign.initSign(privateKey);
            ecdsaSign.update(msg.getBytes("UTF-8"));
            byte[] _signature = ecdsaSign.sign();        
            String publicKey = java.util.Base64.getEncoder().encodeToString(_publicKey.getEncoded());
            String signature = java.util.Base64.getEncoder().encodeToString(_signature);        
            System.out.println("y sign -verify -msg \""+msg+"\" -publicKey \""+publicKey+"\" -signature \""+signature+"\"");
        }catch(Exception e){
            erroFatal(e);
        }  
    }
    
    public void cors(String [] args){
        Object [] obj = get_parms_cors_ip_port_sw(args);
        if ( obj == null )
            erroFatal("Parametros invalidos");
        String ip=(String)obj[0];
        Integer port=(Integer)obj[1];        
        final String [] sw=(obj[2]==null)?(new String[]{}):(((String)obj[2]).split("\\|"));
        System.out.println(
                "Server cors ligado!\n"
                + "exemplo de chamada:\n"
                + "y curl \"http://"+ip+":"+port+"?http://site.com\"\n"
                + "exemplo js:\n"
                + "    var b_status=0;\n"                        
                + "    function b(url){"
                + "      if(location.href.indexOf('http://')!= 0){alert('cors nao pode ser executado nessa aba! somente em http://');return;}\n"
                + "      if(url.indexOf('?')>-1) url=url.split('?')[0]+'?base64?'+btoa(url);\n"
                + "      var xhr = new XMLHttpRequest();\n"
                + "      xhr.withCredentials = false;\n"
                + "      xhr.open(\"GET\", url, false);\n"
                + "      xhr.overrideMimeType(\"text/plain; charset=x-user-defined\");\n"
                + "      xhr.send(null);\n"
                + "      b_status=xhr.status;\n"
                + "      return xhr.responseText;\n"
                + "    }\n"
                + "    b('http://" + ip + ":" + port + "?https://site.com');\n"
        );
        try{            
            ServerSocket serverSocket = new ServerSocket(port, 1, InetAddress.getByName(ip));
            while (true) {
                try {
                    final Socket socket = serverSocket.accept();
                    new Thread() {
                        public void run() {
                            try {  
                                InputStream input = socket.getInputStream();
                                OutputStream output = socket.getOutputStream();
                                byte [] cors_invalido=(
                                                "HTTP/1.1 404 Not Found\r\n"
                                                + "Content-Type: text/html; charset=UTF-8\r\n"
                                                + "Access-Control-Allow-Origin: *\r\n"
                                                + "X-Frame-Options: SAMEORIGIN\r\n"
                                                + "\r\n"
                                                + "chamada invalida para cors.. vc deve utilizar \"?\" na url e nao pode ser no final"
                                            ).getBytes();
                                if (input != null) {
                                    byte [] buf=new byte[1024*10];
                                    int len=input.read(buf);
                                    if ( len <= 0 ){
                                        System.err.println("Erro fatal, header invalido!");
                                        System.exit(1);
                                    }
                                    String texto=new String(buf);
                                    texto=texto.split("\r\n")[0];
                                    texto=texto.split(" ")[1];
                                    int p=texto.indexOf("?");
                                    if ( p <= 0 ){
                                        output.write(cors_invalido);
                                        output.flush();
                                        socket.close();
                                        return;
                                    }
                                    texto=texto.substring(p+1);
                                    if ( texto.length() == 0 ){
                                        output.write(cors_invalido);
                                        output.flush();
                                        socket.close();
                                        return;
                                    }
                                    if ( texto.startsWith("base64?" ) ){
                                        texto=texto.substring(7);
                                        try{
                                            texto=base64_S_S(texto, false);
                                            texto=texto.substring(texto.indexOf("?")+1);
                                        }catch(Exception e ){
                                            output.write(
                                                (    
                                                    "HTTP/1.1 400 OK\r\n"
                                                    + "Content-Type: text/html; charset=UTF-8\r\n"
                                                    + "Access-Control-Allow-Origin: *\r\n"
                                                    + "X-Frame-Options: SAMEORIGIN\r\n"
                                                    + "\r\n"
                                                    + "base64 invalida: " + texto
                                                ).getBytes()                                        
                                            );
                                            output.flush();
                                            socket.close();
                                            return;                                                                                    
                                        }
                                    }
                                    String url=texto;
                                    boolean achou=(sw.length==0);
                                    for ( int i=0;i<sw.length;i++ ){
                                        if ( url.startsWith(sw[i]) ){
                                            achou=true;
                                            break;
                                        }
                                    }
                                    if ( !achou ){
                                        output.write(
                                            (    
                                                "HTTP/1.1 400 OK\r\n"
                                                + "Content-Type: text/html; charset=UTF-8\r\n"
                                                + "Access-Control-Allow-Origin: *\r\n"
                                                + "X-Frame-Options: SAMEORIGIN\r\n"
                                                + "\r\n"
                                                + "solicitacao nao permitida de acordo com os parametros -sw"
                                            ).getBytes()                                        
                                        );
                                        output.flush();
                                        socket.close();
                                        return;                                        
                                    }
                                    curl_string(url);
                                    byte [] s=curl_bytes(url);
                                    if ( curl_error == null ){
                                        String [] headers=curl_response_header.split("\r\n");
                                        int count_cors=0;
                                        String status_301=null;
                                        String location="";
                                        for ( int i=0;i<headers.length;i++ ){
                                            if ( headers[i].toLowerCase().startsWith("access-control-allow-origin: ") ){
                                                headers[i]="Access-Control-Allow-Origin: *";
                                                count_cors++;
                                            }
                                            if ( headers[i].toLowerCase().startsWith("location: ") )
                                                location=headers[i];
                                            if ( headers[i].toUpperCase().startsWith("HTTP/1.1 301 ") || headers[i].toUpperCase().startsWith("HTTP/1.0 301 ") )
                                                status_301=headers[i];
                                        }
                                        if ( status_301 != null ){
                                            output.write(
                                                (    
                                                    "HTTP/1.1 400 OK\r\n"
                                                    + "Content-Type: text/html; charset=UTF-8\r\n"
                                                    + "Access-Control-Allow-Origin: *\r\n"
                                                    + "X-Frame-Options: SAMEORIGIN\r\n"
                                                    + "\r\n"
                                                    + "redirect nao permitido para cors:\n" + status_301 + "\n" + location
                                                ).getBytes()                                        
                                            );
                                            output.flush();
                                            socket.close();
                                            return;                                                                                        
                                        }
                                        if ( count_cors == 0 )
                                            headers=addParm("Access-Control-Allow-Origin: *", headers);
                                            
                                        curl_response_header = String.join("\r\n",headers)+"\r\n\r\n";
                                        output.write(curl_response_header.getBytes());
                                        output.write(s);
                                        output.flush();
                                        socket.close();
                                        return;
                                    }
                                    output.write(
                                        (    
                                            "HTTP/1.1 400 OK\r\n"
                                            + "Content-Type: text/html; charset=UTF-8\r\n"
                                            + "Access-Control-Allow-Origin: *\r\n"
                                            + "X-Frame-Options: SAMEORIGIN\r\n"
                                            + "\r\n"
                                            + curl_error
                                        ).getBytes()                                        
                                    );
                                    output.flush();
                                    socket.close();
                                }
                            } catch (Exception e) {
                                System.out.println("----------> Erro ao executar servidor::" + e.toString());
                            }
                        }
                    }.start();
                } catch (Exception e) {
                    System.out.println("Erro ao executar servidor:" + e.toString());
                }
            }                  
        }catch(Exception e){
            System.out.println(e.toString());
        }  
    }
    
    public void cut(String [] args){
        String [] partes=args[1].substring(2).split(",");
        int [] elem=new int[partes.length*2];
        int count=0;
        try{
            for ( int i=0;i<partes.length;i++ )
            {
                if ( 
                    partes[i].startsWith("-") 
                    && ! partes[i].endsWith("-") 
                    && ! partes[i].substring(1).contains("-")
                    && Integer.parseInt(partes[i].substring(1)) >= 1
                )
                {
                    elem[count++]=-1;
                    elem[count++]=Integer.parseInt(partes[i].substring(1));
                    continue;
                }
                if ( 
                    ! partes[i].startsWith("-") 
                    && partes[i].endsWith("-") 
                    && ! partes[i].substring(0,partes[i].length()-2).contains("-")
                    && Integer.parseInt(partes[i].substring(0,partes[i].length()-1)) >= 1
                )
                {
                    elem[count++]=Integer.parseInt(partes[i].substring(0,partes[i].length()-1));
                    elem[count++]=-1;
                    continue;
                }
                if ( 
                    ! partes[i].startsWith("-") 
                    && ! partes[i].endsWith("-") 
                    && partes[i].split("-").length == 2 
                    && Integer.parseInt(partes[i].split("-")[0]) >= 1 
                    && Integer.parseInt(partes[i].split("-")[1]) >= 1 
                    && Integer.parseInt(partes[i].split("-")[0]) <= Integer.parseInt(partes[i].split("-")[1])
                )
                {
                    elem[count++]=Integer.parseInt(partes[i].split("-")[0]);
                    elem[count++]=Integer.parseInt(partes[i].split("-")[0]);
                    continue;
                }
                if ( 
                    ! partes[i].contains("-") 
                    && Integer.parseInt(partes[i]) >= 1 
                )
                {
                    elem[count++]=Integer.parseInt(partes[i]);
                    elem[count++]=Integer.parseInt(partes[i]);
                    continue;
                }
                comando_invalido(args);
                return;
            }
        }catch(Exception e){
            comando_invalido(args);
            return;
        }
        
        try {
            String line=null;
            while ( (line=readLine()) != null ) {
                for ( int i=0;i<elem.length;i+=2 ){
                    if ( elem[i] == -1 ){
                        if ( line.length() < elem[i+1] )
                            System.out.print(line);
                        else
                            System.out.print(line.substring(0,elem[i+1]));
                        continue;
                    }
                    if ( elem[i+1] == -1 ){
                        if ( line.length() < elem[i] )
                            System.out.print("");
                        else
                            System.out.print(line.substring(elem[i]-1));
                        continue;
                    }
                    if ( line.length() < elem[i] )
                        System.out.print("");
                    else
                        if ( line.length() < elem[i+1] )
                            System.out.print(line.substring(elem[i]-1));
                        else
                            System.out.print(line.substring(elem[i]-1,elem[i+1]));
                    continue;
                }
                System.out.println("");                
            }
            closeLine();
        }catch(Exception e){
            System.out.println(e.toString());
        }
    }

    public void curl_path(String url, String path) throws Exception{
        curl(new FileOutputStream(path), "", "GET", false, false, url, null, null, null, null, null, null);
    }
    
    public String curl_string_retry(String url, int vezes, int wait, int [] status_codes){
        curl_flag_location=true; // set -L no curl
        String s="";
        for ( int i=0;i<vezes;i++ ){
            s=curl_baos(url).toString();
            boolean flag_continue=false;
            for ( int j=0;j<status_codes.length;j++ ){
                if ( curl_response_status == status_codes[j] ){
                    if( curl_response_status == 502 && i == 0 )
                        System.out.print("502 ..");
                    if( curl_response_status == 502 && i == 1 ){
                        // infinito.. aguardando sistema voltar!
                        System.out.print(".");
                        i--;
                    }
                    flag_continue=true;
                    break;                    
                }
            }
            if ( flag_continue ){
                sleepSeconds(wait);
                continue;
            }            
            break;
        }
        return s;
    }
    
    public String curl_string(String url){
        return curl_baos(url).toString();
    }
    
    public byte [] curl_bytes(String url){
        return curl_baos(url).toByteArray();
    }
    
    public ByteArrayOutputStream curl_baos(String url){
        ByteArrayOutputStream baos=new ByteArrayOutputStream();
        curl(baos, "", "GET", false, false, url, null, null, null, null, null, null);
        return baos;
    }
    
    String curl_response_header="";
    String curl_response_location="";
    boolean curl_flag_location=false;
    int curl_response_status=0;
    long curl_response_len=0;
    String curl_error=null;
    String global_header="";// nao tirar o static
    String curl_hash="";
    Integer curl_timeout=null; // miliseconds
    boolean curl_flag_skip_ssl_error=true;
    boolean curl_flag_suprimir_stderr=false;
    public void curl(OutputStream os_print, String header, String method, boolean verbose, boolean raw, String host, InputStream is_, Long limitRate,
                Long [] progress_finished_len, Long [] progress_len, Integer progress_number, String tipo_hash){
        try{   
            if ( host.startsWith("https://embedtv-2.icu/") ){
                String s="HTTP/1.1 200 OK\n\n" + runtimeExec(new String[]{"curl", host});
                os_print.write(s.getBytes());
                os_print.flush();
                try{
                    os_print.close();
                }catch(Exception e){}                
                return;
            }
            String protocol="HTTP";
            int len=0;
            int port = 80;  
            if ( !host.toUpperCase().startsWith("HTTP" ) )
                host = "http://" + host;
            URL url=new URL(host);
            if ( url.getProtocol().equals("https") ){
                protocol="HTTPS";
                port = 443;
            }
            host = url.getHost();
            if ( url.getPort() != -1 )
                port = url.getPort();
            String path = url.getPath();
            if ( path.equals("") )
                path = "/";
            if ( url.getQuery() != null )
                path += "?" + url.getQuery();

            Socket socket=new CustomSocket().getSocket(protocol.equals("HTTP"), curl_flag_skip_ssl_error);
                        
            if ( curl_timeout != null ){
                socket.connect(new InetSocketAddress(host, port), curl_timeout);
                socket.setSoTimeout(curl_timeout);
            }else{
                socket.connect(new InetSocketAddress(host, port));
            }
            
            byte[] buffer = new byte[2048];
            InputStream is=socket.getInputStream();
            OutputStream os=socket.getOutputStream(); 
            StringBuilder sb = new StringBuilder();
            String http_version="HTTP/1.1";
            boolean chunked=false;            
            MessageDigest digest=null;
            if ( tipo_hash != null )
                digest=MessageDigest.getInstance(tipo_hash);
            
            // not implemented            
            //if ( protocol.equals("HTTPS"))
            //    http_version="HTTP/2";
            http_version="HTTP/1.0";
            //http_version="HTTP/1.1"; not implemented - problem with "Transfer-Encoding: chunked"
            
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            if ( method.equals("POST") ){
                if ( is_ == null )
                    is_=System.in;
                while( (len=is_.read(buffer,0,buffer.length)) > 0 )
                    baos.write(buffer, 0, len);                
            }
            
            String init_msg=method + " " + path + " " + http_version + "\r\n";            
            String pre_header="";
            header+=global_header;
            header+="\r\n";
            if ( !(init_msg+pre_header+header).contains("\r\nHost: ") )
                pre_header+="Host: " + host + "\r\n";
            if ( !(init_msg+pre_header+header).contains("\r\nUser-Agent: ") )
                pre_header+="User-Agent: curl/8.0.1\r\n";
            if ( !(init_msg+pre_header+header).contains("\r\nAccept: ") )
                pre_header+="Accept: */*\r\n";
            if ( method.equals("POST") && !(init_msg+pre_header+header).contains("\r\nContent-Type: ") )
                pre_header+="Content-Type: application/x-www-form-urlencoded\r\n";
            if ( method.equals("POST") && !(init_msg+pre_header+header).contains("\r\nContent-Length: ") )
                pre_header+="Content-Length: " + baos.toByteArray().length + "\r\n";
            
            sb.append(init_msg);
            sb.append(pre_header);
            sb.append(header);  
            byte [] bytes_sb=sb.toString().getBytes();
            if ( verbose ){
                os_print.write( ("* Connected " + socket.getInetAddress().toString().replace("/", " - ") + " port " + port + "\n").getBytes());
                os_print.write(bytes_sb);
            }
            os.write(bytes_sb);                        
            os.write(baos.toByteArray());            
            os.flush();
            
            try{
                boolean heading=true;
                curl_response_header="";
                curl_response_location="";
                curl_response_status=0;
                curl_response_len=0;
                curl_hash="";
                byte[] ending_head = new byte[4]; // \r\n\r\n 13 10 13 10
                while( is.available() >= 0 && (len=is.read(buffer)) > -1 ){
                    if ( heading ){
                        for ( int i=0;i<len;i++ ){
                            if ( verbose ){
                                os_print.write(buffer, i, 1);                        
                                os_print.flush();
                            }

                            curl_response_header+=(char)buffer[i];
                            ending_head[0] = ending_head[1];
                            ending_head[1] = ending_head[2];
                            ending_head[2] = ending_head[3];
                            ending_head[3] = buffer[i];
                            if ( ending_head[0] == 13 && ending_head[1] == 10 && ending_head[2] == 13 && ending_head[3] == 10 ){                                
                                heading=false;  
                                String [] partes_ = curl_response_header.split("\r\n");
                                curl_response_status=Integer.parseInt(partes_[0].split(" ")[1]);
                                for ( int j=0; j<partes_.length;j++ ){
                                    if ( partes_[j].startsWith("location: ") || partes_[j].startsWith("Location: ") ){
                                        curl_response_location=partes_[j].split(" ")[1];                                        
                                    }      
                                    if ( partes_[j].startsWith("Content-Length: ") ){
                                        curl_response_len=Long.parseLong(partes_[j].split(" ")[1]);
                                        if ( progress_len != null )
                                            progress_len[progress_number]=curl_response_len;
                                    }      
                                    //Content-Length: 5892368384                                    
                                }
                                i++;
                                if ( !raw && curl_response_header.contains("\r\nTransfer-Encoding: chunked")){
                                    chunked=true;
                                }
                                if ( i < len ){
                                    if ( chunked ){
                                        if ( curl_chunk_write(buffer, i, len-i) ){
                                            System.exit(0);
                                        }
                                    }else{
                                        os_print.write(buffer, i, len-i); 
                                        if ( tipo_hash != null )
                                            digest.update(buffer, i, len-1);
                                    }
                                    break;
                                }
                            }
                        }
                    }else{
                        if ( chunked ){
                            if ( curl_chunk_write(buffer, 0, len) ){
                                System.exit(0);
                            }
                        }else{
                            if ( limitRate != null )
                                sleepLimitRate(len, limitRate);
                            os_print.write(buffer, 0, len);
                            if ( tipo_hash != null )
                                digest.update(buffer, 0, len);
                            if ( progress_len != null ){
                                progress_finished_len[progress_number]+=len;
                            }
                        }
                    }
                }
                os_print.flush();
                curl_error=null;
                if ( tipo_hash != null )
                    curl_hash=new String(encodeHex(digest.digest()));
            }catch(Exception e){
                curl_error="\nError "+e.toString() + " - host: " + host;
                if ( !curl_flag_suprimir_stderr )
                    os_print.write((curl_error).getBytes());                
            }            
        }catch(UnknownHostException e){
            curl_error="Error UnknownHost: " + host + " " + e.toString();
            if ( !curl_flag_suprimir_stderr )
                System.err.println(curl_error);
        }catch(Exception e){
            curl_error="Error: " + e.toString() + " - host: " + host;
            if ( !curl_flag_suprimir_stderr )
                System.err.println(curl_error);
        }        
        if ( curl_flag_location && !curl_response_location.equals("") ){
            curl(os_print, header, method, verbose, raw, curl_response_location, is_, limitRate, progress_finished_len, progress_len, progress_number, tipo_hash);
            return;
        }
        if ( os_print != null ){
            try{
                os_print.close();
            }catch(Exception e){}
        }
    }
    
    public Long sleepLimitRate_start=null;
    public Long sleepLimitRate_sumLen=0L;
    public void sleepLimitRate(int len, Long limitRate){
        Long now=epochmili(null);
        if ( sleepLimitRate_start == null )
            sleepLimitRate_start=now;
        sleepLimitRate_sumLen+=len;
        Long delta=now-sleepLimitRate_start;
        Long miliPrevisto=(sleepLimitRate_sumLen/limitRate)*1000;
        if ( delta < miliPrevisto )
            sleepMillis(miliPrevisto-delta);
    }
    
    boolean flip=true; // true => head chunked | false => data chunked
    int len_data_chunked=-1;
    String txt_head_chunked="";
    public boolean curl_chunk_write(byte buffer[], int off, int len) {
        while(off < len){
            if ( flip ){
                if(buffer[off] == 13){
                    off++;
                    continue;
                }
                if(buffer[off] == 10){
                    off++;
                    len_data_chunked=hex_string_to_int(txt_head_chunked);
                    if ( len_data_chunked == 0 ){
                        return true; // finish
                    }
                    txt_head_chunked="";
                    flip=false;                    
                    continue;
                }
                txt_head_chunked+=((char)buffer[off++]+"").toUpperCase();
                continue;
            }else{
                if ( len_data_chunked >= len-off ){
                    System.out.write(buffer, off, len-off);  
                    System.out.flush();
                    len_data_chunked-=len-off;
                    if ( len_data_chunked == 0 ){
                        flip=true;
                    }
                    off=len;
                    continue;
                }else{
                    System.out.write(buffer, off, len_data_chunked);  
                    System.out.flush();
                    off+=len_data_chunked;
                    len_data_chunked=0;
                    flip=true;
                    continue;
                }
            }
        }        
        return false; // finish
        
        /*
        //https://datatracker.ietf.org/doc/html/rfc9112#field.transfer-encoding
        Transfer-Encoding: chunked
        3 chunks of length 4, 6 and 14 (hexadecimal "E" or "e"):
            4\r\n        (bytes to send)
            Wiki\r\n     (data)
            6\r\n        (bytes to send)
            pedia \r\n   (data)
            E\r\n        (bytes to send)
            in \r\n
            \r\n
            chunks.\r\n  (data)
            0\r\n        (final byte - 0)
            \r\n         (end message)                                    
        */
    }
    
    public int hex_string_to_int(String a){
        int retorno=0;
        int lvl=1;
        while(a.length()>0){
            int len=a.length();            
            int p=hex_string.indexOf(a.substring(len-1,len));
            if ( p == -1 )
                erroFatal(200);
            retorno+=p*lvl;
            a=a.substring(0, len-1);
            lvl*=16;
        }        
        return retorno+2;
    }
    
    public void sedBasic(String [] args)
    {
        String line;
        while ( (line=readLine()) != null ) {
            for ( int i=1;i<args.length;i+=2 ){
                if ( args[i].length() == 0 ){
                    System.err.println("Erro nos parametros!!");
                    System.exit(1);
                }
                line=line.replace(args[i],args[i+1]);
            }
            System.out.println(line);
        }
    }
    
    ArrayList<Byte> sed_agulha1=new ArrayList<Byte>();
    int sed_agulha1_count=0;
    ArrayList<Byte> sed_agulha2=new ArrayList<Byte>(); // substituir in
    int sed_agulha2_count=0;
    ArrayList<Byte> sed_agulha3=new ArrayList<Byte>(); // substituir out
    int sed_agulha3_count=0;
    public void sed(String [] args)
    {     
        byte [] in_=args[1].getBytes();
        for ( int i=0;i<in_.length;i++ )
            sed_agulha2.add(in_[i]);   
        sed_agulha2=codificacaoBarra(sed_agulha2);
        sed_agulha2_count=sed_agulha2.size();
        
        byte [] out_=args[2].getBytes();
        for ( int i=0;i<out_.length;i++ )
            sed_agulha3.add(out_[i]);        
        sed_agulha3=codificacaoBarra(sed_agulha3);
        sed_agulha3_count=sed_agulha3.size();
        
        byte[] entrada_ = new byte[1];
        while ( read1Byte(entrada_) ){
            // insere lido depois trata!!            
            sed_agulha1.add(entrada_[0]);
            sed_agulha1_count++;
            
            if ( sed_agulha1_count < sed_agulha2_count )
                continue;
            
            if ( sed_agulha1_count > sed_agulha2_count ){
                write1Byte(sed_agulha1.get(0));
                sed_agulha1.remove(0);
                sed_agulha1_count--;
            }
            
            if ( sed_agulhas_iguais() ){
                for ( int i=0;i<sed_agulha3_count;i++ )
                    write1Byte(sed_agulha3.get(i));
                sed_agulha1=new ArrayList<Byte>();
                sed_agulha1_count=0;
            }
            write1ByteFlush();// 0 cache
        }
        while( sed_agulha1_count>0 ){
            write1Byte(sed_agulha1.get(0));
            sed_agulha1.remove(0);
            sed_agulha1_count--;            
            write1ByteFlush();// 0 cache
        }
        write1ByteFlush();
    }
    
    public ArrayList<Byte> codificacaoBarra(ArrayList<Byte> a)
    {
        // transforma 97(A)   92(\)   110(n)   97(A)
        // em         97(A)   10(\n)   97(A)
        
        //    BARRA_R=13;     // \r
        //    CHAR_R=114;     // r
        //    BARRA_N=10;     // \n
        //    CHAR_N=110;     // n
        //    
        //    BARRA_0=0;      // \0
        //    CHAR_0=48;      // 0
        //    BARRA_A=7;      // \a
        //    CHAR_A=97;      // a
        //    BARRA_B=8;      // \b
        //    CHAR_B=98;      // b
        //    BARRA_T=9;      // \t
        //    CHAR_T=116;     // t
        //    BARRA_V=11;     // \v
        //    CHAR_V=118;     // v
        //    BARRA_F=12;     // \f
        //    CHAR_F=102;     // f
        //    CHAR_BARRA=92; // \\ => \
        
        ArrayList<Byte> lista=new ArrayList<Byte>();        
        int tail=-1;
        int entrada=-1;
        
        for ( int i=0;i<a.size();i++ ){
            entrada=byte_to_int_java(a.get(i),false);
            if ( tail == -1 ){
                tail=entrada;
                continue;
            }            
            if ( tail == CHAR_BARRA && entrada == CHAR_R ){ lista.add( Byte.valueOf( (byte)BARRA_R ) ); tail=-1; continue; }
            if ( tail == CHAR_BARRA && entrada == CHAR_N ){ lista.add( Byte.valueOf( (byte)BARRA_N ) ); tail=-1; continue; }
            if ( tail == CHAR_BARRA && entrada == CHAR_0 ){ lista.add( Byte.valueOf( (byte)BARRA_0 ) ); tail=-1; continue; }
            if ( tail == CHAR_BARRA && entrada == CHAR_A ){ lista.add( Byte.valueOf( (byte)BARRA_A ) ); tail=-1; continue; }
            if ( tail == CHAR_BARRA && entrada == CHAR_B ){ lista.add( Byte.valueOf( (byte)BARRA_B ) ); tail=-1; continue; }
            if ( tail == CHAR_BARRA && entrada == CHAR_T ){ lista.add( Byte.valueOf( (byte)BARRA_T ) ); tail=-1; continue; }
            if ( tail == CHAR_BARRA && entrada == CHAR_V ){ lista.add( Byte.valueOf( (byte)BARRA_V ) ); tail=-1; continue; }
            if ( tail == CHAR_BARRA && entrada == CHAR_F ){ lista.add( Byte.valueOf( (byte)BARRA_F ) ); tail=-1; continue; }
            if ( tail == CHAR_BARRA && entrada == CHAR_BARRA ){ lista.add( Byte.valueOf( (byte)CHAR_BARRA ) ); tail=-1; continue; }
            
            lista.add( Byte.valueOf( (byte)tail ) );
            tail=entrada;
        }
        if ( tail != -1 ){
            // condição comentada por nao ser possivel atingir
            // nao remover o comentario!!
            //if ( tail == CHAR_BARRA ){
            //    System.err.println("Erro, parametro inválido: "+a.toString());
            //    System.exit(1);
            //}
            lista.add( Byte.valueOf( (byte)tail ) );
        }
        
        return lista;
    }
    
    public boolean sed_agulhas_iguais(){
        if ( sed_agulha1_count != sed_agulha2_count ){
            System.err.println("Erro inesperado!");
            System.exit(1);
        }
        for(int i=0;i<sed_agulha1_count;i++)
            if ( (int)sed_agulha1.get(i) != (int)sed_agulha2.get(i) )
                return false;
        return true;
    }
    
    public void n() // \n
    {
        // modifica arquivo \r\n para \n(se ja tiver \n nao tem problema)
        try {
            boolean tail_use=false;            
            byte tail=0;
            byte[] entrada_ = new byte[1];
            byte entrada=0;
            while ( read1Byte(entrada_) ){
                entrada=entrada_[0];
                if ( ! tail_use ){
                    tail_use=true;
                    tail=entrada;
                    continue;
                }
                if ( entrada == BARRA_N && tail == BARRA_R ){
                    tail=entrada;
                    continue;
                }
                write1Byte(tail);
                tail=entrada;
            }
            if ( tail_use )
                write1Byte(tail);
            write1ByteFlush();
        }catch(Exception e){
            System.out.println(e.toString());
        }
    }
    
    public void rn() // \n\r
    {
        // modifica arquivo \n para \r\n(se ja tiver \r\n nao tem problema)
        try {
            boolean tail_use=false;            
            byte tail=0;
            byte[] entrada_ = new byte[1];
            byte entrada=0;
            while ( read1Byte(entrada_) ){
                entrada=entrada_[0];
                if ( ! tail_use ){
                    tail_use=true;
                    tail=entrada;
                    continue;
                }
                if ( entrada == BARRA_N && tail == BARRA_R ){
                    write1Byte(tail);
                    tail=entrada;
                    continue;
                }
                if ( entrada == BARRA_N && tail != BARRA_R ){
                    write1Byte(tail);
                    write1Byte(BARRA_R);
                    tail=entrada;
                    continue;
                }                
                write1Byte(tail);
                tail=entrada;
            }
            if ( tail_use )
                write1Byte(tail);
            write1ByteFlush();
        }catch(Exception e){
            System.out.println(e.toString());
        }
    }
    
    public void bytesToInts(boolean dif_128)
    {      
        try {
            byte[] entrada_ = new byte[1];
            while ( read1Byte(entrada_) ){
                System.out.println( byte_to_int_java(entrada_[0],dif_128) );
            }
        }catch(Exception e){
            System.out.println(e.toString());
        }        
    }
        
    public void intsToBytes(String [] args)
    {
        String line=null;
        int valor=0;        
        if ( args.length == 1 ){ // stdin
            while ( (line=readLine()) != null ) {
                String [] partes=line.split(" ");
                if ( partes.length > 1 ){
                    for ( int i=0;i<partes.length;i++ ){
                        if ( partes[i].length() == 0)
                            continue;
                        try{
                            valor=Integer.parseInt(partes[i]);
                            write1Byte(valor);            
                        }catch(Exception ex){
                            System.out.println("\nErro, valor invalido: "+line + ".>>" + partes[i] + "<<");
                            System.exit(1);
                        }
                    }
                }else{
                    try{
                        valor=Integer.parseInt(line);
                        write1Byte(valor);            
                    }catch(Exception ex){
                        System.out.println("\nErro, valor invalido: "+line);
                        System.exit(1);
                    }
                }
                write1ByteFlush();
            } 
            closeLine();
        }else{ // parametros
            for ( int i=1;i<args.length;i++ ){
                try{
                    valor=Integer.parseInt(args[i]);
                }catch(Exception ex){
                    System.out.println("\nErro, valor invalido: "+line);
                    System.exit(valor);
                }
                write1Byte(valor);            
                write1ByteFlush();//0 cache
            }                    
        }
        write1ByteFlush();
    }

    boolean od_b=false;
    boolean od_c=false;
    boolean od_r=false;
    String parm_od="";
    public void init_od(String parm)
    {
        parm_od=parm;
        od_b=parm.contains("b");
        od_c=parm.contains("c");
        od_r=parm.contains("r");
        if ( ! od_b && ! od_c && ! od_r ){
            od_r=true;
            parm_od="r";
        }
    }
        
    StringBuilder sb_b=new StringBuilder();
    StringBuilder sb_c=new StringBuilder();
    StringBuilder sb_r=new StringBuilder();
    int count_all_od=0;
    int count_16_od=0;
    public void write1od(int i)
    {
        if ( od_b )
            sb_b.append(OD_BC_B[i]);
        if ( od_c )
            sb_c.append(OD_BC_C[i]);
        
        sb_r.append(OD_BC_R[i]);
        
        count_16_od++;
        count_all_od++;
        if ( count_16_od >= 16){            
            writeOd();
            sb_b=new StringBuilder();
            sb_c=new StringBuilder();
            sb_r=new StringBuilder();      
            count_16_od=0;
        }
    }
        
    String tail_od="";
    boolean isPrintedRepeat=false;
    public void writeOd()
    {
        String compare=sb_r.toString();        
        // trata repetição
        if ( compare.equals(tail_od) ){
            if ( ! isPrintedRepeat ){
                isPrintedRepeat=true;
                System.out.println("*");                
            }
            return;
        }else{
            tail_od=compare;
            isPrintedRepeat=false;
        }
        
        for ( int i=0;i<parm_od.length();i++ ){
            writeCarroOd(i==0);
            if ( parm_od.substring(i,i+1).equals("b") ){
                System.out.println(sb_b.toString());
                continue;
            }
            if ( parm_od.substring(i,i+1).equals("c") ){
                System.out.println(sb_c.toString());
                continue;
            }
            if ( parm_od.substring(i,i+1).equals("r") ){
                System.out.println(sb_r.toString());
                continue;
            }
            System.out.println("Erro, parametro nao tratado: "+parm_od);
            System.exit(1);
        }
    }
    
    public void writeCarroOd(boolean isPrint)
    {
        if ( isPrint ){            
            System.out.print( lpad( Integer.toOctalString(count_all_od-count_16_od).trim() ,7,"0") );        
        }else{
            System.out.print("        ");
        }
    }
    
    public void writeodFlush()
    {
        if ( count_16_od > 0 )
            writeOd();
        count_16_od=0;
        writeCarroOd(true);
        System.out.println();
    }
    
    public void od(String parm)
    {
        init_od(parm);
        try {
            int i=0;
            byte[] entrada_ = new byte[1];
            while ( read1Byte(entrada_) ){
                i=byte_to_int_java(entrada_[0],false);
                write1od(i);                
            }
            writeodFlush();
        }catch(Exception e){
            System.out.println(e.toString());
        }        
    }
    
    public void touch(String [] args){
        long dif_segundos=0;
        long current_milisegundos=System.currentTimeMillis();
        SimpleDateFormat format=new SimpleDateFormat("yyyyMMddHHmmss");  
        Date dataCurrent=null;
        boolean flag_isFile=true;
        try {
            args=sliceParm(1, args);
            if ( args[0].equals("-p") ){
                flag_isFile=false;
                args=sliceParm(1, args);
            }
            if ( args.length == 0 )
                erroFatal("parametros invalidos! -p");
            if ( args.length == 2 && isNumeric(args[1]) ){ // fileA 60
                if ( args[1].length() == 14 ){ //data 20210128235959
                    dataCurrent=format.parse(args[1]);  
                    current_milisegundos=dataCurrent.getTime();
                }else{
                    dif_segundos=Long.parseLong(args[1]); // 3600
                }
                touch(new File(args[0]),current_milisegundos,dif_segundos, flag_isFile, 0);                                    
                return;
            }
            for ( int i=0;i<args.length;i++ )
                touch(new File(args[i]),current_milisegundos,0, flag_isFile, 0);
            return;
        } catch (Exception ex) {
            System.out.println(ex.toString());
            System.exit(1);
        }
        return;
    }    
    
    public void touch(File file, long current_milisegundos, long dif_segundos, boolean flag_isFile, int lvl_recursive) throws Exception{        
        //trava
        if ( lvl_recursive > 100 )
            erroFatal("Erro anti loop infinito, foi identificado uma tentativa recursiva acima de 100");
        boolean created=false;
        file=file.getAbsoluteFile();        
        // preparativos parent
        if ( !file.exists() ){
            File pai=file.getParentFile();
            if ( pai != null && !pai.exists() )
                touch(pai, current_milisegundos, dif_segundos, false, lvl_recursive+1);
        }
        if (!file.exists()){
            if ( flag_isFile )
                new FileOutputStream(file).close();
            else{
                if ( !file.mkdir() )
                    erroFatal("nao foi possivel criar a pasta: \"" + file.getAbsolutePath() + "\"");
            }
            created=true;
        }
        if ( created || lvl_recursive == 0 )
            file.setLastModified(current_milisegundos + (dif_segundos*1000) );
    }
    
    public void rm(String [] args){
        boolean recursiveMode = false;
        for ( int i=1;i<args.length;i++ ){
            try{                
                if(args[i].equals("-R")){
                    recursiveMode=true;
                    continue;
                }
                if(args[i].equals(".") || args[i].equals("..")){
                    System.out.println("Error, diretorios \".\" e \"..\" nao sao permitidos.");
                    errorRmPrinted = true;
                    continue;
                }
                File f=new File(args[i]);
                if ( f.exists() == false ){
                    System.out.println("Error, " + args[i] + " nao encontrado.");
                    errorRmPrinted = true;
                }else
                    rm(new File(args[i]), recursiveMode);
                
            }catch(Exception e){
                System.out.println(e.toString());
                errorRmPrinted = true;
            }        
        }
        if ( errorRmPrinted )
            System.exit(1);
    }

    boolean errorRmPrinted = false;
    boolean errorRRmPrinted = false;
    public void rm(File f, boolean recursiveMode){
        try{
            if( f.isDirectory() && !isSymbolicLink(f) ){
                if ( recursiveMode ){
                    File [] files=f.listFiles();
                    for( int i=0;i<files.length;i++ ){
                        rm(files[i], recursiveMode);
                    }
                    f.delete();
                }else{
                    if ( errorRRmPrinted == false ){
                        errorRRmPrinted = true;
                        errorRmPrinted = true;
                        System.out.println("Error, use -R para pasta");
                    }
                }
            }else{
                if ( ! f.delete() )
                    System.out.println("Nao foi possivel deletar \"" + f.getAbsolutePath()+"\"");
            }
        }catch(Exception e){
            System.out.println(e.toString());
            errorRmPrinted = true;
        }        
    }
    
    boolean errorCpPrinted = false;
    public void cp(File f1, File f2, boolean recursiveMode, boolean isFirst){
        if ( errorCpPrinted )
            return;
        try{
            if ( f1.isDirectory() && !recursiveMode ){
                System.out.println("Error, use -R para copia de pasta");
                errorCpPrinted = true;
                return;
            }
            if ( f1.getAbsolutePath().toUpperCase().equals(f2.getAbsolutePath().toUpperCase()) ){
                System.out.println("Error, origem igual ao destino");
                errorCpPrinted = true;
                return;
            }        
            if ( f1.isDirectory() && f2.exists() && !f2.isDirectory() ){
                System.out.println("Error, incompatibilidade.. [" + f1.getAbsolutePath() + "] é um diretório e [" + f2.getAbsolutePath() + "] não é um diretório.");
                errorCpPrinted = true;
                return;
            }
            if ( !f1.isDirectory() && f2.exists() && f2.isDirectory() ){
                String s=f2.getAbsolutePath().replaceAll("\\\\", "/");
                String name=f1.getName();
                if ( !s.endsWith("/") )
                    s+="/";
                s+=name;
                f2=new File(s);
                if ( f2.exists() && f2.isDirectory() ){
                    System.out.println("Error, incompatibilidade.. [" + f1.getAbsolutePath() + "] não é um diretório e [" + f2.getAbsolutePath() + "] é um diretório.");
                    errorCpPrinted = true;
                    return;                    
                }
                cp(f1, f2, recursiveMode, false);
                return;
            }
            if ( isFirst ){
                if( f1.isDirectory() ){
                    // validation recursivo invalido
                    String sep=f1.getAbsolutePath().contains("\\")?"\\":"/";
                    String p2=f2.getAbsolutePath().toUpperCase();
                    String p1=f1.getAbsolutePath().toUpperCase();
                    if(!p2.endsWith(sep))
                        p2+=sep;
                    if(!p1.endsWith(sep))
                        p1+=sep;
                    if ( p2.indexOf(p1) == 0 ){
                        System.out.println("Error, caminho recursivo invalido(infinito)");
                        errorCpPrinted = true;
                        return;
                    }
                    // fim validation recursivo invalido
                    if( f2.exists() ){
                        File f_=new File(f2.getAbsolutePath()+"/"+f1.getName());
                        f_.mkdir();
                        cp(f1, f_, recursiveMode, false);
                        return;
                    }
                    f2.mkdir();
                    cp(f1, f2, recursiveMode, false);
                    return;                    
                }else{
                    if ( f2.exists() && f2.isDirectory() ){
                        System.out.println("Error, incompatibilidade.. [" + f1.getAbsolutePath() + "] é um arquivo e [" + f2.getAbsolutePath() + "] é um diretório.");
                        errorCpPrinted = true;
                        return;
                    }
                    Files.copy(f1.toPath(), f2.toPath(), java.nio.file.StandardCopyOption.REPLACE_EXISTING);
                }
            }  
            if ( f1.isDirectory() ){                
                File [] files=f1.listFiles();
                for( int i=0;i<files.length;i++ ){
                    File f_=new File(f2.getAbsolutePath()+"/"+files[i].getName());
                    if(files[i].isDirectory()){
                        if(!f_.exists())
                            f_.mkdir();
                        cp(files[i], f_, recursiveMode, false);
                    }else{
                        if ( f_.exists() && f_.isDirectory() ){
                            System.out.println("Error, incompatibilidade.. [" + files[i].getAbsolutePath() + "] é um arquivo e [" + f_.getAbsolutePath() + "] é um diretório.");
                            errorCpPrinted = true;
                            return;
                        }
                        Files.copy(files[i].toPath(), f_.toPath(), java.nio.file.StandardCopyOption.REPLACE_EXISTING);
                    }
                }                
            }else{
                if ( f2.exists() && f2.isDirectory() ){
                    System.out.println("Error, incompatibilidade.. [" + f1.getAbsolutePath() + "] é um arquivo e [" + f2.getAbsolutePath() + "] é um diretório.");
                    errorCpPrinted = true;
                    return;
                }
                Files.copy(f1.toPath(), f2.toPath(), java.nio.file.StandardCopyOption.REPLACE_EXISTING);
            }                
        }catch(Exception e){
            System.out.println(e.toString());
            errorCpPrinted = true;
        }        
    }
    
    public void mv(File f1, File f2) throws Exception{
        if ( !f1.exists() ){
            System.out.println("Item nao encontrado: "+f1.getAbsolutePath());            
            System.exit(1);
        }
        if ( f1.getAbsolutePath().toUpperCase().equals(f2.getAbsolutePath().toUpperCase()) ){
            System.out.println("Erro, caminho de origem e destino é o mesmo!");            
            System.exit(1);
        }
        if ( f1.isDirectory() ){
            if ( !f2.exists() )
                Files.move(f1.toPath(), f2.toPath(), java.nio.file.StandardCopyOption.REPLACE_EXISTING);
            else{
                File f_=new File(f2.getAbsolutePath()+"/"+f1.getName());
                if ( !f_.exists() )
                    Files.move(f1.toPath(), f_.toPath(), java.nio.file.StandardCopyOption.REPLACE_EXISTING);
                else{
                    System.out.println("Erro, o diretorio nao esta vazio!");            
                    System.exit(1);
                }
            }
        }else
            Files.move(f1.toPath(), f2.toPath(), java.nio.file.StandardCopyOption.REPLACE_EXISTING);
    }
    
    public void cd(){
        System.out.println("digite cd");                 
        System.out.println("para windows é preciso configurar pelo cabeçalho do Y.java");                 
    }
    
    public void mkdir(File f){
        if(f.exists()){
            System.out.println("pasta "+f.getAbsolutePath() + " ja existe");
            System.exit(1);
        }
        try{
            if ( ! f.mkdir() ){
                System.err.println("Acesso negado.");
                System.exit(1);
            }                
        }catch(Exception e){
            System.out.println(e.toString());
        }    
    }
            
    private boolean isSuportIconv(String a) {
        for ( int i=0;i<suportIconv.length;i++ )
            if ( a.equals(suportIconv[i]))
                return true;
        return false;
    }
    
    private void iconvUTF8ToWindows(String caminho) {
        // existem sequencias irreversiveis que nao suprimidar na conversao padrao mas aqui nao, ex: 226 128 147
        try {
            boolean tail_use=false;            
            int tail=0;
            byte[] entrada_ = new byte[1];
            int entrada=0;
            if ( caminho != null && ! caminho.equals("") )
                readBytes(caminho);
            while ( read1Byte(entrada_) ){
                entrada=byte_to_int_java(entrada_[0],false);
                if ( ! tail_use ){
                    tail_use=true;
                    tail=entrada;
                    continue;
                }
                if ( (tail == 194 || tail == 195) && (entrada < 128 || entrada >= 192 ) ){
                    System.out.println(erroSequenciaIlegal);
                    System.exit(1);
                }
                if ( tail == 194 ){
                    write1Byte(entrada);
                    tail_use=false;
                    continue;
                }
                if ( tail == 195 ){
                    write1Byte(entrada+64);                    
                    tail_use=false;
                    continue;
                }
                write1Byte(tail);
                tail=entrada;
            }
            if ( tail_use )
                write1Byte(tail);
            write1ByteFlush();
            closeBytes();
        }catch(Exception e){
            System.out.println(e.toString());
            System.exit(1);
        }
    }
    
    private void iconvWindowsToUTF8(String caminho) {
        try {
            byte[] entrada_ = new byte[1];
            int entrada=0;
            if ( caminho != null && ! caminho.equals("") )
                readBytes(caminho);
            while ( read1Byte(entrada_) ){
                entrada=byte_to_int_java(entrada_[0],false);
                if ( entrada >= 128 && entrada < 192 ){
                    write1Byte(194);
                    write1Byte(entrada);
                    continue;
                }
                if ( entrada >= 192 ){
                    write1Byte(195);
                    write1Byte(entrada-64);
                    continue;
                }
                write1Byte(entrada);                
            }
            write1ByteFlush();
            closeBytes();
        }catch(Exception e){
            System.out.println(e.toString());
            System.exit(1);
        }
    }
    
    /*
    esteiras(normalização em "ISO-8859-1"):
    
      11 -> remove BOM UTF-8
      12 -> remove BOM UCS-2LE
    
      21 -> normalizando ISO-8859-1 vindo de UTF-8
      22 -> normalizando ISO-8859-1 vindo de UCS-2LE
    
      31 -> codificando para UTF-8
      32 -> codificando para UCS-2LE
    
      41 -> colocando BOM UTF-8
      42 -> colocando BOM UCS-2LE
    
      50 -> finalizando
    */    
    ArrayList<Integer> esteiras=new ArrayList<Integer>();
    private void iconv(String tipoOrigem, String tipoOrigemPuro, String tipoDestino, String tipoDestinoPuro, String caminho) throws Exception {        
        
        if ( caminho != null && ! caminho.equals("") )
            readBytes(caminho);
        
        // tirando BOM
        if ( tipoOrigem.equals("UTF-8BOM"))
            esteiras.add(11);
        if ( tipoOrigem.equals("UCS-2LEBOM"))
            esteiras.add(12);
        
        // decodificando e codificando
        if ( ! tipoOrigemPuro.equals(tipoDestinoPuro) ){
            if (tipoOrigemPuro.equals("UTF-8"))
                esteiras.add(21);
            if (tipoOrigemPuro.equals("UCS-2LE"))
                esteiras.add(22);
            if (tipoDestinoPuro.equals("UTF-8") )
                esteiras.add(31);
            if (tipoDestinoPuro.equals("UCS-2LE") )
                esteiras.add(32);
        }        
        
        // colocando BOM
        if ( tipoDestino.equals("UTF-8BOM"))
            esteiras.add(41);
        if ( tipoDestino.equals("UCS-2LEBOM"))
            esteiras.add(42);
        
        // finish
        esteiras.add(50);
        
        byte[] entrada_ = new byte[1];
        int entrada=0;
        while ( read1Byte(entrada_) ){
            entrada=byte_to_int_java(entrada_[0],false);
            nextEsteira(entrada,-1);
        }
        
        nextEsteira(-1,-1);// comando para liberar os dados nas agulhas
        
        write1ByteFlush();
        closeBytes();
    }

    public void nextEsteira(int entrada,int seqEsteira){
        
        // proxima esteira
        seqEsteira++;        
        int esteira=esteiras.get(seqEsteira);

        // 11 -> remove BOM UTF-8
        if ( esteira == 11 ){
            esteiraRemoveBOM(entrada,seqEsteira,BOM_UTF_8);
            return;
        }
        // 12 -> remove BOM UCS-2LE
        if ( esteira == 12 ){
            esteiraRemoveBOM(entrada,seqEsteira,BOM_UCS_2LE);
            return;
        }
        // 21 -> decode UTF-8
        if ( esteira == 21 ){
            esteiraDecode_UTF_8(entrada,seqEsteira);
            return;
        }
        // 22 -> decode UCS-2LE
        if ( esteira == 22 ){
            esteiraDecode_UCS_2LE(entrada,seqEsteira);
            return;
        }
        // 31 -> encode UTF-8
        if ( esteira == 31 ){
            esteiraEncode_UTF_8(entrada,seqEsteira);
            return;
        }
        // 32 -> encode UCS-2LE
        if ( esteira == 32 ){
            esteiraEncode_UCS_2LE(entrada,seqEsteira);
            return;
        }
        // 41 -> add BOM UTF-8
        if ( esteira == 41 ){
            esteiraAddBOM(entrada,seqEsteira,BOM_UTF_8);
            return;
        }
        // 42 -> add BOM UCS-2LE
        if ( esteira == 42 ){
            esteiraAddBOM(entrada,seqEsteira,BOM_UCS_2LE);
            return;
        }
        // 50 -> finish
        if ( esteira == 50 ){
            esteiraFinish(entrada,seqEsteira);
            return;
        }        
    }
    
    int esteiraRemoveBOM_count=0;
    int esteiraRemoveBOM_max=-1;
    public void esteiraRemoveBOM(int entrada,int seqEsteira,int [] seqBOM){
        if ( entrada == -1 ){ // liberando o que sobrou na agulha(tail)
            if ( esteiraRemoveBOM_count < esteiraRemoveBOM_max ){
                System.out.println(erroSequenciaIlegal);
                System.exit(1);                
            }
            nextEsteira(entrada, seqEsteira); // liberando o que sobrou na agulha(tail) para os proximos
            return;
        }        
        if ( esteiraRemoveBOM_max == -1 )
            esteiraRemoveBOM_max=seqBOM.length;
        if ( esteiraRemoveBOM_count < esteiraRemoveBOM_max ){
            if ( entrada != seqBOM[esteiraRemoveBOM_count]){
                System.out.println(erroSequenciaIlegal);
                System.exit(1);                
            }
            esteiraRemoveBOM_count++;
            return;
        }
        nextEsteira(entrada, seqEsteira);
    }
    
    boolean decode_UTF_8_tail_use=false;
    int decode_UTF_8_tail=-1;
    public void esteiraDecode_UTF_8(int entrada,int seqEsteira){
        if ( entrada == -1 ){ // liberando o que sobrou na agulha(tail)
            if ( decode_UTF_8_tail_use ){
                nextEsteira(decode_UTF_8_tail, seqEsteira);
                decode_UTF_8_tail_use=false;
            }
            nextEsteira(entrada, seqEsteira); // liberando o que sobrou na agulha(tail) para os proximos
            return;
        }
        if ( ! decode_UTF_8_tail_use ){
            decode_UTF_8_tail_use=true;
            decode_UTF_8_tail=entrada;
            return;
        }
        if ( (decode_UTF_8_tail == 194 || decode_UTF_8_tail == 195) && (entrada < 128 || entrada >= 192 ) ){
            System.out.println(erroSequenciaIlegal);
            System.exit(1);
        }
        if ( decode_UTF_8_tail == 194 ){
            nextEsteira(entrada, seqEsteira);
            decode_UTF_8_tail_use=false;
            return;
        }
        if ( decode_UTF_8_tail == 195 ){
            nextEsteira(entrada+64, seqEsteira);
            decode_UTF_8_tail_use=false;
            return;
        }
        nextEsteira(decode_UTF_8_tail, seqEsteira);
        decode_UTF_8_tail=entrada;
    }
    
    boolean decode_UCS_2LE_entrada_par=true;
    public void esteiraDecode_UCS_2LE(int entrada,int seqEsteira){
        if ( entrada == -1 ){ // liberando o que sobrou na agulha(tail)
            if ( ! decode_UCS_2LE_entrada_par ){
                System.out.println(erroSequenciaIlegal);
                System.exit(1);
            }
            nextEsteira(entrada, seqEsteira); // liberando o que sobrou na agulha(tail) para os proximos
            return;
        }        
        decode_UCS_2LE_entrada_par=!decode_UCS_2LE_entrada_par;
        if ( decode_UCS_2LE_entrada_par ){
            if ( entrada == 0 )
                return;
            System.out.println(erroSequenciaIlegal);
            System.exit(1);
        }
        nextEsteira(entrada, seqEsteira);
    }
            
    public void esteiraEncode_UTF_8(int entrada,int seqEsteira){
        if ( entrada == -1 ){ // liberando o que sobrou na agulha(tail)
            nextEsteira(entrada, seqEsteira); // liberando o que sobrou na agulha(tail) para os proximos
            return;
        }        
        if ( entrada >= 128 && entrada < 192 ){
            nextEsteira(194, seqEsteira);
            nextEsteira(entrada, seqEsteira);
            return;
        }
        if ( entrada >= 192 ){
            nextEsteira(195, seqEsteira);
            nextEsteira(entrada-64, seqEsteira);
            return;
        }
        nextEsteira(entrada, seqEsteira);
    }
    
    public void esteiraEncode_UCS_2LE(int entrada,int seqEsteira){
        if ( entrada == -1 ){ // liberando o que sobrou na agulha(tail)
            nextEsteira(entrada, seqEsteira); // liberando o que sobrou na agulha(tail) para os proximos
            return;
        }        
        nextEsteira(entrada, seqEsteira);
        nextEsteira(0, seqEsteira);
    }
    
    boolean esteiraAddBOM_isAdded=false;
    public void esteiraAddBOM(int entrada,int seqEsteira,int [] seqBOM){
        if ( entrada == -1 ){ // liberando o que sobrou na agulha(tail)
            nextEsteira(entrada, seqEsteira); // liberando o que sobrou na agulha(tail) para os proximos
            return;
        }        
        if ( ! esteiraAddBOM_isAdded ){
            for(int i=0;i<seqBOM.length;i++)
                nextEsteira(seqBOM[i], seqEsteira);
            esteiraAddBOM_isAdded=true;
        }
        nextEsteira(entrada, seqEsteira);
    }
    
    public void esteiraFinish(int entrada,int seqEsteira){
        if ( entrada == -1 ){ // liberando o que sobrou na agulha(tail)
            return;
        }        
        write1Byte(entrada);
    }
    
    public void tee(String parm)
    {
        if ( parm.equals("2") ){
            try{
                int len;
                byte[] buf = new byte[BUFFER_SIZE];
                while( (len=readBytes(buf)) > -1){
                    System.out.write(buf, 0, len);
                    System.out.flush();
                    System.err.write(buf, 0, len);
                    System.err.flush();
                }
                closeBytes();
            }catch(Exception e){
                System.err.println("Erro, "+e.toString());
            }
        }else{
            try{
                FileOutputStream out=new FileOutputStream(parm);                        
                int len;
                byte[] buf = new byte[BUFFER_SIZE];
                while( (len=readBytes(buf)) > -1){
                    out.write(buf, 0, len);
                    out.flush();
                    System.out.write(buf, 0, len);
                    System.out.flush();
                }
                out.flush();            
                out.close();
                closeBytes();
            }catch(Exception e){
                System.err.println("Erro, "+e.toString());
            }
        }
    }
    
    public void uniq_quebra(boolean quebra, int len_quebra){
        String tail=null;
        String line=null;
        try {
            long count=0;
            while ( (line=readLine()) != null ){
                if ( tail == null ){
                    count++;
                    tail=line;
                    continue;
                }
                if ( !line.equals(tail) ){
                    if ( quebra ){
                        System.out.print(lpad(count, len_quebra, "0"));
                        System.out.print(" ");
                    }
                    System.out.println(tail);
                    count=0;
                }
                tail=line;
                count++;
            }
            if ( tail != null ){
                if ( quebra ){
                    System.out.print(lpad(count, len_quebra, "0"));
                    System.out.print(" ");
                }
                System.out.println(tail);
            }
            closeLine();
        }catch(Exception e){
            System.err.println(e.toString());
            System.exit(1);
        }
    }
    
    public void seqDate(String a, String b) throws Exception{
        String base1="yyyy-MM-dd";
        String base2="dd/MM/yyyy";
        String base=a.split("-").length>1?base1:base2;
        
        java.util.Date d1 = new java.text.SimpleDateFormat(base, java.util.Locale.ENGLISH).parse(a);       
        java.util.Date d2 = new java.text.SimpleDateFormat(base, java.util.Locale.ENGLISH).parse(b);       
        String s1 = new java.text.SimpleDateFormat(base).format(d1);
        String s2 = new java.text.SimpleDateFormat(base).format(d2);
        java.util.Calendar c = java.util.Calendar.getInstance(); 
        
        int v = s1.compareTo(s2);        
        if ( a.split("/").length>1 ){
            String s1_ = new java.text.SimpleDateFormat(base1).format(d1);
            String s2_ = new java.text.SimpleDateFormat(base1).format(d2);
            v = s1.compareTo(s2);
        }
        
        if ( v == 0 ){
            System.out.println(s1);
            return;
        }
        int inc=v>0?-1:1;
        while(true){
            System.out.println(s1);                
            if ( s1.equals(s2) )
                break;
            c.setTime(d1); 
            c.add(java.util.Calendar.DATE, inc);
            d1 = c.getTime();
            s1 = new java.text.SimpleDateFormat(base).format(d1);
        }
              
    }
    
    public void add(String a) throws Exception{
        String base1="yyyy-MM-dd";
        String base2="dd/MM/yyyy";
        String base=a.split("-").length>1?base1:base2;

        java.util.Date d1 = new java.text.SimpleDateFormat(base, java.util.Locale.ENGLISH).parse(a);       
        String s1 = new java.text.SimpleDateFormat(base).format(d1);
        java.util.Calendar c = java.util.Calendar.getInstance(); 

        c.setTime(d1); 
        c.add(java.util.Calendar.DATE, 1);
        d1 = c.getTime();
        s1 = new java.text.SimpleDateFormat(base).format(d1);
        System.out.println(s1);
    }
        
    public void seq(int a,int b,int len){
        int inc=1;
        if ( a > b )
            inc=-1;
        while(true){
            System.out.println( lpad(a,len,"0") );
            if ( a == b )
                break;
            a+=inc;
        }
    }
    
    public void awk_print(String [] args)
    {
        ArrayList<Integer> lista=new ArrayList<Integer>();
        int [] elem;
        String [] partes;
        
        try{
            for ( int i=2;i<args.length;i++ ){
                partes=args[i].split(",");
                for ( int j=0;j<partes.length;j++ ){
                    if ( j > 0 )
                        lista.add(500); // " "
                    lista.add(Integer.parseInt(partes[j]));
                }
            }
        }catch(Exception e){
            comando_invalido(args);
            return;
        }
        
        // list command print
        elem=new int[lista.size()];
        for ( int i=0;i<lista.size();i++ )
            elem[i]=lista.get(i);
        
        try {
            String line=null;
            while ( (line=readLine()) != null ) {      
                // partes de linha
                partes=line.replaceAll("\t"," ").replaceAll("\r"," ").split(" ");
                for ( int i=0;i<elem.length;i++ ){                    
                    if ( elem[i] == 0 )
                    {
                        for ( int j=0;j<partes.length;j++ ){
                            if ( j != 0 )
                                System.out.print(" ");
                            System.out.print(partes[j]);
                        }
                        continue;
                    }
                    if ( elem[i] == 500 )
                    {
                        System.out.print(" ");
                        continue;
                    }
                    int p=elem[i];     
                    if ( p > 0 ) // posição iniciada de 0
                        p-=1;
                    else
                        p+=partes.length; // correção do pedido negativo print -1 equivale a print 3 caso o total de palavras seja 4, ou seja, -1 significa o ultimo
                    
                    if ( p < 0 ) continue;
                    if ( p >= partes.length ) continue;                    
                    System.out.print(partes[p]);
                }
                System.out.println("");                
            }
            closeLine();
        }catch(Exception e){
            System.out.println(e.toString());
        }
    }
    
    public void awk_func(String [] args){
        args=removeParm(0, args);
        if ( args.length != 1 )
            erroFatal("Erro inesperado awk_func");                
        String command_min_num="{min-num}";
        String command_date_in_min_num="{date in min-num}";
        String command_date_min_num="{date-min-num}";
        String command_min_num_in_min_num="{min-num in min-num}";
        String matcher_text_in_min_num="{text ABC in min-num}";
        boolean flag_min_num=args[0].contains(command_min_num) 
                || args[0].contains(command_date_in_min_num) 
                || args[0].contains(command_min_num_in_min_num)
                || args[0].contains(command_date_min_num)
                || awk_func_matcherABC(args[0], matcher_text_in_min_num) != null
                ;
        Float min_num=null;        
        String date_min_num=null;
        String s_min_num=null;
        String command_max_num="{max-num}";
        String command_date_in_max_num="{date in max-num}";
        String command_date_max_num="{date-max-num}";
        String command_max_num_in_max_num="{max-num in max-num}";
        String matcher_text_in_max_num="{text ABC in max-num}";
        boolean flag_max_num=args[0].contains(command_max_num) 
                || args[0].contains(command_date_in_max_num) 
                || args[0].contains(command_max_num_in_max_num)
                || args[0].contains(command_date_max_num)
                || awk_func_matcherABC(args[0], matcher_text_in_max_num) != null
                ;
        Float max_num=null;
        String date_max_num=null;
        String s_max_num=null;
        String command_date="{date}";
        boolean flag_date=args[0].contains(command_date);
        
        try {
            String line=null;
            while ( (line=readLine()) != null ){
                awk_func_reset_date();
                line=line.trim();
                String s=args[0];
                if ( flag_min_num ){
                    if ( min_num == null || Float.parseFloat(line) < min_num ){
                        min_num=Float.parseFloat(line);
                        date_min_num=awk_func_get_date();
                        s_min_num=line;
                        s=s.replace(command_min_num_in_min_num, s_min_num);                        
                        s=s.replace(command_date_in_min_num, awk_func_get_date() );
                        int limit=20;
                        while( awk_func_matcherABC(s, matcher_text_in_min_num) != null && s.contains(awk_func_matcherABC(s, matcher_text_in_min_num) ) && limit-->0 )
                            s=s.replace(awk_func_matcherABC(s, matcher_text_in_min_num), awk_func_matcherABC_text);
                    }else{
                        s=s.replace(command_min_num_in_min_num, "");                        
                        s=s.replace(command_date_in_min_num, "");
                        int limit=20;
                        while( awk_func_matcherABC(s, matcher_text_in_min_num) != null && s.contains(awk_func_matcherABC(s, matcher_text_in_min_num) ) && limit-->0 )
                            s=s.replace(awk_func_matcherABC(s, matcher_text_in_min_num), "");
                    }
                    s=s.replace(command_min_num, s_min_num);
                    s=s.replace(command_date_min_num, date_min_num);
                }
                if ( flag_max_num ){
                    if ( max_num == null || Float.parseFloat(line) > max_num ){
                        max_num=Float.parseFloat(line);
                        date_max_num=awk_func_get_date();
                        s_max_num=line;
                        s=s.replace(command_max_num_in_max_num, s_max_num);                        
                        s=s.replace(command_date_in_max_num, awk_func_get_date() );
                        int limit=20;
                        while( awk_func_matcherABC(s, matcher_text_in_max_num) != null && s.contains(awk_func_matcherABC(s, matcher_text_in_max_num) ) && limit-->0 )
                            s=s.replace(awk_func_matcherABC(s, matcher_text_in_max_num), awk_func_matcherABC_text);
                    }else{
                        s=s.replace(command_max_num_in_max_num, "");                        
                        s=s.replace(command_date_in_max_num, "");
                        int limit=20;
                        while( awk_func_matcherABC(s, matcher_text_in_max_num) != null && s.contains(awk_func_matcherABC(s, matcher_text_in_max_num) ) && limit-->0 )
                            s=s.replace(awk_func_matcherABC(s, matcher_text_in_max_num), "");
                    }
                    s=s.replace(command_max_num, s_max_num);
                    s=s.replace(command_date_max_num, date_max_num);
                }
                if ( flag_date ){
                    s=s.replace(command_date, awk_func_get_date() );
                }
                s=s.replace("{}", line).trim();
                System.out.print(line+"\r");                
                if ( !s.equals("") ){
                    System.out.println(s);
                    System.out.flush();
                }
            }
        }catch(Exception e){
            erroFatal(e);
        }
    }
       
    // modelo awk_func_matcher("{} {} {text #MAX# in max-num} {}", "{text ABC in max-num}") retorna "{text #MAX# in max-num}"
    // retorna o primeiro encontrado, ou null
    String awk_func_matcherABC_text=null;
    public String awk_func_matcherABC(String a, String text){ 
        String [] partes=text.split("ABC");
        if ( partes.length != 2 )
            erroFatal("comando invalido " + a);
        int p=0;
        while(p<a.length()){
            int delta=a.indexOf(partes[0], p);
            if ( delta == -1 )
                return null;
            int delta2=a.indexOf(partes[1], p+1);
            if ( delta2 == -1 )
                return null;
            String s=a.substring(delta, delta2+partes[1].length());
            awk_func_matcherABC_text=s.substring(partes[0].length(), s.length()-partes[1].length());
            return s;
        }
        return null;
    }
    
    String awk_func_date_cache=null;
    public String awk_func_get_date() throws Exception{
        if ( awk_func_date_cache == null )
            awk_func_date_cache=date_("+%Y%m%d_%H%M%S", null, null, null);
        return awk_func_date_cache;
    }
    
    public void awk_func_reset_date(){
        awk_func_date_cache=null;
    }
    
    public void awk_start_end(String [] args)
    {
        String [] negativaStartEnd=getNegativaStartEnd(args);
        if ( negativaStartEnd == null )
        {
            comando_invalido(args);
            return;
        }
        String negativa=negativaStartEnd[0]; // S/N
        String start=negativaStartEnd[1]; // ".." ou null
        String end=negativaStartEnd[2]; // ".." ou null
        
        int status=0; // 0 -> fora, 1 -> dentro do range
        if ( start == null )
            status=1;

        try {
            String line=null;
            while ( (line=readLine()) != null ) {
                if ( start != null && status == 0 && line.contains(start) )
                    status=1;
                
                if ( 
                    (negativa.equals("S") && status == 0)
                    || (negativa.equals("N") && status == 1)
                )
                    System.out.println(line);
                
                if ( end != null && status == 1 && line.contains(end) )
                    status=0;   
            }
            closeLine();
        }catch(Exception e){
            System.out.println(e.toString());
        }
    }
            
    public void dev_null()
    {
        try{            
            InputStream inputStream_pipe=System.in;
            byte[] buf = new byte[BUFFER_SIZE];
            while( inputStream_pipe.read(buf,0,BUFFER_SIZE) > 0 ){}
            System.out.flush();
            System.out.close();
        }catch(Exception e){
            System.out.println(e.toString());
        }
    }

    public void dev_in()
    {
        String s="";
        for ( int i=0;i<BUFFER_SIZE/2;i++ )
            s+="0\n";
        byte[] buf = s.getBytes();
        while(true)
            System.out.write(buf, 0, BUFFER_SIZE);
    }

    public void aes(String senha,boolean encoding,String md,byte[] salt){        
        try{
            if ( encoding )
                new AES().encrypt(System.in,System.out,senha,md,salt);
            else
                new AES().decrypt(System.in,System.out,senha,md);
        }catch(Exception e){
            System.err.println(e.toString());
            if(e.toString().contains("java.security.InvalidKeyException: Illegal key size"))
                System.out.println("Erro conhecido no windows! - Utilize outro jdk windows -> https://mega.nz/file/eYYjSTII#OXreG57QM6NQpykXSt5ojXclaBG7AQ8IGlA2oDDPdGo");            
            System.err.println(erroSequenciaIlegal);
            System.exit(1);
        }
    }
    
    private String bytesToHex(byte[] a){
        StringBuilder sb = new StringBuilder();
        for (byte b : a) {
            sb.append(String.format("%02X", b));
        }
        return sb.toString();
    }
    
    private byte[] hexTobytes(String s) {
        int len = s.length();
        byte[] data = new byte[len / 2];
        for (int i = 0; i < len; i += 2) {
            data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4)
                                 + Character.digit(s.charAt(i+1), 16));
        }
        return data;
    }

    public void comando_invalido(String[] args) {
        //Comando inválido
        System.err.print("Comando inválido: [y");
        for ( int i=0;i<args.length;i++ )
            System.err.print(" "+args[i]);
        System.err.println("]");
    }

    public void createjobexecute(String conn) throws Exception {
        String line;
        String SQL="";
        while ( (line=readLine()) != null )
            SQL+=line+"\n";
        closeLine();
        
        System.out.print("jobexecute "); // funciona como orientador, não tem função prática
        System.out.println( 
            base64(
                "jobexecute\n"
                + "-conn\n"
                + conn+"\n"
                + "SQL\n"
                + SQL
                ,true
            )
        );
    }

    public void createjobcarga(String connIn, String fileCSV, String connOut, String outTable, String trunc, String app) throws Exception {
        String line;
        String SQL="";
        while ( (line=readLine()) != null )
            SQL+=line+"\n";
        closeLine();
        
        System.out.print("jobcarga "+outTable+" "); // funciona como orientador, não tem função prática
        System.out.println(
            base64(
                "jobcarga\n"
                + "-connIn\n"
                + connIn+"\n"
                + "-fileCSV\n"
                + fileCSV+"\n"
                + "-connOut\n"
                + connOut+"\n"
                + "-outTable\n"
                + outTable+"\n"
                + "trunc\n"
                + trunc+"\n"
                + "SQL\n"
                + SQL
                ,true
            )
        );
    }

    public void carga(final String connIn,final String fileCSV,final String connOut,final String outTable,final String trunc){
        final String nemVouExplicar=trunc.equals("CREATETABLE")?connOut:"";
        if ( outTable.trim().equals("") )
        {
            System.err.println("Erro, outTable não preenchido!");
            return;
        }
        if ( ! trunc.equals("S") && ! trunc.equals("N") && ! trunc.equals("CREATETABLE") )
        {
            System.err.println("Erro, inesperado!");
            return;
        }
            
        try{
            final PipedInputStream pipedInputStream=new PipedInputStream();
            final PipedOutputStream pipedOutputStream=new PipedOutputStream();
            
            // construção da variavel select(o select pode ser customizado)
            // em CSV nao tem select
            String select_="";  
            if ( !connIn.equals("") ){
                String line;
                while( (line=readLine()) != null )
                    select_+=line+"\n";
                closeLine();
                
                select_=removePontoEVirgual(select_);            
            }
            final String select=select_;
            
            pipedInputStream.connect(pipedOutputStream);

            if ( trunc.equals("S") && ! execute(connOut, "truncate table "+outTable) )
                return;
            if ( trunc.equals("CREATETABLE") && !connIn.equals("") )
            {
                String tabela=getTableByParm(select);
                if ( tabela.equals("") ){
                    System.err.println("Erro, não foi possível encontrar o nome da tabela");
                    System.exit(1);
                }
                String create=getcreate(connIn,tabela,outTable);
                if ( create.contains("USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS 255 COMPUTE STATISTICS") )
                {
                    System.err.println("Erro, não foi possível pegar o metadata a partir de "+tabela+" segue comando: "+create);
                    System.exit(1);
                }
                if ( create.equals("") ){
                    System.err.println("Erro, não foi possível pegar o metadata a partir de "+tabela);
                    System.exit(1);
                }
                if ( !connIn.equals("") )
                {
                    if ( ! execute(connOut, create) )
                        return;                    
                }else{
                    // será feito pelo nemVouExplicar
                }
            }
            
            Thread pipeWriter=new Thread(new Runnable() {
                public void run() {
                    selectInsert(connIn,fileCSV,select,pipedOutputStream,outTable,nemVouExplicar);
                }
            });
            
            Thread pipeReader=new Thread(new Runnable() {
                public void run() {
                    executeInsert(connOut, pipedInputStream);
                }
            });

            pipeWriter.start();
            pipeReader.start();
            
            pipeWriter.join();
            pipeReader.join();
            
            pipedOutputStream.flush();
            pipedOutputStream.close();            
            pipedInputStream.close();        
        }catch(Exception e){
            System.err.println("Erro, "+e.toString());
        }
    }

    public void executejob() {
        try{
            String line;
            String hash="";
            String [] partes;
            ArrayList<Thread> threads = new ArrayList<Thread>();
            String value_="";
            String [] sub_linesjob;

            while ( (line=readLine()) != null ){
                line=line.trim();
                if ( line.equals("") ) continue;
                if ( line.contains(" ") ){
                    partes=line.split(" ");


                    // jobcarga
                    if ( partes.length == 3 && partes[0].equals("jobcarga") )
                        hash=partes[2];
                    // jobexecute
                    if ( hash.equals("") && partes.length == 2 && partes[0].equals("jobexecute") )
                        hash=partes[1];

                    if ( hash.equals("") )
                    {
                        System.err.println("Erro, comando inválido:" + line);
                        return;
                    }

                    value_=base64(hash,false);

                    if ( value_ == null )
                    {
                        System.err.println("Erro, comando inválido:" + line);
                        return;
                    }

                    final ArrayList<String> instrucoes = new ArrayList<String>();
                    String SQL="";
                    sub_linesjob=value_.split("\n");

                    for ( int i=0;i<sub_linesjob.length; )
                    {
                        if ( sub_linesjob[i].equals("SQL") ){
                            instrucoes.add(sub_linesjob[i]);
                            i++;
                            for ( ;i<sub_linesjob.length; ){
                                SQL+=sub_linesjob[i]+"\n";
                                i++;
                            }
                            instrucoes.add(SQL);
                        }else{
                            instrucoes.add(sub_linesjob[i]);
                        }
                        i++;
                    }

                    /*
                    "jobcarga\n"
                    + "-connIn\n"
                    + connIn+"\n"
                    + "-connOut\n"
                    + connOut+"\n"
                    + "-outTable\n"
                    + outTable+"\n"
                    + "trunc\n"
                    + trunc+"\n"
                    + "SQL\n"
                    + SQL
                    */                        

                    if ( instrucoes.size() == 11
                        && instrucoes.get(0).equals("jobcarga")
                        && instrucoes.get(1).equals("-connIn")
                        && instrucoes.get(3).equals("-fileCSV")
                        && instrucoes.get(5).equals("-connOut")
                        && instrucoes.get(7).equals("-outTable")
                        && instrucoes.get(9).equals("trunc")
                        && instrucoes.get(11).equals("SQL")
                        && ! instrucoes.get(12).equals("")
                    ){
                        threads.add(
                            new Thread(new Runnable() {
                                public void run() {
                                    carga(
                                        instrucoes.get(2)
                                        ,instrucoes.get(4)
                                        ,instrucoes.get(6)
                                        ,instrucoes.get(8)
                                        ,instrucoes.get(10)
                                    );
                                }
                            })
                        );
                        continue;
                    }

                    /*
                    "jobexecute\n"
                    + "-conn\n"
                    + conn+"\n"
                    + "SQL\n"
                    + SQL
                    */                        
                    if ( instrucoes.size() == 5
                        && instrucoes.get(0).equals("jobexecute")
                        && instrucoes.get(1).equals("-conn")
                        && instrucoes.get(3).equals("SQL")
                        && ! instrucoes.get(4).equals("")
                    ){
                        threads.add(
                            new Thread(new Runnable() {
                                public void run() {
                                    execute(
                                        instrucoes.get(2)
                                        ,instrucoes.get(4)
                                    );
                                }
                            })
                        );
                        continue;
                    }
                    System.err.println("Erro, comando inválido:" + line);
                    return;
                }
                for ( int i=0;i<threads.size();i++ )
                    threads.get(i).start();
                for ( int i=0;i<threads.size();i++ )
                    threads.get(i).join();
            }
            closeLine();
        }catch(Exception e){
            System.err.println("Erro, "+e.toString());
        }
    }
    
    public String formatacaoInsertClobComAspetas(String _text)
    {
        String retorno = "";
        int len = 0;
        while (_text.length() > 0 )
        {
            if (_text.length() > 3000)
                len = 3000;
            else
                len = _text.length();

            retorno +=
                (retorno.equals("") ? "" : " || ")
                + " to_clob('" + _text.substring(0, len).replace("'", "''") + "') ";
            if (_text.length() <= 3000)
                _text = "";
            else
                _text = _text.substring(len);
        }
        return retorno;
    }    

    private String getcreate(String connIn, String tabela, String outTable) {
        Connection con=null;
        Statement stmt=null;
        ResultSet rs=null;
        
        String schema="";
        String tabela_=tabela;
        
        if ( tabela.contains(".") ){
            schema=tabela.split("\\.")[0];
            tabela=tabela.split("\\.")[1];
        }
        
        String SQL=lendo_arquivo_pacote("/y/sql_get_ddl_createtable").replace("[TABELA]",tabela).replace("[SCHEMA]",schema);

        try{    
            String retorno="";
            con = getcon(connIn);
            if ( con == null ){
                System.err.println("Não foi possível se conectar!!" );
                return "";
            }
            stmt = con.createStatement();
            rs=null;
            rs=stmt.executeQuery(SQL);
            if ( rs.next() ){
                retorno=rs.getString("TXT");
            }    
            close(rs,stmt,con);
            
            if ( ! retorno.equals("") ){
                retorno=removePontoEVirgual(retorno);
                retorno=retorno.trim();                
                String [] partes=retorno.split("\n");
                retorno="CREATE TABLE "+outTable+"\n";
                for ( int i=1;i<partes.length;i++ )
                    retorno+=partes[i]+"\n";
                if ( retorno.contains("USING INDEX PCTFREE 10 INITRANS 2 MAXTRANS") )
                    return tryFixCreate(retorno);
                return retorno;
            }
        }
        catch(Exception e)
        {
            if ( e.toString().contains("ORA-31603") )
            {
                System.err.println("Erro, a tabela "+tabela_+" não foi encontrada!");
                close(rs,stmt,con);
                System.exit(1);
            }
            close(rs,stmt,con);
            return "";
        }        
        close(rs,stmt,con);
        return "";
    }

    private String tryFixCreate(String txt) {
        String retorno="";
        String [] partes=txt.split("\n");
        retorno=partes[0]+"\n";
        retorno+=partes[1]+"\n";
        for ( int i=2;i<partes.length;i++ )
        {
            if ( ! partes[i].trim().startsWith("\"") )
                break;
            retorno+=partes[i]+"\n";
        }
        retorno=retorno.trim();
        retorno=retorno.substring(0,retorno.length()-1)+")";
        return retorno;
    }

    private void close(ResultSet rs, Statement stmt, Connection con) {
        try{ 
            rs.close();
        }catch(Exception e){}
        try{ 
            stmt.close();
        }catch(Exception e){}
        try{ 
            con.close();
        }catch(Exception e){}
    }

    private void try_finish_and_count(long count) {
        // grava em arquivo uma sinalização de sim e count
        String caminho_status_fim=getEnv("STATUS_FIM_Y");
        String caminho_count=getEnv("COUNT_Y");
        if ( caminho_status_fim != null && ! caminho_status_fim.equals("") ){
            salvando_file("FIM\n",new File(caminho_status_fim));
        }
        if ( caminho_count != null && ! caminho_count.equals("") ){
            salvando_file(count+"\n",new File(caminho_count));
        }
    }

    public String somente_banco(String a){
        String [] linhas=lendo_arquivo_pacote(a).split("\n");
        String result="";
        int tag=0;
        for ( int i=0;i<linhas.length;i++ ){
            if ( linhas[i].startsWith(" ") && linhas[i].trim().startsWith("[y ") && !linhas[i].trim().startsWith("[y banco ") ) continue;
            if ( linhas[i].startsWith("[y ") ){
                if ( linhas[i].startsWith("[y banco ") )
                    tag=1;
                else
                    tag=2;
            }
            
            if ( tag > 0 && linhas[i].trim().equals("") )
                tag=0;
            
            if ( tag == 2 ) continue;
            
            result+=linhas[i]+"\n";
        }
        return result;
    }
    
    public String helplikecase(String txt, boolean case_){
        String [] linhas=somente_detalhado().split("\n");
        String result="";
        boolean achou=false;
        for ( int i=0;i<linhas.length;i++ ){
            if ( linhas[i].startsWith("[") ){
                achou=false;
                if ( 
                    (case_ && linhas[i].equals("[y "+txt+"]"))
                    || (!case_ && linhas[i].toUpperCase().contains(txt.toUpperCase()))
                )
                    achou=true;
            }
            if ( achou )
                result+=linhas[i]+"\n";
        }
        if ( result.equals("") )
            return null;        
        return result;
    }
    
    public String somente_detalhado(){
        String [] linhas=lendo_arquivo_pacote("/y/manual").split("\n");
        String result="";
        int count=0;
        boolean passou_help=false;
        for ( int i=0;i<linhas.length;i++ ){
            if ( count == 2 ){
                result+=linhas[i]+"\n";
                if ( linhas[i].trim().equals("[y help]") )
                    passou_help=true;
            }
            if ( linhas[i].trim().equals("") )
                count++;
            if ( count == 3 )
                break;
        }
        if ( !passou_help )
            erroFatal("Erro interno, painel help com problema!"); // nao pode haver linha em branco no painel!!!!
        return result;
    }
    
    public String somente_mini(String a){
        String [] linhas=lendo_arquivo_pacote(a).split("\n");
        String result="";
        for ( int i=0;i<linhas.length;i++ ){
            result+=linhas[i]+"\n";
            if ( linhas[i].trim().equals("") )
                break;
        }
        return result;
    }
        
    public String lendo_arquivo_pacote(String caminho){
        // System.out.println(
        //   lendo_arquivo_pacote("/y/manual")
        // );
        try{      
            String result="";
            readLine(getClass().getResourceAsStream(caminho));
            String strLine;
            while ((strLine = readLine()) != null)
                result+=strLine+"\n";
            closeLine();
            return result;
        }catch (Exception e){}
        return new Arquivos().lendo_arquivo_pacote(caminho);
    }

    public void MetodoGaranteAPermanenciaDeAlgunsImportsJava() // nao remover
    {
        FilterOutputStream a;
        IOException b;
        OutputStream c;
        ByteBuffer d;
        Charset e;
        Arrays f;
        Comparator g;
    }
    
    private String [] getCamposCSV(String txt) {
        // modelos
        // HEADER_CAMPO1;BB;CC;3;4;5;
        // HEADER_CAMPO1;BB;CC;3;4;5
        
        txt=txt.trim();
        if ( txt.endsWith(getSeparadorCSV()) )
            txt=txt.substring(0, txt.length()-1);
        return txt.replace("\"","").split( getSeparadorCSV().equals("|")?"\\|":getSeparadorCSV() ); // split nao funciona com |, tem que usar \\|
    }

    private void readColunaCSV(String line) {
        ponteiroLinhaCSV=0;
        linhaCSV=line;
    }
    
    private String readColunaCSV() {
        if ( linhaCSV.length() == 0 )
            return null;
        if ( ponteiroLinhaCSV == -1 )
            return null;
        if ( ponteiroLinhaCSV >= linhaCSV.length() )
            return null;
        if ( linhaCSV.substring(ponteiroLinhaCSV, ponteiroLinhaCSV+1).equals("\"") )
        {
            return readColunaCSVComplexa();
        }else{
            return readColunaCSVSimples();
        }
        
        // linhaCSV
        /*
        HEADER_CAMPO1;BB;CC;3;4;5;
        11;;";;""""""11';;";55;55;55
        11;;";;""""""11';;";55;55;55
        11;;";;""""""11';;";55;55;55;
        33;44
        33;44
        33;44;44;44;44;44;44;44;44;44;44;44;44;44;44;44
        33;44;44;44;44;44;44;44;44;44;44;44;44;44;44;44        
        */
        
    }
    
    private String readColunaCSVComplexa() { // exmeplo ";;""""""11';;"        
        if ( ponteiroLinhaCSV >= linhaCSV.length()-2 )
            return null;
        int ini=ponteiroLinhaCSV+1;
        int fim=-1;
        int pos=ponteiroLinhaCSV+1; // olhando adiantado
        int pos_=-1;
        while(true)
        {    
            pos_=linhaCSV.indexOf("\"",pos);
            if ( pos_ == -1 )
            {
                System.err.println("Erro: CSV inválido, linha inconsistente: "+linhaCSV);
                System.exit(1);
            }
            if ( linhaCSV.indexOf("\"",pos_+1) == pos_+1 ){
                pos=pos_+2;
                continue;
            }
            fim=pos_;
            ponteiroLinhaCSV=pos_+2;
            break;
        }
        return linhaCSV.substring(ini,fim).replace("\r","").replace("\n","");
    }
    
    private String readColunaCSVSimples() {
        if ( linhaCSV.indexOf(getSeparadorCSV(),ponteiroLinhaCSV) == ponteiroLinhaCSV )
        {
            ponteiroLinhaCSV++;
            return "";
        }
        
        int pos=linhaCSV.indexOf(getSeparadorCSV(),ponteiroLinhaCSV+1);
        int ini=ponteiroLinhaCSV;
        int fim=-1;
        if ( pos == -1 )
        {
            fim=linhaCSV.length();
            ponteiroLinhaCSV=-1;
        }else{
            fim=pos;
            ponteiroLinhaCSV=pos+1;
        }
        return linhaCSV.substring(ini,fim).replace("\r","").replace("\n","");
    }

    private String getCreateByCamposCSV(String[] camposCSV, String table) {
        String result="CREATE TABLE "+table+" (";
        for ( int i=0;i<camposCSV.length;i++ ){
            result+=" \""+camposCSV[i]+"\" varchar2(4000)";
            if ( i != camposCSV.length-1 )
                result+=",";
        }
        result+=")";
        return result;
    }

	//REMOVED_GRAAL_START
    private void scp(String[] args) {        
        // créditos
        // https://github.com/is/jsch/tree/master/examples
        int port=22;
        if ( args.length != 3 && args.length != 4 )
        {
            comando_invalido(args);
            return;
        }
        if ( 
            ( args[1].contains("@") && args[2].contains("@") )
            || ( !args[1].contains("@") && !args[2].contains("@") )
        ){
            comando_invalido(args);
            return;
        }
        if ( args.length == 4 )
        {
            try{
                port=Integer.parseInt(args[3]);
            }catch(Exception e){
                comando_invalido(args);
                return;
            }            
        }
        String[] senha=new String[]{""};
        pedeSenhaCasoNaoTenha(args,senha);
        if ( args[1].contains("@") )
            new JSchCustom().scpFrom(new String[]{args[1],args[2]},senha[0],port);                    
        else
            new JSchCustom().scpTo(new String[]{args[1],args[2]},senha[0],port);                    
        System.exit(0);
    }
    //REMOVED_GRAAL_END
	
	//REMOVED_GRAAL_START
    private void execSsh(String[] args) {        
        // créditos
        // https://github.com/is/jsch/tree/master/examples
        int port=22;
        if ( args.length != 3 && args.length != 4 )
        {
            comando_invalido(args);
            return;
        }
        if ( !args[1].contains("@") )
        {
            comando_invalido(args);
            return;
        }
        if ( args.length == 4 )
        {
            try{
                port=Integer.parseInt(args[3]);
            }catch(Exception e){
                comando_invalido(args);
                return;
            }            
        }
        String[] senha=new String[]{""};
        pedeSenhaCasoNaoTenha(args,senha);
        new JSchCustom().execSsh(new String[]{args[1],args[2]},senha[0],port);
        System.exit(0);
    }
    //REMOVED_GRAAL_END
	
	//REMOVED_GRAAL_START
    private void ssh(String[] args) {        
        // créditos
        // https://github.com/is/jsch/tree/master/examples
        int port=22;
        if ( args.length != 2 && args.length != 3 )
        {
            comando_invalido(args);
            return;
        }
        if ( !args[1].contains("@") )
        {
            comando_invalido(args);
            return;
        }
        if ( args.length == 3 )
        {
            try{
                port=Integer.parseInt(args[2]);
            }catch(Exception e){
                comando_invalido(args);
                return;
            }            
        }
        String[] senha=new String[]{""};
        pedeSenhaCasoNaoTenha(args,senha);
        new JSchCustom().ssh(new String[]{args[1]},senha[0],port);
        System.exit(0);
    }
	//REMOVED_GRAAL_END
    
	//REMOVED_GRAAL_START
    private void sshinfo(String host_,String port_){
        String host = "localhost";
        int port = 22;
        if ( host_ != null )
            host = host_;
        if ( port_ != null )
            port = Integer.parseInt(port_);
        try{
            InetAddress serverAddress = InetAddress.getByName(host);
            Socket socket_ = new Socket(host, port);
            BufferedInputStream _instream = new BufferedInputStream(socket_.getInputStream());
            StringBuffer received = new StringBuffer();
            int b;
            while( (b = _instream.read()) != '\n' )
                received.append((char) b);
            System.out.println(received.toString());
            _instream.close();
            socket_.close();
        }catch(Exception e){
            System.err.println(e.toString());
            System.exit(1);
        }
    }
	//REMOVED_GRAAL_END
    
	//REMOVED_GRAAL_START
    private void sftp(String[] args) {
        // créditos
        // https://github.com/is/jsch/tree/master/examples
        int port=22;
        if ( args.length != 2 && args.length != 3 )
        {
            comando_invalido(args);
            return;
        }
        if ( !args[1].contains("@") )
        {
            comando_invalido(args);
            return;
        }
        if ( args.length == 3 )
        {
            try{
                port=Integer.parseInt(args[2]);
            }catch(Exception e){
                comando_invalido(args);
                return;
            }            
        }        
        String[] senha=new String[]{""};
        pedeSenhaCasoNaoTenha(args,senha);
        new JSchCustom().sftp(new String[]{args[1]},senha[0],port);
        System.exit(0);
    }
	//REMOVED_GRAAL_END
    
	//REMOVED_GRAAL_START
    public void pedeSenhaCasoNaoTenha(String [] args,String [] senha){
        for( int i=0;i<args.length;i++ ){
            if( args[i].contains("@") ){                
                if (  args[i].startsWith("@") || args[i].endsWith("@") ){
                    System.out.println("Error command");
                    System.exit(1);                    
                }
                if ( args[i].contains(",") ){
                    int p_virgula=args[i].indexOf(",");
                    int p_ultima_arroba=args[i].lastIndexOf("@");
                    String user=args[i].substring(0,p_virgula);                    
                    String host=args[i].substring(p_ultima_arroba+1,args[i].length());
                    senha[0]=args[i].substring(p_virgula+1,p_ultima_arroba);
                    args[i]=user+"@"+host;
                }else{
                    java.io.Console console=System.console();
                    if ( console == null ){
                        System.out.println("Error, input nao suportado nesse ambiente, rodando no netbeans?...");
                        System.exit(1);
                    }
                    
                    String user_server_print=args[i];
                    if ( user_server_print.contains(":") )
                        user_server_print=user_server_print.split(":")[0];
                    
                    String password=null;
                    char [] passChar = System.console().readPassword(user_server_print+"'s password: ");
                    if ( passChar != null )
                        password = new String(passChar);
                    
                    if ( password == null || password.trim().equals("") ){
                        System.out.println("Error, not input found");
                        System.exit(1);
                    }
                    senha[0]=password;
                }
                break;
            }
        }
    }
    
    //REMOVED_GRAAL_END    
    private void serverRouter(String[] args) {
        Object [] objs = get_parms_host0_port0_host1_port1_typeShow_log_ipsBanidos_decodes_xor_noLogLocal(args);
        if ( objs == null ){
            comando_invalido(args);
            System.exit(0);
        }
        String host0=(String)objs[0];
        int port0=(Integer)objs[1];
        String host1=(String)objs[2];
        int port1=(Integer)objs[3];
        String typeShow=(String)objs[4];
        String log=(String)objs[5];
        String ips_banidos=(String)objs[6];
        ArrayList<String> decodes=(ArrayList<String>)objs[7];
        Integer xor=(Integer)objs[8];
        Boolean noLogLocal=(Boolean)objs[9];
        
        System.out.println("ips_banidos: " + ips_banidos);
        new Ponte().serverRouter(host0, port0, host1, port1, typeShow, log, noLogLocal, ips_banidos, decodes, xor);
    }

    ArrayList<String> xlsxToCSV_nomes=null;
    ArrayList<String> shared=null;
    private void xlsxToCSV(String caminhoXlsx, boolean mostraEstrutura, boolean listaAbas, int numeroAba, String nomeAba, OutputStream out, boolean suprimeHeader) throws Exception {

        //"C:\\Users\\ywanes\\Documents\\teste.xlsx"
        //xlsxToCSV arquivo.xlsx mostraEstrutura
        //xlsxToCSV arquivo.xlsx listaAbas
        //xlsxToCSV arquivo.xlsx numeroAba 1
        //xlsxToCSV arquivo.xlsx nomeAba Planilha1
        
        try{            
            ZipFile zipFile = new ZipFile(caminhoXlsx);
            Enumeration<? extends ZipEntry> enumeration_entries = zipFile.entries();            
    
            InputStream is=null;            
            String caminho="";
            XML xmlShared=null;
            XML xmlNomes=null;
            int sheet_count=0;
            boolean exportSheetCSV=false;
            int sheetEncontrados=0;
            //XML xml=null;
            //String atributo_t=null;
            
            ArrayList<ZipEntry> entries=new ArrayList<ZipEntry>();
            while(enumeration_entries.hasMoreElements()){
                ZipEntry z=enumeration_entries.nextElement();
                if ( z.getName().equals("xl/sharedStrings.xml") ) // "xl/sharedStrings.xml" precisa ser carregado antes das "xl/worksheets/"
                    entries.add(0,z);
                else
                    entries.add(z);
            }
            
            for ( ZipEntry entry : entries){
                caminho=entry.getName();            
                if ( caminho.equals("xl/sharedStrings.xml") || caminho.equals("xl/workbook.xml") || caminho.startsWith("xl/worksheets/") ){
                    // xl/worksheets/sheet1.xml
                    // xl/worksheets/sheet2.xml
                    // xl/sharedStrings.xml
                    // xl/worksheets/_rels/sheet2.xml.rels
                    // xl/workbook.xml

                    if ( caminho.equals("xl/workbook.xml") && xlsxToCSV_nomes != null )
                        continue; // conteudo ja carregado.
                    if ( caminho.equals("xl/sharedStrings.xml") && shared != null )
                        continue; // conteudo ja carregado.
                                        
                    if ( caminho.startsWith("xl/worksheets/") && caminho.endsWith("xml") && listaAbas )
                        continue;
                    
                    exportSheetCSV=false;
                    if ( caminho.startsWith("xl/worksheets/") && caminho.endsWith("xml") && !mostraEstrutura && !listaAbas ){                        
                        if ( xlsxToCSV_nomes.size() == 0 )
                            erroFatal(99);                    
                        if ( numeroAba == -1 && nomeAba.equals(xlsxToCSV_nomes.get(sheet_count)) ){
                            exportSheetCSV=true;
                        }
                        if ( numeroAba != -1 && numeroAba == sheet_count+1 ){
                            exportSheetCSV=true;
                        }                        
                        sheet_count++;
                        if ( ! exportSheetCSV )
                            continue;
                        sheetEncontrados++;
                    }
                    
                    is = zipFile.getInputStream(entry);
                    new XML().loadIs(is,mostraEstrutura,false,caminho,exportSheetCSV,out,suprimeHeader);
                    is.close();
                    
                    // carrega lista de abas
                    if ( caminho.equals("xl/workbook.xml") && !mostraEstrutura  ){
                        xlsxToCSV_nomes=new ArrayList<String>();
                        xmlNomes=XML.getXML();
                        for ( XML item1 : xmlNomes.getFilhos())
                            if ( item1.getTag().equals("sheets") )
                                for ( XML item2 : item1.getFilhos())
                                    xlsxToCSV_nomes.add(item2.getAtributo("name"));
                    }
                    

                    // carrega dicionario de palavras compartilhadas
                    if ( caminho.equals("xl/sharedStrings.xml") && !mostraEstrutura && !listaAbas ){
                        shared=new ArrayList<String>();  
                        xmlShared=XML.getXML();
                        for ( XML item1 : xmlShared.getFilhos()){
                            for ( XML item2 : item1.getFilhos()){
                                if(item2.getTag().equals("t")){
                                    shared.add(item2.getValue());
                                }
                            }
                        }
                        XML.shared=shared;
                    }
                }
            }

            if ( !mostraEstrutura && !listaAbas && sheetEncontrados==0 ){
                if ( numeroAba != -1 )
                    System.err.println("Erro, numeroAba: "+numeroAba+" não encontrada!");
                else
                    System.err.println("Erro, nomeAba: "+nomeAba+" não encontrada!");
                System.exit(1);
            }
            
        }catch(Exception e){
            System.err.println("Erro "+e.toString());
            System.exit(1);
        }
        // finalizacao será feita no chamador de xlsxToCSV
        /*if ( out != null ){
            out.flush();
            out.close();
        }*/
    }


    public static byte[] readAllBytes(String path) throws IOException {
        java.io.RandomAccessFile f = new java.io.RandomAccessFile(new File(path), "r");
        if (f.length() > Integer.MAX_VALUE)
            throw new IOException("File is too large");
        byte[] b = new byte[(int)f.length()];
        f.readFully(b);        
        if (f.getFilePointer() != f.length())
            throw new IOException("File length changed while reading");
        return b;
    }    

    public boolean copiaByStream_count_print_on=false;
    private void copiaByStream(InputStream pipe_in, OutputStream pipe_out, String label_on) throws Exception {
        byte[] buf = new byte[BUFFER_SIZE];            
        int len;
        while ((len = pipe_in.read(buf)) > -1){
            pipe_out.write(buf, 0, len);
            if ( label_on != null  ){
                print_cursor_speed(len, "recebendo - ", null, true, label_on);
                copiaByStream_count_print_on=true;
            }
        }
        pipe_out.flush();
        pipe_out.close();
    }

    private void interpretaSqlParaSelectCSV(String sqlText) throws Exception {
        String sqlTextBKP=sqlText;
        String sqlTextWhere = "";        
        
        sqlText=sqlText.replace("\t"," ").replace("\r\n"," ").replace("\n"," ").trim();
        sqlText=setLimit(sqlText);
        
        int p_from=sqlText.indexOf(" from this");
        if ( p_from == -1 ){
            throw_erroDeInterpretacaoDeSQL("ORAZ: 02 - Não foi possível interpretar o SQL: "+sqlTextBKP);
        }else{
            sqlTextWhere=sqlText.substring(p_from + " from this".length(),sqlText.length()).trim();        
            sqlText=sqlText.substring(0,p_from).trim();
            if ( ! sqlTextWhere.equals("") && !sqlTextWhere.startsWith("where ") )
                throw_erroDeInterpretacaoDeSQL("ORAZ: 03 - Não foi possível interpretar o SQL: "+sqlTextBKP);
        }
        if ( ! sqlText.startsWith("select ") )
            throw_erroDeInterpretacaoDeSQL("ORAZ: 01 - Não foi possível interpretar o SQL: "+sqlTextBKP);
        
        // remove "select "
        sqlText=sqlText.substring("select ".length());
        
        
        if ( sqlText.equals("") )
            throw_erroDeInterpretacaoDeSQL("ORAZ: 03 - Não foi possível interpretar o SQL: "+sqlTextBKP);
            
        String [] partes=sqlText.split(",");
        String aux_saida="";
        String aux_saidaAlias="";
        for ( int i=0;i<partes.length;i++ ){
            partes[i]=partes[i].trim();
            if(partes[i].equals("*")){
                for ( int j=0;j<selectCSV_camposName.length;j++ ){
                    aux_saida+=","+selectCSV_camposName[j];
                    aux_saidaAlias+=","+selectCSV_camposName[j];
                }
                continue;                
            }
            if(partes[i].split(" ").length == 2){
                aux_saida+=","+partes[i].split(" ")[0];
                aux_saidaAlias+=","+partes[i].split(" ")[1];
                continue;                
            }
            if(partes[i].split(" ").length == 3 && partes[i].split(" ")[1].toLowerCase().equals("as")){
                aux_saida+=","+partes[i].split(" ")[0];
                aux_saidaAlias+=","+partes[i].split(" ")[2];
                continue;                
            }
            if(partes[i].split(" ").length == 1){
                aux_saida+=","+partes[i];
                aux_saidaAlias+=","+partes[i];
                continue;                
            }
            throw_erroDeInterpretacaoDeSQL("ORAZ: 04 - Não foi possível interpretar o SQL: "+sqlTextBKP);
        }
        selectCSV_camposNameSaida=aux_saida.substring(1).split(",");
        selectCSV_camposNameSaidaAlias=aux_saidaAlias.substring(1).split(",");
        if(!sqlTextWhere.equals(""))
            gw=new grammarsWhere(selectCSV_camposName, sqlTextWhere);
    }

    private String setLimit(String a){
        try{
            int p=a.indexOf(" limit ");
            while(a.indexOf(" limit ",p+1) >= 0)
                p=a.indexOf(" limit ",p+1);
            if ( p >= 0 ){
                p++;
                String tail=a.substring(p);
                String [] partes=tail.split(" ");
                if ( partes.length == 2 && partes[0].equals("limit") ){
                    sqlLimit=Integer.parseInt(partes[1]);
                    if ( sqlLimit < 0 ){
                        System.out.println("limit inválido");
                        System.exit(1);
                    }
                    return a.substring(0, a.length() - tail.length()).trim();
                }
            }
        }catch(Exception e){}
        return a;
    }
    
    private void processaRegistroSqlParaSelectCSV(OutputStream out, String tmppppp) throws Exception {
        StringBuilder sb=new StringBuilder();
        boolean achou=false;
        
        if(outJson){
            sb.append("{\n");
            for ( int i=0;i<selectCSV_camposNameSaida.length;i++ ){        
                achou=false;
                for ( int j=0;j<selectCSV_camposName.length;j++ ){                            
                    if ( selectCSV_camposNameSaida[i].equals(selectCSV_camposName[j]) ){
                        achou=true;
                        sb.append("\"");
                        sb.append(selectCSV_camposNameSaidaAlias[i]);
                        sb.append("\": \"");
                        sb.append(selectCSV_camposValue[j]);
                        sb.append("\"");
                        if ( i < selectCSV_camposNameSaida.length-1 )
                            sb.append(",");
                        sb.append("\n");
                        break;
                    }
                }
                if ( ! achou )
                    throw_erroDeInterpretacaoDeSQL("ORAZ: 99 - Não foi possível interpretar o campo: "+selectCSV_camposNameSaida[i]);                
            }
            sb.append("}\n");            
            if ( gw == null || gw.ok(selectCSV_camposValue) ){
                if ( sqlLimit == -1 || sqlCount < sqlLimit ){
                    sqlCount++;
                    if ( sqlCount == 1 )
                        out.write("[\n".getBytes());
                    if ( sqlCount > 1 )
                        out.write(",".getBytes());
                    out.write(sb.toString().getBytes());
                }
            }
        }else{
            for ( int i=0;i<selectCSV_camposNameSaida.length;i++ ){        
                sb.append("\"");
                achou=false;
                for ( int j=0;j<selectCSV_camposName.length;j++ ){        
                    if ( selectCSV_camposNameSaida[i].equals(selectCSV_camposName[j]) ){
                        achou=true;
                        if ( selectCSV_camposValue[j] != null )
                            sb.append(selectCSV_camposValue[j]);
                        break;
                    }
                }
                if ( ! achou && selectCSV_camposNameSaida[i].equals("rownum") ){
                    sb.append(selectCSV_rownum++ + "");
                    achou=true;
                }
                if ( ! achou )
                    throw_erroDeInterpretacaoDeSQL("ORAZ: 99 - Não foi possível interpretar o campo:: "+selectCSV_camposNameSaida[i]);
                sb.append("\"");
                if ( i < selectCSV_camposNameSaida.length-1 )
                    sb.append(csv_sep_output);
            }
            sb.append("\n");
            if ( !selectCSV_headerPrinted ){
                selectCSV_headerPrinted=true;
                out.write(selectCSV_header.toString().getBytes());
            }
            if ( gw == null || gw.ok(selectCSV_camposValue) ){                
                if ( sqlLimit == -1 || sqlCount < sqlLimit ){
                    sqlCount++;
                    out.write(sb.toString().getBytes());
                }
            }
        }
    }

    private void throw_erroDeInterpretacaoDeSQL(String string) throws Exception {
        throw new Exception(string);
    }

    private String get_abaSequencial(ArrayList<String> bkp_lista) {
        if ( bkp_lista.size() > 1 && bkp_lista.get(0).length() > 3 && bkp_lista.get(0).endsWith("(1)") ){
            String tmp=bkp_lista.get(0).substring(0,bkp_lista.get(0).length()-3);
            for ( int i=1;i<bkp_lista.size();i++ ){
                if ( ! bkp_lista.get(i).equals(tmp+"("+(i+1)+")") )
                    return null;
            }
            return tmp;
        }
        return null;
    }

    // tipos de retorno
    // file1|D:\pasta1\file1.class
    // pacote1.file1|D:\pacote1\file1.class
    private ArrayList<String> nav_custom(String dir){
        // dir possiveis
        // .
        // pasta
        // pasta\\
        // d:\\aa
        if ( dir.equals("") ) dir=".";
        dir=new File(dir).getAbsolutePath();
        String sep="/";
        if ( dir.contains("\\") )
            sep="\\";
        if ( dir.endsWith(sep+".") )
            dir=dir.substring(0,dir.length()-2);
        return nav_custom(dir,"",sep);
    }

    private ArrayList<String> nav_custom(String dir1, String dir2, String sep) {
        ArrayList<String> retorno=new ArrayList<String>();
        
        for ( File item : new java.io.File(dir1+dir2).listFiles() ){
            if ( !item.isFile() ) continue;
            if ( !item.getAbsolutePath().endsWith(".class") ) continue;
            String tmp=item.getAbsolutePath().substring(dir1.length()+1);
            tmp=tmp.substring(0,tmp.length()-".class".length());
            tmp=tmp.replace(sep,".");
            retorno.add(
                tmp
                +"|"
                +item.getAbsolutePath()
            );
        }
        
        for ( File item : new java.io.File(dir1+dir2).listFiles() ){
            if ( !item.isDirectory() ) continue;
            retorno.addAll(nav_custom(dir1,dir2+sep+item.getName(),sep));
        }
        return retorno;
    }    

    private void wget(String[] args) {
        args=sliceParm(1,args);
        if ( args.length == 0 )
            args=new String[]{"-h"};
        Wget w=new Wget();
        for ( String comando : args)
            w.comando(comando);
        try {
            w.start_motor();
        } catch (Exception ex) {
            System.err.println("Error: "+ex.toString());
        }
    }
    
    public Object [] get_parms_ip_port_fps(String [] args){
        String ip=null;
        int port=7777;
        int fps=30;
        
        args=sliceParm(1, args);
        
        while(true){
            if ( args.length > 1 && args[0].equals("-ip") ){
                args=sliceParm(1, args);
                ip=args[0];                
                args=sliceParm(1, args);
                continue;
            }
            if ( args.length > 1 && args[0].equals("-port") ){
                args=sliceParm(1, args);
                port=Integer.parseInt(args[0]);
                args=sliceParm(1, args);
                continue;
            }
            if ( args.length > 1 && args[0].equals("-fps") ){
                args=sliceParm(1, args);
                fps=Integer.parseInt(args[0]);
                args=sliceParm(1, args);
                continue;
            }
            if ( args.length > 0 && ip == null ){
                ip=args[0];
                args=sliceParm(1, args);
                continue;                
            }
            break;
        }
        if ( ip == null )
            ip=get_ip();        
        if ( ip == null )
            erroFatal("Não foi possível encontrar o ip!");
        if ( fps != 30 && fps != 60 )
            erroFatal("valor de fps invalido. só permitido 30 e 60");
        if ( ip.contains(":") )
            ip="["+ip+"]";
        return new Object []{ip, port, fps};
    }
    
    public Object [] get_parms_file1_file2_flagOnlyDiff(String [] args){
        String file1=null;
        String file2=null;
        Boolean flagOnlyDiff=false;
        
        args=sliceParm(1, args);
        
        while(args.length>0){
            if ( args.length > 0 && !flagOnlyDiff && args[0].equals("-onlyDiff") ){
                args=sliceParm(1, args);
                flagOnlyDiff=true;
                continue;
            }
            if ( args.length > 0 && file1 == null ){
                file1=args[0];
                args=sliceParm(1, args);
                continue;
            }
            if ( args.length > 0 && file2 == null ){
                file2=args[0];
                args=sliceParm(1, args);
                continue;
            }
            return null;
        }
        return new Object []{file1, file2, flagOnlyDiff};        
    }
        
    private Object [] get_parms_host0_port0_host1_port1_typeShow_log_ipsBanidos_decodes_xor_noLogLocal(String [] args){        
        String host0=null;
        int port0=-1;
        String host1=null;
        int port1=-1;
        String typeShow=null;
        String log=null;
        String ipsBanidos=null;
        ArrayList<String> decodes = new ArrayList<String>();
        Integer xor=null;
        Boolean noLogLocal=false;
        
        args=sliceParm(1, args);
        
        while(true){
            if ( args.length > 0 && !noLogLocal && args[0].equals("-noLogLocal") ){
                args=sliceParm(1, args);
                noLogLocal=true;
                continue;
            }
            if ( args.length > 1 && log == null && args[0].equals("-log_ips") ){
                log=args[1];
                args=sliceParm(2, args);
                continue;
            }
            if ( args.length > 1 && ipsBanidos == null && args[0].equals("-ips_banidos") ){
                ipsBanidos=args[1];
                args=sliceParm(2, args);
                continue;
            }
            if ( args.length > 2 && args[0].equals("-decodeSend") ){
                decodes.add("decodeSend," + args[1] + "," + args[2]);
                args=sliceParm(3, args);
                continue;
            }     
            if ( args.length > 1 && args[0].equals("-xor") ){
                args=sliceParm(1, args);
                xor=Integer.parseInt(args[0]);
                args=sliceParm(1, args);
                continue;
            }     
            if ( args.length > 0 && host0 == null ){
                host0=args[0];
                args=sliceParm(1, args);
                continue;
            }
            if ( args.length > 0 && port0 == -1 ){
                port0=Integer.parseInt(args[0]);
                args=sliceParm(1, args);
                continue;
            }
            if ( args.length > 0 && host1 == null ){
                host1=args[0];
                args=sliceParm(1, args);
                continue;
            }
            if ( args.length > 0 && port1 == -1 ){
                port1=Integer.parseInt(args[0]);
                args=sliceParm(1, args);
                continue;
            }
            if ( args.length > 0 && typeShow == null ){
                typeShow=args[0];
                args=sliceParm(1, args);
                continue;
            }            
            if ( port1 == -1 )
                return null;
            break;
        }
        if ( typeShow == null )
            typeShow="";
        if ( ipsBanidos == null )
            ipsBanidos="";
        return new Object []{host0, port0, host1, port1, typeShow, log, ipsBanidos, decodes, xor, noLogLocal};
    }        
    
    private Object [] get_parms_msg_lang_list_copy_tts_stt(String [] args){        
        String msg=null;
        String lang=null;
        Boolean list=false;
        String copy=null;
        Boolean tts=false;
        Boolean stt=false;
        Boolean modeB=false;
        
        args=sliceParm(1, args);
        
        while(args.length > 0){
            if ( args.length == 1 && args[0].equals("list") ){
                args=sliceParm(1, args);
                list=true;
                continue;
            }
            if ( args.length > 1 && msg == null && args[0].equals("-msg") ){
                args=sliceParm(1, args);
                msg=args[0];
                args=sliceParm(1, args);
                continue;
            }
            if ( args.length > 1 && lang == null && args[0].equals("-lang") ){
                args=sliceParm(1, args);
                lang=args[0];
                args=sliceParm(1, args);
                continue;
            }
            if ( args.length > 0 && !modeB && args[0].equals("-b") ){
                args=sliceParm(1, args);
                modeB=true;
                continue;
            }
            if ( args.length > 1 && copy == null && args[0].equals("-o") ){
                args=sliceParm(1, args);
                copy=args[0];
                args=sliceParm(1, args);
                continue;
            }
            if ( args.length > 0 && !tts && ( args[0].equals("-tts") || args[0].equals("-textToSpeech") ) ){
                tts=true;
                args=sliceParm(1, args);
                continue;
            }
            if ( args.length > 0 && !stt && ( args[0].equals("-stt") || args[0].equals("-speechToText") ) ){
                stt=true;
                args=sliceParm(1, args);
                continue;
            }
            if ( msg == null ){
                msg=args[0];
                args=sliceParm(1, args);
                continue;
            }
            return null;
        }        
        if ( !tts && !stt )
            tts=true;
        if ( tts == stt )
            return null;
        if ( msg!= null && (stt || list))
            return null;
        return new Object []{msg, lang, list, copy, tts, stt, modeB};
    }        
        
    private Object [] get_parms_url_verbose_onlyLink_onlyPreLink_vToken_o_tags_outPath_getScriptRenameBySkipIn(String [] args){
        String url=null;
        Boolean verbose=false;
        Boolean onlyLink=false;
        Boolean onlyPreLink=false;
        Boolean vToken=false;
        String o=null;
        Boolean tags=false;
        String outPath=null;
        String getScriptRenameBySkipIn=null;
        
        Boolean aux_p=false;
        String [] extras=new String[0];
        
        args=sliceParm(1, args);
        
        if ( args.length > 0 && args[0].equals("p") ){
            aux_p=true;
            args=sliceParm(1, args);
        }
        
        while(args.length > 0){
            if ( args.length > 0 && args[0].equals("-onlyLink") ){
                args=sliceParm(1, args);
                onlyLink=true;
                continue;
            }
            if ( args.length > 0 && args[0].equals("-onlyPreLink") ){
                args=sliceParm(1, args);
                onlyPreLink=true;
                continue;
            }
            if ( args.length > 0 && args[0].equals("-vToken") ){
                args=sliceParm(1, args);
                vToken=true;
                continue;
            }
            if ( args.length > 1 && args[0].equals("-o") ){
                args=sliceParm(1, args);
                o=args[0];
                args=sliceParm(1, args);
                continue;
            }
            if ( args.length > 1 && args[0].equals("-outPath") ){
                args=sliceParm(1, args);
                outPath=args[0];
                args=sliceParm(1, args);
                continue;
            }
            if ( args.length > 0 && args[0].equals("-v") ){
                args=sliceParm(1, args);
                verbose=true;
                continue;
            }
            if ( args.length > 0 && args[0].equals("-tags") ){
                args=sliceParm(1, args);
                tags=true;
                verbose=true;
                continue;
            }
            if ( args.length > 0 && getScriptRenameBySkipIn == null && args[0].startsWith("getScriptRenameBySkip,") ){
                getScriptRenameBySkipIn=args[0].substring("getScriptRenameBySkip,".length());
                args=sliceParm(1, args);
                continue;
            }  
            if ( args.length > 0 && args[0].equals("-i") ){
                args=sliceParm(1, args);
                overflix_interative=true;
                continue;
            }            
            if ( args.length > 0 && url == null ){
                url=args[0];
                args=sliceParm(1, args);
                continue;
            }            
            extras=addParm(args[0], extras);
            args=sliceParm(1, args);
        }      
        
        if ( url == null ){
            System.out.println("erro: url null");
            return null;   
        }
        if ( aux_p || ( !url.toLowerCase().startsWith("http://") && !url.toLowerCase().startsWith("https://") && !url.startsWith("-") ) ){
            extras=addParm(url, 0, extras);
            System.out.print(
                overflix_busca(extras)
                // certificado com problema
                 +superflixapi_busca(extras)
            );
            System.exit(0);
        }        
        if ( extras.length > 0 ){
            System.out.println("erro: extras.length > 0: " + extras[0] + " - url: " + url);
            return null;
        }
        if ( onlyLink && onlyPreLink ){
            System.out.println("erro: onlyLink && onlyPreLink");
            return null;
        }
        return new Object []{url, verbose, onlyLink, onlyPreLink, vToken, o, tags, outPath, getScriptRenameBySkipIn};
    }        
           
    public Object [] get_parms_vol_mute_setvol_setmute_program_mutingWhileProgramInPrincipalMonitor(String [] args){
        Boolean vol=false;
        Boolean mute=false;
        String setvol=null;
        String setmute=null;
        String program=null;
        String mutingWhileProgramInPrincipalMonitor=null;
        
        args=sliceParm(1, args);
                
        while(args.length > 0){
            if ( args.length > 0 && args[0].equals("vol") ){
                vol=true;
                args=sliceParm(1, args);
                continue;
            }
            if ( args.length > 0 && args[0].equals("mute") ){
                mute=true;
                args=sliceParm(1, args);
                continue;
            }
            if ( args.length > 1 && args[0].equals("setvol") ){
                args=sliceParm(1, args);
                setvol=args[0];
                args=sliceParm(1, args);
                continue;
            }
            if ( args.length > 1 && args[0].equals("setmute") ){
                args=sliceParm(1, args);
                setmute=args[0];
                args=sliceParm(1, args);
                continue;
            }
            if ( args.length > 1 && args[0].equals("program") ){
                args=sliceParm(1, args);
                program=args[0];
                args=sliceParm(1, args);
                continue;
            }
            if ( args.length > 1 && args[0].equals("mutingWhileProgramInPrincipalMonitor") ){
                args=sliceParm(1, args);
                mutingWhileProgramInPrincipalMonitor=args[0];
                args=sliceParm(1, args);
                continue;
            }
        }      
        if (
            (
                (vol?1:0)
                +(mute?1:0)
                +(setvol!=null?1:0)
                +(setmute!=null?1:0)
                +(mutingWhileProgramInPrincipalMonitor!=null?1:0)
            ) != 1
        )
            return null;
        return new Object []{vol, mute, setvol, setmute, program, mutingWhileProgramInPrincipalMonitor};
    }        

    public Object [] get_parms_iso_source_flagMake(String [] args){
        String iso=null;
        String source=null;
        Boolean flagMake=null;
        
        args=sliceParm(1, args);
        while(args.length > 0){
            if ( args.length > 0 && iso == null && ( args[0].endsWith(".iso") || args[0].endsWith(".ISO") ) ){                
                iso=args[0];
                args=sliceParm(1, args);
                flagMake=source!=null;
                continue;
            }
            if ( args.length > 0 && source == null ){                
                source=args[0];
                args=sliceParm(1, args);                
                continue;
            }
            return null;
        }
        if ( iso == null || source == null || flagMake == null )
            return null;
        return new Object[]{iso, source, flagMake};
    }
    
    public Object [] get_parms_modelo_valor_jurosAM_jurosAA_parcelas(String [] args){
        String modelo=null;
        Double valor=null;
        Double jurosAM=null;
        Double jurosAA=null;
        Integer parcelas=null;
        
        args=sliceParm(1, args);
        while(args.length > 0){
            if ( args.length > 1 && args[0].equals("valor") ){                
                args=sliceParm(1, args);
                valor=Double.parseDouble(args[0]);
                args=sliceParm(1, args);
                continue;
            }
            if ( args.length > 2 && args[0].equals("juros") ){
                if ( jurosAM != null || jurosAA != null )
                    return null;
                args=sliceParm(1, args);
                jurosAM=Double.parseDouble(args[0])/100;
                jurosAM=arredondamentoDouble_Double(jurosAM, 5, false);
                args=sliceParm(1, args);
                String tipo=args[0];
                args=sliceParm(1, args);
                if ( tipo.equals("a.m") ){
                    jurosAA=Math.pow(1 + jurosAM, 12) - 1;
                    jurosAA=arredondamentoDouble_Double(jurosAA, 5, false);
                }else{
                    if ( tipo.equals("a.a") ){
                        jurosAA=jurosAM;
                        jurosAM=Math.pow(1 + jurosAA, 1.0/12) - 1;
                        jurosAM=arredondamentoDouble_Double(jurosAM, 5, false);
                    }else{
                        erroFatal("tipo de juros desconhecido => " + tipo);
                    }
                }
                continue;
            }
            if ( args.length > 1 && args[1].equals("parcelas") ){                
                parcelas=Integer.parseInt(args[0]);
                args=sliceParm(1, args);
                continue;
            }
            if ( args.length > 0 && modelo == null ){
                modelo=args[0];
                args=sliceParm(1, args);
                continue;
            }
            break;
        }      
        if ( modelo == null )
            modelo="price";
        if ( valor == null || jurosAM == null || parcelas == null )
            return null;
        return new Object []{modelo,valor,jurosAM,jurosAA,parcelas};
    }        
       
    private Object [] get_parms_f_mixer_line_wav_mp3_volume(String [] args){
        String f=null;        
        String mixer=null;
        Boolean line=false;
        Boolean wav=false;
        Boolean mp3=false;
        Float volume=null;
        
        args=sliceParm(1, args);
        
        while(args.length > 0){
            if ( args.length > 1 && args[0].equals("-f") ){
                args=sliceParm(1, args);
                f=args[0];
                args=sliceParm(1, args);
                continue;
            }
            if ( args.length > 1 && args[0].equals("-mixer") ){
                args=sliceParm(1, args);
                mixer=args[0];
                args=sliceParm(1, args);
                continue;
            }
            if ( args.length > 1 && args[0].equals("-volume") ){
                args=sliceParm(1, args);
                try{
                    volume=Float.parseFloat(args[0]);
                    if ( volume < 0f || volume > 1f )
                        return null;
                }catch(Exception e){
                    return null;
                }
                args=sliceParm(1, args);
                continue;
            }
            if ( args.length > 0 && args[0].equals("-line") ){
                args=sliceParm(1, args);
                line=true;
                continue;
            }
            if ( args.length > 0 && args[0].equals("-wav") ){
                args=sliceParm(1, args);
                wav=true;
                continue;
            }
            if ( args.length > 0 && args[0].equals("-mp3") ){
                args=sliceParm(1, args);
                mp3=true;
                continue;
            }
            if ( args.length > 0 && f == null ){
                f=args[0];
                args=sliceParm(1, args);                
                continue;
            }
            erroFatal("Erro de parametros");
        }
        int count=0;
        if ( line ) count++;
        if ( wav ) count++;
        if ( mp3 ) count++;
        
        if ( count == 0 )
            wav=true;
        if ( count > 1 )
            erroFatal("Erro, multiplos formatos solicitados!");        
        return new Object []{f, mixer, line, wav, mp3, volume};
    }
               
    private Object [] get_parms_sign(String [] args){
        String msg=null;
        String pass=null;
        Boolean verify=false;
        String publicKey=null;
        String signature=null;
        
        args=sliceParm(1, args);
        
        while(args.length > 0){
            if ( args.length > 1 && msg == null && args[0].equals("-msg") ){
                args=sliceParm(1, args);
                msg=args[0];
                args=sliceParm(1, args);
                continue;
            }
            if ( args.length > 1 && pass == null && args[0].equals("-pass") ){
                args=sliceParm(1, args);
                pass=args[0];
                args=sliceParm(1, args);
                continue;
            }
            if ( args.length > 0 && !verify && args[0].equals("-verify") ){
                args=sliceParm(1, args);
                verify=true;
                continue;
            }
            if ( args.length > 1 && publicKey == null && args[0].equals("-publicKey") ){
                args=sliceParm(1, args);
                publicKey=args[0];
                args=sliceParm(1, args);
                continue;
            }
            if ( args.length > 1 && signature == null && args[0].equals("-signature") ){
                args=sliceParm(1, args);
                signature=args[0];
                args=sliceParm(1, args);
                continue;
            }
            erroFatal("Erro de parametros");
        }        
        if ( 
            ( msg != null && pass != null && !verify && publicKey == null && signature == null )
            || ( msg != null && pass == null && verify && publicKey != null && signature != null )
        )
            return new Object[]{msg, pass, verify, publicKey, signature};
        return null;
    }
    
    private Object [] get_parms_cors_ip_port_sw(String [] args){
        String ip=null;        
        Integer port=4000;
        String sw=null;
        
        args=sliceParm(1, args);
        
        while(args.length > 0){
            if ( args.length > 1 && args[0].equals("-ip") ){
                args=sliceParm(1, args);
                ip=args[0];
                args=sliceParm(1, args);
                continue;
            }
            if ( args.length > 1 && args[0].equals("-port") ){
                args=sliceParm(1, args);
                port=Integer.parseInt(args[0]);
                args=sliceParm(1, args);
                continue;
            }
            if ( args.length > 1 && args[0].equals("-sw") ){
                args=sliceParm(1, args);
                if ( sw == null )
                    sw=args[0];
                else
                    sw+="|"+args[0];
                args=sliceParm(1, args);
                continue;
            }
            erroFatal("Erro de parametros");
        }
        if ( ip == null )
            ip=get_ip();
        return new Object []{ip, port, sw};
    }
            
    private Object [] get_parms_curl_header_method_verbose_raw_host_limitRate_location(String [] args){
        String header="";
        String method="GET";
        boolean verbose=false;
        boolean raw=false;
        String host = "";
        Long limitRate=null;
        Boolean location=false;

        while(true){
            if ( args.length > 1 && (args[0].equals("-H") || args[0].equals("--header")) ){
                header+=args[1]+"\r\n";
                args=sliceParm(2, args);
                continue;
            }
            if ( args.length > 1 && args[0].equals("--limit-rate") ){
                limitRate=getLimitRateByText(args[1]);
                header+=args[1]+"\r\n";
                args=sliceParm(2, args);
                continue;
            }
            if ( args.length > 1 && args[0].equals("-X") ){                    
                if ( !args[1].toUpperCase().equals("POST") && !args[1].toUpperCase().equals("GET") )
                    return null; // parm not ok
                method=args[1].toUpperCase();
                args=sliceParm(2, args);
                continue;
            }
            if ( args.length > 0 && args[0].equals("-v") ){
                verbose=true;
                args=sliceParm(1, args);
                continue;
            }
            if ( args.length > 0 && args[0].equals("-L") ){
                location=true;
                args=sliceParm(1, args);
                continue;
            }
            if ( args.length > 0 && args[0].equals("--raw") ){
                raw=true;
                args=sliceParm(1, args);
                continue;
            }
            if ( args.length > 0 && host.equals("") ){
                host=args[0];
                args=sliceParm(1, args);                
                continue;
            }
            break;
        }
        header+="\r\n";
        return new Object []{header, method, verbose, raw, host, limitRate, location};
    }
    
    private Long getLimitRateByText(String a){
        try{
            while( a.endsWith("k") || a.endsWith("K") || a.endsWith("m") || a.endsWith("M") || a.endsWith("g") || a.endsWith("G") ){            
                String next="";
                if ( a.endsWith("k") || a.endsWith("K") )
                    next="";
                if ( a.endsWith("m") || a.endsWith("M") )
                    next="k";
                if ( a.endsWith("g") || a.endsWith("G") )
                    next="m";
                a=Long.parseLong(a.substring(0, a.length()-1))*1012+next;
            }
        }catch(Exception e){
            erroFatal("Parametro invalido de --limit-rate");
        }
        return Long.parseLong(a);
    }
    
    private Object [] get_parms_json_listOn_noHeader_parm(String [] args){
        boolean listOn=false;
        boolean noHeader=false;
        String parm = "";

        while(true){
            if ( args.length > 0 && args[0].equals("list")){
                listOn=true;
                args=sliceParm(1, args);
                continue;
            }
            if ( args.length > 0 && args[0].equals("noHeader")){
                noHeader=true;
                args=sliceParm(1, args);
                continue;
            }
            if ( args.length > 0 ){ // pega o ultimo parametro sem problemas
                parm=args[0];
                args=sliceParm(1, args);
                continue;                
            }
            break;
        }
        return new Object []{listOn, noHeader, parm};
    }
    
    // usado para take
    private Object [] get_parm_ip_port_server_send_pass_paths(String [] args){
        String ip=null;
        int port=-1;
        Boolean server=false;
        Boolean client=false;
        Boolean send=false;
        Boolean receive=false;
        String pass=null;
        String [] paths=new String[]{};
        ArrayList<String> tmp=new ArrayList<String>();
        
        args=sliceParm(1, args);
        
        while(true){
            if ( args.length > 1 && args[0].equals("-ip")){
                args=sliceParm(1, args);
                ip=args[0];
                args=sliceParm(1, args);
                continue;
            }
            if ( args.length > 1 && args[0].equals("-port")){
                args=sliceParm(1, args);
                port=Integer.parseInt(args[0]);
                args=sliceParm(1, args);
                continue;
            }
            if ( args.length > 0 && args[0].equals("-server")){
                server=true;
                args=sliceParm(1, args);
                continue;
            }
            if ( args.length > 0 && args[0].equals("-client")){
                client=true;
                args=sliceParm(1, args);
                continue;
            }
            if ( args.length > 0 && args[0].equals("-send")){
                send=true;
                args=sliceParm(1, args);
                continue;
            }
            if ( args.length > 0 && ( args[0].equals("-receive") || args[0].equals("-r") ) ){
                receive=true;
                args=sliceParm(1, args);
                continue;
            }
            if ( args.length > 1 && args[0].equals("-pass")){
                args=sliceParm(1, args);
                pass=args[0];
                args=sliceParm(1, args);
                continue;
            }
            if ( args.length > 0 ){
                tmp.add(args[0]);
                args=sliceParm(1, args);
                continue;
            }
            break;
        }
        
        if ( server && client )
            return null;
        if ( send && receive )
            return null;        
        if ( !server && !client )
            server=true;
        if ( !send && !receive ){
            if ( server )
                send=true;
            else
                receive=true;
        }
        if ( tmp.size() > 0 ){
            paths=new String[tmp.size()];
            for ( int i=0;i<tmp.size();i++ )
                paths[i]=tmp.get(i);
        }
        if ( send && paths.length == 0 )
            paths=new String[]{"."};
        if ( !send && paths.length > 0 ){
            System.err.println("Nao é possível usar -receive e descrever paths, ex: "+paths[0]);
            System.exit(1);
        }
        return new Object []{ip, port, server, send, pass, paths};
    }

    private Object [] get_parm_date_(String [] args){
        String format_out_=null;
        String date_from=null;
        String format_in_=null;
        String date_from_ntp=null;
        
        args=sliceParm(1, args);
        
        while(args.length > 0){
            if ( args.length > 1 && args[0].equals("from")){
                args=sliceParm(1, args);
                date_from=args[0];
                args=sliceParm(1, args);
                continue;
            }
            if ( args.length > 1 && args[0].equals("mask")){
                args=sliceParm(1, args);
                format_in_=args[0];
                args=sliceParm(1, args);
                continue;
            }
            if ( args.length > 1 && args[0].equals("fromNTP")){
                args=sliceParm(1, args);
                date_from_ntp=args[0];
                args=sliceParm(1, args);
                continue;
            }
            if ( args[0].trim().startsWith("#") ){
                while(args.length > 0)
                    args=sliceParm(1, args);
                continue;
            }
            if ( args.length > 0 && format_out_ == null ){
                format_out_=args[0];
                args=sliceParm(1, args);
                continue;
            }
            erroFatal("parametros inválidos!");
        }
        
        return new Object []{format_out_, date_from, format_in_, date_from_ntp};
    }        
    
    private Object [] get_parm_sleep_nicks(String [] args){
        Integer sleep=null;
        String nicks=null;
        
        args=sliceParm(1, args);
        
        while(args.length > 0){
            if ( args.length > 1 && args[0].equals("-sleep")){
                args=sliceParm(1, args);
                sleep=Integer.parseInt(args[0]);
                args=sliceParm(1, args);
                continue;
            }
            if ( args.length > 1 && args[0].equals("-nicks")){
                args=sliceParm(1, args);
                nicks=args[0];
                args=sliceParm(1, args);
                continue;
            }
            erroFatal("parametros invalidos!");
        }
        
        return new Object []{sleep, nicks};
    }
        
    // usado para speed e call
    private Object [] get_parm_ip_port_server_send(String [] args){
        String ip=null;
        int port=-1;
        Boolean server=false;
        Boolean client=false;
        Boolean send=false;
        Boolean receive=false;
        
        args=sliceParm(1, args);
        
        while(true){
            if ( args.length > 1 && args[0].equals("-ip")){
                args=sliceParm(1, args);
                ip=args[0];
                args=sliceParm(1, args);
                continue;
            }
            if ( args.length > 1 && args[0].equals("-port")){
                args=sliceParm(1, args);
                port=Integer.parseInt(args[0]);
                args=sliceParm(1, args);
                continue;
            }
            if ( args.length > 0 && args[0].equals("-server")){
                server=true;
                args=sliceParm(1, args);
                continue;
            }
            if ( args.length > 0 && args[0].equals("-client")){
                client=true;
                args=sliceParm(1, args);
                continue;
            }
            if ( args.length > 0 && args[0].equals("-send")){
                send=true;
                args=sliceParm(1, args);
                continue;
            }
            if ( args.length > 0 && ( args[0].equals("-receive") || args[0].equals("-r") ) ){
                receive=true;
                args=sliceParm(1, args);
                continue;
            }
            break;
        }
        
        if ( server && client )
            return null;
        if ( send && receive )
            return null;        
        if ( !server && !client )
            server=true;
        if ( !send && !receive ){
            if ( server )
                send=true;
            else
                receive=true;
        }
        return new Object []{ip, port, server, send};
    }
        
    private Object [] get_parm_host_port_tray(String [] args, int default_port){
        String host=null;
        int port=default_port;
        Boolean tray=false;
        
        args=sliceParm(1, args);
        
        while(args.length > 0){
            if ( args.length > 0 && args[0].equals("-tray")){
                args=sliceParm(1, args);
                tray=true;
                continue;
            }
            if ( args.length > 0 && host == null ){
                host=args[0];
                args=sliceParm(1, args);
                continue;
            }
            port=Integer.parseInt(args[0]);
            args=sliceParm(1, args);
        }
        if ( host == null )
            return null;
        return new Object []{host, port, tray};
    }
           
    private Object [] get_parm_httpserver(String [] args){
        String mode=null;
        String host=get_ip();        
        Integer port=8888;
        String pass="";
        String tituloUrl="";
        String titulo="titulo";
        String dir=".";
        String endsWiths="";
        String ipsBanidos="";
        String log_ips=null;
        Boolean noLogLocal=false;
        String cfg=null;
        String redisDir=null;
        Long redisSeconds=null;
        String redisAll="[ALL]";
        String redisLike="-playlistmovie-"; // template
                
        args=sliceParm(1,args);
        while(args.length > 0){
            if ( args[0].equals("-noLogLocal") ){
                args=sliceParm(1,args);
                noLogLocal=true;
                continue;
            }
            if ( args[0].equals("-mode") ){
                args=sliceParm(1,args);
                mode=args[0];
                args=sliceParm(1,args);
                continue;
            }
            if ( args[0].equals("-host") ){
                args=sliceParm(1,args);
                host=args[0];
                args=sliceParm(1,args);
                continue;
            }
            if ( args[0].equals("-port") ){
                args=sliceParm(1,args);
                port=Integer.parseInt(args[0]);
                args=sliceParm(1,args);
                continue;
            }
            if ( args[0].equals("-pass") ){
                args=sliceParm(1,args);
                pass=args[0];
                args=sliceParm(1,args);
                continue;
            }
            if ( args[0].equals("-titulo_url_token") ){
                args=sliceParm(1,args);
                tituloUrl=args[0];
                args=sliceParm(1,args);
                continue;
            }
            if ( args[0].equals("-titulo") ){
                args=sliceParm(1,args);
                titulo=args[0];
                args=sliceParm(1,args);
                continue;
            }
            if ( args[0].equals("-dir") ){
                args=sliceParm(1,args);
                dir=args[0].trim();
                if (!dir.endsWith("/")) 
                    dir += "/";                
                args=sliceParm(1,args);
                continue;
            }
            if ( args[0].equals("-redisDir") ){
                args=sliceParm(1,args);
                redisDir=args[0].trim();
                args=sliceParm(1,args);
                continue;
            }
            if ( args[0].equals("-redisSeconds") ){
                args=sliceParm(1,args);
                redisSeconds=Long.parseLong(args[0]);
                args=sliceParm(1,args);
                continue;
            }
            if ( args[0].equals("-redisAll") ){
                args=sliceParm(1,args);
                redisAll=args[0].trim();
                args=sliceParm(1,args);
                continue;
            }
            if ( args[0].equals("-redisLike") ){
                args=sliceParm(1,args);
                redisLike=args[0].trim();
                args=sliceParm(1,args);
                continue;
            }
            if ( args[0].equals("-endsWiths") ){
                args=sliceParm(1,args);
                endsWiths=args[0];
                args=sliceParm(1,args);
                continue;
            }
            if ( args[0].equals("-ips_banidos") ){
                args=sliceParm(1,args);
                ipsBanidos=args[0];
                args=sliceParm(1,args);
                continue;
            }
            if ( args[0].equals("-log_ips") ){
                args=sliceParm(1,args);
                log_ips=args[0];
                args=sliceParm(1,args);
                continue;
            }
            if ( args[0].equals("-cfg") ){
                args=sliceParm(1,args);
                cfg=args[0];
                args=sliceParm(1,args);
                continue;
            }
            return null;
        }
        if ( mode != null && mode.equals("playlistserver") && cfg == null )
            erroFatal("Erro de parametros, mode playlistserver exige valor de cfg");
        if ( redisDir == null && redisSeconds != null )
            erroFatal("Erro de parametros, não é possível usar o parametro redisSeconds sem usar o redisDir");
        if ( mode != null && findParm(new String[]{"playlist", "playlistmovie", "playlistserver", "webdav"}, mode, true) == -1 )
            erroFatal("-mode " + mode + " inválido!");
        if ( mode != null && !mode.equals("webdav") && !pass.equals("") )
            erroFatal("-pass só pode ser usado com -mode webdav");
        return new Object[]{mode, host, port, pass, tituloUrl, titulo, dir, endsWiths, ipsBanidos, log_ips, noLogLocal, cfg, redisDir, redisSeconds, redisAll, redisLike};
    }

    private Object [] get_parm_httpproxy(String [] args){
        String host="localhost";
        Integer port=8080;
        Boolean verbose=false;
                
        args=sliceParm(1,args);
        while(args.length > 0){
            if ( args[0].equals("-ip") ){
                args=sliceParm(1,args);
                host=args[0];
                args=sliceParm(1,args);
                continue;
            }
            if ( args[0].equals("-port") ){
                args=sliceParm(1,args);
                port=Integer.parseInt(args[0]);
                args=sliceParm(1,args);
                continue;
            }
            if ( args[0].equals("-verbose") ){
                args=sliceParm(1,args);
                verbose=true;
                continue;
            }
            return null;
        }        
        return new Object[]{host, port, verbose};
    }
    
    private Object [] get_parm_path_symbol_mtime_type_pre_pos(String [] args){
        String path=null;
        boolean acceptSymbolicLink=false;
        float mtime = 0;
        String type = null;
        String pre = null;
        String pos = null;
        
        args=sliceParm(1,args);
        while(args.length > 0){
            if ( args[0].equals("-L") ){
                acceptSymbolicLink=true;                
                args=sliceParm(1,args);
                continue;
            }
            if ( args.length > 1 && args[0].equals("-mtime") ){
                args=sliceParm(1,args);
                try{
                    mtime=Float.parseFloat(args[0]);
                    mtime*=24*60*60*1000;                
                }catch(Exception e){
                    return null;
                }
                args=sliceParm(1,args);
                continue;
            }
            if ( args.length > 1 && args[0].equals("-type") && (args[1].equals("d") || args[1].equals("f") || args[1].equals("-") || args[1].equals("l") ) ){
                args=sliceParm(1,args);
                type=args[0];
                if ( type.equals("-") )
                    type="f";
                args=sliceParm(1,args);
                continue;
            }
            if ( args.length > 1 && args[0].equals("-pre") ){
                args=sliceParm(1,args);
                pre=args[0];
                args=sliceParm(1,args);
                continue;
            }
            if ( args.length > 1 && args[0].equals("-pos") ){
                args=sliceParm(1,args);
                pos=args[0];
                args=sliceParm(1,args);
                continue;
            }
            if ( path == null ){
                path=args[0];
                args=sliceParm(1,args);
                continue;
            }
            return null;
        }
        return new Object[]{path,acceptSymbolicLink,mtime,type,pre,pos};
    }    

    private Object [] get_parm_bmp_file_len(String [] args){
        String file=null;
        String len=null;
        
        args=sliceParm(1,args);
        while(args.length > 0){
            if ( args[0].equals("-file") ){
                args=sliceParm(1,args);
                file=args[0];
                args=sliceParm(1,args);
                continue;
            }
            if ( args[0].equals("-len") ){
                args=sliceParm(1,args);
                len=args[0];
                args=sliceParm(1,args);
                continue;
            }
            if ( args.length > 0 )
                return null;
            break;
        }
        return new Object[]{file, len};
    }
    
    private Object [] get_parm_path_symbol_bkmg(String [] args){
        String path=null;
        boolean acceptSymbolicLink=false;
        String bkmg = null; // byte/kilo/mega/giga
        
        args=sliceParm(1,args);
        while(args.length > 0){
            if ( args[0].equals("-L") ){
                acceptSymbolicLink=true;                
                args=sliceParm(1,args);
                continue;
            }
            if ( args.length > 0 && ( args[0].equals("-b") || args[0].equals("-k") || args[0].equals("-m") || args[0].equals("-g") ) ){
                bkmg=args[0].substring(1);
                args=sliceParm(1,args);
                continue;
            }
            if ( path == null ){
                path=args[0];
                args=sliceParm(1,args);
                continue;
            }
            return null;
        }
        if ( ! acceptSymbolicLink && isWindows() ){
            System.out.println("Warnning: -L foi considerado para o windows.");
            acceptSymbolicLink=true;
        }
        return new Object[]{path,acceptSymbolicLink,bkmg};
    }    
    
    private Object [] get_parms_paths_virtualname_lvlStore(String [] args){
        String [] paths=new String[]{};
        String virtualname="";
        boolean lvlStore=false;
        ArrayList<String> tmp=new ArrayList<String>();
        
        args=sliceParm(2,args);
        while(args.length > 0){
            if ( args[0].equals("-lvlStore") ){
                lvlStore=true;                
                args=sliceParm(1,args);
                continue;
            }
            if ( args.length > 1 && args[0].equals("-name") ){
                virtualname=args[1];
                args=sliceParm(2,args);
                continue;
            }
            if ( args.length > 0 ){
                tmp.add(args[0]);
                args=sliceParm(1,args);
                continue;
            }
            return null;
        }
        if ( !virtualname.equals("") && tmp.size() > 0 )
            return null;
        if ( virtualname.equals("") && tmp.size() == 0 )
            return null;
        if ( tmp.size() > 0 ){
            paths=new String[tmp.size()];
            for ( int i=0;i<tmp.size();i++ )
                paths[i]=tmp.get(i);
        }
        return new Object[]{paths, virtualname, lvlStore};
    }
            
            
    private void find(String path, Boolean superficial, float mtime, boolean acceptSymbolicLink, String type, String pre, 
            String pos, boolean format_lss, String format_du, OutputStream out){
        String sep=System.getProperty("user.dir").contains("/")?"/":"\\";
        File f=null;
        long len_du=0;
        if (path == null){
            f=new File(System.getProperty("user.dir"));
            path="";
        }else{
            try{
                f=new File(path);
            }catch(Exception e){
                System.out.println(e.toString());
                System.exit(1);
            }
        }
        if ( !f.exists() ){
            System.err.println("Error: \""+path+"\" not found!");
            System.exit(1);
        }
        if ( !f.isDirectory() ){
            if ( format_du != null )
                len_du = f.length();
            showfind(f, path, mtime, type, pre, pos, format_lss, format_du, len_du, out);
        }else{
            if ( f.isDirectory())
                find_nav(f, sep, path, superficial, mtime, acceptSymbolicLink, type, pre, pos, format_lss, format_du, out);
        }
    }
    
    private long find_nav(File f, String sep, String hist, Boolean superficial, float mtime, 
                boolean acceptSymbolicLink, String type, String pre, String pos, boolean format_lss, String format_du, OutputStream out){
        long len_du=0;
        long len_du_aux=0;
        String hist_bkp=hist;
        if (superficial || hist.equals("") || hist.equals("/") || (hist.contains(":") && hist.length() <= 3) ){
            // faz nada
        }else{
            if ( format_du == null ){
                showfind(f, hist, mtime, type, pre, pos, format_lss, format_du, 0, out);
            }
            hist+=sep;
        }
        try{
            File [] files = f.listFiles();
            for ( int i=0;i<files.length;i++ ){
                if ( !files[i].isDirectory() ){
                    len_du_aux = 0;
                    if ( superficial ){
                        if ( format_du != null )
                            len_du_aux=files[i].length();
                        else
                            showfind(files[i], files[i].getName(), mtime, type, pre, pos, format_lss, format_du, len_du_aux, out);
                    }else{
                        if ( format_du != null )
                            len_du_aux=new File(hist+files[i].getName()).length();
                        else
                            showfind(files[i], hist+files[i].getName(), mtime, type, pre, pos, format_lss, format_du, len_du_aux, out);
                    }
                    len_du+=len_du_aux;
                }
            }
            boolean force_superficial=false;
            for ( int i=0;i<files.length;i++ ){                
                force_superficial=false;
                if ( files[i].isDirectory() ){
                    // skip anti loop
                    //if ( !acceptSymbolicLink && f.getPath().contains("\\") && !(f.getAbsolutePath()+"\\"+files[i].getName()).replace(":\\\\",":\\").toUpperCase().equals(files[i].toPath().toRealPath().toString().toUpperCase()) )
                    //    continue;                    
                    if (!acceptSymbolicLink && isSymbolicLink(files[i]) )
                        force_superficial=true;
                    if ( superficial || force_superficial){
                        len_du_aux = 0;
                        if ( format_du != null )
                            len_du_aux=files[i].length();
                        else{
                            showfind(files[i], files[i].getName(), mtime, type, pre, pos, format_lss, format_du, len_du_aux, out);
                        }
                    }else
                        len_du += find_nav(files[i], sep, hist+files[i].getName(), superficial, mtime, acceptSymbolicLink, type, pre, pos, format_lss, format_du, out);
                }
                out.flush();
            }
            len_du += f.length();
            if ( format_du != null ){
                showfind(f, hist_bkp, mtime, type, pre, pos, format_lss, format_du, len_du, out);
            }
        }catch(Exception e){}        
        return len_du;
    }
    
    long findnow = 0;
    private void showfind(File f, String name, float mtime, String type, String pre, String pos, boolean format_lss, String format_du, long len_du, OutputStream out){
        try{
            name=name.replace("\\","/");
            boolean print=false;
            String type_a = null;
            String type_lss = null;
            String format_lss_="";
            String format_lss_B="";

            if ( mtime == 0 ){
                print = true;
            }else{
                if ( findnow == 0 ){
                    findnow = java.util.Calendar.getInstance().getTime().getTime();
                }
                long b = new java.util.Date(f.lastModified()).getTime();
                long diffMili = Math.abs(findnow - b);
                if (
                    (mtime > 0 && diffMili >= mtime)
                    || (mtime < 0 && mtime*-1 >= diffMili)
                ){
                    print = true;
                }
            }         
            if ( print && (type != null || format_lss) ){
                type_a="f";
                type_lss="-";
                if ( f.isDirectory() ){
                    if(isSymbolicLink(f)){
                        type_a = "l";
                        type_lss="l";
                    }else{
                        type_a = "d";
                        type_lss="d";
                    }
                }        
            }
            if ( print && type != null && !type.equals(type_a) )
                print = false;
            if ( print ){
                if ( format_lss ){
                    Date d = new Date(f.lastModified());    
                    format_lss_ = f.length() + " " + new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(d) + " ";                
                    String space_="                                                       ";
                    int len_=35;//55
                    format_lss_ = type_lss + space_.substring(0, len_-format_lss_.length()) + format_lss_;                    
                    if ( type_lss.equals("l") ){
                        format_lss_B= f.toPath().toRealPath().toString();
                        if ( format_lss_B.contains(" ") )
                            format_lss_B="\""+format_lss_B+"\"";
                        format_lss_B=" --> " + format_lss_B;
                    }
                }           
                if ( pre != null || pos != null )
                    name="\""+name+"\"";
                if ( pre != null )
                    name=pre+" "+name;
                if ( pos != null )
                    name=name+" "+pos;
                if ( format_du != null ){                
                    if ( format_du.equals("b") )
                        out.write((len_du + "\t" + name + "\n").getBytes());
                    if ( format_du.equals("k") )
                        out.write(((int)(len_du/1024) + "\t" + name + "\n").getBytes());
                    if ( format_du.equals("m") )
                        out.write(((int)(len_du/(1024*1024)) + "\t" + name + "\n").getBytes());
                    if ( format_du.equals("g") )
                        out.write(((int)(len_du/(1024*1024*1024)) + "\t" + name + "\n").getBytes());
                }else{
                    if ( name.contains(" ") ) 
                        if ( isWindows() )
                            name="\"" + name + "\"";
                        else
                            name="'" + name + "'";
                    out.write((format_lss_ + name + format_lss_B + "\n").getBytes());                    
                }
            }
            out.flush();
        }catch(Exception e){
            erroFatal(e);
        }
    }
    
    private boolean lss_linux(String parm){
        try{
            boolean error;
            if ( parm == null )
                parm="ls -ltr --time-style=long-iso";
            else
                parm="ls -ltr --time-style=long-iso \"" + parm + "\"";
            Process proc = Runtime.getRuntime().exec(parm);
            int len=0;
            byte[] b=new byte[1024];
            boolean ok=false;                    
            while ( (len=proc.getInputStream().read(b, 0, b.length)) != -1 ){
                System.out.write(b, 0, len);
                ok=true;
            }
            while ( (len=proc.getErrorStream().read(b, 0, b.length)) != -1 )
                error=true;
            if ( !ok ){
                return false;
            }
        }catch(Exception e){
            System.err.println(e.toString());
            System.exit(1);
        }
        return true;
    }
    
    private boolean lss_mac(String parm_){
        try{
            boolean error;
            int aspeta="'".getBytes()[0];
            int espaco=" ".getBytes()[0];
            byte t_="\t".getBytes()[0];
            boolean literalOn=false;
            String [] parm=new String []{};
            if ( parm_ == null ){
                File [] files=new File(".").listFiles();
                parm=new String[files.length+4];
                parm[0]="stat";
                parm[1]="-l";
                parm[2]="-t";
                parm[3]="%F%T";
                for ( int i=0;i<files.length;i++ )
                    parm[i+4]=files[i].getName();
            }else{
                System.err.println("comando nao implementado!");
                System.exit(1);
            }
            Process proc = Runtime.getRuntime().exec(parm);
            int len=0;
            byte[] b=new byte[1024];
            boolean ok=false;                    
            while ( (len=proc.getInputStream().read(b, 0, b.length)) != -1 ){
                for ( int i=0;i<len;i++ ){
                    if ( b[i] == aspeta ){
                        literalOn=!literalOn;
                        continue;
                    }
                    if ( b[i] == espaco && !literalOn )
                        b[i] = t_;
                }
                System.out.write(b, 0, len);
                ok=true;
            }
            while ( (len=proc.getErrorStream().read(b, 0, b.length)) != -1 )
                error=true;
            if ( !ok ){
                return false;
            }
        }catch(Exception e){
            System.err.println(e.toString());
            System.exit(1);
        }
        return true;
    }
    
    private void split(String bytes, String lines, String prefix, String parm){
        int q_bytes=0;
        int q_lines=0;
        
        if ( !parm.equals("") && ( !new File(parm).exists() || !new File(parm).isFile()) )
        {
            System.err.println(parm + " nao é um arquivo valido!");
            System.exit(1);            
        }            
        
        if ( !bytes.equals("") ){
            try{
                q_bytes=Integer.parseInt(bytes);
                if ( q_bytes <= 0 )
                    throw new Exception();
            }catch(Exception e){
                System.err.println("numero invalido = "+ bytes);
                System.exit(1);                            
            }
        }

        if ( !lines.equals("") ){
            try{
                q_lines=Integer.parseInt(lines);
                if ( q_lines <= 0 )
                    throw new Exception();
            }catch(Exception e){
                System.err.println("numero invalido = "+ lines);
                System.exit(1);                            
            }
        }
        
        InputStream is=null;
        OutputStream os=null;
        try{
            if (parm.equals(""))
                is=System.in;
            else
                is=new FileInputStream(parm);
            
            byte[] buf = new byte[BUFFER_SIZE];
            int count=0;
            int len=0;
            int p=0;
            String name="";
            byte[] n_="\n".getBytes();
			
            while( (len=is.read(buf,0,BUFFER_SIZE)) > 0 ){
                p=0;                                
                if ( q_bytes > 0 ){ // bytes
                    while(p < len){						
                        if ( os == null ){
                            name=getNameSplit(prefix);
                            os = new FileOutputStream(name);
                        }
                        if ( count >= q_bytes ){
                            os.flush();
                            os.close();
                            name=getNameSplit(prefix);
                            os = new FileOutputStream(name);
                            count=0;
                        }                 
                        if ( len-p <= q_bytes-count ){
                            int aux=len-p;
                            os.write(buf, p, aux);
                            count+=aux;
                            p+=aux;
                        }else{
                            int aux=q_bytes-count;
                            os.write(buf, p, aux);
                            count+=aux;
                            p+=aux;                            
                        }
                    }
                }else{ // lines
                    while(p < len){						
                        if ( os == null ){
                            name=getNameSplit(prefix);
                            os = new FileOutputStream(name);
                        }
                        if ( count >= q_lines ){
                            os.flush();
                            os.close();
                            name=getNameSplit(prefix);
                            os = new FileOutputStream(name);
                            count=0;
                        }    
                        int aux=0;
                        while(p < len && count < q_lines){
                            if (buf[p] == n_[0])
                                count++;
                            aux++;
                            p++;                            
                        }
                        os.write(buf, p-aux, aux);
                    }
                }
            }
        }catch(Exception e){
            System.err.println(e.toString());
            System.exit(1);
        }
        try{
            is.close();
        }catch(Exception e){}
        try{
            os.flush();
            os.close();
        }catch(Exception e){}
    }
        
    public String [] getBytesLinesPrefixParm(String [] args){
        String bytes="";        
        String lines="";
        String prefix="";
        String parm="";
        
        if ( args.length > 0 && args[0].equals("split") )
            args=sliceParm(1,args);
        
        if ( args.length > 0 && args[0].startsWith("--bytes=") )
        {
            bytes=args[0].split("=")[1];
            args=sliceParm(1,args);
        }

        if ( args.length > 1 && args[0].startsWith("-b") )
        {
            bytes=args[1];
            args=sliceParm(2,args);
        }
        
        if ( args.length > 0 && args[0].startsWith("--lines=") )
        {
            lines=args[0].split("=")[1];
            args=sliceParm(1,args);
        }

        if ( args.length > 1 && args[0].startsWith("-l") )
        {
            lines=args[1];
            args=sliceParm(2,args);
        }

        if ( args.length > 0 && args[0].startsWith("--prefix=") )
        {
            prefix=args[0].split("=")[1];
            args=sliceParm(1,args);
        }

        if ( args.length > 1 && args[0].startsWith("-p") )
        {
            prefix=args[1];
            args=sliceParm(2,args);
        }
        
        if ( args.length > 0 )
        {
            parm=args[0];
            args=sliceParm(1,args);
        }
        
        if ( args.length > 0 || lines.equals("") == bytes.equals("") )
            return null;

        return new String[]{bytes, lines, prefix, parm};
    }

    private void regua(int p){
        String s="";
        if( p < 0 ) 
            return;
        if ( p > 300 )
            p=300;
        for ( int i=5;i<=p;i+=5 ){
            if(i%10==5)
                s+="....+";
            else{
                String t=""+i;
                while (t.length()<5)
                    t="."+t;
                s+=t;
            }
        }
        System.out.println(s);
    }

    private void link(String fonte, String new_){
        if ( new File(new_).exists() ){
            System.out.println("Error - Ja existe o elemento " + new_ + "!");
            System.exit(1);        
        }else{
            String sep=System.getProperty("user.dir").contains("/")?"/":"\\";
            File [] files = new File(System.getProperty("user.dir")+sep+new_).getParentFile().listFiles();
            for ( int i=0;i<files.length;i++ ){
                if ( files[i].getName().equals(new_)){
                    System.out.println("Error - Ja existe o elemento " + new_ + "!");
                    System.exit(1);                            
                }
            }
        }
        if ( !new File(fonte).exists() ){
            System.out.println("Warning: O Elemento de origem " + fonte + " nao foi encontrado, mesmo assim o linked deve ser criado!");
        }
            
        String [] partes=null;        
        if ( System.getProperty("user.dir").contains("/") )
            partes = new String[]{"ln", "-s", fonte, new_};
        else
            partes = new String[]{"cmd", "/c", "mklink", "/j", new_, fonte};
        
        try{
            String s=runtimeExec(null, partes, null, null, null);
            if ( 
                runtimeExecError != null 
                && runtimeExecError.contains("Os volumes locais s") // quando o disco não é local, exemplo drive mapeado
                && !System.getProperty("user.dir").contains("/") ){
                partes = new String[]{"cmd", "/c", "mklink", "/D", new_, fonte};
                try{
                    runtimeExec(null, partes, null, null, null);
                    System.out.println("finish!");
                    return;
                }catch(Exception e){}
            }
            System.out.println("finish!");
        }catch(Exception e){}
    }

    private void uptime(boolean ms){
        boolean show=false;
        
        String [] command = new String[]{
            "cmd /c wmic path Win32_OperatingSystem get LastBootUpTime, LocalDateTime",
            "cat /proc/uptime",
            "date +%s",
            "sysctl -n kern.boottime",
        };
        String [] index_command = new String[]{
            "windows",
            "linux",
            "aux_mac",
            "mac",
        };      
        String s1_aux="";  
        for ( int i=0;i<command.length;i++ ){
            try {          
                String s = runtimeExec(command[i], null, null, null, null).trim();
                if ( s == null ){
                    if ( runtimeExecError.contains("Permission denied") ){                        
                        System.err.println("Permission denied!");
                        System.exit(1);
                    }
                    continue;
                }

                long seconds=-1;
                if ( index_command[i].equals("windows") ){
                    s = s.split("\r\n")[1];
                    String s1=s.split(" ")[0];
                    String s2=s.split(" ")[2];
                    if ( s1.split("\\.").length > 1 )
                        s1=s1.split("\\.")[0];
                    if ( s2.split("\\.").length > 1 )
                        s2=s2.split("\\.")[0];
                    seconds=new SimpleDateFormat("yyyyMMddHHmmss").parse(s2).getTime() - new SimpleDateFormat("yyyyMMddHHmmss").parse(s1).getTime();                    
                    seconds/=1000;
                }
                if ( index_command[i].equals("linux") ){
                    s = s.split("\r\n")[0];
                    String s1=s.split(" ")[0];
                    String s2=s.split(" ")[1];
                    if ( s1.split("\\.").length > 1 )
                        s1=s1.split("\\.")[0];
                    if ( s2.split("\\.").length > 1 )
                        s2=s2.split("\\.")[0];
                    seconds=Long.parseLong(s1)-Long.parseLong(s2);                    
                    seconds=Long.parseLong(s1); // remover s2 depois
                }
                if ( index_command[i].equals("aux_mac") ){
                    s = s.split("\r\n")[0];
                    s1_aux = s.replace("\r","").replace("\n","");
                    continue;
                }
                if ( index_command[i].equals("mac") ){
                    s = s.split("\r\n")[0];
                    String s1=s1_aux;
                    String s2=s.replace(",","").split(" ")[3];
                    seconds=Long.parseLong(s1)-Long.parseLong(s2);                    
                }
                if ( ms ){
                    System.out.println(seconds+" seconds");
                }else{
                    System.out.println(seconds_to_string(seconds, "format1"));
                }
                show=true;
                break;                        
            } catch (Exception ex) {
                continue;        
            }        
        }
        if ( !show )
            System.out.println("Falha ao obter uptime");
    }
    
    private void cronometro(String parm){
        if ( parm == null ){
            try{
                System.out.println("startado. pressione enter para mais flags.");
                InputStream inputStream_pipe=System.in;
                byte[] buf = new byte[BUFFER_SIZE];
                int len=0;
                ArrayList<Long> lista=new ArrayList<>();
                lista.add(epochmili(null));
                while( (len=inputStream_pipe.read(buf,0,BUFFER_SIZE)) > 0 ){
                    lista.add(epochmili(null));
                    Long [] elem=new Long[lista.size()];
                    for ( int i=0;i<lista.size();i++ )
                        elem[i]=(Long)lista.get(i);
                    String s="";
                    for ( int i=1;i<lista.size();i++ ){
                        if( i == 1 )
                            s=cronometro_format(elem[i]-elem[i-1], elem[i]-elem[i-1]);
                        else
                            s=cronometro_format(elem[i]-elem[i-1], elem[i]-elem[0]);
                    }                        
                    System.out.print(s);
                }
                System.out.flush();
                System.out.close();
            }catch(
                Exception e){System.out.println("Erro fatal!");
            };            
        }else{
            if ( parm.equals("start") )
                if ( ! salvando_file(epochmili(null)+"\n",new File(".cron_flag")) )
                    System.out.println("Erro, nao foi possivel gravar uma flag!");
            if ( parm.equals("flag") )
                if ( ! salvando_file(epochmili(null)+"\n",new File(".cron_flag"),true) )
                    System.out.println("Erro, nao foi possivel gravar uma flag!");
            if ( parm.equals("end") ){
                File f=new File(".cron_flag");
                if ( f.exists() ){
                    String s=lendo_arquivo(".cron_flag")+"\n"+epochmili(null);
                    String [] partes=s.split("\n");
                    Long [] elem=new Long[partes.length];
                    for ( int i=0;i<partes.length;i++ )
                        elem[i]=Long.parseLong(partes[i]);
                    for ( int i=1;i<partes.length;i++ ){
                        if( i == 1 )
                            System.out.println(cronometro_format(elem[i]-elem[i-1], elem[i]-elem[i-1]));
                        else
                            System.out.println(cronometro_format(elem[i]-elem[i-1], elem[i]-elem[0]));
                    }
                    if ( ! new File(".cron_flag").delete() )
                        System.out.println("Erro, nao foi possivel apagar a flag!");
                }else
                    System.out.println("Erro, nao foi possivel ler a flag!");
            }
        }
    }    
    public void steam(String [] args){
        try{
            args=sliceParm(1, args);
            String token=gettoken("steam");
            if ( token == null )
                erroFatal("Nao foi possível encontrar o token steam, digite y help steam para mais informacoes!");
            token=token.trim().split("\n")[0];
            if( token.startsWith(":") || token.endsWith(":") || token.split(":").length != 2 )
                erroFatal("conteudo do token incorreto!");
            String [] partes=token.split(":");
            String steam_api_key=partes[0];
            String steam_id=partes[1];        
            if ( !isHex(steam_api_key) )
                erroFatal("conteudo do token incorreto!");
            if ( !isNumeric(steam_id) )
                erroFatal("conteudo do token incorreto, o steam_id precisa ser numérico!");

            if ( args.length == 1 && args[0].equals("friends") ){
                System.out.println(steam_friends(steam_api_key, steam_id));
            }else{
                if ( args.length == 2 && args[0].equals("friends") && args[1].equals("status") ){
                    String s=steam_friends(steam_api_key, steam_id);
                    s=String.join(",", s.split("\n"));
                    s=steam_status(steam_api_key, s);
                    System.err.println("0-offline, 1-online, 3-ausente");
                    System.out.println(s);
                }else{
                    if ( args.length == 2 && args[0].equals("status") && isNumeric(args[1].replaceAll("\\,","")) ){
                        String s=steam_status(steam_api_key, args[1]);
                        System.err.println("0-offline, 1-online, 3-ausente");
                        System.out.println(s);                        
                    }else{
                        if ( args.length == 1 && args[0].equals("raw") ){
                            String s=steam_friends(steam_api_key, steam_id);
                            s=String.join(",", s.split("\n"));
                            System.out.println(steam_raw(steam_api_key, s));
                        }else{
                            if ( args.length == 3 && args[0].equals("friends") && args[1].equals("clan") && args[2].equals("status") ){                            
                                String s=steam_friends(steam_api_key, steam_id);
                                s=String.join(",", s.split("\n"));
                                s=steam_status(steam_api_key, s);                                
                                String clan=steam_getClanBySteamId(s, steam_id).trim();
                                // contornando bug
                                selectCSV_header=null;
                                selectCSV_headerPrinted=false;                                
                                String statusClan=steam_statusByClan(s, clan);
                                System.err.println("0-offline, 1-online, 3-ausente");
                                System.out.println(statusClan);
                            }else{
                                if ( (args.length == 3 || args.length == 4) && args[0].equals("flag") && isNumeric(args[1]) && isNumeric(args[2]) ){
                                    String som_path=null;
                                    if ( args.length == 4 ){
                                        som_path=args[3];
                                        if ( !new File(som_path).exists() )
                                            erroFatal("Erro, não foi possivel encontrar o arquivo "+som_path);
                                    }
                                    long seconds=Long.parseLong(args[2]);                                                                        
                                    String header="\n##\n##  monitoring: " + args[1] + " a cada " + args[2] + " segundos!\n##\n\n\n";
                                    String status="";
                                    int tail_status_code=1;
                                    int status_code=1;
                                    while(true){                                        
                                        String s=steam_status(steam_api_key, args[1]);
                                        s=steam_personastate(s);
                                        if ( s.equals("0") ){
                                            status_code=0;
                                            status=flag_off;
                                        }
                                        if ( s.equals("1") ){
                                            status_code=1;
                                            status=flag_on;
                                        }
                                        if ( s.equals("3") ){
                                            status_code=3;
                                            status=flag_away;
                                        }
                                        clear_cls();
                                        System.out.println(header+status);
                                        if ( status_code == 1 && tail_status_code != 1 && som_path!=null )
                                            runtimeExec(som_path, null, null, null, null);
                                        sleepSeconds(seconds);
                                        tail_status_code=status_code;
                                    }
                                }else
                                    erroFatal("Parametros invalidos");                                
                            }
                        }
                    }
                }
            }
        }catch(Exception e){
            erroFatal(e);
        }        
    }
    public String steam_custom_curl(String url){
        return curl_string_retry(url, 3, 100, new int[]{429, 502});
    }
    public String steam_friends(String steam_api_key, String steam_id) throws Exception{
        String s=steam_custom_curl("https://api.steampowered.com/ISteamUser/GetFriendList/v1/?key=" + steam_api_key + "&steamid=" + steam_id + "&relationship=friend");
        if ( curl_response_status != 200 )
            erroFatal("Status code:"+curl_response_status);
        if ( curl_error != null )
            erroFatal("Erro: "+curl_error);        
        s=runtimeExecY(new String []{"json", "[elem['steamid'] for elem in data['friendslist']['friends']]"}, s.getBytes());
        if ( s == null )
            erroFatal("Erro: " + runtimeExecError);
        s=s.trim().replace("\"","");
        s+="\n"+steam_id;
        return s;
    }
    String steam_campos_base="steamid,communityvisibilitystate,profilestate,personaname,commentpermission,profileurl,avatar,avatarmedium,avatarfull,avatarhash,lastlogoff,personastate,realname,primaryclanid,timecreated,personastateflags,gameserverip,gameserversteamid,gameextrainfo,gameid,loccountrycode,locstatecode,loccityid";
    String steam_campos="steamid,personastate,personaname,realname,gameextrainfo,gameid,primaryclanid,communityvisibilitystate,profilestate,commentpermission,profileurl,avatar,avatarmedium,avatarfull,avatarhash,lastlogoff,timecreated,personastateflags,gameserverip,gameserversteamid,loccountrycode,locstatecode,loccityid";
    public String steam_raw(String steam_api_key, String steam_ids) throws Exception{
        String s=steam_custom_curl("https://api.steampowered.com/ISteamUser/GetPlayerSummaries/v2/?key=" + steam_api_key + "&steamids=" + steam_ids);
        if ( curl_response_status != 200 )
            erroFatal("Status code:"+curl_response_status);
        if ( curl_error != null )
            erroFatal("Erro: "+curl_error);        
        //monta estrutura
        s=runtimeExecY(new String []{"json", "mostraEstrutura"}, s.getBytes());
        if ( s == null )
            erroFatal("Erro: " + runtimeExecError);
        //normaliza os campos
        String opcional=steam_campos_base;                         
        s=normalizeFieldsJson(s, "        ", opcional);
        return s;
    }
    public String steam_status(String steam_api_key, String steam_ids) throws Exception{
        String s=steam_raw(steam_api_key, steam_ids);
        s=runtimeExecY(new String []{"json", "[elem for elem in data['response']['players']]"}, s.getBytes());
        if ( s == null )
            erroFatal("Erro: " + runtimeExecError);
        s=runtimeExecY(new String []{"selectCSV", "select " + steam_campos + " from this"}, s.getBytes());
        if ( s == null )
            erroFatal("Erro: " + runtimeExecError);
        s=s.replaceAll("\\\\\"", "\"");
        return s;
    }
    public String steam_getClanBySteamId(String txt, String steam_id) throws Exception{
        String s=runtimeExecY(new String []{"selectCSV", "select primaryclanid from this where steamid = '" + steam_id + "'"}, txt.getBytes());
        if ( s == null )
            erroFatal("Erro: " + runtimeExecError);
        String [] partes=s.split("\n");
        s=partes[partes.length-1];
        s=s.replaceAll("\"","").trim();
        return s;
    }
    public String steam_statusByClan(String txt, String clan) throws Exception{
        String s=runtimeExecY(new String []{"selectCSV", "select " + steam_campos + " from this where primaryclanid = '" + clan + "'"}, txt.getBytes());
        if ( s == null )
            erroFatal("Erro: " + runtimeExecError);
        return s;
    }
    public String steam_personastate(String txt) throws Exception{
        String s=runtimeExecY(new String []{"selectCSV", "select personastate from this"}, txt.getBytes());
        String [] partes=s.split("\n");
        s=partes[partes.length-1];
        s=s.replaceAll("\"","").trim();
        return s;
    }
    private String cronometro_format(long a, long b){
        return miliseconds_to_string(a) + " - " + miliseconds_to_string(b) + " total";
    }
    
    private void ping_list(int timeout){
        String line;
        while ( (line=readLine()) != null ) {
            if ( line.startsWith(" ") )
                format_show_ip(line.trim(), ping(line.trim(), timeout));
            else
                System.out.println(line);
        }
    }
    
    private String pingMine(String host, int port) throws Exception{
        // refresh dns jvm
        // networkaddress.cache.ttl=5
        // networkaddress.cache.ttl=-1
        // in %JAVA_HOME%/jre/lib/security/java.security
        String retorno=null;
        Socket socket=new Socket();
        socket.connect(new InetSocketAddress(host, port), 1000);
        InputStream is=socket.getInputStream();
        OutputStream os=socket.getOutputStream();         
        byte[] b=new byte[]{(byte)43,(byte)0,(byte)191,(byte)4,(byte)36,      
            (byte)50,(byte)50,(byte)50,(byte)50,(byte)58,    
            (byte)50,(byte)50,(byte)50,(byte)58,    
            (byte)50,(byte)50,(byte)50,(byte)50,(byte)58,    
            (byte)50,(byte)50,(byte)50,(byte)50,(byte)58,    
            (byte)50,(byte)50,(byte)50,(byte)50,(byte)58,    
            (byte)50,(byte)50,(byte)58,    
            (byte)50,(byte)50,(byte)50,(byte)50,(byte)58,    
            (byte)50,(byte)50,(byte)50,(byte)50,
            (byte)99,(byte)222,(byte)1,(byte)1,(byte)0};
        os.write(b);
        byte [] buf=new byte[1024*10];
        int len=is.read(buf);
        if ( len == -1 )
            throw new Exception("host nao responde: " + host+" " + port);
        String s=new String(buf,0,len,"UTF-8");
        while(s.length()>0&&!s.substring(0,1).equals("{"))
            s=s.substring(1);
        java.io.ByteArrayOutputStream baos = new java.io.ByteArrayOutputStream();
        new JSON(new java.io.ByteArrayInputStream(s.getBytes()), "", false, true, false, false, false, baos);
        retorno=baos.toString();
        return retorno;
    }
    
    public void pingMine_Tray(String host, int port){
        if ( !java.awt.SystemTray.isSupported() )
            erroFatal("Tray não suportado nesse ambiente!");        
        try{
            java.awt.SystemTray tray = java.awt.SystemTray.getSystemTray();                
            java.awt.PopupMenu popup = new java.awt.PopupMenu();
            java.awt.MenuItem item=new java.awt.MenuItem("Exit");
            item.addActionListener(
                new java.awt.event.ActionListener() {
                    public void actionPerformed(java.awt.event.ActionEvent e) {
                        System.exit(0);
                    }
                }
            );        
            popup.add(item);
            java.awt.TrayIcon trayIcon = new java.awt.TrayIcon( convertOnlyDigitNumberToImage(pingMine_getPlayersOnline(host, port)), "numero de onlines minecraft " + host, popup );            
            trayIcon.setImageAutoSize(true);
            tray.add(trayIcon);
            while(true){
                sleepSeconds(10);
                trayIcon.setImage( convertOnlyDigitNumberToImage(pingMine_getPlayersOnline(host, port)) );
            }
        }catch(Exception e){
            erroFatal(e);
        }
    }
    
    public BufferedImage convertOnlyDigitNumberToImage(int n){
        BufferedImage retorno=null;
        try {  
            String [][] digits=new String[][]{
                { /* 0 */ "00000000000000","00011111111000","00011111111000","00011000011000","00011000011000","00011000011000","00011000011000","00011000011000","00011000011000","00011111111000","00011111111000","00000000000000"},
                { /* 1 */ "00000000000000","00000000011000","00000000011000","00000000011000","00000000011000","00000000011000","00000000011000","00000000011000","00000000011000","00000000011000","00000000011000","00000000000000"},
                { /* 2 */ "00000000000000","00011111111000","00011111111000","00000000011000","00000000011000","00011111111000","00011111111000","00011000000000","00011000000000","00011111111000","00011111111000","00000000000000"},
                { /* 3 */ "00000000000000","00011111111000","00011111111000","00000000011000","00000000011000","00011111111000","00011111111000","00000000011000","00000000011000","00011111111000","00011111111000","00000000000000"},
                { /* 4 */ "00000000000000","00011000011000","00011000011000","00011000011000","00011000011000","00011111111000","00011111111000","00000000011000","00000000011000","00000000011000","00000000011000","00000000000000"},
                { /* 5 */ "00000000000000","00011111111000","00011111111000","00011000000000","00011000000000","00011111111000","00011111111000","00000000011000","00000000011000","00011111111000","00011111111000","00000000000000"},
                { /* 6 */ "00000000000000","00011111111000","00011111111000","00011000000000","00011000000000","00011111111000","00011111111000","00011000011000","00011000011000","00011111111000","00011111111000","00000000000000"},
                { /* 7 */ "00000000000000","00011111111000","00011111111000","00000000011000","00000000011000","00000000011000","00000000011000","00000000011000","00000000011000","00000000011000","00000000011000","00000000000000"},
                { /* 8 */ "00000000000000","00011111111000","00011111111000","00011000011000","00011000011000","00011111111000","00011111111000","00011000011000","00011000011000","00011111111000","00011111111000","00000000000000"},
                { /* 9 */ "00000000000000","00011111111000","00011111111000","00011000011000","00011000011000","00011111111000","00011111111000","00000000011000","00000000011000","00011111111000","00011111111000","00000000000000"},
                { /* ? */ "00000000000000","00011111111000","00011100111000","00011000011000","00000000011000","00000000110000","00000001100000","00000011000000","00000000000000","00000011000000","00000011000000","00000000000000"}                
            };	
            String[] digit=digits[10];
            if ( n > 9 )
                digit=digits[9];
            else{
                if ( n >= 0 )
                    digit=digits[n];
            }
            int w=digit[0].length();
            int h=digit.length;
            int [] rgbs=new int[w*h];
            int nivel=0;
            
            nivel=150; int cinza = ((nivel & 0xFF) << 16) | ((nivel & 0xFF) << 8) | (nivel & 0xFF); // RGB
            nivel=150; int vermelho = ((nivel & 0xFF) << 16) | ((0 & 0xFF) << 8) | (0 & 0xFF); // RGB            
            nivel=150; int verde = ((0 & 0xFF) << 16) | ((nivel & 0xFF) << 8) | (0 & 0xFF); // RGB            
            nivel=255; int branco = ((nivel & 0xFF) << 16) | ((nivel & 0xFF) << 8) | (nivel & 0xFF); // RGB            
            nivel=0; int preto = ((nivel & 0xFF) << 16) | ((nivel & 0xFF) << 8) | (nivel & 0xFF); // RGB            
            int c=0;
            for ( int j=0;j<h;j++ ){
                for ( int i=0;i<w;i++ ){
                    if ( digit[j].substring(i,i+1).equals("1") )                        
                        rgbs[c++]=cinza;
                    else
                        rgbs[c++]=preto;
                }
            }                          
            retorno = new BufferedImage(w, h, BufferedImage.TYPE_3BYTE_BGR);
            retorno.setRGB(0, 0, w, h, rgbs, 0, w);            
        } catch (Exception e) {            
            erroFatal(e);
        }        
        return retorno;
    }
    
    public int pingMine_getPlayersOnline(String host, int port){
        String s="";
        try{        
            s=pingMine(host, port);
            //System.out.println(s);
            String [] partes=s.replace(",", "").split("\n");
            for ( int i=0;i<partes.length;i++ )
                if ( partes[i].contains("online") )
                    return Integer.parseInt(partes[i].trim().split(" ")[1]);
        }catch(Exception e){
            //System.out.println(e.toString() + " " + s);
        }
        return -1;
    }        

    private void mouse(String [] args){        
        if ( args.length == 2 && args[1].equals("f5") ){
            mouse_f5();
            return;
        }
        try{
            int dont_move_x=-1;
            int dont_move_y=-1;
            mouse_print_enable=true;
            if ( args.length == 1 ){
                while(true){
                    robotMouseSleep(0.1F);                
                    robotMouseShowXY();
                }
            }else{
                if ( args.length > 2 ){
                    System.err.println("Excesso de parametros, use um conjunto de parametros usando aspas");
                    System.exit(1);
                }
                args = args[1].split(" ");
                int p=0;
                if ( args[0].equals("dontMove") ){
                    args=sliceParm(1, args);
                    if ( args.length == 0 )
                        erroFatal("dontMove usado de forma incorreta!");
                    Integer [] s=robotMouseGetXYAndRGB();
                    dont_move_x=s[0];
                    dont_move_y=s[1];
                    if ( dont_move_x == -1 )
                        erroFatal("erro interno mouse!");
                    mouse_print_enable=false;
                }
                while(true){
                    robotMouseVerifyExit();
                    if ( dont_move_x != -1 ){
                        Integer [] s=robotMouseGetXYAndRGB();
                        if ( s[0] != dont_move_x || s[1] != dont_move_y ){
                            System.out.println("dontMove finalizado!");
                            break;
                        }
                    }
                    if ( p < args.length && ( args[p].equals("move") || args[p].equals("m") ) && p+3 <= args.length ){
                        mouse_print(args[p] + " " + args[p+1] + " " + args[p+2]);
                        robotMouseMove(Integer.parseInt(args[p+1]),Integer.parseInt(args[p+2]));
                        robotDelay(20);
                        p+=3;
                        continue;
                    }
                    if ( p < args.length && ( args[p].equals("sleep") || args[p].equals("s") ) && p+2 <= args.length ){
                        mouse_print(args[p] + " " + args[p+1]);
                        robotMouseSleep(Float.parseFloat(args[p+1]));
                        p+=2;
                        continue;
                    }
                    if ( p < args.length && ( args[p].equals("key") || args[p].equals("k") ) && p+2 <= args.length ){
                        mouse_print(args[p] + " " + args[p+1]);
                        robotKey(args[p+1].toCharArray()[0]);
                        p+=2;
                        continue;
                    }
                    if ( p < args.length && ( args[p].equals("keypress") || args[p].equals("kp") ) && p+2 <= args.length ){
                        mouse_print(args[p] + " " + args[p+1]);
                        robotKeyPress(args[p+1].toCharArray()[0]);
                        p+=2;
                        continue;
                    }
                    if ( p < args.length && ( args[p].equals("keyrelease") || args[p].equals("kr") ) && p+2 <= args.length ){
                        mouse_print(args[p] + " " + args[p+1]);
                        robotKeyRelease(args[p+1].toCharArray()[0]);
                        p+=2;
                        continue;
                    }
                    if ( p < args.length && ( args[p].equals("click") || args[p].equals("c") ) ){
                        mouse_print(args[p]);
                        robotMouseClickEsq();
                        p++;
                        continue;
                    }
                    if ( p < args.length && ( args[p].equals("clickDireito") || args[p].equals("cD") ) ){
                        mouse_print(args[p]);
                        robotMouseClickDir();
                        p++;
                        continue;
                    }
                    if ( p == args.length ){
                        p=0;
                        continue;
                    }
                    erroFatal(11);
                }
            }
        }catch(Exception e){
            erroFatal("robot nao encontrado!");
        }
    }

    private void mouse_f5(){
        String script="""
import threading
import time
import pyautogui
import keyboard
from pynput import mouse
import sys

class AutoClicker:
    def __init__(self):
        self.running = False
        self.running6 = False
        self.click_thread = None
        self.initial_position = None
        self.click_interval = 0.01  # 10ms

    def start_auto_click6(self):
        if self.running:
            return
        self.running6 = True        
        self.start_auto_click()              

    def not_current(self, pos):
        return pos != self.initial_position and not self.running6

    def start_auto_click(self):
        if self.running:
            return
        
        self.running = True
        self.initial_position = pyautogui.position()
        
        def click_loop():
            while self.running:
                if self.not_current(pyautogui.position()):
                    self.stop_auto_click()
                    break
                
                pyautogui.click(button='left')
                
                time.sleep(self.click_interval)
        
        self.click_thread = threading.Thread(target=click_loop, daemon=True)
        self.click_thread.start()
    
    def stop_auto_click(self):
        if self.running:
            self.running6 = False
            self.running = False
            print("Auto-click parado.")
    
    def is_running(self):
        return self.running
                      
    def is_running6(self):
        return self.running6

class MouseMonitor:
    def __init__(self, auto_clicker):
        self.auto_clicker = auto_clicker
        
    def on_move(self, x, y):
        if self.auto_clicker.is_running() and hasattr(self.auto_clicker, 'initial_position') and self.auto_clicker.initial_position and self.not_current( (x, y) ):
            self.auto_clicker.stop_auto_click()

def main():
    auto_clicker = AutoClicker()
    mouse_monitor = MouseMonitor(auto_clicker)
    
    mouse_listener = mouse.Listener(on_move=mouse_monitor.on_move)
    mouse_listener.daemon = True
    mouse_listener.start()
    
    def toggle_auto_click():
        if auto_clicker.is_running():
            auto_clicker.stop_auto_click()
        else:
            auto_clicker.start_auto_click()

    def toggle_auto_click6():
        if auto_clicker.is_running():
            auto_clicker.stop_auto_click()
        else:
            auto_clicker.start_auto_click6()

    keyboard.add_hotkey('f5', toggle_auto_click)
    keyboard.add_hotkey('f6', toggle_auto_click6)
    
    try:
        keyboard.wait()
    except KeyboardInterrupt:
        exit_program(auto_clicker)

def exit_program(auto_clicker):
    auto_clicker.stop_auto_click()
    keyboard.unhook_all()
    sys.exit(0)

if __name__ == "__main__":
    main()
""";
        System.out.println("""
programa em execução!
clicker rapida de 0.01 segundos
F5 liga/desliga podendo ser desligado ao mover o mouse
F6 liga/desliga 
""");            
        
        String retorno=runtimeExec(null, new String[]{"python3"}, null, script.getBytes(), false);
        if ( retorno == null || retorno.equals("") ){
            if ( runtimeExecError.contains("No module named 'keyboard'") )
                erroFatal("\n\nERRO!, é preciso instalar o keyboard, use pip install keyboard");
            System.out.println("Erro: " + runtimeExecError);
        }
        return;
        
    }
    
    boolean mouse_print_enable=true;
    public void mouse_print(String a){
        if ( mouse_print_enable )
            System.out.println(a);
    }
    
    public void injectMicLine(InputStream is){ // not work - nao sei como funciona o Port
        try {
            javax.sound.sampled.Port.Info info = new javax.sound.sampled.Port.Info(javax.sound.sampled.Port.class,"MICROPHONE", true);
            javax.sound.sampled.Line line_ = javax.sound.sampled.AudioSystem.getLine(info);
            //com.sun.media.sound.
            //java.lang.ClassCastException: com.sun.media.sound.PortMixer$PortMixerPort cannot be cast to javax.sound.sampled.SourceDataLine
            javax.sound.sampled.SourceDataLine line = (javax.sound.sampled.SourceDataLine)line_;
            int BUFFER_SIZE = 1024;            
            byte[] buff = new byte[BUFFER_SIZE];            
            int len = 0;   
            while( (len=is.read(buff, 0, BUFFER_SIZE)) > 0 )
                line.write(buff, 0, len);
        } catch (Exception e) {
            erro_amigavel_exception(e);
        } 
    }
    
    public void filterLine(javax.sound.sampled.TargetDataLine line, OutputStream out, boolean filter) throws Exception{
        int BUFFER_SIZE = 1024;            
        byte[] buff = new byte[BUFFER_SIZE];            
        byte[] buff2 = new byte[BUFFER_SIZE];            
        int len = 0;   
        int tmp=0;
        long lenMix=0;
        int countB=0;
        long now = epochmili(null);
        long tmp_now=0;
        while( (len=line.read(buff, 0, BUFFER_SIZE)) > 0 ){
            if ( filter ){
                lenMix=0;
                for ( int i=0;i<len;i++ ){
                    tmp=buff[i];
                    tmp += 128;
                    lenMix+=tmp;
                }
                if ( lenMix < 120000){
                    countB=0;
                }else{
                    countB++;
                }
                if ( countB >= 10){
                    now = epochmili(null);
                    out.write(buff, 0, len);
                }else{
                    tmp_now = epochmili(null);
                    if ( tmp_now < now+1000 )
                        out.write(buff, 0, len);
                    else
                        out.write(buff2, 0, len);
                }
            }else
                out.write(buff, 0, len);
            out.flush();
        }          
    }

    public boolean evitarDeviceAudio(String a){
        if ( a.contains("som primário") )
            return true;
        return false;
    }
    
    private String [] tryGetGuidWindows_cacheName=null;
    private String [] tryGetGuidWindows_cacheGuid=null;
    private void tryGetGuidWindows(String prefix, String name){
        if ( !isWindows() ){
            System.out.println(prefix+name);
            return;
        }
        if ( tryGetGuidWindows_cacheName == null ){
            String [] partes=getMixerGuidWindows().split("\n");
            tryGetGuidWindows_cacheName=new String[partes.length];
            tryGetGuidWindows_cacheGuid=new String[partes.length];
            for ( int i=0;i<partes.length;i++ ){
                tryGetGuidWindows_cacheName[i]=partes[i].split("#")[0];
                tryGetGuidWindows_cacheGuid[i]=partes[i].split("#")[1];
            }
        }
        int count=0;
        for ( int i=0;i<tryGetGuidWindows_cacheName.length;i++ ){
            if ( tryGetGuidWindows_cacheName[i].equals(name) ){
                count++;
                System.out.println(prefix+name+" - "+tryGetGuidWindows_cacheGuid[i]);
            }
        }
        if ( count == 0 )
            System.out.println(prefix+name);
    }
    
    public void printAllMixer(String name, int countTarget, int countSource){
        String prefix="";
        if ( !name.startsWith("Port ") ){
            if ( countTarget > 0 && countSource > 0 )
                prefix="ENTRADA/SAIDA - ";
            else{
                if ( countTarget > 0 ){
                    prefix="ENTRADA - ";
                }else{
                    if ( countSource > 0 )
                        prefix="SAIDA - ";
                    else
                        prefix=countTarget + " ENTRADAS - " + countSource + " SAIDAS - ";
                }
            }
            tryGetGuidWindows(prefix, name);
        }
    }
    
    
    public javax.sound.sampled.Mixer [] getMixers(String filter1Mixer, String notLike, boolean printAllMixer, boolean printFirstOk, Boolean getSource, Boolean getTarget){
        if ( filter1Mixer != null && filter1Mixer.equals("-") ) // "-" -> pegando mixer padrao
            filter1Mixer=null;
        javax.sound.sampled.Mixer.Info[] infos = javax.sound.sampled.AudioSystem.getMixerInfo();
        javax.sound.sampled.Mixer [] mixers=new javax.sound.sampled.Mixer[infos.length];
        boolean [] oks=new boolean[infos.length];        
        int countOks=0;
        for ( int i=0;i<infos.length;i++ ){
            mixers[i]=javax.sound.sampled.AudioSystem.getMixer(infos[i]);
            int countSource=mixers[i].getSourceLineInfo().length;
            int countTarget=mixers[i].getTargetLineInfo().length;
            boolean skip=false;
            String name=infos[i].getName();
            if ( printAllMixer )
                printAllMixer(name, countTarget, countSource);
            if ( filter1Mixer != null && !filter1Mixer.equals(name) )
                continue;
            if ( filter1Mixer== null && notLike != null && name.contains(notLike) )
                continue;            
            if ( (getSource && countSource > 0 )
                || (getTarget && countTarget > 0 )
            ){
                oks[i]=true;
                countOks++;
                if ( countOks == 1 && printFirstOk ){
                    System.err.println("Device -> " + name);
                    System.err.flush();
                }
            }
        }
        javax.sound.sampled.Mixer [] retorno=new javax.sound.sampled.Mixer[countOks];
        int count=0;
        for ( int i=0;i<mixers.length;i++ )
            if ( oks[i] )
                retorno[count++]=mixers[i];
        return retorno;
    }
    
    public javax.sound.sampled.TargetDataLine getLineReader(String mixer, Float volume){
        try{            
            javax.sound.sampled.Line line_=null;            
            if ( mixer != null ){
                javax.sound.sampled.Mixer [] mixers=getMixers(mixer, "som primário", false, true, false, true);                
                if ( mixers.length == 0 )
                    erroFatal("Nenhum mixer encontrado!");
                line_ = mixers[0].getLine(mixers[0].getTargetLineInfo()[0]);
            }else{                            
                javax.sound.sampled.AudioFormat format=getAudioFormatBase();
                javax.sound.sampled.DataLine.Info info=new javax.sound.sampled.DataLine.Info(javax.sound.sampled.TargetDataLine.class, format);
                line_=javax.sound.sampled.AudioSystem.getLine(info);
            }
            javax.sound.sampled.TargetDataLine line = (javax.sound.sampled.TargetDataLine)line_;                               
            line.open(line.getFormat());
            line.start();
            if ( volume != null ){
                // trava de segurança
                if ( volume < 0f || volume > 1f )
                    erroFatal("volume inválido!");
                javax.sound.sampled.FloatControl gainControl = (javax.sound.sampled.FloatControl)line.getControl(javax.sound.sampled.FloatControl.Type.MASTER_GAIN);
                float range = gainControl.getMaximum() - gainControl.getMinimum();
                float gain = (range * volume) + gainControl.getMinimum();
                gainControl.setValue(gain);
            }            
            return line;
        }catch(Exception e){
            erro_amigavel_exception(e);
        }
        return null;
    }
    
    public javax.sound.sampled.SourceDataLine getLineWriter(String mixer, AudioFormat format, Float volume){        
        try{
            javax.sound.sampled.Line line_=null;
            if ( mixer != null ){
                javax.sound.sampled.Mixer [] mixers=getMixers(mixer, "som primário", false, true, true, false);
                if ( mixers.length == 0 )
                    erroFatal("Nenhum mixer encontrado!");
                line_ = mixers[0].getLine(mixers[0].getSourceLineInfo()[0]);
            }else{
                if ( format == null )
                    format = getAudioFormatBase();
                javax.sound.sampled.DataLine.Info info=new javax.sound.sampled.DataLine.Info(javax.sound.sampled.SourceDataLine.class, format);
                line_=javax.sound.sampled.AudioSystem.getLine(info);
            }
            javax.sound.sampled.SourceDataLine line=(javax.sound.sampled.SourceDataLine)line_;
            line.open(line.getFormat());
            line.start();
            if ( volume != null ){
                // trava de segurança
                if ( volume < 0f || volume > 1f )
                    erroFatal("volume inválido!");
                javax.sound.sampled.FloatControl gainControl = (javax.sound.sampled.FloatControl)line.getControl(javax.sound.sampled.FloatControl.Type.MASTER_GAIN);
                float range = gainControl.getMaximum() - gainControl.getMinimum();
                float gain = (range * volume) + gainControl.getMinimum();
                gainControl.setValue(gain);
            }
            return line;
        }catch(Exception e){
            erro_amigavel_exception(e);
        }
        return null;
    }
    
    public javax.sound.sampled.AudioFormat getAudioFormatBase(){
        javax.sound.sampled.AudioFormat result=null;
        result=new javax.sound.sampled.AudioFormat(48000, 16, 2, true, false);
        //result=new javax.sound.sampled.AudioFormat(javax.sound.sampled.AudioFormat.Encoding.PCM_FLOAT, 48000, 16, 2, 4, 48000, false);
        return result;
    }

    /*
    // estudo captura de audio do sistema!
    
    // wasapi   -> Stream #0:0: Audio: pcm_f32le ([3][0][0][0] / 0x0003), 48000 Hz, mono, flt, 1536 kb/s
    // no windows mostra -> Canal 1, 16 bit(s), 48000 Hz (Qualidade de DVD)
    0x0003 ->  WaveFormatEncoding.IeeeFloat

    // gravador -> Stream #0:0: Audio: pcm_s16le ([1][0][0][0] / 0x0001), 44100 Hz, mono, s16, 705 kb/s            
    // testar depois, olhar PCM_SIGNED e PCM_UNSIGNED:

    //PCM_SIGNED
    // new javax.sound.sampled.AudioFormat(javax.sound.sampled.AudioFormat.Encoding.PCM_SIGNED, 44100, 16, 2, 4, 44100, false);

    //PCM_FLOAT
    // new javax.sound.sampled.AudioFormat(javax.sound.sampled.AudioFormat.Encoding.PCM_FLOAT, 44100, 16, 2, 4, 44100, false);

    //https://www.metadata2go.com/file-info/sample-fmt
    u16 – unsigned 16 bits
    s16 – signed 16 bits
    s16p – signed 16 bits, planar
    flt – float
    fltp – float, planar
    dbl – double
    dblp – double, planar     

    AudioFloatConverter
    AudioFloatConversion16S
    https://github.com/jaudiolibs/audioservers/blob/master/audioservers-javasound/src/main/java/org/jaudiolibs/audioservers/javasound/AudioFloatConverter.java
    
    
# gravador onlyLine python mic
import pyaudio
import wave
import sys

stream = pyaudio.PyAudio().open(format=pyaudio.paInt16,
                channels=2,
                rate=48000,
                frames_per_buffer=1024,
                input_device_index=0,
                input=True)

while True:
    sys.stdout.buffer.write(stream.read(1024))
    sys.stdout.flush()

# gravador onlyLine python wasapi_windows - creditos: https://github.com/s0d3s/PyAudioWPatch/blob/master/examples/pawp_record_wasapi_loopback.py#L32
import pyaudiowpatch as pyaudio
import time
import sys

p = pyaudio.PyAudio()

"""
###### HostAPI TypeId ##### https://github.com/jleb/pyaudio/blob/master/src/pyaudio.py
paInDevelopment = pa.paInDevelopment #: Still in development
paDirectSound   = pa.paDirectSound   #: DirectSound (Windows only)
paMME           = pa.paMME           #: Multimedia Extension (Windows only)
paASIO          = pa.paASIO          #: Steinberg Audio Stream Input/Output
paSoundManager  = pa.paSoundManager  #: SoundManager (OSX only)
paCoreAudio     = pa.paCoreAudio     #: CoreAudio (OSX only)
paOSS           = pa.paOSS           #: Open Sound System (Linux only)
paALSA          = pa.paALSA          #: Advanced Linux Sound Architecture (Linux only)
paAL            = pa.paAL            #: Open Audio Library
paBeOS          = pa.paBeOS          #: BeOS Sound System
paWDMKS         = pa.paWDMKS         #: Windows Driver Model (Windows only)
paJACK          = pa.paJACK          #: JACK Audio Connection Kit
paWASAPI        = pa.paWASAPI        #: Windows Vista Audio stack architecture
paNoDevice      = pa.paNoDevice      #: Not actually an audio device
"""

try:
    info = p.get_host_api_info_by_type(pyaudio.paWASAPI) # tentar paALSA para linux?
except OSError:
    print('ERROR')

default_speakers = p.get_device_info_by_index(info["defaultOutputDevice"])

if not default_speakers["isLoopbackDevice"]:
    for loopback in p.get_loopback_device_info_generator():
        if default_speakers["name"] in loopback["name"]:
            default_speakers = loopback
            break
    else:
        print('Default loopback output device not found')
        
def callback(in_data, frame_count, time_info, status):
    sys.stdout.buffer.write(in_data)
    sys.stdout.flush()
    return (in_data, pyaudio.paContinue)

p.open(format=pyaudio.paInt16,
        channels=default_speakers["maxInputChannels"],
        rate=int(default_speakers["defaultSampleRate"]),
        frames_per_buffer=1024,
        input=True,
        input_device_index=default_speakers["index"],
        stream_callback=callback
)
while True:
    pass

# gravador onlyLine python linux(pendente)
# PyAudioWPatch only works on Windows    
    */
    
    public void play(String [] parms) throws Exception{        
        Object [] objs=get_parms_f_mixer_line_wav_mp3_volume(parms);
        if ( objs == null )
            erroFatal("Parametros invalidos");
        String f=(String)objs[0];
        String mixer=(String)objs[1];
        Boolean line=(Boolean)objs[2];
        Boolean wav=(Boolean)objs[3];
        Boolean mp3=(Boolean)objs[4];
        Float volume=(Float)objs[5];
        play(mixer, f, null, line, wav, mp3, volume);
    }
    
    public void play(String mixer, String caminho, InputStream is_force, boolean isLine, boolean isWav, boolean isMp3, Float volume){
        // realmente é preciso ter essa redundancia -> String caminho, InputStream is_force
        // porque na comunicação usa-se inputstream... e no wav file local só funciona File.
        // ou seja, existe 3 cenarios.. System.in, InputStream e File
        // ao tentar usar InputStream "no arquivo wav local" ele dá esse erro aqui:
        // java.io.IOException: mark/reset not supported
        try{
            AudioFormat format=null;            
            InputStream is=null;
            javax.sound.sampled.SourceDataLine line=null;
            if ( isLine ){
                if ( is_force != null ){
                    is=is_force;
                }else{
                    if ( caminho == null )
                        is=System.in;
                    else
                        is=new FileInputStream(caminho);
                }
                line=getLineWriter(mixer, format, volume);                
            }else{
                if ( isWav ){
                    if ( caminho == null ){
                        javax.sound.sampled.AudioInputStream audioStream=javax.sound.sampled.AudioSystem.getAudioInputStream(System.in);
                        format=audioStream.getFormat();
                        is=(InputStream)audioStream;                                
                        line=getLineWriter(mixer, format, volume);                    
                    }else{                        
                        javax.sound.sampled.AudioInputStream audioStream=javax.sound.sampled.AudioSystem.getAudioInputStream(new File(caminho));                    
                        format=audioStream.getFormat();
                        is=(InputStream)audioStream;                                
                        line=getLineWriter(mixer, format, volume);                    
                    }
                }else{
                    if ( isMp3 ){
                        byte [] bytes=null;
                        if ( caminho == null )
                            bytes=readAllBytes();
                        else
                            bytes=readAllBytes(caminho);
                        runtimeExec(null, new String []{"ffmpeg", "-f", "mp3", "-i", "pipe:", "-f", "au", "pipe:"}, null, bytes, false);
                        if ( runtimeExecError.contains("Cannot run") )
                            erroFatal("Nao foi possivel encontrar o ffmpeg!");
                        ByteArrayInputStream bais=new ByteArrayInputStream(runtimeExecOutBytes);                        
                        javax.sound.sampled.AudioInputStream audioStream=javax.sound.sampled.AudioSystem.getAudioInputStream(bais);
                        format=audioStream.getFormat();
                        is=(InputStream)audioStream;                                
                        line=getLineWriter(mixer, format, volume);                                            
                    }else{
                        erroFatal("Erro interno, formato invalido!");
                    }
                }
            }

            int BUFFER_SIZE = 1024;
            byte[] buff = new byte[BUFFER_SIZE];
            int len = 0;            
            while ( (len=is.read(buff, 0, BUFFER_SIZE)) != -1 )
                line.write(buff, 0, len);
            line.drain();
            line.close();
        }catch(Exception e){
            erro_amigavel_exception(e);
        }        
    }    

    public void gravador(String [] parms) throws Exception{        
        Object [] objs=get_parms_f_mixer_line_wav_mp3_volume(parms);
        if ( objs == null )
            erroFatal("Parametros invalidos");
        String f=(String)objs[0];
        String mixer=(String)objs[1];
        Boolean line=(Boolean)objs[2];
        Boolean wav=(Boolean)objs[3];
        Boolean mp3=(Boolean)objs[4];
        Float volume=(Float)objs[5];
        gravador(mixer, f, null, line, wav, mp3, volume);
    }
    
    public void gravador(String mixer, String caminho, OutputStream os_force, boolean isLine, boolean isWav, boolean isMp3, Float volume){
        try {
            javax.sound.sampled.TargetDataLine line=getLineReader(mixer, volume);
            OutputStream os=null;
            if ( os_force != null ){
                os=os_force;
            }else{
                if ( caminho == null )
                    os=System.out;
                else
                    os=new FileOutputStream(caminho);
            }
            
            if ( isLine ){
                // só faz sentido ligar o filtro para: y gravador -line -mixer "Driver de captura de som primário"
                filterLine(line, os, false);
            }else{
                if ( isWav ){
                    javax.sound.sampled.AudioInputStream ais = new javax.sound.sampled.AudioInputStream(line);                    
                    System.err.println("gravando...");            
                    System.err.flush();
                    //javax.sound.sampled.AudioSystem.write(ais, javax.sound.sampled.AudioFileFormat.Type.AU, os); // utilizando AU porinquanto
                    javax.sound.sampled.AudioSystem.write(ais, javax.sound.sampled.AudioFileFormat.Type.AU, os); // utilizando AU porinquanto
                }else{
                    if ( isMp3 ){
                        erroFatal("mp3 nao implementado!");
                    }else{
                        erroFatal("Erro interno, formato invalido!");
                    }
                }
            }
        } catch (Exception e) {
            erro_amigavel_exception(e);
        }        
    }
    
    public void call(String [] args){
        try{        
            Object [] objs=get_parm_ip_port_server_send(args);
            if ( objs == null )
                erroFatal("Parametro invalido");
            String ip=(String)objs[0];
            int port=(Integer)objs[1];
            boolean server=(Boolean)objs[2];
            //boolean send=(Boolean)objs[3];
            String print_after="";

            if ( server && ip == null )
                ip=get_ip();
            if ( ip == null ){
                System.err.println("Nenhum ip foi encontrado!");
                System.exit(1);
            }                
            if ( port == -1 )
                port = 222;
            if ( server )
                print_after="# cliente command:\n# y call -client -ip " + ip + " -port " + port;            
            try{
                int len_buffer=BUFFER_SIZE*1024;
                byte [] buffer=new byte[len_buffer];
                int len=0;
                Socket s = null;
                ServerSocket ss=null;
                if ( server ){
                    try{
                        ss=new ServerSocket(port, 1,InetAddress.getByName(ip));
                    }catch(Exception ee){
                        if ( ee.toString().equals("java.net.BindException: Address already in use (Bind failed)") ){
                            String aux="";
                            System.err.println("Porta " + port + " em uso! - Tente: y call -port " + (port+1)+aux);
                            System.exit(1);                        
                        }
                        if ( ee.toString().equals("java.net.BindException: Cannot assign requested address: JVM_Bind") ){
                            String aux="";
                            System.err.println("ip com problema: " + InetAddress.getByName(ip).toString().replace("/", ""));
                            System.exit(1);                        
                        }
                        erro_amigavel_exception(ee);
                    }
                    System.out.println(print_after);
                    s = ss.accept();
                }else{
                    s = new Socket(InetAddress.getByName(ip), port);                        
                }
                OutputStream os = s.getOutputStream();
                InputStream is = s.getInputStream();
                new Thread(){
                    public void run(){
                        try{                                
                            gravador(null, null, os, true, false, false, null);
                        }catch(Exception e1){}
                    }
                }.start();                    
                play(null, null, is, true, false, false, null);
                s.close();
                if ( ss != null )
                    ss.close();
            }catch(Exception e){
                erro_amigavel_exception(e);
            }   
        }catch(Exception e){
            erro_amigavel_exception(e);
        } 
    }
    
    public void remote(String [] args){
        try{
            Object [] objs = get_parms_ip_port_fps(args);
            if ( objs == null ){
                comando_invalido(args);
                System.exit(0);
            }
            String ip=(String)objs[0];
            int port=(Integer)objs[1];
            int fps=(Integer)objs[2];
            
            System.out.println("http://"+ip+":"+port);
            String format_web="jpg";
            String html=new Texto_longo().get_html_and_header_remote(format_web);
            robotGetImgScreenBytesParallels_start(format_web, fps);
            WebSocketServer wss=new WebSocketServer(new InetSocketAddress(ip, port), html){
                public void onOpen(WebSocket conn, ClientHandshake handshake) {}
                public void onClose(WebSocket conn, int code, String reason, boolean remote) {}
                public void onMessage(WebSocket conn, String message) {
                    if ( message.equals("1") )
                        conn.send("2");
                    try{
                        if ( message.equals("3") )                        
                            conn.send(robotGetImgScreenBytesParallels());
                    }catch(Exception e){
                        System.err.println("Error " + e.toString());
                    }
                }
                public void onError(WebSocket conn, Exception ex) {
                    System.out.println("error: " + ex.toString());
                }
                public void onStart() {}
            };
            wss.start();  
        }catch(Exception e){
            if ( e.toString().contains("WebsocketNotConnectedException") )
                return;
            System.err.println("Error " + e.toString());
        }            
    }
    
    private void clear_cls(){
        try{
            System.out.write(new byte[]{(byte)27,(byte)91,(byte)72,(byte)27,(byte)91,(byte)50,(byte)74,(byte)27,(byte)91,(byte)51,(byte)74});
            System.out.flush();
            /*
                if ( System.getProperty("user.dir").contains("/") )
                    new ProcessBuilder("clear").inheritIO().start().waitFor();
                else
                    new ProcessBuilder("cmd", "/c", "cls").inheritIO().start().waitFor();            
            */
        }catch(Exception e){
            erroFatal("Error..." + e.toString());
        }            
    }
    
    private boolean tipo_cadastrado(int a) {
        return true; 
        // controle desabilitado - ja foram feitos muitos testes... 
        // return a == -9 || a == -5 || a == -3 || a == -1 || a == 1 || a == 2 || a == 3 || a == 4 || a == 12 || a == 93 || a == 2005;                
    }
    
    private boolean banco_tipo_numerico(int a) {
        return a == 2 || a == 3 || a == 4;
    }

    ArrayList<Integer> pivoName=new ArrayList<Integer>();    
    int pivoNameP1=1;    
    private String getNameSplit(String prefix) { // tipo split file => xxa
        if ( pivoName.size() == 0 ){
            pivoName.add(120);
            pivoName.add(97);
            pivoName.add(97);
        }
        String result=prefix;
        int len=pivoName.size();        
        for ( int i=0;i<len;i++ )
            result+=(char)(int)pivoName.get(i);        
        pivoName.set(len-1,pivoName.get(len-1)+1);
        for ( int i=pivoName.size()-1;i>0;i-- ){
            if ( pivoName.get(i) > 122 ){
                pivoName.set(i, 97);
                pivoName.set(i-1,pivoName.get(i-1)+1);
            }
        }
        if (pivoName.get(pivoNameP1) >= 122){
            pivoNameP1++;
            pivoName.add(97);
            pivoName.add(97);            
        }
        return result;
    }

    private boolean bind_isSep(String parm){    
        return parm.startsWith("/") || parm.startsWith("\\");
    }
    
    private String[] bind_asterisk(String[] args) {        
        ArrayList lista=new ArrayList<String>();
        for(int i=0;i<args.length;i++)
            lista.addAll(bind_asterisk_parm(args[i]));
        return arrayList_to_array(lista);
    }
   
    ArrayList bind_nav;
    private ArrayList bind_asterisk_parm(String parm){
        bind_nav=new ArrayList();
        if ( ! parm.contains("*") || parm.equals("") ){
            bind_nav.add(parm);
            return bind_nav;
        }
        String [] partesA=bind_asterisk_getPartes(parm);
        String [] partesB=bind_asterisk_getPartes(parm);
        File f;
        if(parm.length()>1){
            if( partesA[0].equals("/") )
                bind_asterisk_nav(new File("/"), partesA, partesB, 1);
            else
                if( partesA[0].contains(":") )
                    bind_asterisk_nav(new File(partesA[0]+"\\"), partesA, partesB, 2);
                else
                    if(partesA[0].contains("*"))
                        bind_asterisk_nav(new File("."), partesA, partesB, 0);
                    else
                        bind_asterisk_nav(new File(partesA[0]), partesA, partesB, 2);
        }else
            bind_asterisk_nav(new File("."), partesA, partesB, 0);
        if ( bind_nav.size() == 0 )
            bind_nav.add(parm);
        return bind_nav;
    }    
        
    private void bind_asterisk_nav(File f, String [] partesA, String [] partesB, int p){
        if ( ! f.exists() )
            return;
        File [] files=f.listFiles();
        if ( files == null )
            return;
        for( int i=0;i<files.length;i++ ){
            String result_match=bind_match(partesA[p],files[i].getName());
            if ( result_match != null ){
                partesB[p]=result_match;
                if(p+2>=partesA.length){
                    bind_processa(partesB);
                }else{
                    bind_asterisk_nav(files[i], partesA, partesB, p+2);
                }
            }
        }
    }
    
    private String bind_match(String digitado, String presenteNoLocal){
        if(digitado.equals(presenteNoLocal))
            return digitado;
        if(digitado.contains("*")){
            boolean result=bind_match(digitado, 0, presenteNoLocal, 0);
            if (result){
                return presenteNoLocal;
            }
        }
        return null;
    }
    
    private boolean bind_match(String digitado, int pos1, String presenteNoLocal, int pos2){
        if ( pos1 == digitado.length() && pos2 == presenteNoLocal.length())
            return true;
        if ( pos1 >= digitado.length() || pos2 >= presenteNoLocal.length())
            return false;
        if ( digitado.substring(pos1,pos1+1).equals("*") ){
            for(int i=0;i<presenteNoLocal.length()-pos2+1;i++){
                boolean result=bind_match(digitado, pos1+1, presenteNoLocal, pos2+i);
                if(result)
                    return true;
            }
        }else{
            if ( digitado.substring(pos1,pos1+1).equals(presenteNoLocal.substring(pos2,pos2+1)) ){
                return bind_match(digitado, pos1+1, presenteNoLocal, pos2+1);
            }
        }
        return false;
    }
    
    private void bind_processa(String [] partes){
        String s="";
        for(int i=0;i<partes.length;i++)
            s+=partes[i];
        bind_nav.add(s);
    }
    
    private String[] bind_asterisk_getPartes(String parm){    
        ArrayList lista=new ArrayList();
        String tail=parm.substring(0, 1);
        for(int i=1;i<parm.length();i++){
            String p=parm.substring(i, i+1);
            if ( bind_isSep(tail) != bind_isSep(p) ){
                lista.add(tail);
                tail=p;
            }else
                tail+=p;
        }
        lista.add(tail);
        return arrayList_to_array(lista);
    }
    
    private void win(){
        try{
            String s=runtimeExec("cmd /c wmic path softwareLicensingProduct get PartialProductKey,Description,LicenseStatus", null, null, null, null);
            if ( s == null )
                erroFatal(4311);
            String [] lines=s.split("\n");
            for ( int i=0;i<lines.length;i++ ){
                if ( lines[i].length() < 70 )
                    continue;
                if ( lines[i].substring(70, 71).equals(" ") )
                    continue;
                if ( lines[i].substring(55,56).equals("0") )
                    System.out.println(lines[i].substring(0,55) + " - Unlicensed");
                if ( lines[i].substring(55,56).equals("1") )
                    System.out.println(lines[i].substring(0,55) + " - Licensed");
                if ( lines[i].substring(55,56).equals("2") )
                    System.out.println(lines[i].substring(0,55) + " - OOBGrace");
                if ( lines[i].substring(55,56).equals("3") )
                    System.out.println(lines[i].substring(0,55) + " - OOTGrace");
                if ( lines[i].substring(55,56).equals("4") )
                    System.out.println(lines[i].substring(0,55) + " - NonGenuineGrace");
                if ( lines[i].substring(55,56).equals("5") )
                    System.out.println(lines[i].substring(0,55) + " - Notification");
                if ( lines[i].substring(55,56).equals("6") )
                    System.out.println(lines[i].substring(0,55) + " - ExtendedGrace");
            }
        }catch(Exception e){
            System.err.println("Erro fatal 789 " + e.toString());
        }   
    }
    
    private boolean speed(String [] args){
        Object [] objs=get_parm_ip_port_server_send(args);
        if ( objs == null )
            return false;
        String ip=(String)objs[0];
        int port=(Integer)objs[1];
        boolean server=(Boolean)objs[2];
        boolean send=(Boolean)objs[3];
        String print_after=null;
        
        if ( server )
            ip=get_ip();        
        if ( ip == null ){
            System.err.println("Nenhum ip foi encontrado!");
            System.exit(1);
        }                
        if ( port == -1 )
            port = 222;
        if ( server )
            if ( !send )
                print_after="# cliente command:\n# y speed -client -ip " + ip + " -port " + port + " -send";
            else
                print_after="# cliente command:\n# y speed -client -ip " + ip + " -port " + port;
        try{        
            try{
                int len_buffer=BUFFER_SIZE*1024;
                byte [] buffer=new byte[len_buffer];
                int len=0;
                if ( server ){
                    Socket s = null;
                    ServerSocket ss=null;
                    try{
                        ss=new ServerSocket(port, 1,InetAddress.getByName(ip));
                    }catch(Exception ee){
                        if ( ee.toString().equals("java.net.BindException: Address already in use (Bind failed)") ){
                            String aux="";
                            if ( !send )
                                aux=" -receive";
                            System.err.println("Porta " + port + " em uso! - Tente: y speed -port " + (port+1)+aux);
                            System.exit(1);                        
                        }
                        throw ee;
                    }
                    System.out.println(print_after);
                    s = ss.accept();
                    OutputStream os = s.getOutputStream();
                    InputStream is = s.getInputStream();
                    if ( send ){
                        while( true ){
                            os.write(buffer, 0, len_buffer);
                            print_cursor_speed(len_buffer, null, null, false, null);
                        }
                    }else{
                        while( (len=is.read(buffer, 0, len_buffer)) > 0 ){
                            print_cursor_speed(len, null, null, false, null);
                        }
                    }
                    s.close();
                    ss.close();
                }else{
                    Socket s = new Socket(InetAddress.getByName(ip), port);                        
                    OutputStream os = s.getOutputStream();
                    InputStream is = s.getInputStream();
                    if ( send ){
                        while( true ){
                            os.write(buffer, 0, len_buffer);
                            print_cursor_speed(len_buffer, null, null, false, null);
                        }
                    }else{
                        while( (len=is.read(buffer, 0, len_buffer)) > 0 ){
                            print_cursor_speed(len, null, null, false, null);
                        }
                    }
                    s.close();
                }
            }catch(Exception e){
                if ( !copiaByStream_count_print_on ){
                    System.err.println("Erro socket_1_file: "+ e.toString());
                    System.exit(1);
                }
            }   
        }catch(Exception e){
            System.err.println("Erro, "+e.toString());
            System.exit(1);
        } 
        
        return true;
    }

    private void analise_click_min_ou_exit(int n_buttom, int i_){
        if ( n_buttom == 3 ) // click direito
            states_frames[i_]=true;
        else
            System.exit(0);        
        int count_false=0;
        for ( int i=0; i<states_frames.length;i++ )
            if ( states_frames[i] == false )
                count_false++;
        if ( count_false == 0 )
            System.exit(0);
    }
     
    Frame [] lock_frames=null;
    Color [] lock_frames_color=null;
    boolean [] states_frames=null;    
    private void lock(String parm){
        kill_by_text(" y lock ");
        if ( parm != null && parm.equals("0") )
            return;
        GraphicsDevice[] gs=null;
        boolean hasConfigurationDevice=true;
        try{
            gs = robotGetScreenDevices();
        }catch(Exception e){
            erroFatal("Esse sistema não tem ambiente grafico.");
        }
        int len=gs.length;
        lock_frames = new Frame[len];
        lock_frames_color = new Color[len];
        states_frames = new boolean[len]; // false => 0 => tela visivel
        for ( int i=0;i<len;i++ ){
            if ( hasConfigurationDevice )
                lock_frames[i] = new Frame(gs[i].getDefaultConfiguration());
            else
                lock_frames[i] = new Frame();
            if ( parm == null )
                lock_frames_color[i]=Color.black;                
            else
                lock_frames_color[i]=Color.white;
            lock_frames[i].setBackground(lock_frames_color[i]);
            
            if ( !hasConfigurationDevice ){
                lock_frames[i].setUndecorated(true); // tira borda do aplicativo
                lock_frames[i].setExtendedState(lock_frames[i].MAXIMIZED_BOTH);        
            }
            if ( parm == null )
                lock_frames[i].setCursor(Toolkit.getDefaultToolkit().createCustomCursor(new BufferedImage(1,1,1), new Point( 0, 0), "" ));            
            else
                lock_frames[i].setCursor(Toolkit.getDefaultToolkit().createCustomCursor(new BufferedImage(2,2,2), new Point( 0, 0), "" ));            
            lock_frames[i].addWindowListener(new java.awt.event.WindowAdapter() {
                public void windowClosing(java.awt.event.WindowEvent e) {
                    System.exit(0);
                }
            });
            final int i_=i;
            lock_frames[i].addComponentListener(new ComponentListener(){
                public void componentResized(ComponentEvent e){
                    e.getComponent().addMouseListener(new MouseListener() {
                        public void mouseClicked(MouseEvent e){analise_click_min_ou_exit(e.getButton(), i_);}
                        public void mousePressed(MouseEvent e){analise_click_min_ou_exit(e.getButton(), i_);}
                        public void mouseReleased(MouseEvent e){}
                        public void mouseEntered(MouseEvent e){}
                        public void mouseExited(MouseEvent e){}
                    });
                }
                public void componentMoved(ComponentEvent e){}
                public void componentShown(ComponentEvent e){}
                public void componentHidden(ComponentEvent e){}
            });            
            lock_frames[i].addWindowStateListener(new java.awt.event.WindowStateListener() {
               public void windowStateChanged(java.awt.event.WindowEvent e){
                   // bug here - dont use this Listener
               }
            });            
            gs[i].setFullScreenWindow(lock_frames[i]);            
            sleepMillis(100);
        }  
        
        new Thread(){
            public void run(){
                try{
                    while(true){
                        sleepMillis(100);
                        if ( lock_frames == null )
                            continue;
                        for ( int i=0;i<lock_frames.length;i++ ){
                            if ( lock_frames[i] == null )
                                continue;
                            if ( states_frames[i] )
                                lock_frames[i].setExtendedState(1);  
                            else
                                lock_frames[i].setExtendedState(0);  
                            // BUG
                            //lock_frames[i].setBackground(lock_frames_color[i]);
                            //lock_frames[i].revalidate();
                            //lock_frames[i].repaint();
                        }                        
                    }
                }catch(Exception e){}
            }
        }.start();        
    }
       
    public void monitor(boolean oneLine){
        while(true){
            String s=runtimeExec("wmic cpu get loadpercentage", null, null, null, null);
            if ( s == null )
                break;
            String [] partes=s.split("\r\n");
            if ( oneLine ){
                System.out.print("CPU: " + partes[partes.length-1].trim() + "%  \r");
            }else
                System.out.println("CPU: " + partes[partes.length-1].trim() + "%");
            sleepSeconds(1);
        }
    }
    
    public void printScreen(int a){
        try{
            if ( !new File("d:/").exists() )
                erroFatal("drive d:/ nao encontrado!");                
            if ( !new File("d:/ProgramFiles").exists() )
                new File("d:/ProgramFiles").mkdir();
            if ( !new File("d:/ProgramFiles/screens").exists() )
                new File("d:/ProgramFiles/screens").mkdir();
            String s="d:/ProgramFiles/screens/sc_"+date_("+%Y%m%d_%H%M%S_%N", null, null, null) + "_" + random(1000,9999)+".bmp";                    
            javax.imageio.ImageIO.write(robotGetImgScreen(a), "bmp", new File(s));
            System.out.println("printScreen: " + s);
        }catch(Exception e){
            erroFatal(e);
        }
    }
    
    public void dotaMutandoAll(Integer sleep, String nicks){
        if ( sleep != null )
            sleepSeconds(sleep);
        try{
            // variaveis auxiliares
            int _x=0;
            int _y=0;
            
            // fechar painel previsoes
            robotMouseMove(188+1400, 768);
            sleepMillis(50);
            robotMouseClickEsq();
            sleepMillis(50);

            // verifica dota aberto
            System.out.println("analisando se a tela esta com o dota aberto");
            if ( !robotCheckRGB(239, 891, "49 54 56") )
                erroFatal("Não.. programa sendo finalizado!");

            // fecha previsoes
            boolean painel_previsoes=robotCheckRGB(188, 768, "255 255 255");
            if ( painel_previsoes ){
                robotMouseMove(188, 768); // fechar painel previsoes
                sleepMillis(50);
                robotMouseClickEsq();
                sleepMillis(50);
            }
                
            // seleciona jogo para remover cmd na frente
            robotMouseMove(998, 480); 
            sleepMillis(50);
            robotMouseClickEsq();
            sleepMillis(50);

            // verifica se painel esta aberto
            System.out.println("analisando se o painel esta fechado");
            boolean painel_fechado=robotCheckRGB(175, 839, "64 69 73"); // painel fechado
            if ( !painel_fechado )
                erroFatal("Aberto.. programa sendo finalizado!");

            // abrindo painel
            System.out.println("abrindo painel...");
            robotMouseMove(123, 27); // abrir painel
            sleepMillis(50);
            robotMouseClickEsq();
            sleepMillis(150);
            
            // verifica se o painel ainda esta fechado
            painel_fechado=robotCheckRGB(175, 839, "64 69 73"); 
            if ( painel_fechado )
                erroFatal("não foi possivel abrir o painel.. programa sendo finalizado!");
            
            // tirando mouse da frente
            robotMouseMove(998, 480); 
            sleepMillis(50);
            
            // skynet
            String [] naoBloquearEssesNomes="ynet,Analista de Sistema,eBullet,iusky,frist,Madald,arhart,aerte".split(",");
            if ( nicks != null )
                naoBloquearEssesNomes=nicks.split(",");
            System.out.println("jogadores anti block:");
            mostra_array(naoBloquearEssesNomes);
            // get players by OCR
            String [] players=new String[]{"??", "??", "??", "??", "??", "??", "??", "??", "??", "??"};
            if ( naoBloquearEssesNomes.length == 1 && naoBloquearEssesNomes[0].equals("no_ocr") ){
                //pass
                System.out.println("skip no_ocr!" );                
            }else{         
                players=ocr_getNamesDota();
                if ( players == null ){
                    System.out.println("warning.. names não detectados!" );                
                }else{
                    System.out.println("jogadores reconhecidos:");
                    mostra_array(players);
                }
            }
            
            // mutando os jogadores
            int n_eu_mesmo=0; // 0 até 9
            for ( int i=0;i<10;i++ ){
                _x=827;
                _y=121+(70*i)+(i>=5?31:0);
                if ( robotCheckRGB(_x, _y, "63 70 70") ){ // eu mesmo
                    System.out.println("eu mesmo como jogador  " + i);
                    n_eu_mesmo=i;
                    continue;
                }
                if ( findParm(new String[]{players[i]}, naoBloquearEssesNomes, false) >= 0 ){
                    System.out.println("jogador [" + i + "] - " + players[i] + " não pode ser mutado!");
                }else{                    
                    if ( robotCheckRGB(_x, _y, "255 73 73") ){ // mutado
                        System.out.println("jogador [" + i + "] - " + players[i] + " ja mutado!");                    
                    }else{                        
                        robotMouseMove(_x+5, _y);
                        sleepMillis(50);
                        robotMouseClickEsq();
                        sleepMillis(50);
                        System.out.println("mutando o jogador [" + i + "] - " + players[i]);
                    }
                }
            }            

            // click central para fechar painel
            robotMouseMove(998, 480); // meio da tela
            sleepMillis(150);
            
            // verifica se painel de ajuda está fechado
            boolean painel_ajuda_berto=robotCheckRGB(987, 662, "10 13 17"); // painel ajuda aberto
            if ( painel_ajuda_berto )
                erroFatal("Erro, painel de ajuda ja aberto");
            
            // abrindo bainel de ajuda
            System.out.println("abrindo painel de ajuda");
            robotMouseMove(853, 834);
            sleepMillis(150);
            robotMouseClickEsq();
            sleepMillis(150);

            // verifica se painel de ajuda está aberto
            /*
            // esse codigo só olha o painel se estiver em baixo
            painel_ajuda_berto=robotCheckRGB(987, 662, "10 13 17"); // painel ajuda aberto
            if ( !painel_ajuda_berto ){
                robotMouseMove(987, 662);
                erroFatal("Erro, falha ao abrir o painel de ajuda");
            }
            */
            
            // removendo ajuda
            for ( int i=0;i<10;i++ ){
                if ( i == n_eu_mesmo )
                    continue;
                if ( n_eu_mesmo<5 != i<5 )
                    continue;
                //_y=113+(57*i)+(i>=5?34:0);
                _y=121+(70*i)+(i>=5?31:0);
                if ( findParm(new String[]{players[i]}, naoBloquearEssesNomes, false) >= 0 )
                    System.out.println("o jogador [" + i + "] - " + players[i] + " não pode ter a ajuda removida!");
                else{                                        
                    robotMouseMove(1096, _y);
                    sleepMillis(50);                
                    robotMouseClickEsq();
                    sleepMillis(50);
                    System.out.println("removendo ajuda do jogador [" + i + "] - " + players[i]);
                }
            }
            
            // fechando painel de ajuda
            robotMouseMove(998+400, 480); 
            sleepMillis(50);
            robotMouseClickEsq();
            robotMouseMove(998+400, 480); 
            sleepMillis(50);
            robotMouseClickEsq();
            System.out.println("fim");
        }catch(Exception e){
            erroFatal(e);
        }
    }
    
    public void paste(File file1, File file2){
        try{
            readLine(file1);
            readLineB(file2);
            String s1="";
            String s2="";
            while(true){
                if ( s1 != null )
                    s1=readLine();
                if ( s2 != null )
                    s2=readLineB();
                if ( s1 == null && s2 == null )
                    return;
                else{
                    if ( s1 == null )
                        System.out.println(" "  + s2);
                    else{
                        if ( s2 == null )
                            System.out.println(s1);
                        else
                            System.out.println(s1 + " " + s2);
                    }
                }
            }
        }catch(Exception e){
            erro_amigavel_exception(e);
        }
    }
    
    public String ffmpeg(String [] args){
        runtimeExec(null, args, null, null, null);
        String msg=runtimeExecError;
        if ( runtimeExecError.contains("Cannot run") )
            erroFatal("Nao foi possivel encontrar o ffmpeg!");
        return runtimeExecError;        
    }
    public String mkv(File f, boolean verbose, boolean force, boolean lento, String tail) throws Exception{
        File [] files=f.listFiles();
        String edited="_EDITED.mkv";
        String newTag="newTag20240116";
        String display_mkv="";
        String msg="";
        for ( int i=0;i<files.length;i++ ){
            if ( verbose )
                System.out.println("File: " + files[i].getAbsolutePath());
            if ( !files[i].isFile() )
                continue;
            if ( files[i].getName().endsWith(edited) )
                continue;            
            if ( !files[i].getName().endsWith(".mkv") )
                continue;
            String item=files[i].getAbsolutePath().replace("\\","/").replace("/./","/");
            if ( new File(item+edited).exists() ){
                display_mkv="y mv \"" + item+edited + "\" \"" + item + "\"";
                if ( display_mkv.equals(tail) )
                    erroFatal("Erro: aparentemente o processo está em loop!\n" + display_mkv);
                mv(new File(item+edited),new File(item));
                return display_mkv;
            }            
            runtimeExec(null, new String[]{"ffmpeg", "-i", "\"" + item + "\""}, null, null, null);
            msg=runtimeExecError;
            if ( msg.contains("Cannot run") )
                erroFatal("Nao foi possivel encontrar o ffmpeg!");
            if ( !force && msg.contains("NEWTAG          : " + newTag) ) // mkv ja modificado
                continue;             
            String [] partes=msg.replace("\r", "").split("\n");
            boolean inicio=false;
            String removes="";
            String principal=null;
            boolean video=false;
            boolean audio=false;
            for ( int j=0;j<partes.length;j++ ){
                if ( !inicio && partes[j].contains("Stream #0:0") )
                    inicio=true;
                if ( !inicio )
                    continue;
                if ( partes[j].contains("Video Media Handler") )
                    continue;
                if ( partes[j].contains("Video") || partes[j].contains("Stream") ){
                    if ( verbose )
                        System.out.println(partes[j]);
                    String [] partes2=partes[j].trim().split(" ");
                    String p1=partes2[1].substring(3,5).replace("(","").replace(" ","");
                    String p2=partes2[1];
                    String p3=partes2[2].replace(":","");
                    if ( verbose )
                        System.out.println(p1 + " " + p2 + " " + p3);
                    if ( !video && p3.equals("Video") ){
                        video=true;
                        if ( verbose )
                            System.out.println("video identificado");
                        continue;
                    }
                    if ( !audio && p3.equals("Audio")){
                        if (p2.contains("(por)") || partes[j].contains("Audio: mp3") ){
                            principal=p1;
                            audio=true;
                            if ( verbose )
                                System.out.println("audio identificado");
                            continue;
                        }
                    }
                    removes+=" -map -0:a:" + p1;
                }
            }
            if ( !video ){
                erroFatal("Nao foi possivel interpretar o arquivo \"" + item + "\" - Video nao detectado!");
            }
            if ( !audio ){
                if ( msg.split("Audio:").length == 2 ) // contem somente 1 audio
                    continue;
                erroFatal("Nao foi possivel interpretar o arquivo \"" + item + "\" - Audio nao detectado!");
            }
            if ( removes.equals("") )
                continue;  
            // conversao direta
            // ffmpeg -i "A.mkv" -qscale 0 "A.mp4"
            String [] input=null;
            input=new String []{"ffmpeg", "-i", item, "-map", "0"};
            input=addParm(removes.trim().split(" "), input);
            input=addParm(new String[]{"-max_muxing_queue_size", "1024", "-c:v", "copy", "-metadata", "newTag=\"" + newTag + "\"", item + edited}, input);
            
            // mais lento mas funciona
            if ( principal != null && lento )
                input=new String []{"ffmpeg", "-i", item, "-map", "0:0", "-map" , "0:"+principal, "-metadata", "newTag=\"" + newTag + "\"", item + edited};
            
            display_mkv=item;
            if ( display_mkv.equals(tail) )
                erroFatal("Erro: aparentemente o processo está em loop!\n" + display_mkv);            
            System.out.println("processando: " + item);
            runtimeExec(null, input, null, null, null);
            return display_mkv;
        }
        // pastas
        for ( int i=0;i<files.length;i++ ){
            if ( files[i].isDirectory() ){
                String s=mkv(files[i], verbose, force, lento, tail);
                if ( s.equals("") )
                    continue;
                return s;
            }
        }            
        return "";
    }
    
    public String thumbnail(File a, int nivel, String tail){                
        if ( !a.exists() )
            erroFatal("Não foi possível encontrar o caminho " + a.getAbsolutePath());
        if ( nivel == 0 && a.isFile() )
            erroFatal("Erro interno, não é possível nivel 0 com arquivo!");
        if ( a.isFile() ){
            if ( a.getAbsolutePath().endsWith(".png") )
                return "";
            if ( a.getAbsolutePath().endsWith(".vtt") )
                return "";
            if ( new File(a.getAbsolutePath()+".png").exists() )
                return ""; 
        }else{
            if ( a.isDirectory() ){
                File [] files=a.listFiles();
                for ( int i=0;i<files.length;i++ ){                    
                    String s=thumbnail(files[i], nivel+1, tail);
                    if ( !s.equals("") )
                        return s;
                }
                return "";
            }
        }
        String target=a.getAbsolutePath();
        runtimeExec(null, new String[]{"ffmpeg", "-i", "\"" + target + "\""}, null, null, null);
        String msg=runtimeExecError;
        if ( msg.contains("Cannot run") )
            erroFatal("Nao foi possivel encontrar o ffmpeg!");
        if ( msg.contains("Invalid data found") )
            erroFatal("Invalid data found - " + target);
        String [] partes=msg.replace("\r", "").split("\n");        
        String [] partes_base=array_copy(partes);
        int p=-1;
        for ( int i=0;i<10;i++ ){
            p=findParm(partes, "Stream #0:"+i, false);
            if ( p < 0 )
                erroFatal("arquivo " + a.getAbsolutePath() + " nao foi identificado corretamente!");
            if ( partes[p].contains(" fps, ") )
                break;
            p=-1;
        }
        if ( p > -1 ){
            String fps=partes[p];
            String duration="";
            partes=fps.trim().split(" ");
            p=findParm(partes, "fps,", true);
            if ( p > -1 && p < partes.length-1 ){
                fps=partes[p+1];                        
                // arredondar para cima
                float aux=Float.parseFloat(fps);
                int ifps = (int)aux;
                if ( aux != (float)((int)aux) )
                    ifps = ((int)aux)+1;                        
                fps=ifps*10+"";
                p=findParm(partes_base, "Duration:", false);
                if ( p > -1 ){
                    partes=partes_base[p].trim().split(" ");
                    duration=partes[1].replace(",", "");
                    if ( duration.split("\\.").length == 2 )
                        duration=duration.split("\\.")[0];
                    aux=((float)duration_to_seconds(duration)/10)/15;
                    if ( aux != (float)((int)aux) )
                        duration = ((int)aux+1)+"";
                    else
                        duration = (int)aux+"";                            
                    if ( target.equals(tail) )
                        erroFatal("Erro: sistema anti loop ativado: " + target);
                    System.out.println("processando: " + target.replace("\\.\\", "\\"));
                    runtimeExec(null, new String[]{"ffmpeg", "-i", target, "-filter_complex", "select='not(mod(n," + fps + "))',scale=150:84,tile=layout=15x" + duration, "-vframes", "1", target + ".png"}, null, null, null);
                    return target;
                }
                System.out.println("Não foi possível decodificar Duration: " + target);
                mostra_array(partes);
                mostra_array(partes_base);
                System.exit(1);
            }                    
            System.out.println("Não foi possível decodificar fps: " + target);
            mostra_array(partes);
            mostra_array(partes_base);
            System.exit(1);
        }
        System.out.println("Não foi possível decodificar Stream #0:0: " + target);
        mostra_array(partes);
        mostra_array(partes_base);
        System.exit(1);        
        return "";
    }        
    
    public void insta(String id){
        String url="https://www.instagram.com/reels/" + id + "/";
        String dir="d:/insta";                
        if ( ! new File(dir).exists() ){
            System.out.println("Favor criar a pasta d:/insta");
            return;
        }        
        if ( !new File(dir+"/"+id+"/"+id+".mp4").exists() ){
            String txt = "";
            try{
                txt = curl_string("http://localhost:3000/api/video?url="+url);
            }catch(Exception e){
                erro_amigavel_exception(e);
            }
            String [] partes=txt.split("\"");
            if ( !txt.contains("\"videoUrl\":") || partes.length < 22 || !partes[21].startsWith("https://") ){
                if ( txt.contains("\"This post does not exist\"") )
                    erroFatal("Esse servico disse que o post nao existe: http://localhost:3000/api/video?url="+url);
                else
                    erroFatal("Nao foi possivel encontrar o video no servico: http://localhost:3000/api/video?url="+url);
            }
            if ( !new File(dir+"/"+id).exists() ){
                if ( ! new File(dir+"/"+id).mkdir() )
                    erroFatal("Nao foi possivel criar o diretorio " + dir+"/"+id);            
            }
            try{
                curl_path(partes[21], dir+"/"+id+"/"+id+".mp4");
            }catch(Exception e){
                erro_amigavel_exception(e);
            }
            if ( !new File(dir+"/"+id+"/"+id+".mp4").exists() )
                erroFatal("Ocorreu um erro ao tentar gravar o arquivo " + dir+"/"+id+"/"+id+".mp4");
        }
        if ( !new File(dir+"/"+id+"/out-0001.bmp").exists() ){
            runtimeExec(null, new String[]{"cmd", "/c", "ffmpeg -r 1 -i " + id + ".mp4 -r 1 out-%04d.bmp"}, new File(dir+"/"+id), null, null);
            runtimeExec(null, new String[]{"cmd", "/c", "ffmpeg -i " + id + ".mp4 -qscale:v 2 out-%04d.jpg"}, new File(dir+"/"+id), null, null);
            if ( !new File(dir+"/"+id+"/out-0001.bmp").exists() )
                erroFatal("Nao foi possivel encontrar o utilitario ffmpef");
        }
        File [] files=new File(dir+"/"+id).listFiles();
        for ( int i=0;i<files.length;i++ ){
            if ( ! files[i].getName().endsWith(".bmp") )
                continue;
            if ( new File(dir+"/"+id+"/"+files[i].getName()+".assinatura.txt").exists() )
                continue;
            String txt = runtimeExec(null, new String[]{"cmd", "/c", "y bmp -file " + files[i].getName() + " -len 64"}, new File(dir+"/"+id), null, null);
            if ( ! salvando_file(txt, new File(dir+"/"+id+"/"+files[i].getName()+".assinatura.txt")) )
                erroFatal("Nao foi possivel gravar o arquivo " + dir+"/"+id+"/"+files[i].getName()+".assinatura.txt");
            if ( ! salvando_file("", new File(dir+"/"+id+"/"+files[i].getName()) ) )
                erroFatal("Nao foi possivel gravar o arquivo " + dir+"/"+id+"/"+files[i].getName());            
        }
        if ( !new File(dir+"/"+id+".html").exists() ){
            String pre_saida="<html xmlns=\"http://www.w3.org/1999/xhtml\"><head></head><body style=\"background-color: rgb(0, 0, 0);\"><meta charset=\"UTF-8\" http-equiv=\"X-UA-Compatible\" content=\"IE=9\"><style>.bordered {border: solid #ccc 3px;border-radius: 6px;}.bordered td, .bordered th {border-left: 2px solid #ccc;border-top: 2px solid #ccc;padding: 10px;}</style><table id=\"tablebase\" class=\"bordered\" style=\"font-family:Verdana,sans-serif;font-size:10px;border-spacing: 0;\"><tbody><tr>";
            String pos_saida="</tr></tbody></table></body></html>";            
            String saida="<td><img src=\"" + id + "/" + "out-0001.jpg\"></td>";            
            files=new File(dir+"/"+id).listFiles();
            String [] partes1=null;
            String [] partes2=null;
            boolean alter=true;
            int corte=20;
            int nivel=100;    
            boolean disableAlter=true;
            //corte=10; // ajuste
            //nivel=50; // ajuste
            for ( int i=0;i<files.length;i++ ){
                if ( ! files[i].getName().endsWith(".assinatura.txt") )
                    continue;
                partes2=lendo_arquivo(dir+"/"+id+"/"+files[i].getName()).split("\n");
                if ( partes1 != null ){
                    int diff=0;
                    try{
                        diff=insta_diff(partes1, partes2, corte);
                    }catch(Exception e){
                        System.err.println("Erro " + dir+"/"+id+"/"+files[i].getName() + " " + e.toString());
                        throw e;
                    }
                    if ( diff > nivel ){
                        if ( alter || disableAlter ){
                            saida+="<td><img src=\"" + id + "/" + files[i].getName().replace(".bmp.assinatura.txt", ".jpg") + "\"></td>";                            
                        }
                        alter=!alter;
                    }
                }
                partes1=partes2;
            }
            if ( ! salvando_file(pre_saida + saida + pos_saida, new File(dir+"/"+id+".html")) )
                erroFatal("Ocorreu um erro na gravacao do arquivo " + dir+"/"+id+".html");
        }
        runtimeExec(null, new String[]{"cmd", "/c", dir+"/"+id+".html"}, null, null, null);
    }
    
    public int insta_diff(String [] partes1, String [] partes2, int corte){
        int a=Integer.parseInt(partes1[2]);
        int b=Integer.parseInt(partes2[2]);
        int c=a-b;
        int count=0;
        for ( int i=2;i<partes1.length&&i<partes2.length;i++ ){
            a=Integer.parseInt(partes1[i]);
            b=Integer.parseInt(partes2[i]);
            c=a-b;
            if ( c < 0 )
                c=c*-1;
            if ( c >= corte )
                count++;
        }
        return count;
    }
    
    private void decodeUrl_stream(){
        String line=null;
        while ( (line=readLine()) != null )
            System.out.println(decodeUrl(line));
    }

    private void encodeUrl_stream(){
        String line=null;
        while ( (line=readLine()) != null )
            System.out.println(encodeUrl(line));
    }

    //REMOVED_GRAAL_START
    private void controlc(){
        try{
            System.out.println("Control C iniciado...");
            String [] controlC_parms = new String []{"\n", "0"};
            // DisableControlC
            new Util().loadDisableControlC(controlC_parms);
            InputStream inputStream_pipe=System.in;      
            byte [] buff = new byte[BUFFER_SIZE];
            while(true){
                if ( controlC_parms[1].equals("1") )
                    break;
                if ( inputStream_pipe.available() <= 0 )
                    continue;
                inputStream_pipe.read(buff,0,BUFFER_SIZE);
            }   
            System.out.println("3...");
            sleepSeconds(1);
            System.out.println("2...");
            sleepSeconds(1);
            System.out.println("1...");
            sleepSeconds(1);
        }catch(Exception e){
            erroFatal(e);
        }
    }
    //REMOVED_GRAAL_END    
    
    private void update(){        
        try{
            boolean error=false;
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            Process proc = null;
            if ( new File("c:\\y\\compila2.cmd").exists() )
                proc = Runtime.getRuntime().exec("cmd /c compila2.cmd", null, new File("c:\\y"));
            else{
                if ( new File("/opt/y/compila2").exists() )
                    proc = Runtime.getRuntime().exec("compila2", null, new File("/opt/y"));
                else{
                    System.out.print("compila2 não encontrado!");
                    System.exit(1);
                }
            }
            int len=0;
            byte[] b=new byte[1024];
            String s="";
            while ( (len=proc.getInputStream().read(b, 0, b.length)) != -1 ){}
            while ( (len=proc.getErrorStream().read(b, 0, b.length)) != -1 ){
                baos.write(b, 0, len);
                error=true;
            }       
            baos.flush();
            s=baos.toString("UTF-8").trim();
            if ( 
                (
                    s.split("\n").length == 2 
                    && s.split("\n")[s.split("\n").length-2].startsWith("Note: ") 
                    && s.split("\n")[s.split("\n").length-1].startsWith("Note: ")
                ) || (
                    s.split("\n").length > 2 
                    && s.contains("‘Y.java’ saved")
                    && ! s.contains("error")                    
                    && s.split("\n")[s.split("\n").length-2].startsWith("Note: ") 
                    && s.split("\n")[s.split("\n").length-1].startsWith("Note: ")
                ) || (
                    s.split("\n").length > 2 
                    && s.startsWith("% Total")
                    && s.contains("\r100 ")
                    && s.split("\n")[s.split("\n").length-2].startsWith("Note: ") 
                    && s.split("\n")[s.split("\n").length-1].startsWith("Note: ")
                ) ||
                    s.replaceAll("\r\n", "\n").trim().equals("""
Note: Y.java uses or overrides a deprecated API.
Note: Recompile with -Xlint:deprecation for details.
Note: Y.java uses unchecked or unsafe operations.
Note: Recompile with -Xlint:unchecked for details.
""".trim()) ||
                    s.trim().equals("")
            )
                System.out.println("ok");
            else{
                System.err.println(s);
                System.out.println("ERROR!!");
                System.exit(1);
            }
        }catch(Exception e){
            System.err.println(e.toString());
            System.exit(1);
        }        
    }
}

@SuppressWarnings({"unchecked", "deprecation"})
class YDB{
    /*
    
    a estrutura é formada por blocos
    [bloco] -> [tipo] [len] [subbloco]
               1byte  4byte  len-bytes
    
    [tipo]
           0 - table
           1 - campos
           2 - record
           3 - tipocampo(opcional)
     
    [subbloco] -> [key] [value] (loop? [key] [value]) 
                   
    [key] -> [len] [data]
             1byte  len-bytes
    [value] -> [len] [data]
             1bytes len-bytes
    
    obs: Se o data precisar ter o len maior que 256(2^8) é só repetir o mesmo nome de key na sequencia ex: key1 AA key1 AA key2 BB
    
    Exemplo de uso
    YDB ydb=new YDB();
    ydb.writeTable("AA");
    ydb.writeTable("cc");
    ydb.display();
    
    */
    
    ByteArrayOutputStream baos=null;
    ByteArrayOutputStream baos_subbloco=null;
    
    public YDB(){
        baos=new ByteArrayOutputStream();
        baos_subbloco=new ByteArrayOutputStream();
    }
    
    public void writeTable(String a) throws Exception{
        resetSubBloco();
        writeSubBloco("_".getBytes(), a.getBytes());
        writeBloco(new byte[]{0});
    }

    public void writeRecord(String a) throws Exception{
        resetSubBloco();
        String [] partes=a.split(",");
        for ( int i=0;i<partes.length;i++ )
            writeSubBloco(("f"+i+"_").getBytes(), partes[i].getBytes());
        writeBloco(new byte[]{2});
    }

    
    public void resetSubBloco(){
        baos_subbloco=new ByteArrayOutputStream();
    }
    
    public void writeSubBloco(byte [] key, byte [] value) throws Exception{
        if ( key.length > 255 )
            throw new Exception("tamanho de key invalida(acima de 255): " + key.length);
        if ( value.length > 255 )
            throw new Exception("tamanho de value invalida(acima de 255): " + value.length);
        baos_subbloco.write((byte)key.length);
        baos_subbloco.write(key);
        baos_subbloco.write((byte)value.length);
        baos_subbloco.write(value);
    }    
    
    public void writeBloco(byte [] tipo) throws Exception{
        baos.write(tipo);        
        byte [] subbloco=baos_subbloco.toByteArray();
        if ( subbloco.length > 256L*256*256*256 )
            throw new Exception("subbloco muito grande! " + subbloco.length);
        byte[] len = new byte[4];
        len[0] = (byte) subbloco.length;
        len[1] = (byte) (subbloco.length >> 8);
        len[2] = (byte) (subbloco.length >> 16);
        len[3] = (byte) (subbloco.length >> 24);
        baos.write(len);
        baos.write(subbloco);        
        resetSubBloco();
    }
    
    byte [] subbloco=null;
    int tipo=0;
    int pos_readBloco=0;
    boolean tem_bloco=true;
    public void readBloco() throws Exception{        
        byte [] full=baos.toByteArray();
        if ( full.length == 0 )
            throw new Exception("nao existe blocos para serem lidos!");
        tipo=full[pos_readBloco++] & 0xff;
        int len = (full[pos_readBloco++] & 0xff) | 
                   ((full[pos_readBloco++] & 0xff) << 8) | 
                   ((full[pos_readBloco++] & 0xff) << 16) | 
                   ((full[pos_readBloco++] & 0xff) << 24);        
        subbloco=new byte [len];
        System.arraycopy(full, pos_readBloco, subbloco, 0, len);
        pos_readBloco+=len;
        if ( pos_readBloco == full.length )
            tem_bloco=false;
        pos_readSubBloco=0;
        tem_subBloco=true;
    }
    
    int pos_readSubBloco=0;
    boolean tem_subBloco=true;
    String key=null;
    String value=null;
    public void readSubBloco_parcial() throws Exception{
        int len=subbloco[pos_readSubBloco++] & 0xff;
        byte [] a=new byte[len];
        System.arraycopy(subbloco, pos_readSubBloco, a, 0, len);
        key=new String(a, java.nio.charset.StandardCharsets.UTF_8);
        pos_readSubBloco+=len;
        len=subbloco[pos_readSubBloco++] & 0xff;
        a=new byte[len];
        System.arraycopy(subbloco, pos_readSubBloco, a, 0, len);
        value=new String(a, java.nio.charset.StandardCharsets.UTF_8);
        pos_readSubBloco+=len;  
        if ( pos_readSubBloco == subbloco.length )
            tem_subBloco=false;
    }
    
    public void display() throws Exception{
        while(tem_bloco){
            readBloco();
            if ( tipo == 0 ) System.out.println("\nTable");
            if ( tipo == 2 ) System.out.println("\nRecord");
            while(tem_subBloco){
                readSubBloco_parcial();
                System.out.println(key+": "+value);
            }
        }
    }
}


@SuppressWarnings({"unchecked", "deprecation"})
class Tests extends Util{
    public Tests(String [] args, boolean flag_test) throws Exception{
        // comando abaixo para rodar
        //y test
        String force_java_21="""
        """;
        if ( flag_test ){
            teste_unico2();
            return;
        }
        return;
    }
    
    public void teste_unico2() throws Exception{        
        /*
        int x=741;
        int y=362;
        byte [] captura=robotGetImgScreenBytes("bmp");        
        int [] pontos=bmp_findCardXY(captura);
        x=pontos[0];
        y=pontos[1];
        //int x2=0; int y2=0; int x3=7; int y3=9; // findCard
        //int x2=-25; int y2=-10; int x3=-2; int y3=22; // card
        int x2=-25; int y2=25; int x3=-2; int y3=40; // naipe
        bmp_salvarRecorte(captura,x+x2,y+y2,x+x3,y+y3,"c:\\tmp\\hj.bmp");
        System.out.println( bmp_dumpPixels(captura,x+x2,y+y2,x+x3,y+y3,true) );System.out.println("\n\n");
        mostra_array(bmp_findCardXY(captura));
        System.out.println( new PokerCalculator().getProbabilidade(new String[]{"AH", "KD"}, new String[]{"", "", "", "", ""}) ); // Ás de Copas e Rei de Ouros
        // {"2","3","4","5","6","7","8","9","T","J","Q","K","A"}; // T = Ten // J = Jack // Q = Queen // K = King // A = Ace 
        // {"C","D","H","S"}; // C = Paus (Clubs) // D = Ouros (Diamonds) // H = Copas (Hearts) // S = Espadas (Spades) 
        */
        ///////////////
        boolean first=true;
        String tail_error="";        
        while( true ){
            try{
                byte [] captura=robotGetImgScreenBytes("bmp");        
                int [] cartas_xy=bmp_findCardXY(captura);
                boolean lendo_mesa=true; // mesa/mao
                String mesa="";
                String mao="";    
                String out_path="c:\\tmp\\hj.bmp";
                int x,y,x2,y2,x3,y3,n_find_parm;
                String code_md5="";
                String card="";
                String naipe="";                
                String msg_error="";
                String [] codes=new String[]{
                    "5514661a969303faafad0ac5c0cd4570", "2",
                    "07221e2510a9b660ea8562f036e5795b", "2",
                    "87162053aa40b3ee506af3d5c7ba0540", "2",
                    "3550571b28480fc33e063ced9e6829bc", "3",
                    "2285000d0cbdd0e41e9228ecb4253b55", "3",
                    "5c2bc75d23d3e0cbd0bef59dfe4e49ed", "3",
                    "3e3dd921bf91bf83c7b683243b5c0c9c", "4",
                    "1a8de96534c72f4ffffab8bf80ce6a5d", "5",
                    "7238e345344a5a65f3da0c3af713e983", "5",
                    "f5347ca47328dc30d32b56962f39ace4", "6",
                    "6bb360bdf85da4ea6c09581284e3e1e9", "7",
                    "00d58758b6f5ea7e3778621296a61394", "7",
                    "46b918a92922ba94fcc860df0a83900e", "8",
                    "3b4ed506d37f1aceb8c29e8ffa01b631", "8",
                    "a4719a65c20f002f3ca0bd891fad72ea", "9",
                    "3cc4ca8e0f11393d146c28210bc6d59d", "T", // T = Ten
                    "ad0f65639a75cd1281868a93c259d3bc", "J",
                    "3eba4b3e0584d2a0e57664fbb94b09b3", "J",
                    "dc155179d3dd45bfcd834c8fe6208987", "Q",
                    "c6a95146ee98ec70fe7be7a2331b5567", "Q",
                    "e55bcbce64e561d9fb7d2b120f944289", "Q",
                    "4face8bb12e46f96d110d83974c81243", "Q",
                    "9be8cbbf7463c9ccefd45dcc158e98b8", "Q",
                    "62be4eac78a86832bc398094186d3e13", "K",
                    "a3a5884908eec5ae942c51104387c60f", "K",
                    "a1d6d254748ab6d0278ad9940c374ed7", "K",
                    "5004c84bcbb5ba79531d6600bb261975", "A",
                    "16615d99d49f2a618a5b55dc7ac72aa7", "A",
                    "a20eab5b7ddb06aa05352b333ab2923f", "A",
                    "976bae705bb586fbcb9db8168b42203f", "C", // C = ♣ Paus (Clubs)
                    "d90b876edb13b1a4783c798374741523", "D", // D = ♦ Ouros (Diamonds)
                    "bfbacb5a34eef014d5c44af7ba1b7c6b", "D", // D = ♦ Ouros (Diamonds)
                    "24101eb6921e1d2f80feb73d3b514297", "D", // D = ♦ Ouros (Diamonds)
                    "622ea99532017e6b09987928014a9d85", "H", // H = ♥ Copas (Hearts)
                    "c060bd35eedbf9ed0272f4ef6a86e01a", "H", // H = ♥ Copas (Hearts)
                    "30f46d64d05ccf664275375771754eff", "S"  // S = ♠ Espadas (Spades) 
                };
                if ( first )
                    first=false;
                else
                    sleepSeconds(1);
                if ( cartas_xy.length == 2 )
                    lendo_mesa=false;
                if ( cartas_xy.length == 0 ){
                    System.out.print("\r                                                    \r");
                    tail_error=msg_error;
                    continue;
                }else{                    
                    for ( int i=0;i<cartas_xy.length;i+=2 ){
                        if ( i > 0 && lendo_mesa && cartas_xy[i+1] != cartas_xy[i-1] )
                            lendo_mesa=false;
                        x=cartas_xy[i];
                        y=cartas_xy[i+1];
                        x2=-25; y2=-10; x3=-2; y3=22; // card
                        code_md5=digest_text(bmp_dumpPixels(captura,x+x2,y+y2,x+x3,y+y3,true), "md5");
                        n_find_parm=findParm(codes, code_md5, true);
                        if ( n_find_parm == -1 ){                            
                            bmp_salvarRecorte(captura,x+x2,y+y2,x+x3,y+y3,"c:\\tmp\\hj.bmp");
                            msg_error="Não foi possível decodificar o hash: " + code_md5 + "\nimg: " + out_path;
                            break;
                        }else
                            card=codes[n_find_parm+1];
                        x2=-25; y2=25; x3=-2; y3=45; // naipe
                        code_md5=digest_text(bmp_dumpPixels(captura,x+x2,y+y2,x+x3,y+y3,true), "md5");
                        n_find_parm=findParm(codes, code_md5, true);
                        if ( n_find_parm == -1 ){                            
                            bmp_salvarRecorte(captura,x+x2,y+y2,x+x3,y+y3,"c:\\tmp\\hj.bmp");
                            msg_error="Não foi possível decodificar o hash: " + code_md5 + "\nimg: " + out_path;
                            break;
                        }else
                            naipe=codes[n_find_parm+1];
                        if ( lendo_mesa )
                            mesa += " " + card + naipe;
                        else
                            mao += " " + card + naipe;
                    }
                }                
                
                if ( !msg_error.equals("") ){
                    if ( tail_error.equals(msg_error) )
                        erroFatal(msg_error);
                    tail_error=msg_error;
                    continue;
                }
                tail_error=msg_error;
                
                String [] mao_=mao.trim().split(" ");
                String [] mesa_=mesa.trim().split(" ");
                if ( mao_.length != 2 )
                    continue;
                while(mesa_.length < 5)
                    mesa_=addParm("", mesa_);
                //System.out.println( new PokerCalculator().getProbabilidade(new String[]{"AH", "KD"}, new String[]{"", "", "", "", ""}) ); // Ás de Copas e Rei de Ouros
                String prob=new PokerCalculator().getProbabilidade(mao_, mesa_)+"";
                if ( prob.length() > 6 )
                    prob=prob.substring(0, 6);
                System.out.println(
                    prob + " % " +
                    "-> mesa:" + mesa +
                    " mao:" + mao
                );
            }catch(Exception e){
                if ( e.toString().contains("java.lang.ArrayIndexOutOfBoundsException") )
                    continue;
                System.out.println(e.toString());
            }            
        }
    }
    
    public void teste_unico1() throws Exception{
        YDB ydb=new YDB();
        ydb.writeTable("AA");
        ydb.writeRecord("a1,a2");
        ydb.writeTable("cc");
        ydb.display();
    }
    public void teste_unico0() throws Exception{
        /*
        // teste de sequencia de texto
        in:
            y test
            a b c d e
            z1z2z3
            z1z2z3
        out:
            y test
            a b c d e
            'z1z2z3' não é reconhecido como um comando interno
            'z1z2z3' não é reconhecido como um comando interno
        */
        InputStream inputStream_pipe=System.in;
        int BUFFER_SIZE=1024;
        byte[] buf = new byte[BUFFER_SIZE];
        int len=0;
        inputStream_pipe.read(buf,0,1);
        inputStream_pipe.read(buf,0,1);
        inputStream_pipe.read(buf,0,1);
    }
    
    private String [] tests_name=null;
    private String [] tests_commands=null;
    private String [] tests_hash_out=null;
    private String [] tests_hash_err=null;
    private String dir_tests="/tmp/tests_y";
    private String file_command_test=null;
    private void teste_unico() throws Exception{                            
        try{
            //init
            if ( isWindows() ){
                dir_tests="C:/tmp/tests_y";
                file_command_test=dir_tests+"/test.cmd";
            }else
                file_command_test=dir_tests+"/test";
            if ( !new File(dir_tests).exists() ){
                System.out.println("Favor criar a pasta " + dir_tests);
                return;
            }
            tests_name=new String[]{
                "echo     ", // 1
                "selectCSV"  // 2
            };
            tests_commands=new String[]{
                "y echo A", // 1                
                "echo '[{\"a\":\"3\" },{\"a\": \"4\"}]' | y json \"[elem for elem in data]\" | y selectCSV \"select * from this where a != '3'\"" // 2
            };
            tests_hash_out=new String[]{
                "bf072e9119077b4e76437a93986787ef", // 1
                "5528101eac8ee8cf9fcac85e7825ee0d"  // 2
            };
            tests_hash_err=new String[]{                
            };            
            System.out.println("iniciando tests...");
            for ( int i=0;i<tests_name.length;i++ ){ 
                System.out.print("test " + (i+1) + "/" + tests_name.length + " " + tests_name[i] + "... ");
                if ( ! salvando_file("", new File(file_command_test + ".out")) ){
                    System.err.println("Ocorreu um erro ao gravar: " + file_command_test + ".out");
                    return;
                }
                if ( ! salvando_file("", new File(file_command_test + ".err")) ){
                    System.err.println("Ocorreu um erro ao gravar: " + file_command_test + ".err");
                    return;
                }
                String command=tests_commands[i] + " 1> " + file_command_test + ".out 2> " + file_command_test + ".err";
                if ( !isWindows() ){
                    if ( !new File(file_command_test + ".env").exists() )
                        salvando_file("alias y='java -Dfile.encoding=UTF-8 -cp /opt/y:/opt/y/ojdbc6.jar:/opt/y/sqljdbc4-3.0.jar:/opt/y/mysql-connector-java-8.0.26.jar:/opt/y/jsch-0.1.55.jar:. Y'\n", new File(file_command_test + ".env"));
                    command = "shopt -s expand_aliases\nsource " + file_command_test + ".env\n" + command;                                    
                }
                if ( ! salvando_file(command, new File(file_command_test)) ){
                    System.err.println("Ocorreu um erro ao gravar: " + file_command_test);
                    return;
                }
                if ( !isWindows() ){
                    chmod_777(file_command_test);
                    new ProcessBuilder("bash",file_command_test).start().waitFor();                
                }else
                    new ProcessBuilder(file_command_test).start().waitFor();                
                String str_out=digest("MD5", file_command_test + ".out");
                String str_err=digest("MD5", file_command_test + ".err");
                if ( !str_out.equals(tests_hash_out[i]) )
                    System.out.println("Erro " + str_out + "/" + tests_hash_out[i] );                    
                else
                    System.out.println("OK");
            }
        }catch(Exception e){
            erro_amigavel_exception(e);
            System.exit(1);
        }
    }    
}

@SuppressWarnings({"unchecked", "deprecation"})
class multiCurl extends Util{
    int slots=500;
    Long [] progress_finished_len=new Long[slots];
    Long [] progress_finished_len_memory=new Long[slots];
    Long [] progress_len=new Long[slots];
    ArrayList<Thread> threads=new ArrayList<Thread>();
    ArrayList<String> caminhos=new ArrayList<String>();
    public void addCurl(String url, String caminho) throws Exception{        
        if ( threads.size() == 0 ){
            init_progress();
            start_monitor();
        }
        int progress_number=threads.size();
        Thread t=new Thread(){
            public void run(){
                try{
                    sleepMillis(random(1, 2000));    
                    Y y=new Y();
                    y.preparaPath(caminho, true, 0);
                    y.curl(new FileOutputStream(caminho), "", "GET", false, false, url, null, 200000000L, progress_finished_len, progress_len, progress_number, null);
                    if ( y.curl_response_status != 200 && progress_finished_len[progress_number].equals(0L) )
                        progress_finished_len[progress_number]=-1L;
                    // arredondando para finish
                    if ( y.curl_response_status == 200 && progress_finished_len[progress_number] > 10000000 && progress_len[progress_number] > 0 && !progress_finished_len[progress_number].equals(progress_len[progress_number]) && (progress_finished_len[progress_number]+1000000) > progress_len[progress_number] )
                        progress_finished_len[progress_number]=progress_len[progress_number];
                }catch(Exception e1){
                    erroFatal(e1);
                }
            }
        };
        t.start();     
        caminhos.add(caminho);
        threads.add(t);
    }

    public void init_progress(){
        for ( int i=0;i<slots;i++ ){
            progress_finished_len[i]=0L;
            progress_finished_len_memory[i]=0L;
            progress_len[i]=0L;
        }
    }    
    
    public void start_monitor() throws Exception{
        final PipedInputStream pipedInputStream=new PipedInputStream();
        final PipedOutputStream pipedOutputStream=new PipedOutputStream();
        
        pipedInputStream.connect(pipedOutputStream);

        Thread pipeWriter=new Thread(new Runnable() {
            public void run() {                
                try{
                    while(true){
                        for ( int i=0;i<threads.size();i++ ){
                            if ( progress_finished_len[i] != progress_finished_len_memory[i] ){
                                progress_finished_len_memory[i]=progress_finished_len[i];
                                if ( progress_finished_len_memory[i].equals(-1L) ){
                                    pipedOutputStream.write(
                                        (
                                            (i+1)+" [[[ERROR_download]]] "+ caminhos.get(i)+"\n"
                                        ).getBytes()
                                    );                                    
                                }else{
                                    if ( progress_finished_len_memory[i].equals(progress_len[i]) ){                                    
                                        pipedOutputStream.write(
                                            (
                                                (i+1)+" downloaded! "+bytes_to_text(progress_len[i], false)+" "+ caminhos.get(i)+"\n"
                                            ).getBytes()
                                        );
                                    }else{
                                        pipedOutputStream.write(
                                            (
                                                // [=>        ] ?
                                                (i+1)+" downloading... "+bytes_to_text(progress_finished_len_memory[i], false)+"/"+bytes_to_text(progress_len[i], false)+" "+ caminhos.get(i)+"\n"
                                            ).getBytes()
                                        );
                                    }
                                }
                                pipedOutputStream.flush();
                            }
                        }
                        sleepMillis(500);
                    }
                }catch(Exception e1){
                    new Y().erro_amigavel_exception(e1);
                }                
            }
        });

        Thread pipeReader=new Thread(new Runnable() {
            public void run() {
                new Y().progressBar(pipedInputStream, false);
            }
        });

        pipeWriter.start();
        pipeReader.start();
    }
    
    public void wait_numeroDeTrabalhoIgualOuMenor(int n) throws Exception{
        if ( n < 0 )
            erroFatal("internal error wait_numeroDeTrabalhoIgualOuMenor");
        if ( n == 0 ){
            for ( int i=0;i<threads.size();i++ )
                threads.get(i).join();
        }else{
            int count=0;
            while(true){                
                count=0;
                for ( int i=0;i<threads.size();i++ )
                    if ( threads.get(i).isAlive() )
                        count++;
                if ( count <= n )
                    break;
                sleepMillis(100);
            }
            
        }
    }    
}

@SuppressWarnings({"unchecked", "deprecation"})
class grammarsWhere extends Util{
    // teste:
    // cd /opt/y;compila2;echo '[{"a": "a21", "b": "b31"},{"a": "a22", "b": "b32"}]' | y json "[elem for elem in data]" | y selectCSV_banco "select b c, a from this where b = 'b31'" 
    
    public static String [] transferPai=null;
    public static String [] transferFilhoStr=null;
    public static String [][] transferFilho=null;
    public static String [] grammars=new String []{
        "valor_int                                         "
       ,"    parseInt( valor_txt )                         "
       ,"    valor_int * valor_int                         "
       ,"    valor_int / valor_int                         "
       ,"    valor_int + valor_int                         "
       ,"    valor_int - valor_int                         "
       ,"    if( boolean , valor_int , valor_int )         "
       ,"                                                  "
       ,"valor_txt                                         "
       ,"    valor_txt + valor_txt                         "
       ,"    valor_int + valor_txt                         "
       ,"    valor_txt + valor_int                         "
       ,"    substr( valor_txt , valor_int )               "
       ,"    substr( valor_txt , valor_int , valor_int )   "            
       ,"    if( boolean , valor_txt , valor_txt )         "
       ,"    ifnull( valor_txt , valor_txt )               "
       ,"                                                  "
       ,"boolean                                           "
       ,"    not boolean                                   "
       ,"    valor_txt = valor_txt                         "
       ,"    valor_txt like valor_txt                      "
       ,"    valor_int = valor_txt                         "
       ,"    valor_txt = valor_int                         "
       ,"    valor_txt > valor_txt                         "
       ,"    valor_txt < valor_txt                         "
       ,"    valor_txt >= valor_txt                        "
       ,"    valor_txt <= valor_txt                        "
       ,"    valor_txt != valor_txt                        "
       ,"    valor_txt <> valor_txt                        "
       ,"    valor_int = valor_int                         "
       ,"    valor_int > valor_int                         "
       ,"    valor_int < valor_int                         "
       ,"    valor_int >= valor_int                        "
       ,"    valor_int <= valor_int                        "
       ,"    valor_int != valor_int                        "
       ,"    valor_int <> valor_int                        "
       ,"    ( boolean )                                   "
       ,"    boolean and boolean                           "
       ,"    boolean or boolean                            "
       ,"    valor_int in ( valor_int ... )                "
       ,"    valor_txt in ( valor_txt ... )                "
       ,"                                                  "
       ,"valor_txt                                         "
       ,"    ( valor_txt )                                 "
       ,"                                                  "
       ,"valor_txt                                         "
       ,"    ( valor_txt )                                 "
       ,"                                                  "
       ,"root                                              "
       ,"    where boolean                                 "
    };
    
    // teste:
    // cd /opt/y;compila2;echo '[{"a": "a21", "b": "b31"},{"a": "a22", "b": "b32"}]' | y json "[elem for elem in data]" | y selectCSV_banco "select b c, a from this where b = 'b31'"     
    public static String where="";
    public static ArrayList<Node> nodes=new ArrayList<Node>();
    public static ArrayList<Node> nodesTemplate=null;
    public static String [] selectCSV_camposName=null; // nome original(nao eh o alias)    
    grammarsWhere(String [] selectCSV_camposName, String where){
        init();
        this.selectCSV_camposName=selectCSV_camposName;
        this.where=where;        
        initTransfer();
        initNodes();
        //mostrandoNodes(nodes);
        //mostrandoTransfer(transferPai, transferFilhoStr);
    }
    public static void init(){
        transferPai=null;
        transferFilhoStr=null;
        transferFilho=null;        
        where="";
        nodes=new ArrayList<Node>();
        nodesTemplate=null;
        selectCSV_camposName=null;
        transfere_cache = new ArrayList<>();
        transfere_count=0;
        transfere_reading=false;        
    }
    public static boolean ok(String [] selectCSV_camposValue){    
        setCampos(selectCSV_camposValue);
        int limit=100000;
        //mostrandoNodes(nodes);        

        transfere_count=0;
        while(limit-->0 && (nodes.size()>1 || !nodes.get(0).is_this.equals("root") ) ){
            if(transfere())
                continue;
            mostrandoNodes(nodes);
            erroFatal("nao foi possivel entender o where. debug acima");
        }    
        if( !transfere_reading )
            transfere_reading=true;
        if ( limit <= 0 ){
            mostrandoNodes(nodes);
            erroFatal("error anti loop");
        }
        return nodes.get(0).value.equals("S");
    }
    public static ArrayList<Integer> transfere_cache = new ArrayList<>();
    public static int transfere_count=0;
    public static boolean transfere_reading=false;
    public static boolean transfere(){
        for ( int pos_transfer=0;pos_transfer<transferPai.length;pos_transfer++ ){
            for ( int pos_node=0;pos_node<nodes.size();pos_node++ ){
                if(transfere_reading){
                    pos_transfer=transfere_cache.get(transfere_count++);
                    pos_node=transfere_cache.get(transfere_count++);
                }
                Node node=transfere(pos_transfer, pos_node);
                if ( node == null ){
                    if(transfere_reading){
                        erroFatal("transfere_reading error!");
                    }
                    continue;
                }
                // dynamic list remove
                if ( transferFilho[pos_transfer].length > 1 && transferFilho[pos_transfer][1].equals("in") ){ 
                    while(nodes.size() > pos_node){
                        String aux = nodes.get(pos_node).is_this;
                        nodes.remove(pos_node);
                        if ( aux.equals(")") )
                            break;
                    }
                }else{
                    int qnt=transferFilho[pos_transfer].length;
                    for ( int i=0;i<qnt;i++ )
                        nodes.remove(pos_node);
                }
                nodes.add(pos_node, node);
                if(!transfere_reading){
                    transfere_cache.add(pos_transfer);
                    transfere_cache.add(pos_node);
                }
                return true;
            }            
        }
        return false;
    }
    public static Node transfere(int pos_transfer, int pos_node){
        if ( dynamicDetectList(pos_transfer, pos_node) ){
            // ok
        }else{
            for(int i=0;i<transferFilho[pos_transfer].length;i++){
                if(pos_node+i >= nodes.size() || !nodes.get(pos_node+i).is_this.equals(transferFilho[pos_transfer][i]))
                    return null;
            }
        }
        return transfere(transferPai[pos_transfer], transferFilhoStr[pos_transfer], pos_transfer, pos_node, false);
    }
    public static Node transfere(String pai, String filhoStr, int pos_transfer, int pos_node, boolean checkImplementation){
        if ( filhoStr.equals("valor_int * valor_int") ){
            if ( checkImplementation ) return new Node("","");
            return new Node(nodes.get(pos_node).value_decimal.multiply(nodes.get(pos_node+2).value_decimal).toString(),pai);
        }
        if ( filhoStr.equals("valor_int + valor_int") ){
            if ( checkImplementation ) return new Node("","");
            return new Node(nodes.get(pos_node).value_decimal.add(nodes.get(pos_node+2).value_decimal).toString(),pai);
        }
        if ( filhoStr.equals("valor_int + valor_txt") ){
            if ( checkImplementation ) return new Node("","");
            return new Node(nodes.get(pos_node).value_decimal.toString()+nodes.get(pos_node+2).value,pai);        
        }
        if ( filhoStr.equals("valor_txt + valor_int") ){
            if ( checkImplementation ) return new Node("","");
            return new Node(nodes.get(pos_node).value.toString()+nodes.get(pos_node+2).value_decimal,pai);        
        }
        if ( filhoStr.equals("valor_txt + valor_txt") ){
            if ( checkImplementation ) return new Node("","");
            return new Node(nodes.get(pos_node).value.toString()+nodes.get(pos_node+2).value,pai);        
        }
        if ( filhoStr.equals("( valor_int )") ){
            if ( checkImplementation ) return new Node("","");
            return nodes.get(pos_node+1);
        }
        if ( filhoStr.equals("( valor_txt )") ){
            if ( checkImplementation ) return new Node("","");
            return nodes.get(pos_node+1);
        }
        if ( filhoStr.equals("( boolean )") ){
            if ( checkImplementation ) return new Node("","");
            return nodes.get(pos_node+1);
        }
        if ( filhoStr.equals("boolean and boolean") ){
            if ( checkImplementation ) return new Node("","");
            return new Node((nodes.get(pos_node).value.equals("S")&&nodes.get(pos_node+2).value.equals("S"))?"S":"N",pai);
        }
        if ( filhoStr.equals("boolean or boolean") ){
            if ( checkImplementation ) return new Node("","");
            return new Node((nodes.get(pos_node).value.equals("S")||nodes.get(pos_node+2).value.equals("S"))?"S":"N",pai);
        }
        if ( filhoStr.equals("valor_int in ( valor_int ... )") ){
            if ( checkImplementation ) return new Node("","");
            String result="N";
            for ( int i=3;i<nodes.size()-pos_node;i++ ){
                if ( i%2==1 ){
                    if ( nodes.get(pos_node).value_decimal.toString().equals(nodes.get(pos_node+i).value_decimal.toString() ) ){
                        result="S";
                        break;
                    }                        
                }else{
                    if ( nodes.get(pos_node+i).is_this.equals(",") )
                        continue;
                    if ( nodes.get(pos_node+i).is_this.equals(")") ){
                        result="N";
                        break;
                    }
                }
            }
            return new Node(result,pai);        
        }
        if ( filhoStr.startsWith("valor_txt in ( valor_txt ... )") ){
            if ( checkImplementation ) return new Node("","");
            String result="N";
            for ( int i=3;i<nodes.size()-pos_node;i++ ){
                if ( i%2==1 ){
                    if ( nodes.get(pos_node).value.toString().equals(nodes.get(pos_node+i).value.toString() ) ){
                        result="S";
                        break;
                    }                        
                }else{
                    if ( nodes.get(pos_node+i).is_this.equals(",") )
                        continue;
                    if ( nodes.get(pos_node+i).is_this.equals(")") ){
                        result="N";
                        break;
                    }
                }
            }
            return new Node(result,pai);        
        }
        if ( filhoStr.equals("valor_int - valor_int") ){
            if ( checkImplementation ) return new Node("","");
            return new Node(nodes.get(pos_node).value_decimal.subtract(nodes.get(pos_node+2).value_decimal).toString(),pai);
        }
        if ( filhoStr.equals("if( boolean , valor_int , valor_int )") ){
            if ( checkImplementation ) return new Node("","");
            return new Node(nodes.get(pos_node+1).value.equals("S")?nodes.get(pos_node+3).value_decimal.toString():nodes.get(pos_node+5).value_decimal.toString(),pai);
        }
        if ( filhoStr.equals("if( boolean , valor_txt , valor_txt )") ){
            if ( checkImplementation ) return new Node("","");
            return new Node(nodes.get(pos_node+1).value.equals("S")?nodes.get(pos_node+3).value.toString():nodes.get(pos_node+5).value.toString(),pai);
        }
        if ( filhoStr.equals("ifnull( valor_txt , valor_txt )") ){
            if ( checkImplementation ) return new Node("","");
            return new Node(nodes.get(pos_node+1).value.equals("")?nodes.get(pos_node+3).value:nodes.get(pos_node+1).value,pai);
        }
        if ( filhoStr.equals("valor_txt = valor_txt") ){
            if ( checkImplementation ) return new Node("","");
            return new Node(nodes.get(pos_node).value.equals(nodes.get(pos_node+2).value)?"S":"N",pai);        
        }
        if ( filhoStr.equals("valor_txt like valor_txt") ){
            if ( checkImplementation ) return new Node("","");
            String a = nodes.get(pos_node).value;
            String b = nodes.get(pos_node+2).value;
            boolean flag1 = b.startsWith("%");
            boolean flag2 = b.endsWith("%");
            if ( b.length() > 0 && flag1 )
                b=b.substring(1);
            if ( b.length() > 0 && flag2 )
                b=b.substring(0, b.length()-1);
            String result="N";
            if ( flag1 ){
                if( flag2 ){
                    if ( a.contains(b) )
                        result="S";
                }else{
                    if ( a.endsWith(b) )
                        result="S";
                }
            }else{
                if( flag2 ){
                    if ( a.startsWith(b) )
                        result="S";                    
                }else{
                    if ( a.equals(b) )
                        result="S";                    
                }
            }
            return new Node(result,pai);        
        }
        if ( filhoStr.equals("valor_int = valor_txt") ){
            if ( checkImplementation ) return new Node("","");
            return new Node((nodes.get(pos_node).value_decimal+"").equals(nodes.get(pos_node+2).value)?"S":"N",pai);        
        }
        if ( filhoStr.equals("valor_txt = valor_int") ){
            if ( checkImplementation ) return new Node("","");
            return new Node(nodes.get(pos_node).value.equals(nodes.get(pos_node+2).value_decimal+"")?"S":"N",pai);        
        }
        if ( filhoStr.equals("valor_txt != valor_txt") ){
            if ( checkImplementation ) return new Node("","");
            return new Node(!nodes.get(pos_node).value.equals(nodes.get(pos_node+2).value)?"S":"N",pai);        
        }
        if ( filhoStr.equals("valor_txt <> valor_txt") ){
            if ( checkImplementation ) return new Node("","");
            return new Node(!nodes.get(pos_node).value.equals(nodes.get(pos_node+2).value)?"S":"N",pai);        
        }
        if ( filhoStr.equals("valor_int != valor_int") ){
            if ( checkImplementation ) return new Node("","");
            return new Node(!nodes.get(pos_node).value_decimal.equals(nodes.get(pos_node+2).value_decimal)?"S":"N",pai);        
        }
        if ( filhoStr.equals("valor_int <> valor_int") ){
            if ( checkImplementation ) return new Node("","");
            return new Node(!nodes.get(pos_node).value_decimal.equals(nodes.get(pos_node+2).value_decimal)?"S":"N",pai);        
        }
        if ( filhoStr.equals("valor_int = valor_int") ){
            if ( checkImplementation ) return new Node("","");
            return new Node(nodes.get(pos_node).value_decimal.toString().equals(nodes.get(pos_node+2).value_decimal.toString())?"S":"N",pai);        
        }
        if ( filhoStr.equals("where boolean") ){
            if ( checkImplementation ) return new Node("","");
            return new Node(nodes.get(pos_node+1).value,pai);        
        }
        if ( filhoStr.equals("parseInt( valor_txt )") ){
            if ( checkImplementation ) return new Node("","");
            try{
                BigDecimal value_decimal = new BigDecimal(nodes.get(pos_node+1).value);
                return new Node(value_decimal.toString(),pai);        
            }catch(Exception e){
                erroFatal("Nao foi possivel converter -> " + "parseInt( " + nodes.get(pos_node+1).value + " )");
            }
            return null;        
        }        
        if ( filhoStr.equals("valor_int / valor_int") ){
            if ( checkImplementation ) return new Node("","");
            return new Node(nodes.get(pos_node).value_decimal.divide(nodes.get(pos_node+2).value_decimal).toString(),pai);
        }
        if ( filhoStr.equals("substr( valor_txt , valor_int )") ){
            if ( checkImplementation ) return new Node("","");
            try{
                int valor_int = Integer.parseInt(nodes.get(pos_node+3).value);
                return new Node(nodes.get(pos_node+3).value.substring(valor_int),pai);        
            }catch(Exception e){
                erroFatal("Nao foi possivel converter -> " + "substr( " + nodes.get(pos_node+1).value + " , " + nodes.get(pos_node+3).value + " )");
            }
        }        
        if ( filhoStr.equals("substr( valor_txt , valor_int , valor_int )") ){
            if ( checkImplementation ) return new Node("","");
            try{
                int valor_int = Integer.parseInt(nodes.get(pos_node+3).value);
                int valor_int2 = Integer.parseInt(nodes.get(pos_node+5).value);
                return new Node(nodes.get(pos_node+3).value.substring(valor_int,valor_int+valor_int2),pai);        
            }catch(Exception e){
                erroFatal("Nao foi possivel converter -> " + "substr( " + nodes.get(pos_node+1).value + " , " + nodes.get(pos_node+3).value + " , " + nodes.get(pos_node+5).value + " )");
            }
        }        
        if ( filhoStr.equals("not boolean") ){
            if ( checkImplementation ) return new Node("","");
            return new Node(nodes.get(pos_node+1).value.equals("S")?"N":"S",pai);
        }
        if ( filhoStr.equals("valor_txt > valor_txt") ){
            if ( checkImplementation ) return new Node("","");
            return new Node((nodes.get(pos_node).value.compareTo(nodes.get(pos_node+2).value))>0?"S":"N",pai);
        }
        if ( filhoStr.equals("valor_int > valor_int") ){
            if ( checkImplementation ) return new Node("","");
            return new Node((nodes.get(pos_node).value_decimal.compareTo(nodes.get(pos_node+2).value_decimal))>0?"S":"N",pai);
        }
        if ( filhoStr.equals("valor_int >= valor_int") ){
            if ( checkImplementation ) return new Node("","");
            return new Node((nodes.get(pos_node).value_decimal.compareTo(nodes.get(pos_node+2).value_decimal))>=0?"S":"N",pai);
        }
        if ( filhoStr.equals("valor_int < valor_int") ){
            if ( checkImplementation ) return new Node("","");
            return new Node((nodes.get(pos_node).value_decimal.compareTo(nodes.get(pos_node+2).value_decimal))<0?"S":"N",pai);
        }
        if ( filhoStr.equals("valor_int <= valor_int") ){
            if ( checkImplementation ) return new Node("","");
            return new Node((nodes.get(pos_node).value_decimal.compareTo(nodes.get(pos_node+2).value_decimal))<=0?"S":"N",pai);
        }
        if ( filhoStr.equals("valor_txt < valor_txt") ){
            if ( checkImplementation ) return new Node("","");
            return new Node((nodes.get(pos_node).value.compareTo(nodes.get(pos_node+2).value))<0?"S":"N",pai);
        }
        if ( filhoStr.equals("valor_txt >= valor_txt") ){
            if ( checkImplementation ) return new Node("","");
            return new Node((nodes.get(pos_node).value.compareTo(nodes.get(pos_node+2).value))>=0?"S":"N",pai);
        }
        if ( filhoStr.equals("valor_txt <= valor_txt") ){
            if ( checkImplementation ) return new Node("","");
            return new Node((nodes.get(pos_node).value.compareTo(nodes.get(pos_node+2).value))<=0?"S":"N",pai);
        }
        return null;
    }
    
    public static boolean dynamicDetectList(int pos_transfer, int pos_node){        
        if ( transferFilho[pos_transfer].length > 1 && transferFilho[pos_transfer][1].equals("in") ){
            String tipo = transferFilho[pos_transfer][0];
            for(int i=0;i<nodes.size()-pos_node;i++){
                if (i == 0 && nodes.get(pos_node+i).is_this.equals(tipo) )
                    continue;
                if (i == 1 && nodes.get(pos_node+i).is_this.equals("in") )
                    continue;
                if (i == 2 && nodes.get(pos_node+i).is_this.equals("(") )
                    continue;
                if (i == 3 && nodes.get(pos_node+i).is_this.equals(tipo) )
                    continue;
                if (i > 3 && nodes.get(pos_node+i).is_this.equals(tipo) && nodes.get(pos_node+i-1).is_this.equals(",") )
                    continue;
                if (i > 3 && nodes.get(pos_node+i).is_this.equals(",") && nodes.get(pos_node+i-1).is_this.equals(tipo) )
                    continue;
                if (i > 3 && nodes.get(pos_node+i).is_this.equals(")") && nodes.get(pos_node+i-1).is_this.equals(tipo) )
                    return true;
                return false;
            }
        }
        return false;
    }
    
    public static void setCampos(String [] selectCSV_camposValue){        
        nodes=copyListNodes(nodesTemplate);        
        for( int i=0;i<nodes.size();i++ ){
            if(nodes.get(i).nome_campo != null)
                nodes.get(i).value = selectCSV_camposValue[nodes.get(i).nome_campo_index];
            else
                if(nodes.get(i).is_this.equals(""))
                    nodes.get(i).is_this=nodes.get(i).value;
            if ( nodes.get(i).value == null )
                nodes.get(i).value = "";
        }
    }
    
    public static void mostrando(String [] a){
        System.out.println("mostrando inicio:");
        for(int i=0;i<a.length;i++)
            System.out.println(">>"+a[i]+"<<");
        System.out.println("mostrando fim");
    }
    
    public static void mostrandoNodes(ArrayList<Node> a){
        System.out.println("mostrando inicio node:");
        for(int i=0;i<a.size();i++)
            System.out.println("value: "+a.get(i).value+" is_this: "+a.get(i).is_this+" nome_campo: "+a.get(i).nome_campo);
        System.out.println("mostrando fim");
    }
    public static void mostrandoTransfer(String [] transferPai, String [] transferFilhoStr){
        System.out.println("mostrando inicio:");
        for(int i=0;i<transferPai.length;i++)
            System.out.println("pai: " + transferPai[i] + " filhoStr: " + transferFilhoStr[i]);
        System.out.println("mostrando fim");
    }
    public static void addNode(String s, String is_this){
        if ( s.equals("") && !is_this.equals("valor_txt") )
            return;
        nodes.add(new Node(s, is_this));
    }
    public static void initTransfer(){
        int count=0;
        String pai="";
        for ( int i=0;i<grammars.length;i++ ){
            if ( grammars[i].trim().equals("") || !grammars[i].startsWith(" ") )
                continue;
            count++;
        }
        transferPai = new String[count];
        transferFilhoStr = new String[count];
        transferFilho = new String[count][0];
        count=0;
        for ( int i=0;i<grammars.length;i++ ){
            if ( grammars[i].trim().equals("") )
                continue;
            if ( !grammars[i].startsWith(" ") ){
                pai=grammars[i].trim();
                continue;
            }
            transferPai[count]=pai;
            transferFilhoStr[count]=grammars[i].trim();
            transferFilho[count++]=grammars[i].trim().split(" ");
        }
        // check implementation transfer
        for ( int i=0;i<transferFilhoStr.length;i++ ){
            Node node = transfere("", transferFilhoStr[i], -1, -1, true);
            if ( node == null )
                erroFatal("Erro interno. Nao foi possivel encontrar a implementação " + transferFilhoStr[i]);
        }
    }
    
    public static void initNodes(){
        boolean literal_on=false;
        String tail="";
        String s="";
        for(int i=0;i < where.length();i++){
            String t=where.substring(i, i+1);
            if(t.equals("\t") || t.equals("\n") || t.equals("\r"))
                t=" ";
            if(tail.equals("")){
                if(!t.equals(" "))
                    tail=t;
                continue;
            }
            if(!literal_on && t.equals(" ") && tail.equals(" "))
                continue;
            if(literal_on){
                if (tail.equals("'")){
                    addNode(s, "valor_txt");
                    literal_on=false;
                    s="";
                    tail=t;
                    continue;
                }
                s+=tail;
                tail=t;
                continue;
            }
            if(!literal_on && tail.equals("'")){
                if ( t.equals("'") ){
                    addNode("","valor_txt");
                    s="";
                    tail="";
                    continue;                    
                }
                literal_on=true;
                tail=t;
                continue;
            }
            if(!literal_on && "\\({[,=<>+-*/".indexOf(tail) > 0){
                if ( (tail.equals(">") || tail.equals("<") || tail.equals("!")) && t.equals("=") ){
                    //pass
                }else{
                    s+=tail;
                    addNode(s.trim(), "");
                    s="";
                    tail=t;
                    continue;
                }
            }
            if(!literal_on && "'\\)}],=<>+-*/".indexOf(t) > 0){
                if ( (tail.equals(">") || tail.equals("<") || tail.equals("!")) && t.equals("=") ){
                    //pass
                }else{
                    s+=tail;
                    addNode(s.trim(), "");
                    s="";
                    tail=t;
                    continue;
                }
            }
            if(!literal_on && tail.equals(" ")){
                addNode(s.trim(), "");
                s="";
                tail=t;
                continue;
            }
            s+=tail;
            tail=t;
        }
        if(literal_on){
            if(tail.equals("'")){
                addNode(s, "valor_txt");
                s="";
            }else
                erroFatal("error, expected: '");
        }else{
            if(!tail.equals(""))
                s+=tail;
            addNode(s.trim(), "");
        }
        nodesTemplate=copyListNodes(nodes);
        if(nodes.size()==0)
            erroFatal("erro na interpretacao do where");
    }
    
    private static ArrayList<Node> copyListNodes(ArrayList<Node> a){
        ArrayList<Node> b=new ArrayList<Node>();
        b.addAll(a);
        return b;
    }
    
    @SuppressWarnings({"unchecked", "deprecation"})
    static class Node{
        final String is_root="root";
        final String is_boolean="boolean";
        final String is_valor_txt="valor_txt";
        final String is_valor_int="valor_int";
        String is_this="";  
        String nome_campo=null;
        int nome_campo_index=-1;
        String value="";
        BigDecimal value_decimal=null;        
        public Node(String s, String is_this_){
            value=s;
            is_this=is_this_;
            if ( is_this.equals("") ){
                for( int i=0;i<selectCSV_camposName.length;i++ ){
                    if(selectCSV_camposName[i].equals(s)){
                        nome_campo=selectCSV_camposName[i];
                        nome_campo_index=i;
                        is_this=is_valor_txt;
                        break;
                    }
                }
            }
            if ( is_this.equals("") || is_this.equals("valor_int")){
                value=s;
                try{
                    value_decimal = new BigDecimal(value);
                    is_this=is_valor_int;
                }catch(Exception e){
                    if(is_this.equals("valor_int"))
                        erroFatal("Erro interno 004");
                }
            }
        }
    }
}

@SuppressWarnings({"unchecked", "deprecation"})
class WebDAVServer extends Util{
    private static final Map<String, String> USERS = new HashMap<>();

    public WebDAVServer(String host, int port, String pass){
        try{
            if ( pass != null && !pass.equals("") ){
                String [] partes=pass.split(",");
                if ( partes.length > 0 ){
                    if ( partes.length%2 == 1 ){
                        erroFatal("parametro -pass incorreto! " + pass);
                    }
                    for ( int i=0;i<partes.length;i+=2 ){
                        USERS.put(partes[i], partes[i+1]);
                    }
                }
            }
            if ( host == null ){
                try{
                    host=InetAddress.getLocalHost().getHostName();
                }catch(Exception e){
                    System.out.println("warning: procurando ip ...");
                    host=getListaIPs().get(0);
                    System.out.println("warning: ip localizado -> "+host);
                }                    
            }

            ServerSocket serverSocket = new ServerSocket(port, 1,InetAddress.getByName(host));
            String host_display="http://" + host + ":" + port;
            if (host.contains(":"))
                host_display="http://[" + host + "]:" + port;
            System.out.println("Service opened: " + host_display + "\ndir: " + new File(".").getAbsolutePath() );

            while (true) {
                Socket clientSocket = serverSocket.accept();
                new Thread(new WebDAVHandler(clientSocket)).start();
            }
        }catch(Exception e){
            erroFatal(e);
        }
    }

    @SuppressWarnings({"unchecked", "deprecation"})
    private class WebDAVHandler implements Runnable {
        private final Socket clientSocket;

        public WebDAVHandler(Socket clientSocket) {
            this.clientSocket = clientSocket;
        }

        @Override
        public void run() {
            try (InputStream in = clientSocket.getInputStream();
                 OutputStream out = clientSocket.getOutputStream()) {

                // Ler o header byte por byte
                StringBuilder headerBuilder = new StringBuilder();
                int prevByte = -1;
                int currByte;

                while ((currByte = in.read()) != -1) {
                    headerBuilder.append((char) currByte);

                    // Verificar se encontramos o fim do header (\r\n\r\n)
                    if (prevByte == '\r' && currByte == '\n') {
                        int nextByte1 = in.read();
                        int nextByte2 = in.read();

                        if (nextByte1 == '\r' && nextByte2 == '\n') {
                            // Fim do header encontrado
                            headerBuilder.append((char) nextByte1).append((char) nextByte2);
                            break;
                        } else {
                            headerBuilder.append((char) nextByte1).append((char) nextByte2);
                        }
                    }

                    prevByte = currByte;
                }

                // Processar o header
                String header = headerBuilder.toString();
                String[] headerLines = header.split("\r\n");
                String requestLine = headerLines[0];

                // Extrair método e caminho
                String[] requestParts = requestLine.split(" ");
                String method = requestParts[0];
                String path = "";
                if ( requestParts.length > 1 )
                    path=requestParts[1];

                String decodedPath = decodeUrl(path);

                // Extrair cabeçalhos
                Map<String, String> headers = new HashMap<>();
                for (int i = 1; i < headerLines.length; i++) {
                    String[] headerParts = headerLines[i].split(":", 2);
                    if (headerParts.length == 2) {
                        headers.put(headerParts[0].trim().toLowerCase(), headerParts[1].trim());
                    }
                }

                // Verificar autenticação
                if (USERS.size() > 0 && !isAuthenticated(headers, out)) {
                    return; // Se não autenticado, encerra a conexão
                }

                // Processar a requisição
                switch (method) {
                    case "GET":
                        handleGet(out, decodedPath);
                        break;
                    case "PUT":
                        handlePut(in, out, decodedPath, headers);
                        break;
                    case "MKCOL":
                        handleMkcol(out, decodedPath);
                        break;
                    case "DELETE":
                        handleDelete(out, decodedPath);
                        break;
                    case "MOVE":
                        handleMove(in, out, decodedPath, headers);
                        break;
                    case "PROPFIND":
                        handlePropfind(in, out, decodedPath, headers);
                        break;
                    case "OPTIONS":
                        handleOptions(out);
                        break;
                    default:
                        sendResponse(out, "HTTP/1.1 501 Not Implemented -> " + method + " - " + decodedPath, "Method not supported");
                        break;
                }

            } catch (IOException e) {
                e.printStackTrace();
            } finally {
                try {
                    clientSocket.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }

        private boolean isAuthenticated(Map<String, String> headers, OutputStream out) throws IOException {
            String authHeader = headers.get("authorization");
            if (authHeader == null || !authHeader.startsWith("Basic ")) {
                // Solicitar autenticação
                sendResponse(out, "HTTP/1.1 401 Unauthorized", "Unauthorized", "WWW-Authenticate: Basic realm=\"WebDAV\"");
                return false;
            }

            // Decodificar credenciais
            String credentials = new String(Base64.getDecoder().decode(authHeader.substring("Basic ".length())));
            String[] userPass = credentials.split(":");
            if (userPass.length != 2) {
                sendResponse(out, "HTTP/1.1 401 Unauthorized", "Invalid credentials");
                return false;
            }

            String username = userPass[0];
            String password = userPass[1];

            // Verificar usuário e senha
            if (!USERS.containsKey(username) || !USERS.get(username).equals(password)) {
                sendResponse(out, "HTTP/1.1 401 Unauthorized", "Invalid username or password");
                return false;
            }

            return true; // Autenticado com sucesso
        }

        private void handleGet(OutputStream out, String path) throws IOException {
            File file = new File("." + path);

            // Verificar se o arquivo/diretório existe
            if (!file.exists()) {
                sendResponse(out, "HTTP/1.1 404 Not Found - " + new File("." + path).getAbsolutePath(), "Resource not found");
                return;
            }

            // Se for um arquivo, enviar o conteúdo
            if (file.isFile()) {
                try (FileInputStream fis = new FileInputStream(file)) {
                    // Enviar cabeçalhos de resposta
                    String responseHeaders = "HTTP/1.1 200 OK\r\n" +
                            "Content-Type: application/octet-stream\r\n" +
                            "Content-Length: " + file.length() + "\r\n" +
                            "\r\n";
                    out.write(responseHeaders.getBytes());

                    // Enviar o conteúdo do arquivo
                    byte[] buffer = new byte[1024];
                    int bytesRead;
                    while ((bytesRead = fis.read(buffer)) != -1) {
                        out.write(buffer, 0, bytesRead);
                    }
                } catch (IOException e) {
                    // Em caso de erro ao ler o arquivo
                    sendResponse(out, "HTTP/1.1 500 Internal Server Error", "Failed to read file: " + e.getMessage());
                }
            }
            // Se for um diretório, listar o conteúdo
            else if (file.isDirectory()) {
                File[] files = file.listFiles();
                if (files == null) {
                    sendResponse(out, "HTTP/1.1 500 Internal Server Error", "Failed to list directory contents");
                    return;
                }

                // Construir a lista de arquivos e diretórios
                StringBuilder directoryListing = new StringBuilder();
                directoryListing.append("<html><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"><body><h1>Directory Listing: ").append(path).append("</h1><ul>");

                // Adicionar link para o diretório pai (..)
                if (!path.equals("/")) {
                    String parentPath = new File(path).getParent();
                    if (parentPath == null) {
                        parentPath = "/";
                    }
                    directoryListing.append("<li>[DIR] <a href=\"").append(parentPath).append("\">..</a></li>");
                }

                // Listar arquivos e diretórios
                for (File f : files) {
                    String name = f.getName();
                    String type = f.isDirectory() ? "DIR" : "FILE";
                    directoryListing.append("<li>[").append(type).append("] <a href=\"").append(path.endsWith("/") ? path : path+"/").append(name).append("\">").append(name).append("</a></li>");
                }

                directoryListing.append("</ul></body></html>");

                // Enviar a lista como resposta
                sendResponse(out, "HTTP/1.1 200 OK", directoryListing.toString(), "Content-Type: text/html");
            }
        }

        private void handlePut(InputStream in, OutputStream out, String path, Map<String, String> headers) throws IOException {
            File file = new File("." + path);

            // Verificar se o diretório pai existe
            File parentDir = file.getParentFile();
            if (parentDir != null && !parentDir.exists()) {
                sendResponse(out, "HTTP/1.1 409 Conflict", "Parent directory does not exist");
                return;
            }

            // Obter o tamanho do conteúdo (Content-Length)
            int contentLength = Integer.parseInt(headers.getOrDefault("content-length", "0"));
            if (contentLength <= 0) {
                sendResponse(out, "HTTP/1.1 411 Length Required", "Content-Length header is required");
                return;
            }

            // Criar ou sobrescrever o arquivo
            try (FileOutputStream fos = new FileOutputStream(file)) {
                byte[] buffer = new byte[1024];
                int bytesRead;
                int totalBytesRead = 0;

                // Ler o corpo da requisição e gravar no arquivo
                while (totalBytesRead < contentLength) {
                    bytesRead = in.read(buffer, 0, Math.min(buffer.length, contentLength - totalBytesRead));
                    if (bytesRead == -1) {
                        // Fim do fluxo de entrada inesperado
                        sendResponse(out, "HTTP/1.1 500 Internal Server Error", "Unexpected end of input stream");
                        return;
                    }
                    fos.write(buffer, 0, bytesRead);
                    totalBytesRead += bytesRead;
                }

                // Resposta de sucesso
                if (file.exists()) {
                    sendResponse(out, "HTTP/1.1 204 No Content", ""); // Arquivo atualizado
                } else {
                    sendResponse(out, "HTTP/1.1 201 Created", "File created"); // Arquivo criado
                }
            } catch (IOException e) {
                sendResponse(out, "HTTP/1.1 500 Internal Server Error", "Failed to write file: " + e.getMessage());
            }
        }

        private void handleMkcol(OutputStream out, String path) throws IOException {
            File dir = new File("." + path);
            if (dir.mkdir()) {
                sendResponse(out, "HTTP/1.1 201 Created", "Directory created");
            } else {
                sendResponse(out, "HTTP/1.1 409 Conflict", "Directory already exists or invalid path");
            }
        }

        public boolean detect_recursive_isSymbolicLink=false;
        private void handleDelete(OutputStream out, String path) throws IOException {
            if ( !isWindows() ){
                sendResponse(out, "HTTP/1.1 403 Forbidden - Delete not implemented in this S.O", "Delete not implemented in this S.O");
                return;
            }
            detect_recursive_isSymbolicLink=false;
            File file = new File("." + path);

            // Verificar se o recurso existe
            if (!file.exists()) {
                sendResponse(out, "HTTP/1.1 404 Not Found", "Resource not found");
                return;
            }

            // Verificar se é um symbolic link
            if (isSymbolicLink(file)) {
                sendResponse(out, "HTTP/1.1 403 Forbidden - Deletion of symbolic links is not allowed", "Deletion of symbolic links is not allowed");
                return;
            }

            // Excluir recursivamente (se for um diretório)
            if (file.isDirectory()) {
                if (!deleteDirectory(file)) {
                    if ( detect_recursive_isSymbolicLink ){
                        sendResponse(out, "HTTP/1.1 403 Forbidden - Deletion of symbolic links is not allowed", "Deletion of symbolic links is not allowed");
                        return;                        
                    }
                    sendResponse(out, "HTTP/1.1 500 Internal Server Error", "Failed to delete directory");
                    return;
                }
            } else {
                // Excluir arquivo
                if (!file.delete()) {
                    if ( detect_recursive_isSymbolicLink ){
                        sendResponse(out, "HTTP/1.1 403 Forbidden - Deletion of symbolic links is not allowed", "Deletion of symbolic links is not allowed");
                        return;                        
                    }
                    sendResponse(out, "HTTP/1.1 500 Internal Server Error", "Failed to delete file");
                    return;
                }
            }

            // Resposta de sucesso
            sendResponse(out, "HTTP/1.1 204 No Content", "");
        }

        private void handleMove(InputStream in, OutputStream out, String sourcePath, Map<String, String> headers) throws IOException {
            // Extrair o cabeçalho Destination
            String destinationHeader = headers.get("destination");
            if (destinationHeader == null) {
                sendResponse(out, "HTTP/1.1 400 Bad Request", "Destination header is required");
                return;
            }

            // Decodificar o caminho de destino
            URI destinationUri;
            try {
                destinationUri = new URI(destinationHeader);
            } catch (URISyntaxException e) {
                sendResponse(out, "HTTP/1.1 400 Bad Request ? " + e.toString(), "Invalid Destination header");
                return;
            }

            String destinationPath = destinationUri.getPath();
            //String decodedDestinationPath = URLDecoder.decode(destinationPath, "UTF-8");
            String decodedDestinationPath = destinationPath;

            // Verificar se o destino está dentro do diretório raiz do servidor
            File sourceFile = new File("." + sourcePath);
            File destinationFile = new File("." + decodedDestinationPath);

            if ( !destinationFile.getCanonicalPath().startsWith(new File(".").getCanonicalPath()) ){                
                sendResponse(out, "HTTP/1.1 403 Forbidden - Destination is outside the server root directory", "Destination is outside the server root directory");
                return;
            }

            // Verificar symbolic links
            if (isSymbolicLink(sourceFile) || isSymbolicLink(destinationFile)) {
                sendResponse(out, "HTTP/1.1 403 Forbidden - Moving symbolic links is not allowed", "Moving symbolic links is not allowed");
                return;
            }

            // Verificar se o recurso de origem existe
            if (!sourceFile.exists()) {
                sendResponse(out, "HTTP/1.1 404 Not Found ? " + sourceFile.getAbsolutePath(), "Source resource not found");
                return;
            }

            // Verificar se o recurso de destino já existe
            boolean overwrite = headers.getOrDefault("overwrite", "T").equalsIgnoreCase("T");
            if (destinationFile.exists() && !overwrite) {
                sendResponse(out, "HTTP/1.1 412 Precondition Failed - Destination resource already exists and overwrite is disabled", "Destination resource already exists and overwrite is disabled");
                return;
            }

            // Verificar se o diretório pai do destino existe
            File parentDir = destinationFile.getParentFile();
            if (parentDir != null && !parentDir.exists()) {
                sendResponse(out, "HTTP/1.1 409 Conflict - Parent directory of destination does not exist", "Parent directory of destination does not exist");
                return;
            }

            // Mover o recurso
            try {
                boolean success = sourceFile.renameTo(destinationFile);
                if (!success) {
                    sendResponse(out, "HTTP/1.1 500 Internal Server Error - Failed to move resource", "Failed to move resource");
                    return;
                }

                // Resposta de sucesso
                if (destinationFile.exists()) {
                    sendResponse(out, "HTTP/1.1 204 No Content", ""); // Recurso sobrescrito
                } else {
                    sendResponse(out, "HTTP/1.1 201 Created", "Resource moved"); // Recurso criado
                }
            } catch (SecurityException e) {
                sendResponse(out, "HTTP/1.1 403 Forbidden - Permission denied", "Permission denied");
            }
        }

        private boolean isSymbolicLink(File f)throws IOException {
            java.nio.file.Path ab_path=f.toPath().toAbsolutePath();
            java.nio.file.Path parent_path=ab_path.getParent();
            java.nio.file.Path real_path=null;
            int n=0;
            n=1;
            if ( Files.isSymbolicLink(f.toPath()) ){
                n=2;
                return true;
            }
            n=3;
            try{
                real_path=ab_path.toRealPath();
            }catch(Exception e){
                return false;
            }
            if ( !isWindows() ){
                n=4;
                return false;
            }
            n=5;
            if ( !ab_path.toString().toUpperCase().equals(parent_path.toString().toUpperCase()) ){
                n=6;
                if ( real_path.toString().toUpperCase().equals( (parent_path.toRealPath().toString()+"\\"+f.getName()).toUpperCase() )){
                    n=7;
                    return false;
                }
            }
            n=8;
            if ( !ab_path.toString().toUpperCase().equals(real_path.toString().toUpperCase()) ){
                n=9;
                return true;
            }
            return false;
        }

        /**
         * Exclui um diretório e seu conteúdo recursivamente.
         * Retorna false se encontrar um symbolic link ou falhar ao excluir.
         */
        private boolean deleteDirectory(File directory) throws IOException {
            File[] files = directory.listFiles();
            if (files == null) {
                return false; // Falha ao listar o conteúdo do diretório
            }

            for (File file : files) {
                // Verificar se é um symbolic link
                if (isSymbolicLink(file)) {
                    detect_recursive_isSymbolicLink=true;
                    return false; // Não permite exclusão se houver symbolic links
                }

                // Excluir recursivamente
                if (file.isDirectory()) {
                    if (!deleteDirectory(file)) {
                        return false; // Falha ao excluir subdiretório
                    }
                } else {
                    if (!file.delete()) {
                        return false; // Falha ao excluir arquivo
                    }
                }
            }

            // Excluir o diretório principal
            return directory.delete();
        }

        private void handlePropfind(InputStream in, OutputStream out, String path, Map<String, String> headers) throws IOException {
            File file = new File("." + path);
            if (!file.exists()) {
                sendResponse(out, "HTTP/1.1 404 Not Found - " + file.getAbsolutePath(), "Resource not found");
                return;
            }

            // Verificar profundidade (Depth header)
            String depth = headers.getOrDefault("depth", "0");
            if (!depth.equals("0") && !depth.equals("1") && !depth.equals("infinity")) {
                sendResponse(out, "HTTP/1.1 400 Bad Request", "Invalid Depth header");
                return;
            }

            // Gerar resposta XML
            StringBuilder xmlResponse = new StringBuilder();
            xmlResponse.append("<?xml version=\"1.0\" encoding=\"utf-8\"?>\n")
                    .append("<D:multistatus xmlns:D=\"DAV:\">\n");

            // Adicionar propriedades do recurso solicitado
            appendResourceProperties(xmlResponse, file, path);

            // Se for um diretório, listar seus membros
            if (file.isDirectory() && (depth.equals("1") || depth.equals("infinity"))) {
                File[] members = file.listFiles();
                if (members != null) {
                    for (File member : members) {
                        String memberPath = path + (path.endsWith("/") ? "" : "/") + member.getName();
                        appendResourceProperties(xmlResponse, member, memberPath);
                    }
                }
            }

            xmlResponse.append("</D:multistatus>");

            // Enviar resposta
            sendResponse(out, "HTTP/1.1 207 Multi-Status", xmlResponse.toString(), "Content-Type: application/xml; charset=utf-8");
        }

        private void appendResourceProperties(StringBuilder xmlResponse, File file, String path) {
            // espaço %20
            // +      %2B
            // nao sei explicar porque funciona + mudar para %20 sendo que %20 é espaço e nao +
            // esse é um caso de endecodeURIComponent ?
            String escapedPath=encodeUrl(path).replaceAll("\\+", "%20").replaceAll("%2F", "/");

            xmlResponse.append("  <D:response>\n")
                    .append("    <D:href>").append(escapedPath).append("</D:href>\n")
                    .append("    <D:propstat>\n")
                    .append("      <D:prop>\n")
                    .append("        <D:getlastmodified>").append(new Date(file.lastModified())).append("</D:getlastmodified>\n")
                    .append("        <D:getcontentlength>").append(file.length()).append("</D:getcontentlength>\n")
                    .append("        <D:resourcetype>")
                    .append(file.isDirectory() ? "<D:collection/>" : "")
                    .append("</D:resourcetype>\n")
                    .append("      </D:prop>\n")
                    .append("      <D:status>HTTP/1.1 200 OK</D:status>\n")
                    .append("    </D:propstat>\n")
                    .append("  </D:response>\n");
        }

        private void handleOptions(OutputStream out) throws IOException {
            // Lista de métodos suportados
            String allowedMethods = "OPTIONS, GET, PUT, MKCOL, DELETE, PROPFIND";
            // Nível de conformidade WebDAV (1 para básico, 2 para avançado)
            String davHeader = "1";

            // Resposta
            String response = "HTTP/1.1 200 OK\r\n" +
                    "Allow: " + allowedMethods + "\r\n" +
                    "DAV: " + davHeader + "\r\n" +
                    "Content-Length: 0\r\n" +
                    "\r\n";
            out.write(response.getBytes());
        }

        private void sendResponse(OutputStream out, String status, String body) throws IOException {
            sendResponse(out, status, body, null);
        }

        private void sendResponse(OutputStream out, String status, String body, String additionalHeader) throws IOException {
            String response = status + "\r\n" +
                (additionalHeader == null || !additionalHeader.contains("Content-Type: ") ? "Content-Type: text/plain\r\n" : "") +
                "Content-Length: " + body.getBytes().length + "\r\n" +
                "Access-Control-Allow-Origin: *\r\n" +
                "X-Frame-Options: SAMEORIGIN\r\n" +                    
                (additionalHeader != null ? additionalHeader + "\r\n" : "") +
                "\r\n" +
                body;
            out.write(response.getBytes());
        }
    }
}

@SuppressWarnings({"unchecked", "deprecation"})
class Redis extends Util{
    File f_redis=null;
    String [] path=null;
    String sep="\\";
    Long redisSeconds=60L;
    String redisAll=null;
    String redisLike=null;
    Thread t=null;
    ArrayList<String> del_list=new ArrayList<String>();
    public Redis(String redisDir, Long redisSeconds, String redisAll, String redisLike){        
        if ( redisDir != null && !redisDir.equals("") ){
            // sync in file Redis
            this.redisSeconds=redisSeconds;
            this.redisAll=redisAll;
            this.redisLike=redisLike;
            f_redis=new File(redisDir);
            if ( !f_redis.exists() || !f_redis.isDirectory() )
                erroFatal("Esse caminho não existe ou não é um diretório: " + redisDir);
            File [] files=f_redis.listFiles();
            for(int i=0;i<files.length;i++){
                if ( !files[i].isFile() )
                    erroFatal("Esse, esse objeto não é um arquivo: " + redisDir);                        
                String key=files[i].getName();
                String value=lendo_arquivo(files[i].getAbsolutePath());
                redis_map[0].put(key, value);
                redis_file[0].put(key, value);
            }
            if ( f_redis.getAbsolutePath().contains("/") )
                sep="/";
            path=new String[]{f_redis.getAbsolutePath()+sep};
            t=new Thread(){
                public void run(){
                    final long _redisSeconds=redisSeconds;
                    try{
                        while(true){
                            while(del_list.size()>0){
                                if ( new File(path[0]+del_list.get(0)).exists() )
                                    new File(path[0]+del_list.get(0)).delete();
                                del_list.remove(0);
                            }
                            try{Thread.sleep(_redisSeconds);}catch(Exception e){} 
                            Object [] objs=redis_map[0].keySet().toArray();
                            for(int i=0;i<objs.length;i++){
                                String key=(String)objs[i];
                                String value=null;
                                if ( !redis_file[0].containsKey(key) ){
                                    value=(String)redis_map[0].get(key);
                                }else{
                                    value=(String)redis_map[0].get(key);
                                    if ( !value.equals( (String)redis_file[0].get(key) ) )
                                        redis_file[0].put(key, value);
                                    else
                                        value=null;
                                }
                                if ( value != null ){
                                    redis_file[0].put(key, value);
                                    BufferedWriter out = new BufferedWriter(new FileWriter(new File(path[0]+key), false));
                                    out.write(value);
                                    out.flush();
                                    out.close();                                
                                }
                            }
                        }
                    }catch(Exception e){
                        System.err.println("Erro thread: " + e.toString());
                        System.exit(1);
                    }
                }
            };
            t.start();
        }
    }
    public void add(String key, String value){ // ADD
        redis_map[0].put(key, value);
    }
    public String get(String key){ // GET
        if( redis_map[0].containsKey(key) )
            return (String)redis_map[0].get(key);
        return "null";
    }
    public int addConcorrenteSign(String id, Boolean sign, String key, String value){ // ADDCS
        if ( sign || !redis_sign.containsKey(key) ){
            redis_sign.put(key, id);                        
        }else{
            if( !((String)redis_sign.get(key)).equals(id) )
                return 1;            
        }
        redis_map[0].put(key, value);
        return 0;
    }
    public void del(String [] keys){
        for ( int i=0;i<keys.length;i++ ){
            if( redis_map[0].containsKey(keys[i]) )
                redis_map[0].remove(keys[i]);
            if( redis_file[0].containsKey(keys[i]) )
                redis_file[0].remove(keys[i]);
            del_list.add(keys[i]);
        }
    }
    public String getAll(){
        return getLike(null);
    }
    public String getLike(String like){
        StringBuilder sb=new StringBuilder();
        Object [] objs=redis_map[0].keySet().toArray();
        if ( objs.length > 0 && like == null )
            sb.append("keys:\n");
        for(int i=0;i<objs.length;i++){
            String key=(String)objs[i];
            if ( like == null || key.startsWith(like) ){
                if ( key.startsWith("secret-") )
                    continue;
                sb.append(key);
                sb.append(" ");
                sb.append(redis_map[0].get(key));
                sb.append("\n");
            }
        }
        if ( like == null ){
            objs=redis_sign.keySet().toArray();
            if ( objs.length > 0 )
                sb.append("signs:\n");
            for(int i=0;i<objs.length;i++){
                String key=(String)objs[i];
                if ( key.startsWith("secret-") )
                    continue;
                sb.append(key);
                sb.append(" ");
                sb.append(redis_sign.get(key));
                sb.append("\n");
            }        
        }
        String retorno=sb.toString();
        if ( retorno.equals("") )
            return "null";
        return retorno;
    }
}
/*
    Formato:
    A = Ace
    K = King
    Q = Queen
    J = Jack
    T = Ten
    Naipes:
    H = Copas (Hearts)
    D = Ouros (Diamonds)
    C = Paus (Clubs)
    S = Espadas (Spades)    
*/
// System.out.println( new PokerCalculator().getProbabilidade(new String[]{"AH", "KD"}, new String[]{"", "", "", "", ""}) ); // Ás de Copas e Rei de Ouros
class PokerCalculator{
    private final String[] RANKS = {"2","3","4","5","6","7","8","9","T","J","Q","K","A"}; // T = Ten // J = Jack // Q = Queen // K = King // A = Ace 
    private final String[] SUITS = {"C","D","H","S"}; // C = Paus (Clubs) // D = Ouros (Diamonds) // H = Copas (Hearts) // S = Espadas (Spades) 

    class Card {
        String r, s;
        Card(String r, String s) { this.r = r; this.s = s; }
        public String toString() { return r + s; }
    }

    class Deck{
        List<Card> cards = new ArrayList<>();
        Deck() {
            for (String r : RANKS)
                for (String s : SUITS)
                    cards.add(new Card(r, s));
        }
        void remove(Card c) {
            cards.removeIf(x -> x.r.equals(c.r) && x.s.equals(c.s));
        }
        Card draw(Random rnd) {
            return cards.remove(rnd.nextInt(cards.size()));
        }
    }

    // Métodos de avaliar mão (simples —  usa ranking numérico)
    private int evaluateHand(List<Card> hand) {
        // Implementação reduzida — usa apenas ranking por maior carta
        // Para cálculo real, substitua por um algoritmo completo (ex: Cactus Kev)
        List<Integer> ranks = new ArrayList<>();
        for (Card c : hand) ranks.add(Arrays.asList(RANKS).indexOf(c.r));
        Collections.sort(ranks);
        return ranks.get(ranks.size()-1); // maior carta
    }

    private double simulate(String[] yourCards, String[] communityCards, int iterations) {
        Random rnd = new Random();
        int wins = 0;

        for (int i = 0; i < iterations; i++) {
            Deck deck = new Deck();

            // suas cartas
            Card c1 = new Card("" + yourCards[0].charAt(0), "" + yourCards[0].charAt(1));
            Card c2 = new Card("" + yourCards[1].charAt(0), "" + yourCards[1].charAt(1));
            deck.remove(c1); deck.remove(c2);

            // cartas já abertas
            List<Card> comm = new ArrayList<>();
            for (String s : communityCards) {
                if (s != null && !s.isEmpty()) {
                    Card ct = new Card("" + s.charAt(0), "" + s.charAt(1));
                    comm.add(ct);
                    deck.remove(ct);
                }
            }

            // completa a mesa (até 5 cartas)
            while (comm.size() < 5)
                comm.add(deck.draw(rnd));

            // cartas do oponente
            Card o1 = deck.draw(rnd);
            Card o2 = deck.draw(rnd);

            // monta mãos finais
            List<Card> yourFinal = new ArrayList<>();
            yourFinal.add(c1); yourFinal.add(c2); yourFinal.addAll(comm);

            List<Card> oppFinal = new ArrayList<>();
            oppFinal.add(o1); oppFinal.add(o2); oppFinal.addAll(comm);

            int yourRank = evaluateHand(yourFinal);
            int oppRank  = evaluateHand(oppFinal);

            if (yourRank > oppRank) wins++;
        }

        return wins / (double) iterations;
    }
    public double getProbabilidade(String[] yourCards, String[] community){
        return simulate(yourCards, community, 20000) * 100;
    }
}

@SuppressWarnings({"unchecked", "deprecation"})
class Util{    
    public String erroSequenciaIlegal="Erro, sequencia ilegal!";
    
    // aux base64
    int V_0b00000011=3; // 0b00000011 (3)
    int V_0b0000000011=3; // 0b0000000011 (3)
    int V_0b0000001111=15; // 0b0000001111 (15)
    int V_0b000000001111=15; // 0b000000001111 (15)
    int V_0b000000111111=63; // 0b000000111111 (63)
    int V_0b11111100=252; // 0b11111100 (252)
    int V_0b1111110000=1008; // 0b1111110000 (1008)
    int V_0b1111111100=1020; // 0b1111111100 (1020)
    int V_0b111111000000=4032; // 0b111111000000 (4032)
    int V_0b111111110000=4080; // 0b111111110000 (4080)    
    
    public String [] check_util_list=new String[]{
        "D:/ProgramFiles/iso/manual.txt,https://github.com/ywanes/utility_y/blob/master/y/utils_exe/iso/manual.txt,e7574cf7b22bf7ffa180921f0706a43e",
        "D:/ProgramFiles/iso/efisys.bin,https://github.com/ywanes/utility_y/blob/master/y/utils_exe/iso/efisys.bin,65602bb5e3c7c39a88a973c73e896765",
        "D:/ProgramFiles/iso/etfsboot.com,https://github.com/ywanes/utility_y/blob/master/y/utils_exe/iso/etfsboot.com,d4befebf3cef129ac087422b9e912788",
        "D:/ProgramFiles/iso/oscdimg.exe,https://github.com/ywanes/utility_y/blob/master/y/utils_exe/iso/oscdimg.exe,5107d2b7f13da005e5ea6d5b805be7fe",
        "D:/ProgramFiles/7z/7z.exe,https://github.com/ywanes/utility_y/blob/master/y/utils_exe/7z/7z.exe,b6d5860f368b28caa9dd14a51666a5cd",
        "D:/ProgramFiles/7z/7z.dll,https://github.com/ywanes/utility_y/blob/master/y/utils_exe/7z/7z.dll,c4aabd70dc28c9516809b775a30fdd3f",
    };
    
    
    HashMap cache_duolingo_hashmap=new HashMap();
    StringBuilder cache_duolingo_sb=new StringBuilder();

    public boolean check_util(String a){
        try{
            if ( a.trim().length() == 0 )
                erroFatal("Erro interno 3242");
            for ( int i=0;i<check_util_list.length;i++ ){
                String [] partes=check_util_list[i].split(",");
                if ( partes.length != 3 )
                    erroFatal("Erro interno 3243");
                String path=partes[0];
                String host=partes[1].replace("https://github.com/", "https://raw.githubusercontent.com/").replace("/blob/", "/refs/heads/");
                String hash=partes[2];
                if ( !new File("D:/ProgramFiles").exists() )
                    path=path.replace("D:/ProgramFiles", "C:/ProgramFiles");
                if ( !path.equals(a) )
                    continue;
                Y y=new Y();
                if ( new File(path).exists() ){
                    if ( new File(path).isDirectory() )
                        erroFatal("Erro fatal, esse caminho não pode ser diretorio => " + path);
                    else{
                        String _hash=digest("MD5", path);
                        if ( _hash.equals(hash) )
                            return true;
                        else
                            erroFatal("Arquivo corrompiado: " + path + " hash encontrado: " + _hash + ", hash esperado: " + hash);
                    }
                }
                if ( !y.preparaPath(path, true, 0) )
                    erroFatal("Não foi possível criar as pastas de preparação do arquivo a seguir: " + path);
                y.curl(new FileOutputStream(path), "", "GET", false, false, host, null, null, null, null, null, "MD5");
                if ( !new File(path).exists() )
                    erroFatal("Não foi possível gravar o arquivo " + path);
                if ( !y.curl_hash.equals(hash) )
                    erroFatal("Arquivo baixado corrompiado: " + path + " hash baixado: " + y.curl_hash + ", hash esperado: " + hash + ", host: " + host);
                return true;
            }
        }catch(Exception e){
            erroFatal(e);
        }        
        return false;
    }
    
    public char[] encodeHex(byte[] data) {
        char[] toDigits = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};
        int l = data.length;
        char[] out = new char[l << 1];
        for (int i = 0, j = 0; i < l; i++) {
            out[j++] = toDigits[(0xF0 & data[i]) >>> 4];
            out[j++] = toDigits[0x0F & data[i]];
        }
        return out;
    }
    
    public void xor(int parm){
        while(parm < 0)
            parm+=256;
        while(parm >= 256)
            parm-=256;        
        try{
            InputStream inputStream_pipe=System.in;
            byte[] buf = new byte[BUFFER_SIZE];
            int len=0;
            while( (len=inputStream_pipe.read(buf,0,BUFFER_SIZE)) > 0 ){
                for( int i=0;i<len;i++ ){
                    int z=buf[i];
                    if ( z < 0 )
                        z+=256;
                    buf[i]=(byte)(z^parm);
                }
                System.out.write(buf, 0, len);
            }
            System.out.flush();
            System.out.close();
        }catch(Exception e){
            System.err.println("Erro, "+e.toString());
        }
    }
    
    public void xor_ofuscation(int a, String b){
        try{
            String [] tags=b.split(",");
            int c=tags.length;
            InputStream inputStream_pipe=System.in;
            byte[] buf = new byte[BUFFER_SIZE];
            int len=0;
            int t=0;
            while( (len=inputStream_pipe.read(buf,0,BUFFER_SIZE)) > 0 ){
                for( int i=0;i<len;i++ ){
                    int z=buf[i];
                    if ( z < 0 )
                        z+=256;
                    buf[i]=(byte)( z^Integer.parseInt(tags[(i+a+t)%c]) );
                }
                System.out.write(buf, 0, len);
                t+=len;
            }
            
            System.out.flush();
            System.out.close();
        }catch(Exception e){
            System.err.println("Erro, "+e.toString());
        }
    }
    
    public String digest(String tipo, String caminho_opcional){        
        try {
            if ( caminho_opcional != null )
                readBytes(new File(caminho_opcional));
            MessageDigest digest=MessageDigest.getInstance(tipo);            
            byte[] buf = new byte[BUFFER_SIZE];            
            int len;
            while( (len=readBytes(buf)) > -1 )
                digest.update(buf, 0, len);
            closeBytes();            
            return new String(encodeHex(digest.digest()));            
        } catch (Exception ex) {
            System.err.println("Erro: "+ex.toString());
            System.exit(1);
        }
        return null;
    }

    public String digest_text(String txt,String tipo){
        try {
            byte[] bytesOfMessage = txt.getBytes("UTF-8");
            MessageDigest md = MessageDigest.getInstance(tipo);            
            return new String(encodeHex(md.digest(bytesOfMessage)));                
        } catch (Exception e) {
            System.out.println(e.toString());
        }
        return null;
    }
        
    public void chmod_777(String path){
        try{
            Runtime.getRuntime().exec(new String[]{"chmod", "777", path});        
        }catch(Exception e){}
    }

    // faz arredondamento e tira notação cientifica    
    // de   5.8000000000000003E-2
    // para 0.058
    // de 0.99409999999999998
    // para 0.9941
    public String arredondamentoNumber(String txt) {        
        
        boolean analise=false;
        if ( txt.equals("6.7100000000000007E-2") ) // 0.060
            analise=true;
        
        
        int flutuacao=0;
        String tmp="";
        String a="";
        String b="";
        boolean achou=false;
        
        if ( txt.contains("E") ){
            tmp=txt.split("E")[1];
            txt=txt.split("E")[0];
            flutuacao=Integer.parseInt(tmp);
        }
        
        a=txt.split("\\.")[0];
        b=txt.split("\\.")[1];
        
        if ( b.length() >= 15 ){
            // arredondamento ...999X
            // de 0.99409999999999998
            // para 0.9941
            if ( 
                b.substring(b.length()-2,b.length()-1).equals("9") 
                && b.substring(b.length()-3,b.length()-2).equals("9") 
                && b.substring(b.length()-4,b.length()-3).equals("9") 
            ){
                for( int i=b.length()-5;i>=0;i-- ){
                    if ( ! b.substring(i,i+1).equals("9") ){
                        b=b.substring(0,i)+(Integer.parseInt(b.substring(i,i+1))+1);
                        achou=true;
                        break;
                    }
                }
                if ( ! achou ){
                    b="0";
                    a=(Integer.parseInt(a)+1)+"";
                }
            }else{
                // convert 058000000000000003 em 058
                if ( 
                    b.substring(b.length()-2,b.length()-1).equals("0") 
                    && b.substring(b.length()-3,b.length()-2).equals("0") 
                    && b.substring(b.length()-4,b.length()-3).equals("0") 
                ){
                    for( int i=b.length()-5;i>=0;i-- ){
                        if ( ! b.substring(i,i+1).equals("0") ){
                            b=b.substring(0,i)+b.substring(i,i+1);
                            achou=true;
                            break;
                        }
                    }
                }
                if ( ! achou ){
                    b="0";
                }
            }
        }
                
        while(flutuacao>0){
            if ( b.length() == 0 ){
                a+="0";
            }else{
                a+=b.substring(0,1);
                b=b.substring(1);
            }
            flutuacao--;
        }
        while(flutuacao<0){
            b=a+b;
            a="0";
            flutuacao++;
        }    
        if ( b.equals("0") )
            return a;
        return a+"."+b;
    }
    
    public Double arredondamentoDouble_Double(Double valor, int n_arredondamento, boolean trunca) {
        java.math.RoundingMode roundingMode=java.math.RoundingMode.HALF_UP;
        if ( trunca )
            roundingMode=java.math.RoundingMode.DOWN;
        BigDecimal bd = new BigDecimal(Double.toString(valor));
        bd = bd.setScale(n_arredondamento, roundingMode);
        return bd.doubleValue();
    }

    public String arredondamentoDouble(Double valor, int n_arredondamento, boolean trunca) {
        java.math.RoundingMode roundingMode = java.math.RoundingMode.HALF_UP;
        if (trunca)
            roundingMode = java.math.RoundingMode.DOWN;
        java.math.BigDecimal bd = new java.math.BigDecimal(Double.toString(valor));
        bd = bd.setScale(n_arredondamento, roundingMode);
        return String.format(
            java.util.Locale.US, 
            "%." + n_arredondamento + "f", 
            bd.doubleValue()
        );
    }
    
    public void format_show_ip(String a, String b){
        if ( b != null ){
            String s1="                                                                ".substring(0, 40-a.length());
            String s2=" ";
            if(b.equals("NOK"))
                s2="";
            System.out.println("   "+ a + s1 + " -> ping " + s2 + b);
        }else
            System.out.println("   "+ a );
    }
    
    public String ping(String a, int timeout){
        try{
            InetAddress address = InetAddress.getByName(a);
            if ( address.isReachable(timeout) ){
                return "OK";
            }
        } catch (Exception e){
            //System.out.println("Error: " + e.toString());
        }        
        return "NOK";
    }
    
    public String ipsString(){
        // return fake test:
        //if ( 1 == 1 ) return "Realtek PCIe GbE Family Controller;;192.168.15.11;2804:1b2:1002:3473:921:b978:fa99:9cd;2804:1b2:1002:3473:2119:9128:824e:f2d5;fe80::2ff8:c289:c063:8686";
        
        String result="";
        String result2="";
        boolean has_items=false;
        try{
            int count_address_in_interface=0;
            java.util.Enumeration<java.net.NetworkInterface> interfaces = java.net.NetworkInterface.getNetworkInterfaces();
            while (interfaces.hasMoreElements()) {
                java.net.NetworkInterface iface = interfaces.nextElement();
                if (iface.isLoopback() || !iface.isUp())
                    continue;    
                has_items=false;
                result2=iface.getDisplayName()+";;";
                count_address_in_interface=0;
                String [] filter=new String[]{".", ":"};
                for(int i=0;i<filter.length;i++){
                    java.util.Enumeration<java.net.InetAddress> addresses = iface.getInetAddresses();                    
                    while(addresses.hasMoreElements()){
                        java.net.InetAddress addr = addresses.nextElement();
                        String ip=addr.getHostAddress().contains("%")?addr.getHostAddress().split("%")[0]:addr.getHostAddress();
                        for ( int j=0;j<10;j++ )
                            ip=ip.replace(":0:","::").replace(":::","::");
                        if (!ip.contains(filter[i]))
                            continue;
                        if ( ip.startsWith("fd") )
                                continue;
                        if ( ip.startsWith("fe") )
                                continue;                        
                        if ( count_address_in_interface > 0 )
                            result2+=";";
                        result2+=ip;
                        has_items=true;
                        count_address_in_interface++;
                    }
                } 
                if ( has_items ){
                    if ( !result.equals("") )
                        result+=";;;";
                    result+=result2;
                }
            }
        }catch(Exception e){
            erro_amigavel_exception(e);
        }
        result=add_principais(result);
        return result;
    }
    
    public String [] ips(boolean ping, int timeout, boolean list, boolean printOn){
        String ipv4=null;
        String ipv6=null;
        String ipv6_nat=null;
        String ipv6_my=null;
        String ipv6_other=null;
        
        int count=0;
        String ips_string=ipsString();
        String [] tuplas = ips_string.split(";;;");            
        for ( String tupla : tuplas ){
            String [] tupla_partes=tupla.split(";;");
            if ( tupla_partes.length < 2 ) // anti pani
                continue;            
            String iface=tupla_partes[0];
            String [] ips=tupla_partes[1].split(";");
            boolean first=true;
            for ( String ip : ips ){
                if ( list && ++count == 1 )
                    if ( printOn )
                        System.out.println("a=$(\ncat << 'EOF'");
                if ( first ){
                    first=false;
                    if ( printOn )
                        System.out.println(iface+":");
                }
                if ( ip.contains(".") ){ // ipv4
                    if ( ipv4 == null )
                        ipv4=ip;
                }else{ 
                    if ( ip.contains(":") ){ // ipv6
                        if ( ip.startsWith("fe") || ip.startsWith("fd") ){
                            if ( ipv6_nat == null )
                                ipv6_nat=ip;
                        }else{
                            if ( ip.contains("::") ){
                                if ( ipv6_other == null )
                                    ipv6_my=ip;
                            }else{
                                ipv6_other=ip;
                            }
                        }
                    }else{
                        // desconhecido
                    }
                }
                String ping_=null;
                if ( ping )
                    ping_=ping(ip, timeout);
                if ( printOn )
                    format_show_ip(ip, ping_);
            }
        }
        if( list && count > 0 )
            if ( printOn )
                System.out.println("EOF\n)\necho \"$a\" | y ping list");

        ipv6=ipv6_my;
        if ( ipv6 == null )
            ipv6=ipv6_other;        
        if ( ipv6 == null )
            ipv6=ipv6_nat;
        return new String[]{ipv4, ipv6};
    }   
        
    public String get_ip(){
        String ip=null;
        String [] ipv4_ipv6=ips(true, 15, false, false);
        if ( ipv4_ipv6[1] != null )
            return ipv4_ipv6[1];
        return ipv4_ipv6[0];
    }
    
    public ArrayList<String> getListaIPs()
    {     
        ArrayList<String> lista=new ArrayList<String>();
        ArrayList<String> lista2=new ArrayList<String>();

        try {
            java.util.Enumeration<java.net.NetworkInterface> interfaces = java.net.NetworkInterface.getNetworkInterfaces();
            while (interfaces.hasMoreElements()) {
                java.net.NetworkInterface iface = interfaces.nextElement();
                if (iface.isLoopback() || !iface.isUp())
                    continue;
                java.util.Enumeration<InetAddress> addresses = iface.getInetAddresses();
                while(addresses.hasMoreElements()) {
                    InetAddress addr = addresses.nextElement();
                    if ( addr.getHostAddress().startsWith("192.168.0.") || addr.getHostAddress().startsWith("192.168.1.") )
                        lista.add(addr.getHostAddress());                       
                    else
                        lista2.add(addr.getHostAddress());                       
                }
            }
        } catch (java.net.SocketException e) {
            throw new RuntimeException(e);
        } 
        lista.addAll(lista2);        
        return lista;
    }
    
    public Long getSecondsByNtp(String url) throws Exception{
        if ( url == null || url.equals("_") )
            url="pool.ntp.org";
        byte[] buffer = new byte[48];
        java.net.DatagramPacket packet = new java.net.DatagramPacket(buffer, buffer.length, java.net.InetAddress.getByName(url), 123);
        buffer[0] = 0x1B;
        java.net.DatagramSocket socket = new java.net.DatagramSocket();
        socket.send(packet);
        socket.receive(packet);
        socket.close();
        long seconds = 0;
        for (int i = 0; i < 4; i++)
            seconds = (seconds << 8) | (buffer[40 + i] & 0xFF);
        seconds-=2208988800L;
        return seconds;
    }
    
    public String get_mixer(String like){
        if ( !isWindows() )
            return "comando só habilitado para windows!";
        String s=getMixerGuidWindows();
        String [] partes=s.split("\n");
        for ( int i=0;i<partes.length;i++ ){
            if ( partes[i].contains(like) )
                return partes[i].split("#")[1];
        }
        return null;        
    }    
    public void ocr(byte [] input, OutputStream os) throws Exception{
        String s=runtimeExec(null, new String[]{"D:\\ProgramFiles\\Tesseract-OCR\\tesseract.exe", "-", "-"}, null, input, null);
        if ( !runtimeExecError.equals("") && !runtimeExecError.contains("Detected") && !runtimeExecError.contains("Estimating") )
            erroFatal("Erro: " + runtimeExecError);
        os.write(s.getBytes());
    }
    public String [] ocr_getNamesDota() throws Exception{
        byte [] tmp=robotGetImgScreenBmpNamesDotaBytes();
        ByteArrayOutputStream baos=new ByteArrayOutputStream();
        ocr(tmp, baos);
        String s=baos.toString().trim();
        int limit=1000;
        while( s.contains("\n\n") )
            s=s.replaceAll("\n\n", "\n");
        String [] partes=s.split("\n");
        if ( partes.length != 10 )
            return null;
        return partes;
    }
    public void bmp_editing(byte [] a, int[] freeze, int rgb, int len_x_check, int len_y_check){
        int c18=1;
        int c19=256;
        int c20=256*256;
        int c21=256*256*256;
        int c22=1;
        int c23=256;
        int c24=256*256;
        int c25=256*256*256;
        if ( a.length < 26 )
            erroFatal("length invalido para bmp");
        int len_x=
                c18 * (a[18]<0?(a[18]+255):a[18])+
                c19 * (a[19]<0?(a[19]+255):a[19])+
                c20 * (a[20]<0?(a[20]+255):a[20])+
                c21 * (a[21]<0?(a[21]+255):a[21]);  
        int len_y=
                c22 * (a[22]<0?(a[22]+255):a[22])+
                c23 * (a[23]<0?(a[23]+255):a[23])+
                c24 * (a[24]<0?(a[24]+255):a[24])+
                c25 * (a[25]<0?(a[25]+255):a[25]);  
        len_x++;//nem sei o porque disso!
        if ( len_x != len_x_check || len_y != len_y_check )
            erroFatal("Erro, resolução não esperada! " + len_x + "x" + len_y + " diferente de " + len_x_check + "x" + len_y_check);
        int c=54;
        for ( int y=0;y<len_y;y++ ){
            for ( int x=0;x<len_x;x++ ){
                for ( int z=0;z<3;z++ ){
                    boolean skip=false;
                    for ( int i=0;i<freeze.length;i+=4 ){
                        if ( x >= freeze[0+i] && x < freeze[2+i] && y >= freeze[1+i] && y < freeze[3+i] ){
                            skip=true;
                            break;
                        }
                    }
                    if ( !skip )
                        a[c]=(byte)rgb;
                    c++;
                }
            }
        }
    }    
    public String format_float(Float a, int precisao){
        // 0.07000001 -> 0.07
        BigDecimal bd = new BigDecimal(a).setScale(precisao, java.math.RoundingMode.HALF_EVEN);
        return bd.doubleValue()+"";
    }
    public static Redis redis=null;
    public static HashMap redis_sign=new HashMap();
    public final static HashMap [] redis_map=new HashMap[]{new HashMap()};
    public final static HashMap [] redis_file=new HashMap[]{new HashMap()};
    public static String getListaCompleta_cache=null;
    public static long getListaCompleta_last=0;
    public String getListaCompleta(File a, long nivel){
        StringBuilder sb=new StringBuilder();
        long now=epoch(null);
        if ( nivel == 0 && getListaCompleta_cache != null && getListaCompleta_last > now-60 )
            return getListaCompleta_cache;
        if ( a.isFile() ){
            sb.append(a.getAbsolutePath());
            sb.append("\n");
        }else{
            if ( a.isDirectory() ){
                sb.append(a.getAbsolutePath());
                sb.append("\n");
                File [] f_=a.listFiles();
                for ( int i=0;i<f_.length;i++ )
                    sb.append(getListaCompleta(f_[i], nivel+1));
            }
        }
        String retorno=sb.toString().replace("\\","/");
        if ( nivel == 0 ){            
            getListaCompleta_cache=retorno;
            getListaCompleta_last=now;
        }
        return retorno;
    }
    
    public void mostra_array(String [] a){
        mostra_array(a, a.length);
    }
    
    public void mostra_array(String [] a, int len){
        for ( int i=0;i<(len<a.length?len:a.length);i++ )
            System.out.println(i + " -> >>" + a[i] + "<<");        
    }
    
    public void mostra_array(byte [] a){
        mostra_array(a, a.length);
    }
    
    public void mostra_array(byte [] a, int len){
        for ( int i=0;i<(len<a.length?len:a.length);i++ )
            System.out.println(i + " -> >>" + (int)a[i] + "<<");        
    }
    
    public void mostra_array(int [] a){
        mostra_array(a, a.length);
    }

    public void mostra_array(int [] a, int len){
        for ( int i=0;i<(len<a.length?len:a.length);i++ )
            System.out.println(i + " -> >>" + a[i] + "<<");        
    }

    public boolean ends_array(byte [] a, int len, byte [] b){                
        if ( len > a.length || len < b.length || b.length < 1 )
            return false;
        int start=len-b.length;
        for ( int i=start;i<b.length;i++ )
            if ( a[i] != b[i] )
                return false;
        return true;
    }
    
    public String [] array_copy(String [] a){
        String [] a2 = new String[a.length];            
        System.arraycopy(a, 0, a2, 0, a.length);
        return a2;
    }
    
    public String normalizeFieldsJson(String txt, String nivel, String preCamposOpcional){
        /*
        modifica disso
        {
          "response": {
            "players": [
              {
                "profilestate": 1,
                "personaname": "AA",
                "commentpermission": 1
              },
              {
                "profilestate": 2,
                "commentpermission": 2
              }
            ]
          }
        }
        para isso:
        {
          "response": {
            "players": [
              {
                "profilestate": 1,
                "personaname": "AA",
                "commentpermission": 1
              },
              {
                "profilestate": 2,
                "personaname": "",
                "commentpermission": 2
              }
            ]
          }
        }
        
        */
        String [] partes=txt.split("\n");
        boolean tail_inside=false;
        int count_nova_key=0;
        String [] key=new String[0];
        String [] line=new String[0];        
        String [] nova_key=new String[0];        
        String [] nova_line=new String[0];        
        //         "timecreated": 1390075701,
        //         key->timecreated
        //         line->         "timecreated": 1390075701
        
        // pegando ou atualizando novas keys
        if ( preCamposOpcional == null )
            preCamposOpcional="";
        if ( !preCamposOpcional.equals("") )
            nova_key=preCamposOpcional.split(",");
        for ( int i=0;i<partes.length;i++ ){
            boolean inside=partes[i].startsWith(nivel+"\"");
            if ( inside == true && tail_inside == false ){
                count_nova_key=0;
            }
            if ( inside ){
                String key_=partes[i].trim().split("\"")[1];
                key=addParm(partes[i].trim().split("\"")[1], key);
                if ( count_nova_key == nova_key.length || !key_.equals(nova_key[count_nova_key]) ){
                    int p=findParm(nova_key, key_, true);
                    if ( p > 0 )
                        count_nova_key=p;
                    else{
                        nova_key=addParm(key_, count_nova_key, nova_key);                        
                    }
                }
                count_nova_key++;
            }
            if ( inside && partes[i].endsWith(",") )
                line=addParm(partes[i].substring(0, partes[i].length()-1), line);
            else
                line=addParm(partes[i], line);
            tail_inside=inside;
        }
        
        //mostra_array(nova_key);
        
        // inserindo linhas novas
        String tail_line=null;
        count_nova_key=0;
        tail_inside=false;
        int limit=1000;
        for ( int i=0;i<line.length;i++ ){            
            boolean completa=false;
            if ( tail_line != null ){
                boolean inside=tail_line.startsWith(nivel+"\"");                
                boolean inside_atual=line[i].startsWith(nivel+"\"");                
                if ( inside == true && tail_inside == false ){
                    count_nova_key=0;
                }
                if ( inside ){
                    limit=1000;
                    String key_=tail_line.trim().split("\"")[1];
                    while(limit-->0){                        
                        if ( !key_.equals(nova_key[count_nova_key]) ){
                            nova_line=addParm(nivel+"\""+nova_key[count_nova_key]+"\": \"\"", nova_line);                        
                            count_nova_key++;
                            continue;
                        }
                        break;
                    }
                    count_nova_key++;
                    //completa
                    if ( !inside_atual && count_nova_key < nova_key.length )
                        completa=true;
                }
                tail_inside=inside;
            }
            nova_line=addParm(tail_line, nova_line);
            limit=1000;
            while ( completa && limit-->0 && count_nova_key < nova_key.length ){
                nova_line=addParm(nivel+"\""+nova_key[count_nova_key]+"\": \"\"", nova_line);                        
                count_nova_key++;                        
            }                
            tail_line=line[i];            
        }
        if ( tail_line != null )
            nova_line=addParm(tail_line, nova_line);
        
        // colocando virgula no ponto certo
        tail_line=null;
        count_nova_key=0;
        tail_inside=false; 
        String s="";
        for ( int i=0;i<nova_line.length;i++ ){            
            if ( tail_line != null ){
                boolean inside=tail_line.startsWith(nivel+"\"");
                boolean inside_atual=nova_line[i].startsWith(nivel+"\"");
                if ( inside_atual && inside )
                    s+=tail_line+",\n";
                else
                    s+=tail_line+"\n";
                tail_inside=inside;
            }
            tail_line=nova_line[i];            
        }
        if ( tail_line != null )
            s+=tail_line+"\n";
        return s;
    }
           
    public byte [] getBytesInputStream(java.io.InputStream is) throws Exception{
        byte [] buf=new byte[1024];
        int len=0;        
        java.io.ByteArrayOutputStream baos=new java.io.ByteArrayOutputStream();
        while( (len=is.read(buf, 0, buf.length)) > 0 )
            baos.write(buf, 0, len);        
        return baos.toByteArray();
    }
    
    public String get_spaces(long n){
        StringBuilder sb=new StringBuilder();
        for ( long i=0;i<n;i++ )
            sb.append(" ");
        return sb.toString();
    }
    
    public String lpad(long inputLong, int length,String append) {
        if ( inputLong < 0 )
            return lpad(true,(inputLong+"").substring(1),length,append);
        else
            return lpad(false,inputLong+"",length,append);
    }

    public String lpad(String inputString, int length,String append) {
        return lpad(false,inputString,length,append);
    }

    public String lpad(boolean sinalNegativo, String inputString, int length,String append) {
        int len_input=inputString.length();
        if ( len_input >= length) {
            if ( sinalNegativo )
                return "-"+inputString;
            else
                return inputString;
        }
        StringBuilder sb = new StringBuilder(sinalNegativo?"-":"");
        for ( int i=0;i<length-len_input;i++ )
            sb.append(append);
        sb.append(inputString);
        return sb.toString();
    }
    
    public boolean salvando_file(String texto, File arquivo){
        return salvando_file(texto, arquivo, false);
    }
    
    public boolean salvando_file(String texto, File arquivo, boolean append) {
        try{                    
            BufferedWriter out = new BufferedWriter(new FileWriter(arquivo, append));
            out.write(texto);            
            out.flush();
            out.close();
            return true;
        }catch(Exception e){
            System.err.println(e.toString());
        }        
        return false; 
    }    

    public boolean salvando_file(byte [] a, File arquivo, boolean append) {
        try{                    
            FileOutputStream fos = new FileOutputStream(arquivo, append);
            fos.write(a);            
            fos.flush();
            fos.close();
            return true;
        }catch(Exception e){
            System.err.println(e.toString());
        }        
        return false; 
    }    
        
    public String[] sliceParm(int qty, String[] args){ // remove uma quantidade, sempre as iniciais
        if ( qty == 0 )
            erroFatal("erro interno sliceParm");
        String [] retorno=new String[args.length-qty];
        for ( int i=qty;i<args.length;i++ )
            retorno[i-qty]=args[i];
        return retorno;
    }
    public int[] sliceParm(int qty, int[] args){ // remove uma quantidade, sempre as iniciais
        if ( qty == 0 )
            erroFatal("erro interno sliceParm");
        int [] retorno=new int[args.length-qty];
        for ( int i=qty;i<args.length;i++ )
            retorno[i-qty]=args[i];
        return retorno;
    }
    public long[] sliceParm(int qty, long[] args){ // remove uma quantidade, sempre as iniciais
        if ( qty == 0 )
            erroFatal("erro interno sliceParm.. quantidade não pode ser 0");
        long [] retorno=new long[args.length-qty];
        for ( int i=qty;i<args.length;i++ )
            retorno[i-qty]=args[i];
        return retorno;
    }
    
    public String[] removeParm(int n, String[] args){ // deleta 1 item. n=posicao
        if ( n >= args.length )
            erroFatal("erro interno removeParm");
        String [] retorno=new String[args.length-1];
        for ( int i=0;i<args.length;i++ ){
            if ( i > n )
                retorno[i-1]=args[i];
            else
                retorno[i]=args[i];
        }
        return retorno;
    }
    
    public int[] removeParm(int n, int[] args){ // deleta 1 item. n=posicao
        if ( n >= args.length )
            erroFatal("erro interno removeParm");
        int [] retorno=new int[args.length-1];
        for ( int i=0;i<args.length;i++ ){
            if ( i > n )
                retorno[i-1]=args[i];
            else
                retorno[i]=args[i];
        }
        return retorno;
    }
    public long[] removeParm(int n, long[] args){ // deleta 1 item. n=posicao
        if ( n >= args.length )
            erroFatal("erro interno removeParm");
        long [] retorno=new long[args.length-1];
        for ( int i=0;i<args.length;i++ ){
            if ( i > n )
                retorno[i-1]=args[i];
            else
                retorno[i]=args[i];
        }
        return retorno;
    }

    public int findParm(String [] a, String filtro, boolean equal){
        for ( int i=0;i<a.length;i++ ){
            if ( a[i].equals(filtro) && equal )
                return i;
            if ( a[i].contains(filtro) && !equal )
                return i;
        }
        return -1;
    }
    
    public int findParm(String [] a, String [] filtro, boolean equal){
        for ( int i=0;i<a.length;i++ ){
            for ( int j=0;j<filtro.length;j++ ){
                if ( a[i].equals(filtro[j]) && equal )
                    return i;
                if ( a[i].contains(filtro[j]) && !equal )
                    return i;
            }
        }
        return -1;
    }
    
    public String[] addParm(String a, String[] args) {
        return addParm(a, args.length, args);
    }
    
    public String[] addParm(String a, int pos, String[] args){        
        String [] retorno=new String[args.length+1];
        retorno[pos]=a;
        int delta=0;
        for ( int i=0;i<args.length;i++ ){
            if ( i == pos )
                delta=1;
            retorno[i+delta]=args[i];
        }
        return retorno;
    }
    
    public String[] addParm(String [] args0, String[] args) {
        String [] retorno=new String[args0.length+args.length];
        for ( int i=0;i<args.length;i++ )
            retorno[i]=args[i];
        for ( int i=0;i<args0.length;i++ )
            retorno[i+args.length]=args0[i];
        return retorno;
    }
    
    public int[] addParm(int a, int[] args) {
        return addParm(a, args.length, args);
    }
    
    public int[] addParm(int a, int pos, int[] args){        
        int [] retorno=new int[args.length+1];
        retorno[pos]=a;
        int delta=0;
        for ( int i=0;i<args.length;i++ ){
            if ( i == pos )
                delta=1;
            retorno[i+delta]=args[i];
        }
        return retorno;
    }    
    
    public byte[] addParm(byte a, byte[] args) {
        return addParm(a, args.length, args);
    }
    
    public byte[] addParm(byte a, int pos, byte[] args){        
        byte [] retorno=new byte[args.length+1];
        retorno[pos]=a;
        int delta=0;
        for ( int i=0;i<args.length;i++ ){
            if ( i == pos )
                delta=1;
            retorno[i+delta]=args[i];
        }
        return retorno;
    }    
    
    public long[] addParm(long a, long[] args) {
        return addParm(a, args.length, args);
    }
    
    public long[] addParm(long a, int pos, long[] args){        
        long [] retorno=new long[args.length+1];
        retorno[pos]=a;
        int delta=0;
        for ( int i=0;i<args.length;i++ ){
            if ( i == pos )
                delta=1;
            retorno[i+delta]=args[i];
        }
        return retorno;
    }    
    
    String flag_off=    "  ####   ######  ######\n" +
                        " #    #  #       #\n" +
                        " #    #  #####   #####\n" +
                        " #    #  #       #\n" +
                        " #    #  #       #\n" +
                        "  ####   #       #\n" +
                        "\n";
    String flag_away=   "   ##    #    #    ##     #   #\n" +
                        "  #  #   #    #   #  #     # #\n" +
                        " #    #  #    #  #    #     #\n" +
                        " ######  # ## #  ######     #\n" +
                        " #    #  ##  ##  #    #     #\n" +
                        " #    #  #    #  #    #     #\n";
    String flag_on= "                  #################################################           ######                                     ######\n" +
                    "                  #################################################           #######                                    ######\n" +
                    "                  #################################################           ########                                   ######\n" +
                    "                  #################################################           #########                                  ######\n" +
                    "                  #######                                   #######           ##########                                 ######\n" +
                    "                  #######                                   #######           ###########                                ######\n" +
                    "                  #######                                   #######           ############                               ######\n" +
                    "                  #######                                   #######           ###### ######                              ######\n" +
                    "                  #######                                   #######           ######  ######                             ######\n" +
                    "                  #######                                   #######           ######   ######                            ######\n" +
                    "                  #######                                   #######           ######    ######                           ######\n" +
                    "                  #######                                   #######           ######     ######                          ######\n" +
                    "                  #######                                   #######           ######      ######                         ######\n" +
                    "                  #######                                   #######           ######       ######                        ######\n" +
                    "                  #######                                   #######           ######        ######                       ######\n" +
                    "                  #######                                   #######           ######         ######                      ######\n" +
                    "                  #######                                   #######           ######          ######                     ######\n" +
                    "                  #######                                   #######           ######           ######                    ######\n" +
                    "                  #######                                   #######           ######            ######                   ######\n" +
                    "                  #######                                   #######           ######             ######                  ######\n" +
                    "                  #######                                   #######           ######              ######                 ######\n" +
                    "                  #######                                   #######           ######               ######                ######\n" +
                    "                  #######                                   #######           ######                ######               ######\n" +
                    "                  #######                                   #######           ######                 ######              ######\n" +
                    "                  #######                                   #######           ######                  ######             ######\n" +
                    "                  #######                                   #######           ######                   ######            ######\n" +
                    "                  #######                                   #######           ######                    ######           ######\n" +
                    "                  #######                                   #######           ######                     ######          ######\n" +
                    "                  #######                                   #######           ######                      ######         ######\n" +
                    "                  #######                                   #######           ######                       ######        ######\n" +
                    "                  #######                                   #######           ######                        ######       ######\n" +
                    "                  #######                                   #######           ######                         ######      ######\n" +
                    "                  #######                                   #######           ######                          ######     ######\n" +
                    "                  #######                                   #######           ######                           ######    ######\n" +
                    "                  #######                                   #######           ######                            ######   ######\n" +
                    "                  #######                                   #######           ######                             ######  ######\n" +
                    "                  #######                                   #######           ######                              ###### ######\n" +
                    "                  #######                                   #######           ######                               ############\n" +
                    "                  #######                                   #######           ######                                ###########\n" +
                    "                  #######                                   #######           ######                                 ##########\n" +
                    "                  #################################################           ######                                  #########\n" +
                    "                  #################################################           ######                                   ########\n" +
                    "                  #################################################           ######                                    #######\n" +
                    "                  #################################################           ######                                     ######\n";
    
    public void pss(String [] filter){
        if ( os(true).endsWith("Windows") ){
            load_pss_windows();
            pss_windows(false, filter);
            return;
        }else{
            if ( os(true).endsWith("Linux") ){
                load_pss_linux();
                pss_linux(false, filter);
                return;
            }
        }
        System.err.println("Nao implementado para esse sistema operacional!");
        System.exit(1);        
    }
    
    public String [] pids_search(String a, String b, String c, boolean include_current_pid){ // a->like b->notLike c->notLike
        String current=getCurrentPID()+"";
        ArrayList<String> lista=new ArrayList();
        if ( isWindows() ){
            String s_=runtimeExec("cmd /c wmic path win32_process where \"commandline like '%" + a + "%'\" get ProcessId, CommandLine", null, null, null, null);
            if ( s_ == null )
                return new String[]{};
            String [] lines=s_.split("\n");
            for ( int i=0;i<lines.length;i++ ){
                if ( i == 0 )
                    continue;
                if ( b != null && lines[i].contains(b) )
                    continue;            
                if ( c != null && lines[i].contains(c) )
                    continue;            
                String [] partes=lines[i].trim().split(" ");
                if ( !include_current_pid && partes[partes.length-1].equals(current) )
                    continue;
                lista.add(partes[partes.length-1]);
            }            
        }else{
            load_pss_linux();
            for ( int i=0;i<pss_parm3.size();i++ )
                if ( (" "+pss_parm3.get(i)+" ").contains(a) )
                    lista.add(pss_parm1.get(i));
        }
        return arrayList_to_array(lista);        
    }
    
    public void kill_by_path(String path){
        String s=runtimeExec(null, new String[]{"handle64", "-accepteula", path}, null, null, null);        
        if ( s == null || s.equals("") ){
            if ( runtimeExecError != null && !runtimeExecError.equals("") ){
                if ( runtimeExecError.contains("handle64") )
                    erroFatal("Erro, não foi encontrado o programa handle64(e coloque na pasta programfiles), baixe ele aqui: https://github.com/ywanes/utility_y/tree/master/y/utils_exe");
                erroFatal("Erro, comando invalido...\n\n"+runtimeExecError);
            }
        }
        String [] pids=new String[]{};
        String [] lines=s.split("\n");
        for ( int i=0;i<lines.length;i++ ){
            String [] campos=lines[i].split(" ");
            int p=findParm(campos, "pid:", true);
            if ( p > -1 && p+1 < campos.length)
                pids=addParm(campos[p+1], pids);
        }
        if ( pids.length > 0 )
            kill_by_pids(pids);            
    }
    
    public boolean kill_by_text(String a){ 
        return kill_by_text(a, null, null, false);
    }
    
    public boolean kill_by_text(String a, String b, String c, boolean include_current_pid){ // a->like b->notLike c->notLike
        String [] pids=pids_search(a, b, c, include_current_pid);
        if ( pids.length > 0 ){
            kill_by_pids(pids);
            return true;
        }
        return false;
    }
    
    public void kill_by_pids(String [] parms_){
        kill_by_pids(parms_, null, "-9");
    }
    
    public void kill_by_pids(String [] parms_, OutputStream out, String type){
        try{
            String [] parms=new String[0];
            String [] parms_steps_type2=new String[0];
            if ( isLinux() ){
                parms = addParm("kill", parms);
                parms = addParm(type, parms);
                for ( int i=0;i<parms_.length;i++ )
                    parms = addParm(parms_[i], parms);
            }
            if ( isWindows() ){
                if ( type.equals("-9") ){
                    parms = addParm("taskkill", parms);
                    parms = addParm("/f", parms);
                    for ( int i=0;i<parms_.length;i++ ){
                        parms = addParm("/pid", parms);
                        parms = addParm(parms_[i], parms);
                    }
                }
                if ( type.equals("-2") ){
                    parms_steps_type2 = parms_;
                }
            }
            Charset.forName("UTF-8");
            if ( parms.length == 0 && parms_steps_type2.length == 0 )                
                erroFatal("erro interno - parametros invalidos.. ");
            if ( parms.length > 0 ){
                String s=runtimeExec(null, parms, null, null, null);
                if ( s == null )
                    s=runtimeExecError;
                s+="\n";
                if ( out != null )
                    out.write(s.getBytes());  
                return;
            }
            if ( parms_steps_type2.length > 0 ){                
                if ( !new File("c:/windows/windows-kill.exe").exists() )
                    erroFatal("Não foi possível encontrar a ferramenta c:/windows/windows-kill.exe - favor baixar em https://github.com/ElyDotDev/windows-kill/releases");
                for ( int i=0;i<parms_steps_type2.length;i++ ){
                    String s=runtimeExec(null, new String[]{"windows-kill", "-2", parms_steps_type2[i]}, null, null, null);
                    if ( s == null )
                        erroFatal(runtimeExecError);
                    s+="\n";
                    if ( out != null )
                        out.write(s.getBytes());            
                }
                return;
            }
        }catch(Exception e){
            try{
                if ( out != null )
                    out.write(e.toString().getBytes());            
            }catch(Exception e2){
                System.err.println("Erro desconhecido");
            }
        }
    }
        
    public String getLocalDateTime_windows(){
        try{
            String s=runtimeExec("cmd /c wmic path Win32_OperatingSystem get LocalDateTime", null, null, null, null);
            String [] lines=s.split("\n");
            return lines[1].trim();
        }catch(Exception e){
            System.err.println("Erro fatal 4324" + e.toString());
        }   
        return null;
    }

    private String LocalDateTimeCache_windows=null;
    private String getLocalDateTimeCache_windows(){
        if ( LocalDateTimeCache_windows == null )
            LocalDateTimeCache_windows = getLocalDateTime_windows();
        return LocalDateTimeCache_windows;
    }
    
    private ArrayList<String> pss_parm1 = new ArrayList<>();
    private ArrayList<String> pss_parm2 = new ArrayList<>();
    private ArrayList<String> pss_parm3 = new ArrayList<>();
    private ArrayList<String> pss_parm4 = new ArrayList<>();
    private ArrayList<String> pss_parm5 = new ArrayList<>();
    private ArrayList<Boolean> pss_flag = new ArrayList<>();
    public void load_pss_init(){
        pss_parm1 = new ArrayList<>();
        pss_parm2 = new ArrayList<>();
        pss_parm3 = new ArrayList<>();
        pss_parm4 = new ArrayList<>();
        pss_parm5 = new ArrayList<>();
        pss_flag = new ArrayList<>();        
    }
    
    public void load_pss_windows() {        
        try{
            String currentPID=getCurrentPID()+"";
            load_pss_init();
            String s_=runtimeExec("cmd /c wmic path win32_process get CommandLine,CreationDate,ExecutablePath,Name,ParentProcessId,ProcessId", null, null, null, null);
            String [] lines=s_.split("\n");
            ArrayList<Integer> list_p = new ArrayList<>();
            boolean isWord=false;
            for ( int i=0;i<lines.length;i++ ){
                String s=lines[i];
                if( i == 0 ){
                    for ( int j=0;j<s.length();j++ ){
                        String t=s.substring(j, j+1);
                        if ( isWord == !t.equals(" ") )
                            continue;
                        isWord=!isWord;
                        if ( isWord )
                            list_p.add(j);
                    }
                    continue;
                }else{
                    if ( s.length() < list_p.get(4) )
                        continue;
                    String CommandLine = s.substring(list_p.get(0), list_p.get(1)).trim();
                    String CreationDate = s.substring(list_p.get(1), list_p.get(2)).trim();
                    String ExecutablePath = s.substring(list_p.get(2), list_p.get(3)).trim();
                    String Name = s.substring(list_p.get(3), list_p.get(4)).trim();
                    String ParentProcessId = s.substring(list_p.get(4), list_p.get(5)).trim();
                    String ProcessId = s.substring(list_p.get(5)).trim();
                    
                    CreationDate = CreationDate.split("\\.")[0];
                    String LocalDateTime = getLocalDateTimeCache_windows().split("\\.")[0];
                    long seconds=new SimpleDateFormat("yyyyMMddHHmmss").parse(LocalDateTime).getTime() - new SimpleDateFormat("yyyyMMddHHmmss").parse(CreationDate).getTime();
                    seconds/=1000;
                    String deltaTime=seconds_to_string(seconds, "format2");
                    
                    // skip current pid
                    if ( currentPID.equals(ProcessId) || currentPID.equals(ParentProcessId) )
                        continue;
                    pss_parm1.add(ProcessId);
                    pss_parm2.add(ParentProcessId);
                    pss_parm3.add(deltaTime);
                    pss_parm4.add(Name);
                    pss_parm5.add(CommandLine.length()==0?ExecutablePath:CommandLine);
                    pss_flag.add(false);
                }
            }                            
        }catch(Exception e){
            System.err.println("Erro fatal 44556 " + e.toString());
        }
    }
      
    public void load_pss_linux() {        
        try{
            load_pss_init();
            Process proc;
            proc = Runtime.getRuntime().exec("ps -ef");
            int len=0;
            byte[] b=new byte[1024];
            boolean ok=false;                    
            boolean error=false;                    
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            while ( (len=proc.getInputStream().read(b, 0, b.length)) != -1 ){
                baos.write(b, 0, len);
                ok=true;
            }
            while ( (len=proc.getErrorStream().read(b, 0, b.length)) != -1 ){
                error=true;
            }    
            if ( error ){
                System.err.println("Erro fatal 99!");
                System.exit(1);
            }
            String [] lines=baos.toString().split("\n");
            ArrayList<Integer> list_p = new ArrayList<>();
            for ( int i=0;i<lines.length;i++ ){
                String [] partes_=lines[i].split(" ");
                String [] partes=new String[3];
                int count=0;
                for ( int j=0;j<partes_.length;j++ ){
                    if ( partes_[j].equals("") )
                        continue;
                    partes[count++]=partes_[j];
                    if ( count >= 3 )
                        break;
                }
                if ( partes[1].equals("PID") )
                    continue;
                pss_parm1.add(partes[1]);
                pss_parm2.add(partes[2]);
                pss_parm3.add(lines[i]);
                pss_parm4.add("n/a"); // nao remover essa linha
                pss_flag.add(false);
            }                            
        }catch(Exception e){
            System.err.println("Erro fatal 676 " + e.toString());
        }
    }
          
    public int getCurrentPID(){
        return Integer.parseInt(java.lang.management.ManagementFactory.getRuntimeMXBean().getName().split("@")[0]);
    }
    
    public void pss_windows(boolean exigencia_flag, String [] filter){
        for ( int i=0;i<pss_parm1.size();i++ ){
            if ( !exigencia_flag || pss_flag.get(i) ){
                if ( pss_parm3.get(i).contains("0:00:00:0") ){ // skip o proprio comando
                    if ( pss_parm5.get(i).contains("C:\\Windows\\system32\\cmd.exe  /S /D /c\" y grep") )
                        continue;
                    if ( pss_parm4.get(i).contains("java.exe") && pss_parm5.get(i).contains(".jar Y grep ") )
                        continue;
                }
                if ( filter == null )
                    System.out.println(pss_parm1.get(i)+"\t"+pss_parm2.get(i)+"\t"+pss_parm3.get(i)+"\t"+pss_parm4.get(i)+"\t"+pss_parm5.get(i));
                else{
                    for ( int j=0;j<filter.length;j++ ){
                        if ( filter[j].equals(pss_parm1.get(i)) ){
                            System.out.println(pss_parm1.get(i)+"\t"+pss_parm2.get(i)+"\t"+pss_parm3.get(i)+"\t"+pss_parm4.get(i)+"\t"+pss_parm5.get(i));
                            break;
                        }
                    }
                }
            }
        }
    }
          
    public void pss_linux(boolean exigencia_flag, String [] filter){
        for ( int i=0;i<pss_parm1.size();i++ )
            if ( !exigencia_flag || pss_flag.get(i) )
                System.out.println(pss_parm3.get(i));
    }
    
    public void pid_windows(String pid){
        load_pss_windows();
        pid_nav_up(pid, pid+",");
        pid_nav_down(pid, pid+",");
        pss_windows(true, null);
    }
    
    public void pid_linux(String pid){
        load_pss_linux();
        pid_nav_up(pid, pid+",");
        pid_nav_down(pid, pid+",");
        pss_linux(true, null);
    }
    
    public void pid_nav_up(String pid, String path){
        for ( int i=0;i<pss_flag.size();i++ ){
            if ( pss_parm1.get(i).equals(pid) && !pss_parm4.get(i).equals("svchost.exe") ){
                pss_flag.set(i, true);
                if ( !pss_parm1.get(i).equals(pss_parm2.get(i)) && !(","+path).contains(","+pss_parm2.get(i)+",") )
                    pid_nav_up(pss_parm2.get(i),path+pss_parm2.get(i)+",");
            }
        }
    }
    
    public void pid_nav_down(String pid, String path){
        for ( int i=0;i<pss_flag.size();i++ ){
            if ( pss_parm2.get(i).equals(pid) ){
                pss_flag.set(i, true);
                if ( !pss_parm1.get(i).equals(pss_parm2.get(i)) && !(","+path).contains(","+pss_parm1.get(i)+",") )
                    pid_nav_down(pss_parm1.get(i),path+pss_parm1.get(i)+",");
            }
        }
    }
    
    public String fixNameFile(String a){
        // nao pode colocar .replaceAll("#", "") senão quebra tudo.
        return a.replaceAll("'", "").replaceAll(":", "-").replaceAll("&", "-").replaceAll("#039;", "").trim();
    }
    
    public ArrayList<String> getPivot(String a, String quebralinha){
        ArrayList<String> retorno=new ArrayList<String>();
        String [] partes=a.split(quebralinha);
        String linha_key=partes[0];
        String linha_value=partes[1];
        int p_key=0;
        int p_value=0;
        String key="";
        String value="";
        boolean wording=false;
        String t=null;
        while(p_key<linha_key.length() && p_value<linha_value.length()){
            if ( p_key<linha_key.length() ){
                t=linha_key.substring(p_key, p_key+1);
                if ( !t.equals(" ") ){
                    if ( !wording ){
                        if ( !value.equals("") )
                            retorno.add(key.trim()+": "+value.trim());
                        key="";
                        value="";
                    }
                    wording=true;
                }else{
                    wording=false;
                }
                key+=t;
                p_key++;
            }
            if ( p_value<linha_value.length() ){
                t=linha_value.substring(p_value, p_value+1);
                value+=t;
                p_value++;
            }
        }
        if ( !value.equals("") )
            retorno.add(key.trim()+": "+value.trim());
        return retorno;
    }
    
    public String decodeUrl(String a){
        try{   
            a=a.replaceAll("\\+", "%2B");
            return java.net.URLDecoder.decode( a, "UTF-8");
        }catch(Exception e){
            return "Erro_no_decode_url";
        }
    }
    
    public String encodeUrl(String a){
        try{    
            return java.net.URLEncoder.encode( a, "UTF-8");
        }catch(Exception e){
            return "Erro_no_decode_url";
        }
    }    

    public String add_principais(String a){
        if ( a.split(";;;").length > 1 ){
            String primeira_interface=a.split(";;;")[0];
            if ( primeira_interface.contains("::") ){
                String [] ips=primeira_interface.split(";;")[1].split(";");
                String achou="";                
                for ( int i=0;i<ips.length;i++ ){
                    if ( !ips[i].contains(":") || ips[i].contains("::") )
                        continue;
                    for ( int j=0;j<ips.length;j++ ){
                        if ( !ips[j].contains("::") )
                            continue;
                        if ( ips[i].startsWith(ips[j].split("::")[0]) ){
                            achou=ips[j];
                            break;
                        }
                    }
                    break;
                }
                if ( achou.equals("") )
                    achou="NAO_ACHOU";
                String result="";
                int count_ips=0;
                boolean other_preenchido=false;
                for ( int i=0;i<ips.length;i++ ){
                    if( ips[i].contains("::") && !ips[i].equals(achou) )
                        continue;
                    if ( ips[i].contains(":") && !ips[i].contains("::") ){
                        if ( !other_preenchido )
                            other_preenchido=true;
                        else
                            continue;
                    }
                    if ( count_ips > 0 )
                        result+=";";
                    result+=ips[i];
                    count_ips++;
                }
                if ( result.equals("") )
                    return a;
                else
                    return "Principais;;"+result+";;;"+a+";;;"+"Principais;;"+result;
            }
        }
        return a;
    }
    
    public static PlaylistServer playlistserver=null;

    public String runtimeExecY(String [] commands, byte [] std_in){
        String cp="c:\\y;c:\\y\\ojdbc6.jar;c:\\y\\sqljdbc4-3.0.jar;c:\\y\\mysql-connector-java-8.0.26.jar;c:\\y\\postgresql-42.7.5.jar;c:\\y\\jsch-0.1.55.jar";
        File path_y=new File("C:\\y");
        if ( commands == null || commands.length == 0 )
            erroFatal("Erro interno 220");
        commands=addParm("cmd", 0, commands);
        commands=addParm("/c", 1, commands);
        commands=addParm("java", 2, commands);
        commands=addParm("-Dfile.encoding=UTF-8", 3, commands);
        commands=addParm("-cp", 4, commands);
        commands=addParm(cp, 5, commands);
        commands=addParm("Y", 6, commands);
        return runtimeExec(null, commands, path_y, std_in, null);
    }
    
    public String runtimeExec(String [] commands) throws Exception{
        return runtimeExec(null, commands, null, null, false);
    }
    
    /*
    public String runtimeExecError = "";
    public byte [] runtimeExecOutBytes = null;
    public boolean flag_real_time_output = false;
    public String runtimeExec(String line_commands, String [] commands,File file_path, byte [] std_in, Boolean flag_charset_windows){
        try{
            final String charset=(flag_charset_windows != null && flag_charset_windows)?"ISO-8859-1":"UTF-8";
            
            if ( commands == null )
                commands=line_commands.split(" ");
            runtimeExecError="";
            Process proc = Runtime.getRuntime().exec(commands, null, file_path);            
            
            Thread ok0=new Thread(){
                public void run(){
                    try{
                        if ( std_in != null ){                                
                            OutputStream os=proc.getOutputStream();
                            os.write(std_in);
                            os.flush();
                            os.close();
                        }
                    }catch(Exception e1){
                        runtimeExecError="Erro interno 210 - " + e1.toString();
                    }
                }
            };
            ok0.start();                        
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            ByteArrayOutputStream baos_err = new ByteArrayOutputStream();
            Thread ok=new Thread(){
                public void run(){
                    try{                        
                        int len=0;
                        byte[] b1=new byte[1024];
                        ByteArrayOutputStream baos2=new ByteArrayOutputStream();
                        while ( (len=proc.getInputStream().read(b1, 0, b1.length)) != -1 ){
                            if ( flag_real_time_output ){
                                baos2.write(b1, 0, len);
                                baos2.flush();
                                System.out.print(baos2.toString(charset));                                
                                System.out.flush();                                
                                baos2=new ByteArrayOutputStream();
                            }else{
                                baos.write(b1, 0, len);
                                baos.flush();
                            }
                        }                    
                    }catch(Exception e1){
                        runtimeExecError="Erro interno 211";
                    }
                }
            };
            ok.start();
            Thread nok=new Thread(){
                public void run(){
                    try{
                        int len=0;
                        byte[] b2=new byte[1024];
                        while ( (len=proc.getErrorStream().read(b2, 0, b2.length)) != -1 ){
                            baos_err.write(b2, 0, len);
                            baos_err.flush();
                            runtimeExecError=baos_err.toString("UTF-8");                
                        }  
                    }catch(Exception e2){
                        runtimeExecError="Erro interno 212";
                    }
                }
            };
            nok.start();
            ok0.join();
            ok.join();
            nok.join();
            runtimeExecOutBytes=baos.toByteArray();
            String s=baos.toString(charset).replace("\r\n","\n");
            String [] linhas=s.split("\n");
            if ( commands.length >= 3 && commands[0].equals("cmd") && commands[1].equals("/c") && linhas[0].endsWith(": 65001")){
                s="";
                for ( int i=1;i<linhas.length;i++ )
                    s+=linhas[i]+"\n";
            }
            if ( !runtimeExecError.equals("") && s.equals("") )
                return null;
            return s;
        }catch(Exception e){
            runtimeExecError=e.toString();            
        }
        return null;
    }
    */

    public String runtimeExecError = "";
    public byte[] runtimeExecOutBytes = null;
    public boolean flag_real_time_output = false;
    public String runtimeExec(String line_commands, String[] commands, File file_path, byte[] std_in, Boolean flag_charset_windows) {
        try {
            final String charset = (flag_charset_windows != null && flag_charset_windows) ? "ISO-8859-1" : "UTF-8";

            if (commands == null)
                commands = line_commands.split(" ");

            runtimeExecError = "";

            // USANDO PROCESSBUILDER EM VEZ DE RUNTIME.EXEC()
            ProcessBuilder pb = new ProcessBuilder(commands);
            if (file_path != null) {
                pb.directory(file_path);
            }
            Process proc = pb.start();

            // finalizando filhos
            ProcessHandle processHandle = proc.toHandle();
            Runtime.getRuntime().addShutdownHook(new Thread(() -> {
                destroyProcessTree(processHandle);
            }));
            
            Thread ok0 = new Thread() {
                public void run() {
                    try {
                        if (std_in != null) {
                            OutputStream os = proc.getOutputStream();
                            os.write(std_in);
                            os.flush();
                            os.close();
                        }
                    } catch (Exception e1) {
                        runtimeExecError = "Erro interno 210 - " + e1.toString();
                    }
                }
            };
            ok0.start();

            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            ByteArrayOutputStream baos_err = new ByteArrayOutputStream();

            Thread ok = new Thread() {
                public void run() {
                    try {
                        int len = 0;
                        byte[] b1 = new byte[1024];
                        ByteArrayOutputStream baos2 = new ByteArrayOutputStream();
                        while ((len = proc.getInputStream().read(b1, 0, b1.length)) != -1) {
                            if (flag_real_time_output) {
                                baos2.write(b1, 0, len);
                                baos2.flush();
                                System.out.print(baos2.toString(charset));
                                System.out.flush();
                                baos2 = new ByteArrayOutputStream();
                            } else {
                                baos.write(b1, 0, len);
                                baos.flush();
                            }
                        }
                    } catch (Exception e1) {
                        runtimeExecError = "Erro interno 211";
                    }
                }
            };
            ok.start();

            Thread nok = new Thread() {
                public void run() {
                    try {
                        int len = 0;
                        byte[] b2 = new byte[1024];
                        while ((len = proc.getErrorStream().read(b2, 0, b2.length)) != -1) {
                            baos_err.write(b2, 0, len);
                            baos_err.flush();
                            runtimeExecError = baos_err.toString("UTF-8");
                        }
                    } catch (Exception e2) {
                        runtimeExecError = "Erro interno 212";
                    }
                }
            };
            nok.start();

            ok0.join();
            ok.join();
            nok.join();

            runtimeExecOutBytes = baos.toByteArray();
            String s = baos.toString(charset).replace("\r\n", "\n");
            String[] linhas = s.split("\n");

            if (commands.length >= 3 && commands[0].equals("cmd") && commands[1].equals("/c") && linhas[0].endsWith(": 65001")) {
                s = "";
                for (int i = 1; i < linhas.length; i++)
                    s += linhas[i] + "\n";
            }

            if (!runtimeExecError.equals("") && s.equals(""))
                return null;
            return s;

        } catch (Exception e) {
            runtimeExecError = e.toString();
        }
        return null;
    }

    private void destroyProcessTree(ProcessHandle root) {
        root.descendants().forEach(descendant -> {
            descendant.destroy();
            try {
                descendant.onExit().get(2, TimeUnit.SECONDS);
            } catch (Exception e) {
                descendant.destroyForcibly();
            }
        });
        
        if (root.isAlive()) {
            root.destroy();
            try {
                root.onExit().get(3, TimeUnit.SECONDS);
            } catch (Exception e) {
                root.destroyForcibly();
            }
        }
    }
    
    public String [] regex_matcher(String start, String end, String text, Boolean trunc_lens){
        ArrayList<String> lista=new ArrayList<String>();
        java.util.regex.Matcher matcher = java.util.regex.Pattern.compile(start+"[\\s\\S]*?"+end).matcher(text);        
        while ( matcher.find() )
            lista.add(matcher.group());
        if ( trunc_lens ){
            String [] lista2=new String[lista.size()];
            for ( int i=0;i<lista.size();i++ )
                lista2[i]=lista.get(i).substring(start.length(),lista.get(i).length()-end.length());
            return lista2;
        }
        return arrayList_to_array(lista);
    }
    
    public String[] arrayList_to_array(ArrayList a){
        String[] args=new String[a.size()];
        for(int i=0;i<a.size();i++)
            args[i]=a.get(i).toString();
        return args;        
    }
    
    public int[] arrayList_to_array_int(ArrayList a){
        int[] args=new int[a.size()];
        for(int i=0;i<a.size();i++)
            args[i]=(int)a.get(i);
        return args;        
    }

    public void erro_amigavel_exception(Exception e){
        erroFatal(get_erro_amigavel_exception(e));
    }
    
    public String get_erro_amigavel_exception(Exception e){
        if ( e.toString().equals("java.net.BindException: Address already in use (Bind failed)") )
            return "Erro, esse servico ja esta aberto";
        if ( 
            e.toString().equals("java.net.ConnectException: Connection refused: connect") 
            || e.toString().equals("java.net.ConnectException: Connection refused") 
            || e.toString().equals("java.net.ConnectException: Connection refused (Connection refused)")
        )
            return "Erro, offline";
        if ( 
            e.toString().equals("java.net.SocketException: Connection reset by peer: socket write error")
            || e.toString().equals("java.net.SocketException: Connection reset") 
        )
            return "Desconectou-se!";
        return e.toString();        
    }
    
    public ByteArrayOutputStream delete_baos(ByteArrayOutputStream baos_, int start, int end){
        byte [] bytes_baos_=baos_.toByteArray();
        ByteArrayOutputStream baos=new ByteArrayOutputStream();
        if ( start != 0 || start >= end || end > bytes_baos_.length )
            erroFatal(123);        
        if ( end < bytes_baos_.length )
            baos.write(bytes_baos_, end, bytes_baos_.length-end);
        return baos;
    }
    
    public String miliseconds_to_string(long miliseconds){
        long _miliseconds=miliseconds%1000;
        long seconds=(miliseconds-_miliseconds)/1000;
        return seconds_to_string(seconds, "format2") + "." + lpad(_miliseconds, 3, "0");
    }
    
    public String seconds_to_string(long seconds, String format){
        String s=null;
        long second = 1;
        long minute = 60*second;
        long hour = 60*minute;
        long day = 24*hour;
        long minutes=0;
        long hours=0;
        long days=0;
        while(seconds >= day){
            seconds-=day;
            days++;
        }
        while(seconds >= hour){
            seconds-=hour;
            hours++;
        }
        while(seconds >= minute){
            seconds-=minute;
            minutes++;
        }
        if ( format.equals("format1") ){ // format2 padrao
            s="up ";
            if ( !s.equals("up ") || days > 0 ){
                s+=" "+days+" days,";
            }
            if ( !s.equals("up ") || hours > 0 ){
                s+=" "+hours+" hours,";
            }
            if ( !s.equals("up ") || minute > 0 ){
                s+=" "+minutes+" minutes,";
            }
            if ( !s.equals("up ") || second > 0 ){
                s+=" "+seconds+" seconds";
            }     
            return s;        
        }
        return days+":"+(hours<10?"0":"")+hours+":"+(minutes<10?"0":"")+minutes+":"+(seconds<10?"0":"")+seconds;
    }
    
    public int duration_to_seconds(String a){
        if ( a.split(":").length == 3 ){
            return Integer.parseInt(a.split(":")[0])*60*60+Integer.parseInt(a.split(":")[1])*60+Integer.parseInt(a.split(":")[2]);
        }
        return -1;
    }
            
    public static int byte_to_int_java(byte a,boolean dif_128) {
        // os bytes em java vem 0..127 e -128..-1 totalizando 256
        // implementacao manual de Byte.toUnsignedInt(a)
        // dif_128 true  => -128..127
        // dif_128 false =>    0..255
        int i=(int)a;
        if ( !dif_128 && i < 0 )
            i+=256;
        return i;
    }
    
    public static int [] indexBase64 = new int []{65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,
        89,90,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,48,49,50,
        51,52,53,54,55,56,57,43,47};
    // ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=
    public static String txtBase64="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    
    public void base64(InputStream pipe_in,OutputStream pipe_out,boolean encoding) throws Exception{        
        // ex: base64(System.in,System.out,true);
        if ( encoding )
            base64encode(pipe_in,pipe_out);
        else
            base64decode(pipe_in,pipe_out);                    
    }
    
    public void base64encode(InputStream pipe_in,OutputStream pipe_out) throws Exception{        
        int BUFFER_SIZE_ = 1;
        byte [] buf=new byte[BUFFER_SIZE_];
        int len=-1;
        int entrada=-1;
        int agulha=0;
        int agulha_count=0;
        int indexPadding=61; // "="
        while(true){
            while( (len=pipe_in.read(buf,0,BUFFER_SIZE_)) == 0 ){}
            if ( len == -1 ){
                if ( agulha_count == 4 ){
                    pipe_out.write( indexBase64[ agulha<<2 ] );
                    pipe_out.write( indexPadding );
                }
                if ( agulha_count == 2 ){
                    pipe_out.write( indexBase64[ agulha<<4 ] );
                    pipe_out.write( indexPadding );
                    pipe_out.write( indexPadding );
                }  
                break;
            }
            entrada=byte_to_int_java(buf[0],false);
            agulha=(agulha<<8)|entrada;
            agulha_count+=8;
            while(agulha_count>=6){
                if ( agulha_count == 6 ){
                    pipe_out.write( indexBase64[ agulha ] );
                    agulha=0;
                    agulha_count-=6;
                    continue;
                }
                if ( agulha_count == 8 ){
                    pipe_out.write( indexBase64[ (agulha & V_0b11111100)>>2 ] );
                    agulha&=V_0b00000011;
                    agulha_count-=6;
                    continue;
                }
                if ( agulha_count == 10 ){
                    pipe_out.write( indexBase64[ (agulha & V_0b1111110000)>>4 ] );
                    agulha&=V_0b0000001111;
                    agulha_count-=6;
                    continue;
                }
                if ( agulha_count == 12 ){
                    pipe_out.write( indexBase64[ (agulha & V_0b111111000000)>>6 ] );
                    agulha&=V_0b000000111111;
                    agulha_count-=6;
                    continue;
                }
            }
        }    
        pipe_out.flush();
    }
    
    public void base64decode(InputStream pipe_in,OutputStream pipe_out) throws Exception{        
        int BUFFER_SIZE_ = 1;
        byte [] buf=new byte[BUFFER_SIZE_];
        int len=-1;
        int entrada=-1;
        int agulha=0;
        int agulha_count=0;        
        int padding_count=0;
        while(true){
            while( (len=pipe_in.read(buf,0,BUFFER_SIZE_)) == 0 ){}
            if ( len == -1 ){
                if ( agulha_count == 0 && padding_count == 0 && agulha == 0 ){
                    break;
                }
                if ( agulha_count == 4 && padding_count == 2 && agulha == 0 ){
                    break;
                }
                if ( agulha_count == 2 && padding_count == 1 && agulha == 0 ){
                    break;
                }
                throw new Exception(erroSequenciaIlegal);
            }
            entrada=byte_to_int_java(buf[0],false);
            // suprimindo \r\n
            // no windows, o y echo sem aspeta pode dar problema
            // assim da problema =>     y echo YQo= | y base64 -d
            // assim nao da problema => y echo "YQo=" | y base64 -d
            if ( entrada == 10 || entrada == 13 || entrada == 32 ){
                continue;
            }
            entrada=txtBase64.indexOf((char)entrada);
            if ( entrada == -1 ){
                System.err.println(erroSequenciaIlegal);
                System.exit(1);
            }
            if ( entrada == 64 ){
                padding_count++;
                continue;
            }            
            agulha=(agulha<<6)|entrada;
            agulha_count+=6;
            while(agulha_count>=8){
                if ( agulha_count == 8 ){
                    pipe_out.write( agulha );
                    agulha=0;
                    agulha_count-=8;
                    continue;
                }
                if ( agulha_count == 10 ){
                    pipe_out.write( (agulha & V_0b1111111100)>>2 );
                    agulha&=V_0b0000000011;
                    agulha_count-=8;
                    continue;
                }
                if ( agulha_count == 12 ){
                    pipe_out.write( (agulha & V_0b111111110000)>>4 );
                    agulha&=V_0b000000001111;
                    agulha_count-=8;
                    continue;
                }
            }
        }    
        pipe_out.flush();        
    }
    
    public byte[] base64_B_B(byte[] txt,boolean encoding) throws Exception{ // byte in byte out
        ByteArrayInputStream bais=new ByteArrayInputStream(txt);
        ByteArrayOutputStream baos=new ByteArrayOutputStream();
        base64(bais,baos,encoding);
        return baos.toByteArray();
    }
    
    public String base64_S_S(String txt,boolean encoding) throws Exception{ // String in String out
        return new String(base64_B_B(txt.getBytes(),encoding));
    }

    public String base64_B_S(byte[] txt,boolean encoding) throws Exception{ // byte in String out
        return new String(base64_B_B(txt,encoding));
    }
    
    public byte[] base64_S_B(String txt,boolean encoding) throws Exception{ // String in byte out
        return base64_B_B(txt.getBytes(),encoding);
    }
    
    public String base64(String txt,boolean encoding) throws Exception{        
        return base64_S_S(txt,encoding);
    }
        
    public static String hex_string="0123456789ABCDEF";
    public String lendo_arquivo(String caminho) {
        String result="";
        String strLine;
        try{
            readLine(caminho);
            while ((strLine = readLine()) != null)   {
                if ( result.equals("") )
                    result+=strLine;
                else
                    result+="\n"+strLine;
            }
            closeLine();
        }catch (Exception e){
            System.out.println(e.toString());
        }
        return result;
    }
    
    public static int random(int min, int max){
        return java.util.concurrent.ThreadLocalRandom.current().nextInt(min, max + 1);        
    }

    private long print_cursor_speed_timer_mili=-1;
    private long print_cursor_speed_count_len_bytes=0;
    private long print_cursor_speed_count_total_len_bytes=0;
    public void print_cursor_speed(int len_bytes, String pre_line, String force_finish, Boolean show_total, String label_on){
        if ( label_on == null )
            label_on="";
        if ( force_finish != null ){
            System.out.println("\r"+force_finish+"                                                                                ");
            return;
        }
        print_cursor_speed_count_len_bytes+=len_bytes;
        print_cursor_speed_count_total_len_bytes+=len_bytes;
        if ( print_cursor_speed_timer_mili == -1 ){
            print_cursor_speed_timer_mili=System.currentTimeMillis();            
            return;
        }else{
            long tmp=System.currentTimeMillis();
            if ( tmp > print_cursor_speed_timer_mili + 1000 ){
                print_cursor_speed_timer_mili=tmp;
                String o=null;                
                String o2="";
                if ( pre_line != null ){
                    if ( show_total )
                        o="\r"+pre_line+print_cursor_speed_count_total_len_bytes+" bytes - "+bytes_to_text(print_cursor_speed_count_total_len_bytes)+" - "+bytes_to_text(print_cursor_speed_count_len_bytes)+"/s - "  + bits_to_text(print_cursor_speed_count_len_bytes)+"/s - " + label_on;
                    else
                        o="\r"+pre_line+bytes_to_text(print_cursor_speed_count_len_bytes)+"/s - "  + bits_to_text(print_cursor_speed_count_len_bytes)+"/s - " + label_on;
                }else{
                    if ( show_total )
                        o="\r"+print_cursor_speed_count_total_len_bytes+" bytes - "+bytes_to_text(print_cursor_speed_count_total_len_bytes)+" - "+bytes_to_text(print_cursor_speed_count_len_bytes)+"/s - "  + bits_to_text(print_cursor_speed_count_len_bytes)+"/s - " + label_on;
                    else
                        o="\r"+bytes_to_text(print_cursor_speed_count_len_bytes)+"/s - "  + bits_to_text(print_cursor_speed_count_len_bytes)+"/s - " + label_on;
                }
                int len_o=o.length();
                if ( len_o < 130 )
                    o2=get_spaces(130-len_o);
                System.out.print(o);
                System.out.print(o2);
                System.out.print("\r");
                print_cursor_speed_count_len_bytes=0;
            }else
                return;
        }                
    }
    
    public String bits_to_text(long a){
        return valor_to_text(a*8, true)+"b";
    }
    public String bits_to_text(long a, boolean com_espaco){
        return valor_to_text(a*8, com_espaco)+"b";
    }
    
    public String bytes_to_text(long a){
        return valor_to_text(a, true)+"B";
    }
    public String bytes_to_text(long a, boolean com_espaco){
        return valor_to_text(a, com_espaco)+"B";
    }
    
    public String valor_to_text(long unit, boolean com_espaco){
        long fator=1024;
        String s="";
        String _espaco=com_espaco?" ":"";
        if ( unit/(fator*fator*fator*fator) >= 1 )
            return arredondamentoDouble(((double)unit/(fator*fator*fator*fator)) ,2, false)+_espaco+"T";
        if ( unit/(fator*fator*fator) >= 1 )
            return arredondamentoDouble(((double)unit/(fator*fator*fator)) ,2, false)+_espaco+"G";
        if ( unit/(fator*fator) >= 1 )
            return arredondamentoDouble(((double)unit/(fator*fator)) ,2, false)+_espaco+"M";
        if ( unit/(fator) >= 1 )
            return arredondamentoDouble(((double)unit/(fator)) ,2, false)+_espaco+"K";
        return unit+_espaco+"B";
    }
    
    public String porcentagem(long a, long b){
        String s=arredondamentoDouble((double)a*100/b, 2, false)+"%";
        if ( s.length() < 6 )
            return " "+s;
        return s;
    }
    
    static void testOn() {
        try{
            inputStream_pipe=new FileInputStream("c:/tmp/file.json");
        }catch(Exception e){
            erroFatal(404);
        }
    }
    public final static int BUFFER_SIZE=1024;
    
    public static String separadorCSVCache=null;
    public static String getSeparadorCSV(){
        if ( separadorCSVCache != null )
            return separadorCSVCache;
        String sep_=getEnv("CSV_SEP_Y");
        if ( sep_ == null || sep_.trim().equals("") )
            separadorCSVCache=sep_=";";
        return sep_;
    }
    
    public void readLine(String caminho) throws Exception{
        readLine(new File(caminho));
    }
    
    public void readLine(File f) throws Exception{
        readLine(new FileInputStream(f));
    }
    
    public java.util.Scanner scanner_pipe=null;
    public void readLine(InputStream in){            
        readLine(in,null,null);
    }    
    
    public void readLine(InputStream in,String encoding,String delimiter){
        if ( delimiter == null )
            delimiter="\n";
        if ( encoding == null )
            scanner_pipe=new java.util.Scanner(in);
        else
            scanner_pipe=new java.util.Scanner(in,encoding);
        scanner_pipe.useDelimiter(delimiter);        
    }    
    
    public String readLine(){        
        try{            
            if ( scanner_pipe == null ){
                readLine(System.in);                
            }
            if ( scanner_pipe.hasNext() )                
                return scanner_pipe.next().replace("\r","");
            else
                return null;            
        }catch(java.util.NoSuchElementException no) {
            return null;
        }catch(Exception e){
            System.err.println("NOK: "+e.toString());
        }
        return null;
    }
    
    public String read1String(){
        while(true){
            try{            
                if ( scanner_pipe == null )
                    readLine(System.in, null, "");
                if ( scanner_pipe.hasNext() )
                    return scanner_pipe.next();
                else
                    return null;            
            }catch(java.util.NoSuchElementException no) {
                if ( no.toString().equals("java.util.InputMismatchException")){   // {"a":"name🚩 Proje"}         
                    scanner_pipe.skip(".");
                    continue;
                }
                return null;
            }catch(Exception e){
                System.err.println("NOK: "+e.toString());
            }
            return null;
        }
    }
    
    public String readString(){
        StringBuilder sb=new StringBuilder();
        String aux="";
        boolean first=true;
        while ( (aux=readLine()) != null ){
            if ( first )
                first=false;
            else
                sb.append("\n");
            sb.append(aux);
        }
        return sb.toString();
    }
    
    public void closeLine(){
        try{
            scanner_pipe.close();            
        }catch(Exception e){}
        scanner_pipe=null;
    }
    
    public List<String> readAllLines(String caminho){
        try{   
            return java.nio.file.Files.readAllLines(java.nio.file.Paths.get(caminho));
        }catch(Exception e){
            erroFatal(e);
        }
        return null;
    }
    
    public ArrayList<String> readAllLines(){
        ArrayList<String> lines=new ArrayList();
        String line=null;
        while( (line=readLine()) != null )
            lines.add(line);
        return lines;
    }
    
    public static java.util.Scanner scanner_pipeB=null;
    public void readLineB(String caminho) throws Exception{
        readLineB(new File(caminho));
    }
    
    public void readLineB(File f) throws Exception{
        readLineB(new FileInputStream(f), null, null);
    }

    public static void readLineB(InputStream in,String encoding,String delimiter){
        if ( delimiter == null )
            delimiter="\n";
        if ( encoding == null )
            scanner_pipeB=new java.util.Scanner(in);
        else
            scanner_pipeB=new java.util.Scanner(in,encoding);
        scanner_pipeB.useDelimiter(delimiter);        
    }    
    
    public String readLineB(){        
        try{
            if ( scanner_pipeB == null )
                readLineB(System.in, null ,null);
            if ( scanner_pipeB.hasNext() )
                return scanner_pipeB.next();
            else
                return null;
        }catch(java.util.NoSuchElementException no) {
            return null;
        }catch(Exception e){
            System.err.println("NOK: "+e.toString());
        }
        return null;
    }
    
    public void closeLineB(){
        try{
            scanner_pipeB.close();
        }catch(Exception e){}
        scanner_pipeB=null;
    }
    
    public static InputStream inputStream_pipe=null;        
    public void readBytes(String caminho) throws Exception{
        readBytes(new File(caminho));
    }
    public void readBytes(File file) throws Exception{
        readBytesInit();
        inputStream_pipe=new FileInputStream(file);
    }
    
    public int readBytes(byte[] buf){
        return readBytes(buf,0,BUFFER_SIZE);
    }
    
    int read1Byte_n=-1;
    int read1Byte_len=-1;
    public void readBytesInit(){
        read1Byte_n=-1;
        read1Byte_len=-1;
    }
    
    public int readBytes(byte[] buf,int off,int len){
        try{
            if ( inputStream_pipe == null ){
                readBytesInit();
                inputStream_pipe=System.in;
            }
            int retorno=-1;
            while( (retorno=inputStream_pipe.read(buf,off,len)) == 0 ){
            }
            return retorno;
        }catch(Exception e){
            System.err.println("Erro, "+e.toString());
            System.exit(1);
        }
        return -1;
    }
    
    byte[] read1ByteBuff = new byte[BUFFER_SIZE];
    public boolean read1Byte(byte [] b){
        if ( inputStream_pipe == null ){
            readBytesInit();
            inputStream_pipe=System.in;
        }   
        if ( read1Byte_n == -1 || read1Byte_n >= read1Byte_len ){
            read1Byte_n=0;
            read1Byte_len=readBytes(read1ByteBuff);            
        } 
        if ( read1Byte_n < read1Byte_len ){
            b[0]=read1ByteBuff[read1Byte_n];
            read1Byte_n++;
            return true;
        }
        return false;
    }
    
    public byte[] readAllBytes(){
        byte[] tmp = new byte[BUFFER_SIZE];
        int len=0;
        ByteArrayOutputStream baos=new ByteArrayOutputStream();
        while( (len=readBytes(tmp, 0, BUFFER_SIZE)) >= 0 )
            baos.write(tmp, 0, len);
        return baos.toByteArray();
    }
    
    public void closeBytes(){
        try{
            inputStream_pipe.close();            
        }catch(Exception e){}
        inputStream_pipe=null;
    }
    
    public void write1Byte(int b){
        write1Byte(new byte[]{(byte)b});
    }

    // write1Byte
    byte[] write1ByteBuff = new byte[BUFFER_SIZE];
    int write1Byte_n=0;
    public void write1Byte(byte [] b){
        if ( write1Byte_n >= BUFFER_SIZE ){
            System.out.write(write1ByteBuff, 0, BUFFER_SIZE);
            write1Byte_n=0;            
        }
        write1ByteBuff[write1Byte_n]=b[0];
        write1Byte_n++;
    }
    
    public void write1ByteFlush(){
        if ( write1Byte_n > 0 ){
            System.out.write(write1ByteBuff, 0, write1Byte_n);
            write1Byte_n=0;
        }
    }    

    private String osGetTypeTrueCache=null;
    private String osGetTypeFalseCache=null;
    public String os(boolean getType) {
        try{
            if ( getType && osGetTypeTrueCache != null )
                return osGetTypeTrueCache;
            if ( !getType && osGetTypeFalseCache != null )
                return osGetTypeFalseCache;        
            // processamento rapido getType
            if ( getType ){
                osGetTypeTrueCache=System.getProperty("user.dir").contains("/")?"Linux":"Windows";
                return osGetTypeTrueCache;                     
            }
            boolean show=false;
            String [] commands = new String[]{
                // BootDevice,RegisteredUser, removido!
                "cmd /c wmic os get BuildNumber,Caption,OSArchitecture,Version && wmic ComputerSystem get UserName,TotalPhysicalMemory && wmic cpu get loadpercentage,ThreadCount,L3CacheSize,name && wmic path Win32_VideoController get Caption,adapterram && wmic logicaldisk get deviceid,size,freespace",
                "system_profiler SPSoftwareDataType",
                "oslevel",
                "lsb_release -a",
                "cat /etc/os-release",
                "cat /proc/version",
            };
            String [] types = new String[]{
                "Windows",
                "Mac",
                "Linux",
                "Linux",
                "Linux",
                "Linux",
            };
            for ( int i=0;i<commands.length;i++ ){
                String s=runtimeExec(commands[i], null, null, null, null);
                if ( s == null )
                    continue;
                if ( getType ){
                    osGetTypeTrueCache=types[i];
                    return osGetTypeTrueCache;                     
                }
                s=tryPivotWindowsAndAjustsValues(s, types[i]);
                // extras
                s=tryGetCurrentBuildNumberWindowsByOs(s, types[i]);
                s=tryGetKernellInLinuxByOs(s, types[i]);
                s=tryGetFirewallInWindowsByOs(s, types[i]);
                s=tryGetDefaultAudioInWindowsByOs(s, types[i]);
                s=tryGetRamGPUInWindowsByOs(s, types[i]);                
                s=s.replace("\r\n\r\n", "\r\n").replace("\n\n", "\n");
                osGetTypeFalseCache=s;
                return osGetTypeFalseCache;                     
            }
        }catch(Exception e){
            erroFatal("Erro 432424 " + e.toString());
        }
        return null;
    }

    public String tryGetRamGPUInWindowsByOs(String s, String type){
        if ( ! type.equals("Windows") )
            return s;

        String command="$qwMemorySize = (Get-ItemProperty -Path \"HKLM:\\SYSTEM\\ControlSet001\\Control\\Class\\{4d36e968-e325-11ce-bfc1-08002be10318}\\0*\" -Name HardwareInformation.qwMemorySize -ErrorAction SilentlyContinue).\"HardwareInformation.qwMemorySize\"\n" +
                        "[math]::round($qwMemorySize/1GB)";
        String retorno=runtimeExec(null, new String[]{"powershell", "-noprofile", "-c", "-"}, null, command.getBytes(), null);
        if ( retorno == null || retorno.equals("") )
            return s;
        return s+"GPU_Memory: " + retorno.trim() + " GB";
    }
    
    public String tryGetCurrentBuildNumberWindowsByOs(String s, String type){
        if ( ! type.equals("Windows") )
            return s;

        String retorno=runtimeExec(null, new String[]{"Reg", "Query", "HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion", "/v", "CurrentBuildNumber"}, null, null, null);
        if ( retorno == null || retorno.equals("") )
            return s;
        if ( retorno.split(" ").length <= 13 )
            return s;
        return s+"Build_OS: " + retorno.split(" ")[13];
    }
    
    public String tryPivotWindowsAndAjustsValues(String s, String type){
        String retorno="";
        String DeviceID_FreeSpace_Size="";
        if ( ! type.equals("Windows") )
            return s;
        String [] partes=s.split("\r\n\r\n");
        ArrayList<String> elementos=new ArrayList<String>();
        for ( int i=0;i<partes.length;i++ ){
            String [] partes2=partes[i].split("\r\n");
            for ( int j=1;j<partes2.length;j++ ){
                elementos.addAll(getPivot(partes2[0]+"\r\n"+partes2[j], "\r\n"));
            }
        }
        for ( int i=0;i<elementos.size();i++ ){
            String tmp=elementos.get(i);            
            if ( tmp.startsWith("DeviceID: ") ){
                String value=tmp.substring("DeviceID: ".length()).replace(":", "").trim();                
                DeviceID_FreeSpace_Size="Drive "+value;
                //retorno+=tmp+"\r\n";
                continue;
            }
            if ( tmp.startsWith("FreeSpace: ") ){
                String value=tmp.substring("FreeSpace: ".length());
                tmp="FreeSpace: "+value;
                //retorno+=tmp+"\r\n";
                DeviceID_FreeSpace_Size+=" "+value;
                continue;
            }
            if ( tmp.startsWith("Size: ") ){
                String value=tmp.substring("Size: ".length());
                tmp="Size: "+value;
                DeviceID_FreeSpace_Size+=" "+value;
                String [] FDS_partes=DeviceID_FreeSpace_Size.split(" ");                                        
                if ( FDS_partes.length > 3 ){
                    retorno+=FDS_partes[0]
                            +" "+FDS_partes[1]
                            +" "+porcentagem(Long.parseLong(FDS_partes[3])-Long.parseLong(FDS_partes[2]), Long.parseLong(FDS_partes[3]))
                            +" "+valor_to_text(Long.parseLong(FDS_partes[3])-Long.parseLong(FDS_partes[2]), false)
                            +"/"
                            +valor_to_text(Long.parseLong(FDS_partes[3]), false)
                            +"\r\n";                    
                }else{
                    retorno+=FDS_partes[0]
                        +" "+FDS_partes[1]
                        +"\r\n";
                }
                continue;
            }
            if ( tmp.startsWith("UserName: ") && !retorno.contains("UserName: ")){
                String value=tmp.substring("UserName: ".length());
                tmp="UserName: "+value;
                retorno+=tmp+"\r\n";
                continue;
            }
            if ( tmp.startsWith("L3CacheSize: ") && !retorno.contains("CACHE_L3: ")){
                String value=tmp.substring("L3CacheSize: ".length());
                tmp="CACHE_L3: "+bytes_to_text(Long.parseLong(value)*1024);
                retorno+=tmp+"\r\n";
                continue;
            }
            if ( tmp.startsWith("TotalPhysicalMemory: ") && !retorno.contains("CPU_Memory: ")){
                String value=tmp.substring("TotalPhysicalMemory: ".length());
                tmp="CPU_Memory: "+bytes_to_text(Long.parseLong(value));
                retorno+=tmp+"\r\n";
                continue;
            }
            // bugado só mostra até 4giga
            /*
            if ( tmp.startsWith("AdapterRAM: ") ){ // bugado só mostra até 4giga
                String value=tmp.substring("AdapterRAM: ".length());
                tmp="TotalPhysicalMemoryGPU: "+bytes_to_text(Long.parseLong(value));
                retorno+=tmp+"\r\n";
                continue;
            } 
            */
            if ( tmp.startsWith("Caption: ") && !retorno.contains("OS: ")){
                String value=tmp.substring("Caption: ".length());
                tmp="OS: " +value;
                retorno+=tmp+"\r\n";
                continue;
            }
            if ( tmp.startsWith("Caption: ") && !tmp.equals("Caption: Microsoft Remote Display Adapter") ){
                String value=tmp.substring("Caption: ".length());
                tmp="GPU: " +value;
                retorno+=tmp+"\r\n";
                continue;
            }
            if ( tmp.startsWith("LoadPercentage: ") && !retorno.contains("CPU_Usage: ")){
                String value=tmp.substring("LoadPercentage: ".length());
                tmp="CPU_Usage: " +value+"%";
                retorno+=tmp+"\r\n";
                continue;
            }
            if ( tmp.startsWith("Name: ") && !retorno.contains("CPU: ")){
                String value=tmp.substring("Name: ".length());
                value=value.replaceAll("Intel\\(R\\) Core\\(TM\\) ", "Intel ").replaceAll(" CPU @ ", " ");
                tmp="CPU: " +value;
                retorno+=tmp+"\r\n";
                continue;
            }
            if ( tmp.startsWith("ThreadCount: ") && !retorno.contains("CPU_Threads: ")){
                String value=tmp.substring("ThreadCount: ".length());
                tmp="CPU_Threads: " +value;
                retorno+=tmp+"\r\n";
                continue;
            }
        }
        return retorno;
    }
    
    public String tryGetKernellInLinuxByOs(String s, String type){
        if ( ! type.equals("Linux") )
            return s;
        if ( ! s.contains("Distributor ID:\tUbuntu") )
            return s;
        String tmp=runtimeExec("uname -r", null, null, null, null);
        if ( tmp == null )
            return s;
        return s+"Kernell:\t" + tmp;       
    }
            
    public String tryGetFirewallInWindowsByOs(String s, String type){
        if ( ! type.equals("Windows") )
            return s;
        String tmp=runtimeExec("netsh advfirewall show allprofiles state", null, null, null, null);
        if ( tmp == null )
            return s;        
        String [] partes=tmp.split("\n");
        if ( partes.length < 13 )
            return s;
        if ( partes[2].length() < 2 || !partes[2].substring(0, 1).equals("-") )
            return s;    
        String p1=partes[7].substring(15).trim();
        String p2=partes[7].substring(15).trim();
        if ( !p1.equals("Desligado") && !p1.equals("Ligado") && !p1.equals("ON") && !p1.equals("OFF") )
            return s+"Firewall: ?";
        if ( !p2.equals("Desligado") && !p2.equals("Ligado") && !p2.equals("ON") && !p2.equals("OFF") )
            return s+"Firewall: ?";
        if ( p1.equals("Ligado") || p1.equals("ON") || p2.equals("Ligado") || p2.equals("ON") )
            return s+"Firewall: On";
        return s+"Firewall: Off";
    }

    public String tryGetDefaultAudioInWindowsByOs(String s, String type){
        if ( ! type.equals("Windows") )
            return s;
        return s+"\n"+getDefaultAudioWindows();
    }
    
    public boolean isSymbolicLink(File f){
        java.nio.file.Path ab_path=f.toPath().toAbsolutePath();
        java.nio.file.Path parent_path=ab_path.getParent();
        java.nio.file.Path real_path=null;
        int n=0;
        try{
            n=1;
            if ( Files.isSymbolicLink(f.toPath()) ){
                n=2;
                return true;
            }
            n=3;
            try{
                real_path=ab_path.toRealPath();
            }catch(Exception e){
                return false;
            }
            if ( !isWindows() ){
                n=4;
                return false;
            }
            n=5;
            if ( !ab_path.toString().toUpperCase().equals(parent_path.toString().toUpperCase()) ){
                n=6;
                if ( real_path.toString().toUpperCase().equals( (parent_path.toRealPath().toString()+"\\"+f.getName()).toUpperCase() )){
                    n=7;
                    return false;
                }
            }
            n=8;
            if ( !ab_path.toString().toUpperCase().equals(real_path.toString().toUpperCase()) ){
                n=9;
                return true;
            }
        }catch(Exception e){
            erroFatal("Error isSymbolicLink " + ab_path + " - internal_step: " + n);
        }
        return false;
    }
    
    public boolean isWindows(){
        return os(true).equals("Windows");
    }

    public boolean isFfmpeg(){
        runtimeExec("ffmpeg.exe", null, null, null, null);
        return runtimeExecError.startsWith("ffmpeg version");
    }

    public String getMixerGuidWindows(){ // ex: Microfone (HUSKY)#{0.0.1.00000000}.{0b216a1a-1a07-420d-b569-db728eb036cf}
        String s=runtimeExec("pnputil /enum-devices /connected", null, null, null, null);
        if ( runtimeExecError != null && !runtimeExecError.equals("") )
            return runtimeExecError;        
        String [] partes=s.split("\n");        
        s="";
        int count=0;
        String id="";
        String name="";
        for ( int i=0;i<partes.length;i++ ){
            if ( partes[i].length() == 0 ){
                count=0;
                continue;
            }
            count++;
            if ( count == 1 ){
                if ( partes[i].length() > 30 ){
                    id=partes[i].substring(30).trim();
                    int p=id.indexOf("{");
                    if ( p > -1 )
                        id=id.substring(p);                    
                }else
                    id="id";
                continue;
            }
            if ( count == 2 ){
                if ( partes[i].length() > 30 )
                    name=partes[i].substring(30).trim();
                else
                    name="name";
                continue;
            }
            if ( count == 3 && partes[i].length() > 30 && partes[i].substring(30).trim().equals("AudioEndpoint") ){
                s+=name+"#"+id+"\n";
                continue;
            }
        }
        return s;
    }
    
    public String getMixerGuidWindowsWithRegedit(){ // comando depreciado.. use o getMixerGuidWindows()
        String retorno="";
        String [] commands=new String[]{"Get-ChildItem -Path \"HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\MMDevices\\Audio\\Render\" -recurse", 
                                        "Get-ChildItem -Path \"HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\MMDevices\\Audio\\Capture\" -recurse"};
        for ( int j=0;j<commands.length;j++ ){                                
            String s=runtimeExec(null, new String[]{"powershell", "-noprofile", "-c", "-"}, null, commands[j].getBytes(), null);
            if ( s == null || s.equals("") )
                erroFatal(runtimeExecError);
            String [] partes=s.split("\n");
            String p1=null;
            String p2=null;
            for ( int i=0;i<partes.length;i++ ){
                if ( partes[i].contains("Render\\") || partes[i].contains("Capture\\") ){
                    p1=null;
                    p2=null;
                    continue;
                }
                if ( partes[i].contains("{a45c254e-df1c-4efd-8020-67d146a850e0},2 ") ){
                    p1=partes[i].split(":")[1].trim();
                    continue;
                }
                if ( partes[i].contains("{b3f8fa53-0004-438e-9003-51a46e139bfc},6 ") ){
                    p2=partes[i].split(":")[1].trim();
                    continue;
                }
                if ( partes[i].contains("MMDEVAPI#{0.0.0.00000000}") || partes[i].contains("MMDEVAPI#{0.0.1.00000000}") ){
                    if ( p1 == null || p2 == null ){
                        p1=null;
                        p2=null;
                        continue;
                    }
                    retorno+=p1 + " (" + p2 + ")#" + partes[i].split("#")[2]+"\n";
                }
            }
        }
        return retorno;
    }
    
    public String getDefaultAudioWindows(){
        String text="Add-Type @'\n" +
            "[Guid(\"D666063F-1587-4E43-81F1-B948E807363F\"), InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]\n" +
            "interface IMMDevice {\n" +
            "    int a(); int o();\n" +
            "    int GetId([MarshalAs(UnmanagedType.LPWStr)] out string id);\n" +
            "}\n" +
            "[Guid(\"A95664D2-9614-4F35-A746-DE8DB63617E6\"), InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]\n" +
            "interface IMMDeviceEnumerator {\n" +
            "    int f();\n" +
            "    int GetDefaultAudioEndpoint(int dataFlow, int role, out IMMDevice endpoint);\n" +
            "}\n" +
            "[ComImport, Guid(\"BCDE0395-E52F-467C-8E3D-C4579291692E\")] class MMDeviceEnumeratorComObject { }\n" +
            "\n" +
            "public static string GetDefault (int direction) {\n" +
            "    var enumerator = new MMDeviceEnumeratorComObject() as IMMDeviceEnumerator;\n" +
            "    IMMDevice dev = null;\n" +
            "    Marshal.ThrowExceptionForHR(enumerator.GetDefaultAudioEndpoint(direction, 1, out dev));\n" +
            "    string id = null;\n" +
            "    Marshal.ThrowExceptionForHR(dev.GetId(out id));\n" +
            "    return id;\n" +
            "}\n" +
            "'@ -name audio -Namespace system\n" +
            "\n" +
            "function getFriendlyName($id) {\n" +
            "    $reg = \"HKLM:\\SYSTEM\\CurrentControlSet\\Enum\\SWD\\MMDEVAPI\\$id\"\n" +
            "    return (get-ItemProperty $reg).FriendlyName\n" +
            "}\n" +
            "\n" +
            "$id0 = [audio]::GetDefault(0)\n" +
            "$id1 = [audio]::GetDefault(1)\n" +
            "write-host \"Default Speaker: $(getFriendlyName $id0)\" \n" +
            "write-host \"Default Micro: $(getFriendlyName $id1)\""; 
        String s=runtimeExec(null, new String[]{"powershell", "-noprofile", "-c", "-"}, null, text.getBytes(), null);
        if ( s == null || s.equals("") )
            return "";//erroFatal(runtimeExecError);
        return s;
    }
    
    
    public boolean isWindowsAdm(){
        return os(true).equals("Windows") && runtimeExec("reg add HKEY_CLASSES_ROOT\\tmp\\y -f", null, null, null, null) != null;
    }
    
    public boolean isLinux(){
        return os(true).equals("Linux");
    }
    
    public boolean isMac(){
        return os(true).equals("Mac");
    }
    
    public static String [] listWordEnv = new String [] {"STATUS_FIM_Y","COUNT_Y","CSV_SEP_Y","CSV_ONLYCHAR_Y",
            "FORMAT_DATA_Y","COM_SEPARADOR_FINAL_CSV_Y","SEM_HEADER_CSV_Y","TOKEN_Y","ORAs_Y","var"};  
    private static String [] listEnv = null;
    public String[] initEnvByParm(String[] args) {
        ArrayList lista=new ArrayList<String>();
        for ( int i=0;i<args.length;i++ ){
            boolean achou=false;
            if ( args[i].equals("-ignore") && i+1 < args.length ){
                i++;
                continue;
            }                            
            for ( int j=0;j<listWordEnv.length;j++ ){
                if ( args[i].equals("-"+listWordEnv[j]) && i+1 < args.length ){
                    setEnv(listWordEnv[j], args[i+1]);
                    i++;
                    achou=true;
                    break;
                }
            }
            if ( achou )
                continue;
            lista.add(args[i]);
        }  
        return arrayList_to_array(lista);
    }

    public static void setEnv(String env, String value) {
        for ( int i=0;i<listWordEnv.length;i++ ){
            if ( listWordEnv[i].equals(env) ){
                if ( listEnv == null )
                    listEnv = new String[listWordEnv.length];
                listEnv[i] = value;
                return;
            }
        }
        erroFatal(70);
    }

    public static String getEnv(String env) {
        for ( int i=0;i<listWordEnv.length;i++ ){
            if ( listWordEnv[i].equals(env) ){
                if ( listEnv != null && listEnv[i] != null ){
                    return listEnv[i];
                }
                return System.getenv(env);
            }
        }
        erroFatal(71);
        return null;
    }
    
    // %z no linux significa -0300, aqui esta sendo usado para empregar o zoneid America/Sao_Paulo    
    // no java, print de zzzz com zondeId America/Sao_Paulo sai Fuso horário de Brasília
    // lista de zoneid => java.time.ZoneId.getAvailableZoneIds()
    // modelo padrao 
    // System.out.println(date_("+%Y%m%d_%H%M%S", null, null, null));
    public String [] format_codes_date_in= new String []{"%z"  , "%d", "%m", "%Y",   "%H", "%M", "%S", "%N",  "%Z" };
    public String [] format_codes_date_out=new String []{"zzzz",  "dd", "MM", "yyyy", "HH", "mm", "ss", "SSS", "X"  };    
    public String format_america_sao_paulo_zoneid="America/Sao_Paulo";
    public String format_america_sao_paulo_zzzz=get_zzzz(format_america_sao_paulo_zoneid);
    public String date_(String format_out_, String date_from, String format_in_, String date_from_ntp) throws Exception{
        if ( date_from_ntp != null ){            
            date_from=getSecondsByNtp(date_from_ntp)+"";
            format_in_="+%s";
            date_from_ntp=null;
            return date_(format_out_, date_from, format_in_, date_from_ntp);
        }
        StringBuilder sb=new StringBuilder();
        String format_out="+%d/%m/%Y %H:%M:%S";
        if ( format_out_ != null )
            format_out=format_out_;
        if(format_out.startsWith("+"))
            format_out=format_out.substring(1);
        Date d = date_from_mask(date_from, format_in_);
        String w="";
        for(int i=0;i<format_out.length();i++){
            w+=format_out.substring(i, i+1);
            if( w.equals("%") )
                continue;
            boolean achou=false;
            for ( int j=0;j<format_codes_date_in.length;j++ ){
                if ( format_codes_date_in[j].equals(w) ){
                    achou=true;
                    sb.append(new SimpleDateFormat(format_codes_date_out[j]).format(d));
                    w="";
                    break;
                }
            }
            if ( achou )
                continue;            
            if(w.equals("%s")){
                sb.append(epoch(d));
                w="";
                continue;
            }
            sb.append(w);
            w="";
        }
        return sb.toString().replace(format_america_sao_paulo_zzzz,format_america_sao_paulo_zoneid);
    }
      
    public static String get_zzzz(String a){
        SimpleDateFormat out = new SimpleDateFormat("zzzz");
        out.setTimeZone(java.util.TimeZone.getTimeZone(a));
        return out.format(new Date());
    }
    
    public Date date_from_mask(String date_, String format){ // y date "+%s%N" from "20240625_102251_345_-03" mask "+%Y%m%d_%H%M%S_%N_%Z"
        if ( date_ == null || format == null )
            return new Date();
        if ( format.startsWith("\\+") )
            erroFatal("mask invalida! " + format);        
        format=format.substring(1);        
        if ( format.equals("%s") || format.equals("%s%N") ){
            Long tmp=Long.parseLong(date_);
            if ( tmp < 1000000000000L )
                tmp*=1000;
            return new Date(tmp);
        }
        for ( int i=0;i<format_codes_date_in.length;i++ )
            format=format.replace(format_codes_date_in[i], format_codes_date_out[i]);        
        try{
            return new SimpleDateFormat( format ).parse(date_.replace(format_america_sao_paulo_zoneid,format_america_sao_paulo_zzzz));
        }catch(Exception e){
            erroFatal("Erro format " + e.toString() + " date_:" + date_ + " format: " + format);
        }
        return null;
    }
    
    public static long epoch(Date d) {
        return Long.parseLong((epochmili(d)+"").substring(0,10));                
    }
    
    public static long epochmili(Date d){
        if ( d == null )
            d = new Date();        
        return d.toInstant().toEpochMilli();
    }
    
    public static String get_ip_origem_by_socket(Socket credencialSocket){        
        String ip_origem=credencialSocket.getRemoteSocketAddress().toString().substring(1);
        if ( ip_origem.contains(":") ){
            int p=ip_origem.length()-1;
            while(ip_origem.charAt(p--) != ':'){}
            return ip_origem.substring(0,p+1);
        }        
        return ip_origem;
    }

    public static boolean ip_banido(String ips_banidos, String ip_origem){
        String [] banidos=ips_banidos.split(",");
        for ( int i=0;i<banidos.length;i++){
            if ( banidos[i].equals(ip_origem) )
                return true;
            if ( banidos[i].startsWith("::") && ip_origem.endsWith(banidos[i].substring(2)) )
                return true;
            if ( banidos[i].endsWith("::") && ip_origem.startsWith(banidos[i].substring(0,banidos[i].length()-2)) )
                return true;
        }
        return false;
    }
    
    private static int identify_log=0; // 1 -> File, 2 -> POST    
    private static FileWriter cache_log=null;    
    public void log_serverRouter(String log, Boolean noLogLocal, String ip_origem, boolean banido){
        String tag_ip=" ip: ";
        if ( banido )
            tag_ip=" ip BANIDO: ";
        if ( identify_log == 0 ){
            if(log.toUpperCase().startsWith("HTTP"))
                identify_log=2;
            else{
                identify_log=1;
                try{
                    cache_log=new FileWriter(log,true);
                }catch(Exception e){
                    erroFatal("Error " + 55 + " " + e.toString() + " Path: " + log);
                }
            }
        }
        if ( identify_log == 1 ){
            try{
                if ( !noLogLocal || !ip_origem.contains(":0:0:0:") ){
                    cache_log.write(date_(null, null, null, null));
                    cache_log.write(tag_ip);
                    cache_log.write(ip_origem);
                    cache_log.write("\n");
                    cache_log.flush();
                }
            }catch(Exception e){
                System.out.println(e.toString());
                erroFatal(56);
            }
        }else{
            System.out.println("Nao implementado!");
            erroFatal(57);
        }
    }
        
    public static void erroFatal(int n) {
        erroFatal("Erro Fatal " + n + "!!!!");
    }    
    
    public static void erroFatal(String a) {
        System.err.println(a);
        System.exit(1);
    }    
    
    public static void erroFatal(Exception e){
        System.err.println(e.toString());
        System.exit(1);
    }
    
	//REMOVED_GRAAL_START
    public void loadClassByBytes(java.util.HashMap classes, String principal, String [] args_){
        try{ 
            ClassLoader classLoader=new ClassLoader() {            
                @Override protected Class<?> findClass(String name) 
                throws ClassNotFoundException { 
                    if ( classes.containsKey(name) ){ 
                        try { 
                            byte[] data=base64_S_B((String)classes.get(name),false);
                            return defineClass(name,data,0,data.length);        
                        }catch(Exception e){ 
                            System.err.println("Erro no carregamento da classe "+name); 
                            System.exit(1); 
                        } 
                    } 
                    return super.findClass(name); 
                } 
            }; 
            Class c=classLoader.loadClass(principal); 
            java.lang.reflect.Method method=c.getDeclaredMethod("main", String[].class );
            method.invoke(null, new Object[]{ args_ } ); 
        }catch(Exception e){ 
            System.err.println("Erro " + e.toString());
            System.exit(1);
        } 
    }
    //REMOVED_GRAAL_END    
    //REMOVED_GRAAL_START
    public void loadDisableControlC(String [] args){
        //https://rosettacode.org/wiki/Handle_a_signal#Java
        /*
        import sun.misc.Signal;
        import sun.misc.SignalHandler;
        public class DisableControlC {
            public static void main(String [] args) throws InterruptedException {
                Signal.handle(new Signal("INT"), new SignalHandler() {
                    public void handle(Signal sig) {
                        if(args.length > 0 && args[0] != null )
                            System.out.print(args[0]);
                        if(args.length > 1)
                            args[1]="1";
                    }
                }
            );
          }
        }
        */
        java.util.HashMap classes=new java.util.HashMap(); 
        String principal="DisableControlC";
        //classes.put("DisableControlC","yv66vgAAADQAIQoACQAVBwAWCAAXCgACABgHABkKAAUAFQoAAgAaBwAbBwAcAQAMSW5uZXJDbGFzc2VzAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEABG1haW4BABYoW0xqYXZhL2xhbmcvU3RyaW5nOylWAQAKRXhjZXB0aW9ucwcAHQEAClNvdXJjZUZpbGUBABREaXNhYmxlQ29udHJvbEMuamF2YQwACwAMAQAPc3VuL21pc2MvU2lnbmFsAQADSU5UDAALAB4BABFEaXNhYmxlQ29udHJvbEMkMQwAHwAgAQAPRGlzYWJsZUNvbnRyb2xDAQAQamF2YS9sYW5nL09iamVjdAEAHmphdmEvbGFuZy9JbnRlcnJ1cHRlZEV4Y2VwdGlvbgEAFShMamF2YS9sYW5nL1N0cmluZzspVgEABmhhbmRsZQEAQyhMc3VuL21pc2MvU2lnbmFsO0xzdW4vbWlzYy9TaWduYWxIYW5kbGVyOylMc3VuL21pc2MvU2lnbmFsSGFuZGxlcjsAIQAIAAkAAAAAAAIAAQALAAwAAQANAAAAHQABAAEAAAAFKrcAAbEAAAABAA4AAAAGAAEAAAADAIkADwAQAAIADQAAADEAAwABAAAAFbsAAlkSA7cABLsABVm3AAa4AAdXsQAAAAEADgAAAAoAAgAAAAUAFAAJABEAAAAEAAEAEgACABMAAAACABQACgAAAAoAAQAFAAAAAAAI");    
        //classes.put("DisableControlC$1","yv66vgAAADQAGAoAAwAQBwARBwATBwAUAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEABmhhbmRsZQEAFChMc3VuL21pc2MvU2lnbmFsOylWAQAKU291cmNlRmlsZQEAFERpc2FibGVDb250cm9sQy5qYXZhAQAPRW5jbG9zaW5nTWV0aG9kBwAVDAAWABcMAAUABgEAEURpc2FibGVDb250cm9sQyQxAQAMSW5uZXJDbGFzc2VzAQAQamF2YS9sYW5nL09iamVjdAEAFnN1bi9taXNjL1NpZ25hbEhhbmRsZXIBAA9EaXNhYmxlQ29udHJvbEMBAARtYWluAQAWKFtMamF2YS9sYW5nL1N0cmluZzspVgAwAAIAAwABAAQAAAACAAAABQAGAAEABwAAAB0AAQABAAAABSq3AAGxAAAAAQAIAAAABgABAAAABQABAAkACgABAAcAAAAZAAAAAgAAAAGxAAAAAQAIAAAABgABAAAABwADAAsAAAACAAwADQAAAAQADgAPABIAAAAKAAEAAgAAAAAACA==");
        //classes.put("DisableControlC","yv66vgAAADQAIgoACQAVBwAWCAAXCgACABgHABkKAAUAGgoAAgAbBwAcBwAdAQAMSW5uZXJDbGFzc2VzAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEABG1haW4BABYoW0xqYXZhL2xhbmcvU3RyaW5nOylWAQAKRXhjZXB0aW9ucwcAHgEAClNvdXJjZUZpbGUBABREaXNhYmxlQ29udHJvbEMuamF2YQwACwAMAQAPc3VuL21pc2MvU2lnbmFsAQADSU5UDAALAB8BABFEaXNhYmxlQ29udHJvbEMkMQwACwAQDAAgACEBAA9EaXNhYmxlQ29udHJvbEMBABBqYXZhL2xhbmcvT2JqZWN0AQAeamF2YS9sYW5nL0ludGVycnVwdGVkRXhjZXB0aW9uAQAVKExqYXZhL2xhbmcvU3RyaW5nOylWAQAGaGFuZGxlAQBDKExzdW4vbWlzYy9TaWduYWw7THN1bi9taXNjL1NpZ25hbEhhbmRsZXI7KUxzdW4vbWlzYy9TaWduYWxIYW5kbGVyOwAhAAgACQAAAAAAAgABAAsADAABAA0AAAAdAAEAAQAAAAUqtwABsQAAAAEADgAAAAYAAQAAAAMACQAPABAAAgANAAAAMgAEAAEAAAAWuwACWRIDtwAEuwAFWSq3AAa4AAdXsQAAAAEADgAAAAoAAgAAAAUAFQALABEAAAAEAAEAEgACABMAAAACABQACgAAAAoAAQAFAAAAAAAI");    
        //classes.put("DisableControlC$1","yv66vgAAADQAKQkABQAWCgAGABcJABgAGQoAGgAbBwAcBwAeBwAfAQAIdmFsJGFyZ3MBABNbTGphdmEvbGFuZy9TdHJpbmc7AQAGPGluaXQ+AQAWKFtMamF2YS9sYW5nL1N0cmluZzspVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBAAZoYW5kbGUBABQoTHN1bi9taXNjL1NpZ25hbDspVgEADVN0YWNrTWFwVGFibGUBAApTb3VyY2VGaWxlAQAURGlzYWJsZUNvbnRyb2xDLmphdmEBAA9FbmNsb3NpbmdNZXRob2QHACAMACEACwwACAAJDAAKACIHACMMACQAJQcAJgwAJwAoAQARRGlzYWJsZUNvbnRyb2xDJDEBAAxJbm5lckNsYXNzZXMBABBqYXZhL2xhbmcvT2JqZWN0AQAWc3VuL21pc2MvU2lnbmFsSGFuZGxlcgEAD0Rpc2FibGVDb250cm9sQwEABG1haW4BAAMoKVYBABBqYXZhL2xhbmcvU3lzdGVtAQADb3V0AQAVTGphdmEvaW8vUHJpbnRTdHJlYW07AQATamF2YS9pby9QcmludFN0cmVhbQEABXByaW50AQAVKExqYXZhL2xhbmcvU3RyaW5nOylWADAABQAGAAEABwABEBAACAAJAAAAAgAAAAoACwABAAwAAAAiAAIAAgAAAAoqK7UAASq3AAKxAAAAAQANAAAABgABAAAABQABAA4ADwABAAwAAABIAAMAAgAAAB8qtAABvgSgABgqtAABAzLGAA+yAAMqtAABAzK2AASxAAAAAgANAAAADgADAAAABwASAAgAHgAJABAAAAADAAEeAAMAEQAAAAIAEgATAAAABAAUABUAHQAAAAoAAQAFAAAAAAAI");
        classes.put("DisableControlC","yv66vgAAADQAIgoACQAVBwAWCAAXCgACABgHABkKAAUAGgoAAgAbBwAcBwAdAQAMSW5uZXJDbGFzc2VzAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEABG1haW4BABYoW0xqYXZhL2xhbmcvU3RyaW5nOylWAQAKRXhjZXB0aW9ucwcAHgEAClNvdXJjZUZpbGUBABREaXNhYmxlQ29udHJvbEMuamF2YQwACwAMAQAPc3VuL21pc2MvU2lnbmFsAQADSU5UDAALAB8BABFEaXNhYmxlQ29udHJvbEMkMQwACwAQDAAgACEBAA9EaXNhYmxlQ29udHJvbEMBABBqYXZhL2xhbmcvT2JqZWN0AQAeamF2YS9sYW5nL0ludGVycnVwdGVkRXhjZXB0aW9uAQAVKExqYXZhL2xhbmcvU3RyaW5nOylWAQAGaGFuZGxlAQBDKExzdW4vbWlzYy9TaWduYWw7THN1bi9taXNjL1NpZ25hbEhhbmRsZXI7KUxzdW4vbWlzYy9TaWduYWxIYW5kbGVyOwAhAAgACQAAAAAAAgABAAsADAABAA0AAAAdAAEAAQAAAAUqtwABsQAAAAEADgAAAAYAAQAAAAMACQAPABAAAgANAAAAMgAEAAEAAAAWuwACWRIDtwAEuwAFWSq3AAa4AAdXsQAAAAEADgAAAAoAAgAAAAUAFQAOABEAAAAEAAEAEgACABMAAAACABQACgAAAAoAAQAFAAAAAAAI");
        classes.put("DisableControlC$1","yv66vgAAADQAKwkABgAXCgAHABgJABkAGgoAGwAcCAAdBwAeBwAgBwAhAQAIdmFsJGFyZ3MBABNbTGphdmEvbGFuZy9TdHJpbmc7AQAGPGluaXQ+AQAWKFtMamF2YS9sYW5nL1N0cmluZzspVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBAAZoYW5kbGUBABQoTHN1bi9taXNjL1NpZ25hbDspVgEADVN0YWNrTWFwVGFibGUBAApTb3VyY2VGaWxlAQAURGlzYWJsZUNvbnRyb2xDLmphdmEBAA9FbmNsb3NpbmdNZXRob2QHACIMACMADAwACQAKDAALACQHACUMACYAJwcAKAwAKQAqAQABMQEAEURpc2FibGVDb250cm9sQyQxAQAMSW5uZXJDbGFzc2VzAQAQamF2YS9sYW5nL09iamVjdAEAFnN1bi9taXNjL1NpZ25hbEhhbmRsZXIBAA9EaXNhYmxlQ29udHJvbEMBAARtYWluAQADKClWAQAQamF2YS9sYW5nL1N5c3RlbQEAA291dAEAFUxqYXZhL2lvL1ByaW50U3RyZWFtOwEAE2phdmEvaW8vUHJpbnRTdHJlYW0BAAVwcmludAEAFShMamF2YS9sYW5nL1N0cmluZzspVgAwAAYABwABAAgAARAQAAkACgAAAAIAAAALAAwAAQANAAAAIgACAAIAAAAKKiu1AAEqtwACsQAAAAEADgAAAAYAAQAAAAUAAQAPABAAAQANAAAAYQADAAIAAAAvKrQAAb6eABgqtAABAzLGAA+yAAMqtAABAzK2AAQqtAABvgSkAAsqtAABBBIFU7EAAAACAA4AAAAWAAUAAAAHABEACAAdAAkAJgAKAC4ACwARAAAABAACHRAAAwASAAAAAgATABQAAAAEABUAFgAfAAAACgABAAYAAAAAAAg=");
        loadClassByBytes(classes, principal, args);
    }
	//REMOVED_GRAAL_END
	
    public void sleepFloatSeconds(Float a){
        sleepMillis((long)(a*1000));  
    }
    
    public void sleepSeconds(int seconds){
        sleepMillis((long)(seconds*1000));        
    }

    public void sleepSeconds(long seconds){
        sleepMillis(seconds*1000);        
    }

    public void sleepMillis(long mili){
        try {Thread.sleep(mili);} catch (InterruptedException e) { }  
    }
    
    java.awt.Robot robot_local=null;
    public java.awt.Robot robotGet() throws Exception{
        if ( robot_local == null )
            robot_local=new java.awt.Robot();
        return robot_local;
    }

    ///////////////
    public void bmp_salvarRecorte(
            byte[] bmpBytes,
            int cropX1,
            int cropY1,
            int cropX2,
            int cropY2,
            String outputPath
    )throws IOException{

        // ----- LER WIDTH E HEIGHT -----
        int width = bmp_salvarRecorte_readIntLE(bmpBytes, 18);
        int height = bmp_salvarRecorte_readIntLE(bmpBytes, 22);

        boolean originalTopDown = height < 0;
        int absHeight = Math.abs(height);

        // Bits por pixel
        int bpp = bmp_salvarRecorte_readShortLE(bmpBytes, 28);
        if (bpp != 24)
            throw new IOException("Apenas BMP 24 bits sem compressão são suportados.");

        // ----- PARÂMETROS -----
        int cropWidth  = cropX2 - cropX1;
        int cropHeight = cropY2 - cropY1;

        int originalRowSize = (width * 3 + 3) & ~3;
        int croppedRowSize  = (cropWidth * 3 + 3) & ~3;

        int croppedImageSize = croppedRowSize * cropHeight;
        int fileSize = 54 + croppedImageSize;

        ByteArrayOutputStream out = new ByteArrayOutputStream();
        DataOutputStream dos = new DataOutputStream(out);

        // ----- BMP HEADER -----
        dos.writeBytes("BM");
        dos.writeInt(Integer.reverseBytes(fileSize));
        dos.writeInt(0);
        dos.writeInt(Integer.reverseBytes(54));

        // ----- DIB HEADER -----
        dos.writeInt(Integer.reverseBytes(40));
        dos.writeInt(Integer.reverseBytes(cropWidth));

        // GRAVAR SEMPRE TOP-DOWN (altura negativa)
        dos.writeInt(Integer.reverseBytes(-cropHeight));

        dos.writeShort(Short.reverseBytes((short) 1));
        dos.writeShort(Short.reverseBytes((short) 24));
        dos.writeInt(0);
        dos.writeInt(Integer.reverseBytes(croppedImageSize));
        dos.writeInt(Integer.reverseBytes(2835));
        dos.writeInt(Integer.reverseBytes(2835));
        dos.writeInt(0);
        dos.writeInt(0);

        // ----- COPIAR PIXELS -----

        byte[] padding = new byte[croppedRowSize - cropWidth * 3];

        for (int y = 0; y < cropHeight; y++) {

            int sourceY;

            if (originalTopDown) {
                // → BMP original já é top-down
                sourceY = cropY1 + y;
            } else {
                // → BMP original é bottom-up
                sourceY = absHeight - 1 - (cropY1 + y);
            }

            int origem = 54 + sourceY * originalRowSize + cropX1 * 3;

            dos.write(bmpBytes, origem, cropWidth * 3);
            dos.write(padding);
        }

        try (FileOutputStream fos = new FileOutputStream(outputPath)) {
            fos.write(out.toByteArray());
        }
    }

/*
            255,255,255
255,255,255 232,232,233 232,232,233
            221,221,222
    
255,255,255 255,255,255 255,255,255 
255,255,255 232,232,233 232,232,233 
255,255,255 221,220,222 222,221,223     

255,255,255 255,255,255 255,255,255
255,255,255 232,232,233 232,232,233
255,255,255 221,220,222 222,221,223    

 255,255,255 255,255,255 255,255,255
 255,255,255 233,232,233 233,232,233
 255,255,255 222,221,222 223,222,223    

255,255,255 255,255,255 255,255,255
255,255,255 233,232,233 233,232,233
255,255,255 222,221,222 223,222,223

255,255,255 255,255,255 255,255,255
255,255,255 233,232,233 233,232,233
255,255,255 222,221,222 223,222,223   
    */

    public int[] bmp_findCardXY(
            byte[] bmpBytes
    ) {
        ArrayList<Integer> resultados = new ArrayList<Integer>();

        // ----------- LER HEADER -----------
        int width  = encontrarPadroes_readIntLE(bmpBytes, 18);
        int height = encontrarPadroes_readIntLE(bmpBytes, 22);
        int bpp    = encontrarPadroes_readShortLE(bmpBytes, 28);

        if (bpp != 24)
            throw new RuntimeException("Somente BMP 24 bits sem compressão.");

        int pixelDataOffset = encontrarPadroes_readIntLE(bmpBytes, 10);
        int rowSize = (width * 3 + 3) & ~3; // alinhamento de 4 bytes

        // Função para ler RGB de um ponto (x,y) em BMP invertido
        class Pix {
            int[] get(int x, int y) {
                // y invertido
                int realY = (height - 1 - y);
                int index = pixelDataOffset + realY * rowSize + x * 3;
                int b = bmpBytes[index] & 0xFF;
                int g = bmpBytes[index + 1] & 0xFF;
                int r = bmpBytes[index + 2] & 0xFF;
                return new int[]{r, g, b};
            }
        }

        Pix pix = new Pix();

        // ----------- VARREDURA COMPLETA -----------
        for (int y = 1; y < height - 1; y++) {
            for (int x = 1; x < width - 1; x++) {

                int[] centro = pix.get(x, y);
                int[] cima   = pix.get(x, y - 1);
                int[] baixo  = pix.get(x, y + 1);
                int[] esq    = pix.get(x - 1, y);
                int[] dir    = pix.get(x + 1, y);

                if (
                    (        
                           (centro[0] == 232 || centro[0] == 233)
                        && (centro[1] == 232 || centro[1] == 233)
                        && (centro[2] == 232 || centro[2] == 233)
                    ) &&                        
                    encontrarPadroes_match(cima,   255,255,255) &&
                    encontrarPadroes_match(esq,    255,255,255) &&
                    (        
                           (dir[0] == 232 || dir[0] == 233)
                        && (dir[1] == 232 || dir[1] == 233)
                        && (dir[2] == 232 || dir[2] == 233)
                    ) &&                        
                    (        
                           (baixo[0] == 220 || baixo[0] == 221 || baixo[0] == 222)
                        && (baixo[1] == 220 || baixo[1] == 221 || baixo[1] == 222)
                        && (baixo[2] == 220 || baixo[2] == 221 || baixo[2] == 222)
                    )
                    ){
                    resultados.add(x);
                    resultados.add(y);
                }
            }
        }
        if ( resultados.size() == 0 )        
            return new int[]{};
        return arrayList_to_array_int(resultados);
    }

    // ------- Função auxiliar p/ comparar RGB ------
    private boolean encontrarPadroes_match(int[] rgb, int r, int g, int b) {
        return rgb[0] == r && rgb[1] == g && rgb[2] == b;
    }

    // ------- Funções LE já conhecidas -------
    public int encontrarPadroes_readIntLE(byte[] data, int offset) {
        return (data[offset] & 0xFF) |
                ((data[offset + 1] & 0xFF) << 8) |
                ((data[offset + 2] & 0xFF) << 16) |
                ((data[offset + 3] & 0xFF) << 24);
    }

    public short encontrarPadroes_readShortLE(byte[] data, int offset) {
        return (short) ((data[offset] & 0xFF) |
                ((data[offset + 1] & 0xFF) << 8));
    }

    /*
    retorno
255,255,255 255,255,255 255,255,255 255,255,255 255,255,255 255,255,255 255,255,255
255,255,255 255,255,255 255,255,255 255,255,255 255,255,255 255,255,255 255,255,255
255,255,255 255,255,255 255,255,255 255,255,255 255,255,255 255,255,255 255,255,255
255,255,255 255,255,255 255,255,255 255,255,255 232,232,233 232,232,233 232,232,233
255,255,255 255,255,255 255,255,255 255,255,255 221,221,222 222,222,223 224,224,225
255,255,255 255,255,255 255,255,255 255,255,255 221,221,222 237,237,237 255,255,255
255,255,255 255,255,255 255,255,255 255,255,255 221,221,222 237,237,237 255,255,255
255,255,255 255,255,255 255,255,255 255,255,255 221,221,222 237,237,237 255,255,255
255,255,255 255,255,255 255,255,255 255,255,255 221,221,222 237,237,237 255,255,255
    
    */
    public String bmp_dumpPixels(byte[] bmpBytes, int cropX1, int cropY1, int cropX2, int cropY2, boolean monocromatico) throws Exception{
        int dataOffset = ((bmpBytes[10] & 0xFF) |
                         ((bmpBytes[11] & 0xFF) << 8) |
                         ((bmpBytes[12] & 0xFF) << 16) |
                         ((bmpBytes[13] & 0xFF) << 24));
        int width = ((bmpBytes[18] & 0xFF) |
                    ((bmpBytes[19] & 0xFF) << 8) |
                    ((bmpBytes[20] & 0xFF) << 16) |
                    ((bmpBytes[21] & 0xFF) << 24));
        int height = ((bmpBytes[22] & 0xFF) |
                     ((bmpBytes[23] & 0xFF) << 8) |
                     ((bmpBytes[24] & 0xFF) << 16) |
                     ((bmpBytes[25] & 0xFF) << 24));
        boolean flipped = height > 0;
        height = Math.abs(height);
        int rowSize = ((width * 3 + 3) / 4) * 4;
        if (cropX1 < 0) cropX1 = 0;
        if (cropY1 < 0) cropY1 = 0;
        if (cropX2 > width) cropX2 = width;
        if (cropY2 > height) cropY2 = height;
        if (cropX2 <= cropX1 || cropY2 <= cropY1)
            throw new Exception("Recorte inválido.");

        int cropW = cropX2 - cropX1;
        int cropH = cropY2 - cropY1;
        StringBuilder sb = new StringBuilder();
        for (int y = 0; y < cropH; y++) {
            int srcY = flipped ? (height - 1 - (cropY1 + y)) : (cropY1 + y);
            int rowStart = dataOffset + srcY * rowSize;
            for (int x = 0; x < cropW; x++) {
                int pixelIndex = rowStart + (cropX1 + x) * 3;
                int b = bmpBytes[pixelIndex] & 0xFF;
                int g = bmpBytes[pixelIndex + 1] & 0xFF;
                int r = bmpBytes[pixelIndex + 2] & 0xFF;
                if ( monocromatico ){
                    if ( String.format("%03d,%03d,%03d", r, g, b).equals("255,255,255") )
                        sb.append("1");
                    else
                        sb.append("0");
                }else
                    sb.append(String.format("%03d,%03d,%03d", r, g, b));
                if (x < cropW - 1) sb.append(" ");
            }
            if (y < cropH - 1) sb.append("\n");
        }
        return sb.toString();
    }
    
    public byte[] bmp_recortarSomentePixels(
            byte[] bmpBytes,
            int cropX1,
            int cropY1,
            int cropX2,
            int cropY2
    )throws IOException{
        int width = bmp_salvarRecorte_readIntLE(bmpBytes, 18);
        int height = bmp_salvarRecorte_readIntLE(bmpBytes, 22);
        boolean originalTopDown = height < 0;
        int absHeight = Math.abs(height);

        int bpp = bmp_salvarRecorte_readShortLE(bmpBytes, 28);
        if (bpp != 24)
            throw new RuntimeException("Apenas BMP 24 bits são suportados");

        int cropWidth  = cropX2 - cropX1;
        int cropHeight = cropY2 - cropY1;

        int originalRowSize = (width * 3 + 3) & ~3;
        int croppedRowSize  = (cropWidth * 3 + 3) & ~3;

        ByteArrayOutputStream out = new ByteArrayOutputStream();

        byte[] padding = new byte[croppedRowSize - cropWidth * 3];

        for (int y = 0; y < cropHeight; y++) {

            int sourceY;

            if (originalTopDown) {
                sourceY = cropY1 + y;
            } else {
                sourceY = absHeight - 1 - (cropY1 + y);
            }

            int origem = 54 + sourceY * originalRowSize + cropX1 * 3;

            out.write(bmpBytes, origem, cropWidth * 3);
            out.write(padding);
        }

        return out.toByteArray();
    }
    
    public int bmp_salvarRecorte_readIntLE(byte[] data, int offset) {
        return (data[offset] & 0xFF) |
               ((data[offset + 1] & 0xFF) << 8) |
               ((data[offset + 2] & 0xFF) << 16) |
               ((data[offset + 3] & 0xFF) << 24);
    }

    public short bmp_salvarRecorte_readShortLE(byte[] data, int offset) {
        return (short) (
                (data[offset] & 0xFF) |
                ((data[offset + 1] & 0xFF) << 8)
        );
    }

    public void bmp_assinatura(File path, Integer len_block, OutputStream os) throws Exception{          
        byte[] entrada_ = new byte[1];
        int c=0;
        int rgb=0;
        int c18=1;
        int c19=256;
        int c20=256*256;
        int c21=256*256*256;
        int c22=1;
        int c23=256;
        int c24=256*256;
        int c25=256*256*256;
        int x=0; // posicao temporaria de x
        int y=0; // posicao temporaria de y
        int len_x=0; // len total em x
        int len_y=0; // len total em y
        int n_block_x=0; // numeros de blocos em x
        int n_block_y=0; // numeros de blocos em y
        int len_block_x=0; // len de trabalho em x
        int len_block_y=0; // len de trabalho em y
        int [][][] sums=null;   
        int [][][] counts=null;
        int count_pixels_block = 0;
        if ( len_block != null )
            count_pixels_block=len_block*len_block;
        boolean header=true;
        try{
            if ( path != null )
                readBytes(path);
        }catch(Exception e){
            erro_amigavel_exception(e);
        }        
        while ( read1Byte(entrada_) ){
            int n=entrada_[0];
            if ( n < 0 ) n+=256;
            if ( header ){
                if ( c == 18 ) c18*=n;
                if ( c == 19 ) c19*=n;
                if ( c == 20 ) c20*=n;
                if ( c == 21 ){
                    c21*=n;
                    len_x=c18+c19+c20+c21;
                    os.write((len_x+"").getBytes());
                    os.write("\n".getBytes());
                }
                if ( c == 22 ) c22*=n;
                if ( c == 23 ) c23*=n;
                if ( c == 24 ) c24*=n;
                if ( c == 25 ){
                    c25*=n;
                    len_y=c22+c23+c24+c25;
                    os.write((len_y+"").getBytes());
                    os.write("\n".getBytes());
                    if ( len_block != null ){
                        if (len_x < len_block || len_y < len_block )
                            erroFatal("Nao eh possivel a assinatura menor que a img!");
                        n_block_x=(int)(len_x/len_block);
                        n_block_y=(int)(len_y/len_block);
                        len_block_x=n_block_x*len_block;
                        len_block_y=n_block_y*len_block;
                        sums = new int[n_block_x][n_block_y][3];
                        counts = new int[n_block_x][n_block_y][3];
                    }
                    header=false;
                    c=0;
                    continue;
                }  
                c++;                
                continue;
            }else{
                if ( len_block == null ){
                    // sem assinatura
                    os.write((n+"").getBytes());
                    os.write("\n".getBytes());
                    continue;
                }else{
                    // com assinatura                    
                    if ( c%len_x < len_block_x && c < len_x*len_block_y ){ // dentro da area de trabalho
                        x = (int)((c%len_x)/len_block);
                        y = (int)((c/len_x)/len_block);
                        sums[x][y][rgb]+=n;
                        counts[x][y][rgb]+=1;
                        if ( counts[x][y][rgb] == count_pixels_block ){
                            os.write(((int)(sums[x][y][rgb]/counts[x][y][rgb])+"").getBytes());
                            os.write("\n".getBytes());
                        }
                    }
                    rgb++;
                    if ( rgb >= 3 ){
                        rgb=0;
                        c++;
                    }
                    continue;
                }
            }
        } 
        os.flush();
    }   
        
    public byte[] robotGetImgScreenBmpNamesDotaBytes() throws Exception{
        byte [] tmp=robotGetImgScreenBytes("bmp");
        bmp_editing(tmp, 
            new int[]{
                145, 1080-115, 335, 1080-90,
                145, 1080-(115+70), 335, 1080-(90+70),
                145, 1080-(115+70*2), 335, 1080-(90+70*2),
                145, 1080-(115+70*3), 335, 1080-(90+70*3),
                145, 1080-(115+70*4), 335, 1080-(90+70*4),
                145, 1080-(115+380+70*0), 335, 1080-(90+380+70*0),
                145, 1080-(115+380+70*1), 335, 1080-(90+380+70*1),
                145, 1080-(115+380+70*2), 335, 1080-(90+380+70*2),
                145, 1080-(115+380+70*4), 335, 1080-(90+380+70*4),
                145, 1080-(115+380+70*3), 335, 1080-(90+380+70*3)
            }, 
        0, 1920, 1080);
        return tmp;
    }
    
    public byte[] robotGetImgScreenBytes(String format_web) throws Exception{
        return robotGetImgScreenBytes(-1, format_web);
    }
    
    public byte[] robotGetImgScreenBytes(int monitor_id, String format_web) throws Exception{
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        javax.imageio.ImageIO.write(robotGetImgScreen(-1), format_web, baos);
        return baos.toByteArray();
    }
        
    public BufferedImage robotGetImgScreen(int monitor_id){
        /* 
           //use
           javax.imageio.ImageIO.write(robotGetImgScreen(-1), "bmp", new File("c:/tmp/s.bmp"));
           //use2
           ByteArrayOutputStream baos = new ByteArrayOutputStream();
           javax.imageio.ImageIO.write(robotGetImgScreen(-1), "bmp", baos);
           byte[] bytes = baos.toByteArray();
           //use3
           System.out.println(robotGetImgScreen(-1).getHeight());
        */
        try{
            java.awt.Robot robot=robotGet();
            java.awt.Rectangle rec=null;
            if ( monitor_id == -1 )
                rec = new java.awt.Rectangle(java.awt.Toolkit.getDefaultToolkit().getScreenSize());
            else
                rec = robotGetScreenDevices()[monitor_id].getConfigurations()[0].getBounds();
            return robot.createScreenCapture(rec);
        }catch(Exception e){
            System.out.println("Erro " + e.toString());
        }
        return null;
    }
    
    public java.awt.GraphicsDevice[] robotGetScreenDevices(){
        return java.awt.GraphicsEnvironment.getLocalGraphicsEnvironment().getScreenDevices();
    }            
    
    public void robotMouseSleep(Float n) throws Exception{
        Float remove=0.1F;
        if ( n == 0F ){
            robotMouseVerifyExit();
            return;
        }
        while ( n > 0F ){
            robotMouseVerifyExit();
            if ( n < 0.1F )
                remove=n;
            sleepFloatSeconds(remove);
            n-=remove;
        }        
    }
    
    public void robotMouseVerifyExit() throws Exception{
        if ( java.awt.MouseInfo.getPointerInfo() == null )
            System.exit(0);        
    }
                
    public Integer[] robotMouseGetXYAndRGB() throws Exception{
        java.awt.PointerInfo p = java.awt.MouseInfo.getPointerInfo();        
        if ( p == null )
            System.exit(0);
        java.awt.Point location=p.getLocation();  
        Color c=robotGet().getPixelColor(location.x, location.y);        
        return new Integer[]{location.x, location.y, c.getRed(), c.getGreen(), c.getBlue(), c.getRGB()};
    }

    public void robotMouseShowXY() throws Exception{
        Integer[] xyrgb=robotMouseGetXYAndRGB();
        System.out.println("x: " + xyrgb[0] + ", y: " + xyrgb[1] + ", rgb: " + xyrgb[2] + " " + xyrgb[3] + " " + xyrgb[4] + " " + xyrgb[5]);
    }
    
    public boolean robotCheckRGB(int x, int y, String rgb) throws Exception{
        Color c=robotGet().getPixelColor(x, y);
        return ( (c.getRed() + " " + c.getGreen() + " " + c.getBlue()).equals(rgb) || rgb.equals(c.getRGB()+"") );
    }
    
    public void robotMouseMove(int a, int b) throws Exception{
        robotGet().mouseMove(a, b);
    }
    
    public void robotDelay(int a) throws Exception{
        robotGet().delay(a);
    }
    
    public void robotMouseClickEsq() throws Exception{
        robotMousePressEsq();
        robotMouseReleaseEsq();
    }
    
    public void robotMouseClickDir() throws Exception{
        robotMousePressDir();
        robotMouseReleaseDir();
    }
    
    public void robotMousePressEsq() throws Exception{
        robotGet().mousePress(java.awt.event.InputEvent.BUTTON1_DOWN_MASK);
    }        
    
    public void robotMousePressDir() throws Exception{
        robotGet().mousePress(java.awt.event.InputEvent.BUTTON3_DOWN_MASK);
    }        

    public void robotMouseReleaseEsq() throws Exception{
        robotGet().mouseRelease(java.awt.event.InputEvent.BUTTON1_DOWN_MASK);
    }        
    
    public void robotMouseReleaseDir() throws Exception{
        robotGet().mouseRelease(java.awt.event.InputEvent.BUTTON3_DOWN_MASK);
    }   
    
    public void robotKey(char a) throws Exception{
        robotKeyPress(a);
        robotKeyRelease(a);
    }
    
    public void robotKeyPress(char a) throws Exception{
        robotGet().keyPress(robotKeyByChar(a));
    }
    
    public void robotKeyRelease(char a) throws Exception{
        robotGet().keyRelease(robotKeyByChar(a));
    }
    
    
    public int robotKeyByChar(char character){        
        switch (character) {
        case 'a': return java.awt.event.KeyEvent.VK_A;
        case 'b': return java.awt.event.KeyEvent.VK_B;
        case 'c': return java.awt.event.KeyEvent.VK_C;
        case 'd': return java.awt.event.KeyEvent.VK_D;
        case 'e': return java.awt.event.KeyEvent.VK_E;
        case 'f': return java.awt.event.KeyEvent.VK_F;
        case 'g': return java.awt.event.KeyEvent.VK_G;
        case 'h': return java.awt.event.KeyEvent.VK_H;
        case 'i': return java.awt.event.KeyEvent.VK_I;
        case 'j': return java.awt.event.KeyEvent.VK_J;
        case 'k': return java.awt.event.KeyEvent.VK_K;
        case 'l': return java.awt.event.KeyEvent.VK_L;
        case 'm': return java.awt.event.KeyEvent.VK_M;
        case 'n': return java.awt.event.KeyEvent.VK_N;
        case 'o': return java.awt.event.KeyEvent.VK_O;
        case 'p': return java.awt.event.KeyEvent.VK_P;
        case 'q': return java.awt.event.KeyEvent.VK_Q;
        case 'r': return java.awt.event.KeyEvent.VK_R;
        case 's': return java.awt.event.KeyEvent.VK_S;
        case 't': return java.awt.event.KeyEvent.VK_T;
        case 'u': return java.awt.event.KeyEvent.VK_U;
        case 'v': return java.awt.event.KeyEvent.VK_V;
        case 'w': return java.awt.event.KeyEvent.VK_W;
        case 'x': return java.awt.event.KeyEvent.VK_X;
        case 'y': return java.awt.event.KeyEvent.VK_Y;
        case 'z': return java.awt.event.KeyEvent.VK_Z;
        case '`': return java.awt.event.KeyEvent.VK_BACK_QUOTE;
        case '0': return java.awt.event.KeyEvent.VK_0;
        case '1': return java.awt.event.KeyEvent.VK_1;
        case '2': return java.awt.event.KeyEvent.VK_2;
        case '3': return java.awt.event.KeyEvent.VK_3;
        case '4': return java.awt.event.KeyEvent.VK_4;
        case '5': return java.awt.event.KeyEvent.VK_5;
        case '6': return java.awt.event.KeyEvent.VK_6;
        case '7': return java.awt.event.KeyEvent.VK_7;
        case '8': return java.awt.event.KeyEvent.VK_8;
        case '9': return java.awt.event.KeyEvent.VK_9;
        case '-': return java.awt.event.KeyEvent.VK_MINUS;
        case '=': return java.awt.event.KeyEvent.VK_EQUALS;
        case '!': return java.awt.event.KeyEvent.VK_EXCLAMATION_MARK;
        case '@': return java.awt.event.KeyEvent.VK_AT;
        case '#': return java.awt.event.KeyEvent.VK_NUMBER_SIGN;
        case '$': return java.awt.event.KeyEvent.VK_DOLLAR;
        case '^': return java.awt.event.KeyEvent.VK_CIRCUMFLEX;
        case '&': return java.awt.event.KeyEvent.VK_AMPERSAND;
        case '*': return java.awt.event.KeyEvent.VK_ASTERISK;
        case '(': return java.awt.event.KeyEvent.VK_LEFT_PARENTHESIS;
        case ')': return java.awt.event.KeyEvent.VK_RIGHT_PARENTHESIS;
        case '_': return java.awt.event.KeyEvent.VK_UNDERSCORE;
        case '+': return java.awt.event.KeyEvent.VK_PLUS;
        case '\t':return java.awt.event.KeyEvent.VK_TAB;
        case '\n':return java.awt.event.KeyEvent.VK_ENTER;
        case '[': return java.awt.event.KeyEvent.VK_OPEN_BRACKET;
        case ']': return java.awt.event.KeyEvent.VK_CLOSE_BRACKET;
        case '\\':return java.awt.event.KeyEvent.VK_BACK_SLASH;
        case ';': return java.awt.event.KeyEvent.VK_SEMICOLON;
        case ':': return java.awt.event.KeyEvent.VK_COLON;
        case '\'':return java.awt.event.KeyEvent.VK_QUOTE;
        case '"': return java.awt.event.KeyEvent.VK_QUOTEDBL;
        case ',': return java.awt.event.KeyEvent.VK_COMMA;
        case '.': return java.awt.event.KeyEvent.VK_PERIOD;
        case '/': return java.awt.event.KeyEvent.VK_SLASH;
        case ' ': return java.awt.event.KeyEvent.VK_SPACE;
        default:
            throw new IllegalArgumentException("Cannot type character " + character);
        }        
    }
    
    int rGISBP_p = 0;
    int rGISBP_len = 6; // melhor configuração
    /*
    parallels e fps
    len=1;//9
    len=2;//18
    len=3;//25
    len=4;//30
    len=5;//36
    len=6;//38
    len=7;//38
    len=8;//38
    */    
    byte [][] rGISBP_data=null;
    boolean [] rGISBP_control=null;
    long [] rGISBP_control_time=null; // ajuda no sincronismo
    public void robotGetImgScreenBytesParallels_start(String format_web, int fps) throws Exception{
        rGISBP_data=new byte[rGISBP_len][0];        
        rGISBP_control=new boolean[rGISBP_len];
        rGISBP_control_time=new long[rGISBP_len];
        Thread [] workers=new Thread[rGISBP_len];
        final long [] sleep_fps=new long[]{fps==30?130:1};
        for ( int i=0;i<rGISBP_len;i++ ){
            final int n_control=i;
            workers[n_control]=new Thread(){
                public void run(){
                    try{                        
                        java.awt.Robot robot=new java.awt.Robot();
                        java.awt.Rectangle rec = new java.awt.Rectangle(java.awt.Toolkit.getDefaultToolkit().getScreenSize());
                        while(true){    
                            while(rGISBP_control[n_control]){
                                sleepMillis(sleep_fps[0]); // fps controlado aqui
                            }
                            java.io.ByteArrayOutputStream baos = new java.io.ByteArrayOutputStream();                            
                            BufferedImage tmp=robot.createScreenCapture(rec);
                            rGISBP_control_time[n_control]=epochmili(null);
                            baos.write( (rGISBP_control_time[n_control]+"").getBytes() );
                            
                            // add mouse
                            int x = MouseInfo.getPointerInfo().getLocation().x;
                            int y = MouseInfo.getPointerInfo().getLocation().y;
                            Graphics2D graphics2D = tmp.createGraphics();
                            detectMoved(x, y, 500, graphics2D);
                            //rastroMoved(x, y, 500, graphics2D);
                            
                            javax.imageio.ImageIO.write(tmp, format_web, baos);
                            rGISBP_data[n_control]=baos.toByteArray();
                            rGISBP_control[n_control]=true;
                        }
                    }catch(Exception e){
                        //System.out.println("Erro " + n_control + " " + e.toString());
                    }
                }                
            };
            workers[n_control].start();
        }    
    }
    
    public int [] rastroMoved_x=new int[0];
    public int [] rastroMoved_y=new int[0];    
    public long [] rastroMoved_time=new long[0];
    public void rastroMoved(int _x, int _y, long duracao, Graphics2D graphics2D){
        long _time=epochmili(null);
        rastroMoved_x = addParm(_x, rastroMoved_x);
        rastroMoved_y = addParm(_y, rastroMoved_y);
        rastroMoved_time = addParm(_time, rastroMoved_time);
        int pos=rastroMoved_x.length;
        while(--pos >= 0){
            if ( rastroMoved_time[pos] > _time+duracao ){
                rastroMoved_x=removeParm(pos, rastroMoved_x);
                rastroMoved_y=removeParm(pos, rastroMoved_y);
                rastroMoved_time=removeParm(pos, rastroMoved_time);
                continue;
            }
            BufferedImage bi = new BufferedImage(3,3,1);
            int a=150000;
            bi.setRGB(0, 0, a);
            bi.setRGB(0, 1, a);
            bi.setRGB(0, 2, a);
            bi.setRGB(1, 0, a);
            bi.setRGB(1, 1, a);
            bi.setRGB(1, 2, a);
            bi.setRGB(2, 0, a);
            bi.setRGB(2, 1, a);
            bi.setRGB(2, 2, a);
            graphics2D.drawImage(bi, _x, _y, 50, 50, null);          
        }
    }
    
    public void detectMoved(int _x, int _y, long delay, Graphics2D graphics2D){
        if ( detectMoved(_x, _y, delay) ){
            BufferedImage bi = new BufferedImage(3,3,1);
            int a=150000;
            bi.setRGB(0, 0, a);
            bi.setRGB(0, 1, a);
            bi.setRGB(0, 2, a);
            bi.setRGB(1, 0, a);
            bi.setRGB(1, 1, a);
            bi.setRGB(1, 2, a);
            bi.setRGB(2, 0, a);
            bi.setRGB(2, 1, a);
            bi.setRGB(2, 2, a);
            graphics2D.drawImage(bi, _x, _y, 18, 18, null);                      
        }
    }
    

    long detectMoved_inicio=0; 
    int detectMoved_x=-1;
    int detectMoved_y=-1;
    public boolean detectMoved(int _x, int _y, long delay){
        if ( detectMoved_inicio == 0 ){
            detectMoved_inicio=epochmili(null);
            detectMoved_x=_x;
            detectMoved_y=_y;
            return true;
        }  
        long tmp=epochmili(null);
        if ( _x == detectMoved_x && _y == detectMoved_y ){
            if ( tmp < detectMoved_inicio+1000 )
                return true;
            return false;
        }
        detectMoved_inicio=tmp;
        detectMoved_x=_x;
        detectMoved_y=_y;
        return true;
    }
    
    public byte[] robotGetImgScreenBytesParallels(){
        while( !rGISBP_control[rGISBP_p] )
            sleepMillis(1);
        int tmp_len=rGISBP_data[rGISBP_p].length;
        byte [] result=rGISBP_data[rGISBP_p];
        rGISBP_control[rGISBP_p]=false;
        rGISBP_p++;
        if ( rGISBP_p >= rGISBP_len )
            rGISBP_p=0;
        return result;
    }        
    
    public byte[] robotGetImgScreenBytesByPowerShell(){        
    /*
Add-Type -AssemblyName System.Windows.Forms
Add-Type -AssemblyName System.Drawing
$targetMonitor = 1  # 0 = Primário, 1 = Segundo monitor
$allScreens = [System.Windows.Forms.Screen]::AllScreens
if ($targetMonitor -ge $allScreens.Count) {
    Write-Host "Erro: Monitor não encontrado!" -ForegroundColor Red
    exit
}
$screen = $allScreens[$targetMonitor].Bounds
$width = $screen.Width
$height = $screen.Height
while ($true) {
    # Cria bitmap e captura a tela
    $bitmap = New-Object System.Drawing.Bitmap $width, $height
    $graphics = [System.Drawing.Graphics]::FromImage($bitmap)
    $graphics.CopyFromScreen($screen.X, $screen.Y, 0, 0, $bitmap.Size)
    $memoryStream = New-Object System.IO.MemoryStream
    $bitmap.Save($memoryStream, [System.Drawing.Imaging.ImageFormat]::Jpeg)
    $base64 = [Convert]::ToBase64String($memoryStream.ToArray())
    $memoryStream.Dispose()
	[Console]::WriteLine($base64)
	[Console]::Out.Flush()
    $graphics.Dispose()
    $bitmap.Dispose()
}
    */
        return null;
    }
    
    public boolean preparaPath(String caminho, boolean contemFile, int nivel){
        // examples
        // contemFile true  => d:\\aa\\b.mp3
        // contemFile false => d:\\aa
        String caminho_up=null;
        String sep="\\";
        if ( caminho.contains("/") )
            sep="/";
        int p=caminho.lastIndexOf(sep);
        if ( p > 0 )
            caminho_up=caminho.substring(0, caminho.lastIndexOf(sep));
        if ( nivel == 0 && contemFile ){
            if ( caminho_up != null )
                return preparaPath(caminho_up, contemFile, nivel+1);
            return true;
        }
        if ( !new File(caminho).exists() ){
            preparaPath(caminho_up, contemFile, nivel+1);
            return new File(caminho).mkdir();
        }  
        return true;
    }    

    javax.net.ssl.TrustManager[] trustAllCerts = new javax.net.ssl.TrustManager[] {
        new javax.net.ssl.X509TrustManager() {
            public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                return null;
            }
            public void checkClientTrusted(java.security.cert.X509Certificate [] certs, String authType) {
            }
            public void checkServerTrusted(java.security.cert.X509Certificate [] certs, String authType) {
            }
        }
    };
            
    @SuppressWarnings({"unchecked", "deprecation"})
    class CustomSocket{
        public Socket getSocket(boolean flag_http, boolean flag_skip_ssl_error) throws Exception{
            if (!flag_http){
                if ( flag_skip_ssl_error ){
                    SSLContext sslContext = SSLContext.getInstance("TLS");
                    sslContext.init(null, flag_skip_ssl_error?trustAllCerts:null, new SecureRandom());
                    return sslContext.getSocketFactory().createSocket();
                }
                javax.net.ssl.SSLSocketFactory sf = (javax.net.ssl.SSLSocketFactory) javax.net.ssl.SSLSocketFactory.getDefault();
                return sf.createSocket();                
            }
            return new Socket();
        }
    }
    
    
}


@SuppressWarnings({"unchecked", "deprecation"})
class JSON extends Util{
    boolean literal=false;   
    String command="";
    boolean mostraTabela=false;
    boolean mostraEstrutura=false;
    boolean mostraEstruturaDebug=false;
    boolean list_on=false;
    boolean noHeader=false;
    String filterA=""; // filtro definido
    String filterB=""; // filtro definido auxiliar para lista de nao objetos ex: [1, 2, 3]
    boolean filterMatchA=false; // match in filterA
    boolean filterMatchB=false; // match in filterB
    boolean auto_detect_campos=false;
    String [] campos = new String[99];
    int count_campos=0;
    String [] camposCandidate = new String[99];
    int count_camposCandidate=0;
    boolean finish_add_campos=false;
    boolean header_printed=false;
    OutputStream os=null;
    /*
        controle de literal e guarda key pai(key de key/value da camada superiora)
        contra_barra_lvl controla os elementos "  \\ ou \" " no literal
        exemplo de literal => "abc"
        command => exemplo de parametro de comando: 
            "[elem['id'] for elem in data]"
    */
    JSON(InputStream is, String command, boolean mostraTabela, 
                boolean mostraEstrutura, boolean mostraEstruturaDebug, boolean list_on, boolean noHeader, OutputStream _os){ // "[elem['id'] for elem in data['items']]"        
        
        try{
            if ( command == null )
                command="";
            readLine(is, null, "");
            this.command=command;
            this.mostraTabela=mostraTabela;
            this.mostraEstrutura=mostraEstrutura;
            this.mostraEstruturaDebug=mostraEstruturaDebug;  
            this.list_on=list_on;
            this.noHeader=noHeader;
            this.os=_os;
            if ( !command.equals("") && !setFilter() )
                erroFatal("Error, invalid filter!");

            String t=null;
            int contra_barra_lvl=0;   
            while( (t=read1String()) != null ){
                if (literal && contra_barra_lvl > 1)
                    contra_barra_lvl=0;
                else
                    if ((literal && t.equals("\\") && contra_barra_lvl == 0)
                        || (literal && contra_barra_lvl == 1))
                        contra_barra_lvl++;
                if ( t.equals("\"") && contra_barra_lvl != 2 ){
                    literal=!literal;
                    if ( literal )
                        key_pai="";
                }
                if ( !literal && t.equals(" ") ){
                    continue;
                }
                if ( t.equals("\t") || t.equals("\r") || t.equals("\n") ){
                    continue;
                }
                if ( literal && !t.equals("\"") && !t.equals(" ") ){
                    key_pai+=t;
                }
                next(t);
                if ( !literal && t.equals(":")){
                    next(" ");            
                }
            }   
            nextflush();
        }catch(Exception e){
            erroFatal(e);
        }
    }
    
    String [] pilha=new String [999];
    String [] pilha_pai=new String [999];
    String key_pai="";
    int count_pilha=0;
    String level_in="[{";
    String level_out="]}";
    int seq=0;
    /*
        tratando por caracter
        level_in.contains(t) significa t contem { ou [
        level_out.contains(t) significa t contem } ou ]
        pilha => empilha as tas { [ fazendo o controle quando desempilhar
        pilha_pai => empilha as keys de key/value
        out => saida em buffer
        outwrite => print saida
        debug => trata mostraEstruturaDebug, codigo de elementos identados
        identacao => controle de identacao - para parametro mostraEstrutura
    */
    private void next(String t) throws Exception{
        if ( !literal ){
            if ( level_in.contains(t) ){
                seq=0;
                int aux=level_in.indexOf(t);
                pilha[count_pilha]=level_out.substring(aux, aux+1);
                pilha_pai[count_pilha]=key_pai;
                key_pai="";
                count_pilha++;
                out(t);
                outwrite();                
                debug();
                identacao();
                return;
            }
            if ( level_out.contains(t) ){
                if (count_pilha==0 || !pilha[count_pilha-1].equals(t))
                    erroFatal(99);
                count_pilha--;     
                outwrite();
                debug();
                identacao();
                out(t);
                return;
            }
            if ( t.equals(",")){
                key_pai="";
                out(t);
                outwrite();
                debug();
                identacao();
                return;
            }
        }
        out(t);
    }   
    
    /*
      Define o filtro, ex data['items']['itemsB']
    */
    private boolean setFilter(){ // "[elem['id'] for elem in data['items']['itemsB']]"
        if ( command.startsWith("[") && command.endsWith("]") ) // tira o [ e ] das bordas de "[elem['id'] for elem in data['items']['items2']]"
            command=command.substring(1,command.length()-1); 
        else
            return false;
        String [] partes=command.split(" for elem in ");
        if ( partes.length == 2 ){
            String a=partes[0];
            String b=partes[1];
            // parte a
            if(a.equals("elem"))
                auto_detect_campos=true;
            else{
                if(a.startsWith("[") && a.endsWith("]"))
                    a=a.substring(1, a.length()-1);
                String [] aa=a.split(",");
                for(int i=0;i<aa.length;i++){
                    partes=aa[i].split("'"); // elem['id']
                    if ( partes.length == 3 ){
                        camposCandidate[count_camposCandidate++]=partes[1];                
                    }
                }
            }
            
            if ( b.startsWith("data") ){ // data['items']['itemsB'] -> _.items.itemsB._
                                               // data -> _
                partes=b.substring(4).replace("]","],").split(",");
                filterA="_";
                for ( String parte : partes ){
                    if ( parte.equals("") )
                        continue;
                    if ( parte.startsWith("[") && parte.endsWith("]") )
                        parte=parte.substring(1, parte.length()-1);
                    else
                        return false;
                    if ( 
                        (parte.startsWith("'") && !parte.endsWith("'"))
                        || (!parte.startsWith("'") && parte.endsWith("'"))
                    )
                        return false;
                    parte=parte.replace("'","");
                    filterA+="."+parte;
                }
                filterB=filterA;
                filterA+="._";
            }else
                return false;
        }    
        return true;
    }
    
    /*
        identacao para mostraEstrutura
    */
    private void identacao() {     
        for ( int i=0;i<count_pilha*2;i++ )
            out_mostra+=" ";
    }
    
    /*
      finaliza ultimas pendencias apos ultimo next
    */   
    private void nextflush() throws Exception{
        outwrite();
        if ( !command.equals("") ){
            if ( !finish_add_campos  )
                print_header();
            if ( !detail.equals("") ){
                os.write(detail.getBytes());
                os.write("\n".getBytes());
            }
        }
    }
    
    String [] tabelas=new String[99];
    int count_tabelas=0; 
    /*
        mostra estrutura interna de identacao ex _.{.[
    */
    private void debug() throws Exception{
        String txtDebug="";
        String tabela="data";
        for ( int i=0;i<count_pilha;i++ ){
            if ( i > 0 )
                txtDebug+=".";
            String p=pilha_pai[i].equals("")?"_":pilha_pai[i];
            txtDebug+=p;
            if ( i > 0 && i < count_pilha-1)
                tabela+="['"+p+"']";
        }
        if ( mostraEstruturaDebug ){
            os.write(txtDebug.getBytes() );
            os.write("\n".getBytes());
        }
        if ( mostraTabela ){
            if ( txtDebug.endsWith("._")){// && !txtDebug.contains("._.") ){
                tabela="[elem for elem in " + tabela + "]";
                if ( !contemNaTabela(tabela) && count_tabelas < 50 ){
                    tabelas[count_tabelas++]=tabela;
                    os.write( ("y json \""+tabela+"\"").getBytes() );
                    os.write("\n".getBytes());
                }
            }           
        }
        filterMatchA=txtDebug.equals(filterA); // list of obj -> [{"b":1},{"b":2}] ou [[1,2],[3,4]]
        filterMatchB=txtDebug.equals(filterB); // list of value -> [1,2]
    }
    
    /*
        verifica situação para mostrar em mostraTabela
    */
    private boolean contemNaTabela(String a){
        for ( int i=0;i<count_tabelas;i++ )
            if ( tabelas[i].equals(a) )
                return true;
        return false;
    }                    
    
    String _out="";
    String out_mostra="";
    /*
        buffer de saida
    */
    private void out(String a){
        _out+=a;
        out_mostra+=a;
    }
    
    String detail="";
    String key="";
    String value="";    
    boolean unica_verificacao=false;
    /*
        imprime
    */
    private void outwrite() throws Exception{
        if ( mostraEstrutura || mostraEstruturaDebug ){
            os.write(out_mostra.getBytes());
            os.write("\n".getBytes());
        }
        if ( !unica_verificacao && !command.equals("") && filterMatchB ){
            unica_verificacao=true;
            if ( !_out.startsWith("{") && !_out.startsWith("[") ){
                filterMatchA=filterMatchB;
                filterA=filterB;
            }
        }
        if ( !command.equals("") && filterMatchA && get_KeyValue() ){
            // add campo
            if ( !finish_add_campos ){
                if ( value.equals("{") || value.equals("[") ){
                    // pass
                }else{
                    if ( auto_detect_campos ){
                        if ( contem(key) )
                            finish_add_campos=true;
                        else
                            campos[count_campos++]=key;
                    }else{
                        if ( contem(key) )
                            finish_add_campos=true;
                        else
                            if ( contemCandidate(key) )
                                campos[count_campos++]=key;
                    }
                }
            }
            if ( finish_add_campos && !header_printed ){
                header_printed=true;
                print_header();
            }
            if ( finish_add_campos && campos[0].equals(key) && !detail.equals("") ){
                if ( list_on ){
                    //pass
                }else{
                    os.write(detail.getBytes());
                    os.write("\n".getBytes());
                    detail="";                                        
                }
            }
            if ( contem(key) ){
                if ( !detail.equals("") )
                    if ( list_on )
                        detail+=", ";
                    else
                        detail+=getSeparadorCSV();
                detail+="\""+value+"\"";
            }
        }
        
        _out="";
        out_mostra="";
    }

    private void print_header() throws Exception{
        if ( list_on == false && noHeader == false){
            for ( int i=0;i<count_campos;i++ ){
                if ( i != 0 ){
                    os.write(getSeparadorCSV().getBytes());
                }
                os.write( ("\""+campos[i]+"\"").getBytes() );
            }
            os.write("\n".getBytes());
        }
    }
    
    /*
        verifica se o campo ja foi mapeado
        Se nao foi, verifica o que fazer e ja foi finaliza o mapeamento    
    */
    private boolean contem(String a){
        for ( int i=0;i<count_campos;i++ )
            if ( campos[i].equals(a) )
                return true;
        return false;
    }
    
    /*
        verifica se o campo foi explicitamente solicitado
        essa funcao auxilia para que o mapeamento esteja em ordem da leitura do json e nao na ordem da solicitacao
    */
    private boolean contemCandidate(String a){
        for ( int i=0;i<count_camposCandidate;i++ )
            if ( camposCandidate[i].equals(a) )
                return true;
        return false;
    }
    
    /*
        get key value do objeto
    */
    private boolean get_KeyValue(){
        String a=_out;
        key="?";
        value="?";
        if ( a.endsWith("{") || a.endsWith("[") || a.equals("}") || a.equals("]") || a.equals("},") || a.equals("],") ){
            return false;
        }
        a=tiraVirgula(a);
        int p=a.indexOf(": ");
        if ( p > 0 ){
            key=tiraAspasPontas(a.substring(0, p-1));
            value=tiraAspasPontas(a.substring(p+2,a.length()));
        }else{
            key="f"+(++seq)+"_";
            value=tiraAspasPontas(a);
        }   
        value=value.replace("\"", "\"\"");
        return true;
    }
    
    /*
        remove virgula de quebra de key/value ex:
        {
            "aa": "aa",
            "bb": "bb"
        }
    */
    private String tiraVirgula(String a){
        if ( a.endsWith(",") )
            return a.substring(0,a.length()-1);         
        return a;
    }
    
    /*
        remove aspas para pegar texto puro ex: "texto" => texto
    */
    private String tiraAspasPontas(String a){
        if ( a.startsWith("\"") )
            a = a.substring(1, a.length());
        if ( a.endsWith("\"") )
            a = a.substring(0, a.length()-1);
        return a;
    }
     
}

@SuppressWarnings({"unchecked", "deprecation"})
class Ponte extends Util{
    //exemplo
    //new Ponte().serverRouter("192.168.0.100",8080,"192.168.0.200",9090,"");                
    //new Ponte().serverRouter("192.168.0.100",8080,"192.168.0.200",9090,"show");                
    //new Ponte().serverRouter("192.168.0.100",8080,"192.168.0.200",9090,"showOnlySend");                
    //new Ponte().serverRouter("192.168.0.100",8080,"192.168.0.200",9090,"showOnlyReceive");                
    
    public static boolean displayIda=false;
    public static boolean displayVolta=false;
    public static boolean displaySimple=false;

    public void serverRouter(final String host0,final int port0,final String host1,final  int port1,final String typeShow, String log, Boolean noLogLocal, String ips_banidos, ArrayList<String> decodes, Integer xor){
        Ambiente ambiente=null;
        try{
            ambiente=new Ambiente(host0,port0);
        }catch(Exception e){
            System.out.println("Nao foi possível utilizar a porta "+port0+" - "+e.toString());
            System.exit(1);
        }     
        System.out.println("ServerRouter criado.");
        System.out.println("obs: A ponte só estabelece conexão com o destino quando detectar o início da origem");
        if ( typeShow.equals("show") || typeShow.equals("showOnlySend") || typeShow.equals("showSimple"))
            displayIda=true;
        if ( typeShow.equals("show") || typeShow.equals("showOnlyReceive") || typeShow.equals("showSimple"))
            displayVolta=true;
        if ( typeShow.equals("showSimple") )
            displaySimple=true;
        while(true){
            try{
                final Socket credencialSocket=ambiente.getCredencialSocket();
                final String ip_origem = get_ip_origem_by_socket(credencialSocket);
                boolean is_ip_banido = ip_banido(ips_banidos, ip_origem);
                if ( log != null )
                    log_serverRouter(log, noLogLocal, ip_origem, is_ip_banido);
                if ( is_ip_banido ){
                    System.out.println("Conexao de origem BANIDO: " + ip_origem + ", data:" + (new Date()));
                    continue;
                }else
                    System.out.println("Conexao de origem: " + ip_origem + ", data:" + (new Date()));
                new Thread(){
                    public void run(){
                        ponte0(credencialSocket,host1,port1,ip_origem,decodes,xor);
                    }
                }.start();   
            }catch(Exception e){
                System.out.println("FIM "  + e.toString());
                break;
            }
        }
    }

    private void ponte0(Socket credencialSocket, String host1, int port1, String ip_origem, ArrayList<String> decodes, Integer xor) {
        String id=padLeftZeros(new Random().nextInt(100000)+"",6);
        System.out.println("iniciando ponte id "+id+" - ip origem "+ip_origem);
        Origem origem=null;
        try{
            Destino destino=new Destino(host1,port1,decodes,xor);                    
            origem=new Origem(credencialSocket,id,decodes,xor);
            origem.referencia(destino);
            destino.referencia(origem);
            origem.start(); // destino é startado no meio do start da origem;
        }catch(Exception e){
            //System.out.println("termino inexperado de ponte id "+id+" - "+e.toString());
            origem.destroy();
        }
        System.out.println("finalizando ponte id "+id);
    }

    @SuppressWarnings({"unchecked", "deprecation"})
    private class Destino {   // |   |<->|
        OutputStreamCustom os=null;
        Origem origem=null;
        String host1;
        int port1;    
        byte[][] decode_A=null;
        boolean[] decode_A_asterisco=null;
        byte[][] decode_B=null;
        byte[][] suprime=null;        
        boolean[] suprime_asterisco=null;
        String decode_tag="decodeSend";
        String suprime_tag="suprimeSend";
        Integer xor=null;
        private Destino(String host1, int port1, ArrayList<String> decodes, Integer xor) {
            this.host1=host1;
            this.port1=port1;
            this.xor=xor;
            init_decodes(decodes);
            init_suprimes(decodes);
        }
        private void init_decodes(ArrayList<String> decodes){
            int count=0;
            for ( int i=0;i<decodes.size();i++ ){
                if ( decodes.get(i).split(",")[0].equals(decode_tag) )
                    count++;
            }               
            if ( count > 0 ){
                decode_A=new byte[count][0];
                decode_A_asterisco=new boolean[count];
                decode_B=new byte[count][0];
                count=0;
                for ( int i=0;i<decodes.size();i++ ){
                    String [] partes=decodes.get(i).split(",");
                    if ( partes[0].equals(decode_tag) ){
                        String [] tmp=partes[1].split(" ");
                        int len=tmp.length;
                        decode_A_asterisco[count]=false;
                        if ( tmp[len-1].equals("...") ){
                            len--;
                            decode_A_asterisco[count]=true;
                        }
                        decode_A[count]=new byte[len];                        
                        for ( int j=0;j<len;j++ )
                            decode_A[count][j]=(byte)Integer.parseInt(tmp[j]);
                        
                        tmp=partes[2].split(" ");
                        decode_B[count]=new byte[tmp.length];
                        for ( int j=0;j<tmp.length;j++ )
                            decode_B[count][j]=(byte)Integer.parseInt(tmp[j]);
                        count++;
                    }
                }
            }
        }
        private void init_suprimes(ArrayList<String> decodes){
            int count=0;
            for ( int i=0;i<decodes.size();i++ ){
                if ( decodes.get(i).split(",")[0].equals(suprime_tag) )
                    count++;
            }               
            if ( count > 0 ){
                suprime=new byte[count][0];
                count=0;
                for ( int i=0;i<decodes.size();i++ ){
                    String [] partes=decodes.get(i).split(",");
                    if ( partes[0].equals(suprime_tag) ){
                        String [] tmp=partes[1].split(" ");
                        int len=tmp.length;
                        suprime_asterisco[count]=false;
                        if ( tmp[len-1].equals("...") ){
                            len--;
                            decode_A_asterisco[count]=true;
                        }
                        suprime[count]=new byte[len];
                        for ( int j=0;j<len;j++ )
                            suprime[count][j]=(byte)Integer.parseInt(tmp[j]);
                    }
                }
            }
        }        
        private void referencia(Origem origem) {
            this.origem=origem;
        }
        private void start() throws Exception {
            Socket socket=new Socket(host1, port1);                                                
            final InputStream is=socket.getInputStream();           //  |   |<- |             
            os=new OutputStreamCustom(socket.getOutputStream());    //  |   | ->|
            new Thread(){
                public void run(){
                    int len=0;   
                    byte[] buffer = new byte[2048];
                    try{
                        while( (len=is.read(buffer)) > -1 )
                            origem.volta(len,buffer);
                        System.out.println("desconectou"); 
                    }catch(Exception e){
                        //System.out.println("desconectou destino "+e.toString());
                    }
                    origem.destroy(); 
                }
            }.start();                                    
        }

        private void ida(byte[] buffer,int len, String ponteID) throws Exception {   // |   | ->|          
            if ( xor != null ){
                for ( int i=0;i<len;i++ ){
                    int z=buffer[i];
                    if ( z < 0 )
                        z+=256;
                    buffer[i]=(byte)(z^xor);
                }
            }            
            if ( decode_A != null ){
                for ( int i=0;i<decode_A.length;i++ ){
                    if ( decode_A[i].length == len || (decode_A[i].length <= len && decode_A_asterisco[i] ) ){
                        for( int j=0;j<len;j++ ){
                            if ( decode_A[i][j] != buffer[j] )
                                break;
                            if ( j == len-1 ){
                                os.write(OutputStreamCustom.IDA, decode_B[i], 0, decode_B[i].length, ponteID);
                                return;                                
                            }
                        }
                    }
                }
            }
            if ( suprime != null ){
                for ( int i=0;i<suprime.length;i++ ){
                    if ( suprime[i].length == len || ( suprime[i].length <= len && suprime_asterisco[i] ) ){
                        for( int j=0;j<len;j++ ){
                            if ( suprime[i][j] != buffer[j] )
                                break;
                            if ( j == len-1 )                                
                                return;                                
                        }
                    }
                }
            }
            os.write(OutputStreamCustom.IDA,buffer,0,len,ponteID);
        }
    }

    @SuppressWarnings({"unchecked", "deprecation"})
    private class Origem {    // |<->|   |
        String ponteID="";
        Socket socket=null;
        OutputStreamCustom os=null;
        Destino destino=null;
        int port0;
        byte[][] decode_A=null;
        boolean[] decode_A_asterisco=null;
        byte[][] decode_B=null;
        byte[][] suprime=null;        
        boolean[] suprime_asterisco=null;
        String decode_tag="decodeReceive";
        String suprime_tag="suprimeReceive";
        Integer xor=null;
        private Origem(Socket credencialSocket,String ponteID, ArrayList<String> decodes, Integer xor) {            
            socket=credencialSocket;
            this.ponteID=ponteID;
            this.xor=xor;
            init_decodes(decodes);
            init_suprimes(decodes);
        }
        private void init_decodes(ArrayList<String> decodes){
            int count=0;
            for ( int i=0;i<decodes.size();i++ ){
                if ( decodes.get(i).split(",")[0].equals(decode_tag) )
                    count++;
            }               
            if ( count > 0 ){
                decode_A=new byte[count][0];
                decode_A_asterisco=new boolean[count];
                decode_B=new byte[count][0];
                count=0;
                for ( int i=0;i<decodes.size();i++ ){
                    String [] partes=decodes.get(i).split(",");
                    if ( partes[0].equals(decode_tag) ){
                        String [] tmp=partes[1].split(" ");
                        int len=tmp.length;
                        decode_A_asterisco[count]=false;
                        if ( tmp[len-1].equals("...") ){
                            len--;
                            decode_A_asterisco[count]=true;
                        }
                        decode_A[count]=new byte[len];                        
                        for ( int j=0;j<len;j++ )
                            decode_A[count][j]=(byte)Integer.parseInt(tmp[j]);
                        
                        tmp=partes[2].split(" ");
                        decode_B[count]=new byte[tmp.length];
                        for ( int j=0;j<tmp.length;j++ )
                            decode_B[count][j]=(byte)Integer.parseInt(tmp[j]);
                        count++;
                    }
                }
            }
        }
        private void init_suprimes(ArrayList<String> decodes){
            int count=0;
            for ( int i=0;i<decodes.size();i++ ){
                if ( decodes.get(i).split(",")[0].equals(suprime_tag) )
                    count++;
            }               
            if ( count > 0 ){
                suprime=new byte[count][0];
                count=0;
                for ( int i=0;i<decodes.size();i++ ){
                    String [] partes=decodes.get(i).split(",");
                    if ( partes[0].equals(suprime_tag) ){
                        String [] tmp=partes[1].split(" ");
                        int len=tmp.length;
                        suprime_asterisco[count]=false;
                        if ( tmp[len-1].equals("...") ){
                            len--;
                            decode_A_asterisco[count]=true;
                        }
                        suprime[count]=new byte[len];
                        for ( int j=0;j<len;j++ )
                            suprime[count][j]=(byte)Integer.parseInt(tmp[j]);
                    }
                }
            }
        }            
        private void referencia(Destino destino) {
            this.destino=destino;
        }

        private void start() throws Exception {
            // start destino
            destino.start();
            // start origem
            int len=0;
            byte[] buffer = new byte[2048];            
            InputStream is=null;
            os=null;
            BufferedInputStream bis=null;                            
            is=socket.getInputStream();                            //  | ->|   |
            os=new OutputStreamCustom(socket.getOutputStream());   //  |<- |   |         
            bis=new BufferedInputStream(is);                            
            while( (len=bis.read(buffer)) != -1 )
                destino.ida(buffer,len,ponteID);
            try{ bis.close(); }catch(Exception e){}
            try{ is.close(); }catch(Exception e){}
        }

        private void volta(int len,byte[] buffer) throws Exception { // |<- |   |
            if ( xor != null ){
                for ( int i=0;i<len;i++ ){
                    int z=buffer[i];
                    if ( z < 0 )
                        z+=256;
                    buffer[i]=(byte)(z^xor);
                }
            }
            if ( decode_A != null ){
                for ( int i=0;i<decode_A.length;i++ ){
                    if ( decode_A[i].length == len || (decode_A[i].length <= len && decode_A_asterisco[i] ) ){
                        for( int j=0;j<len;j++ ){
                            if ( decode_A[i][j] != buffer[j] )
                                break;
                            if ( j == len-1 ){
                                os.write(OutputStreamCustom.VOLTA,decode_B[i],0,decode_B[i].length,ponteID);
                                return;                                
                            }
                        }
                    }
                }
            }
            if ( suprime != null ){
                for ( int i=0;i<suprime.length;i++ ){
                    if ( suprime[i].length == len || ( suprime[i].length <= len && suprime_asterisco[i] ) ){
                        for( int j=0;j<len;j++ ){
                            if ( suprime[i][j] != buffer[j] )
                                break;
                            if ( j == len-1 )                                
                                return;                                
                        }
                    }
                }
            }        
            os.write(OutputStreamCustom.VOLTA,buffer,0,len,ponteID);
        }

        private void destroy() {
            try{                
                socket.close();
            }catch(Exception e){}
        }
    }

    @SuppressWarnings({"unchecked", "deprecation"})
    public static class OutputStreamCustom{ 
        public static int IDA=1;   //  |   | ->|
        public static int VOLTA=2; //  |<- |   |

        private OutputStream os=null;
        private OutputStreamCustom(OutputStream os) {
            this.os=os;
        }
        
        public void write(int sentido_, byte[] buffer, int off, int len, String ponteID) throws IOException {
            // implementar aqui o controle geral
            //  if (sentido_ == IDA)     |   | ->|
            //  if (sentido_ == VOLTA)   |<- |   |
            os.write(buffer, off, len);
            mostra_(sentido_, buffer, len, ponteID);
        }

        private void mostra_(int sentido_, byte[] buffer, int len, String ponteID){
            if (sentido_ == IDA){
                if (displayIda)
                    mostra("->", buffer, len, ponteID, !displaySimple);
                // nao remover controle displaySimple!
                if (displaySimple)
                    System.out.println("1 "+ponteID+" "+cleanTextContent(new String(buffer,0,len)));
            }
            if (sentido_ == VOLTA){
                if (displayVolta)
                    mostra("<-", buffer, len, ponteID, !displaySimple);
                // nao remover controle displaySimple!
                if (displaySimple)
                    System.out.println("2 "+ponteID+" "+cleanTextContent(new String(buffer,0,len))); 
            }
        }

        private void mostra(String direcao, byte[] buffer, int len, String ponteID, boolean flag_show_int) {
            // INT
            if ( flag_show_int ){
                System.out.println(
                    direcao+"(id "+ponteID+" int):"
                    +getInts(buffer,len)
                );
                // STR
                for (String parte : new String(buffer,0,len).split("\n") )                
                    System.out.println(direcao+"(id "+ponteID+" str):"+parte);            
            }else{
                for (String parte : new String(buffer,0,len).split("\n") )                
                    System.out.println(direcao+parte);            
            }
        }

        private String cleanTextContent(String text) 
        {
            // strips off all non-ASCII characters
            text = text.replaceAll("[^\\x00-\\x7F]", " ");
            // erases all the ASCII control characters
            text = text.replaceAll("[\\p{Cntrl}&&[^\r\n\t]]", " ");
            // removes non-printable characters from Unicode
            text = text.replaceAll("\\p{C}", " ");
            return text.replace("$"," ").trim();
        }
        
        private String getInts(byte[] buffer,int len) {            
            int count=0;
            StringBuilder sb=new StringBuilder();
            for (byte b : buffer){
                sb.append(Y.OD_BC_R[Y.byte_to_int_java(b,false)]);
                if ( ++count >= len )
                    break;
            }
            return sb.toString();
        }

        private String getHexs(byte[] buffer,int len) {            
            int count=0;
            StringBuilder sb=new StringBuilder();
            for (byte b : buffer){
                sb.append(String.format("%02X",Y.byte_to_int_java(b,false)));
                if ( ++count >= len )
                    break;
            }
            return sb.toString();
        }

    }

    @SuppressWarnings({"unchecked", "deprecation"})
    class Ambiente {
        ServerSocket serverSocket=null;
        private Ambiente(String host0,int port0) throws Exception {
            // exemplo host0 -> "192.168.0.100"
            if ( host0 == null ){
                try{
                    host0=InetAddress.getLocalHost().getHostName();
                }catch(Exception e){
                    System.out.println("warning: procurando ip ...");
                    host0=getListaIPs().get(0);
                    System.out.println("warning: ip localizado -> "+host0);
                }                    
            }
            
            serverSocket = new ServerSocket(port0, 1,InetAddress.getByName(host0));
        }
        private Socket getCredencialSocket() throws Exception {
            return serverSocket.accept();
        }

    }
    
    public String padLeftZeros(String inputString, int length) {
        if (inputString.length() >= length) {
            return inputString;
        }
        StringBuilder sb = new StringBuilder();
        while (sb.length() < length - inputString.length()) {
            sb.append('0');
        }
        sb.append(inputString);

        return sb.toString();
    }
}  

@SuppressWarnings({"unchecked", "deprecation"})
class XML extends Util{
    public static String linhasExcel="0123456789";    
    public static int linhasExcel_len=linhasExcel.length();    
    public static String colunasExcel="ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    public static int colunasExcel_len=colunasExcel.length();    
    public static String sepCSV=";";
    
    private static void resetControleTags(){
        controleTags_pilha=new ArrayList<String>();
        controleTags_tags=new ArrayList<String>();
        controleTags_nivelTail=-1;
        pivo_t=null;
        pivo_r=null;
        pivo_txt=null;
    }
    
    private static ArrayList<String> controleTags_pilha=new ArrayList<String>();
    private static ArrayList<String> controleTags_tags=new ArrayList<String>();
    private static int controleTags_nivelTail=-1;
    private static String pivo_t=null;
    private static String pivo_r=null;
    private static String pivo_s=null;
    private static String pivo_txt=null;
    public static ArrayList<String> shared=null;
    private static void controleTags(String txt,int nivel,boolean exportSheetCSV){
        nivel=nivel-1;// lista iniciada com 0
        pivo_txt=null;
        
        if ( nivel == controleTags_nivelTail+1 ){
            if ( ! txt.trim().startsWith("<") ){
                // pivo_txt
                if ( exportSheetCSV 
                    && controleTags_pilha.size() == 5
                    && controleTags_pilha.get(0).equals("worksheet")
                    && controleTags_pilha.get(1).equals("sheetData")
                    && controleTags_pilha.get(2).equals("row")
                    && controleTags_pilha.get(3).equals("c")
                    && controleTags_pilha.get(4).equals("v")
                ){
                    pivo_txt=txt;                    
                }
                return;
            }
            if ( txt.trim().startsWith("</") ){
                erroFatal(54);
            }
            controleTags_pilha.add(getTagFromLine(txt));
            controleTags_nivelTail=nivel;
            controleTagsUpdate();
            // pivo_t/pivo_r/pivo_r
            if ( exportSheetCSV 
                && controleTags_pilha.size() == 4
                && controleTags_pilha.get(0).equals("worksheet")
                && controleTags_pilha.get(1).equals("sheetData")
                && controleTags_pilha.get(2).equals("row")
                && controleTags_pilha.get(3).equals("c")                
            ){                
                pivo_t=null;
                pivo_r=null;
                pivo_s=null;
                HashMap att=getAtributosFromLine(txt);
                if (att.containsKey("t"))
                    pivo_t=att.get("t").toString();
                if (att.containsKey("r"))
                    pivo_r=att.get("r").toString();
                if (att.containsKey("s"))
                    pivo_s=att.get("s").toString();
            }            
            return;
        }
        if ( nivel == controleTags_nivelTail ){
            if ( ! txt.trim().startsWith("<") ) return;
            if ( txt.trim().startsWith("</") ) return;
            // remove a ultima posicao
            controleTags_pilha.remove(controleTags_pilha.size()-1); 
            controleTags_pilha.add(getTagFromLine(txt));
            controleTags_nivelTail=nivel;
            controleTagsUpdate();
            // pivo_t/pivo_r/pivo_s
            if ( exportSheetCSV 
                && controleTags_pilha.size() == 4
                && controleTags_pilha.get(0).equals("worksheet")
                && controleTags_pilha.get(1).equals("sheetData")
                && controleTags_pilha.get(2).equals("row")
                && controleTags_pilha.get(3).equals("c")                
            ){                
                pivo_t=null;
                pivo_r=null;
                pivo_s=null;
                HashMap att=getAtributosFromLine(txt);
                if (att.containsKey("t"))
                    pivo_t=att.get("t").toString();
                if (att.containsKey("r"))
                    pivo_r=att.get("r").toString();
                if (att.containsKey("s"))
                    pivo_s=att.get("s").toString();
            }                        
            return;
        }

        if ( nivel == controleTags_nivelTail-1 ){
            if ( ! txt.trim().startsWith("<") )
                return;                
            if ( txt.trim().startsWith("</") ){
                controleTags_pilha.remove(controleTags_pilha.size()-1); 
                controleTags_nivelTail=nivel;
                return;
            }
            // remove as duas ultimas posicoes
            controleTags_pilha.remove(controleTags_pilha.size()-1);
            controleTags_pilha.remove(controleTags_pilha.size()-1); 
            controleTags_pilha.add(getTagFromLine(txt));
            controleTags_nivelTail=nivel;
            controleTagsUpdate();
            return;
        }
    }
    
    private static void controleTagsUpdate(){
        String tag="";
        for ( int j=0;j<controleTags_pilha.size();j++ )
            tag+="/"+controleTags_pilha.get(j);
        boolean achou=false;
        for ( int j=0;j<controleTags_tags.size();j++ ){
            if ( controleTags_tags.get(j).equals(tag) ){
                achou=true;
                break;
            }
        }
        if ( ! achou )
            controleTags_tags.add(tag);
    }
    
    private HashMap atributos=new HashMap();
    private String value=null;
    private ArrayList<XML> filhos=new ArrayList<XML>();
    private String tag=null;    
    
        
    public static ArrayList<String> listaTxt=null;
    public static ArrayList<Integer> listaNivel=null;
    public void loadIs(InputStream is,boolean mostraEstrutura,boolean mostraTags,String caminho, boolean exportSheetCSV,OutputStream out, boolean suprimeHeader) throws Exception {
        resetLista();
        
        readLine(is,"UTF-8",">");        
        StringBuilder sb=new StringBuilder();
        String txt=null;
        boolean first=true;
        
        String entrada=null;
        String tail=null;
        sb=new StringBuilder();
        int len=0;
        int nivel=1;
        boolean tag_in=false;
        boolean tag_finish=false;
        boolean tag_value=false;
        boolean tail_tag_abertura=false; //
        
        if ( exportSheetCSV )
            processaCelulaInit();
        
        if ( mostraEstrutura && caminho != null )
            System.out.println("\n=> "+caminho);        
        
        resetControleTags();
        
        while ( (txt=readLine()) != null ){                        
            txt=txt.replace("\n","")+">";
            len=txt.length();
            

            if ( first ){
                first=false;
                int detectBOM=txt.indexOf("<?xml");
                if ( detectBOM > -1 && detectBOM <= 3 )
                    continue;
            }

            for( int i=0;i<len;i++ ){
                entrada=txt.substring(i,i+1);
                
                if ( nivel < 1 ){                    
                    erroFatal(1);
                }     
                if ( tag_in && tag_value ){
                    erroFatal(2);
                }
                if ( tail == null ){
                    tail=entrada;
                    continue;
                }
                if( !tag_in && !tag_value && tail.equals("<") && entrada.equals("/") ){ // tag de fechamento
                    sb.append(tail);
                    sb.append(entrada);
                    tail=null;
                    tag_in=true;
                    tag_finish=true;
                    nivel--;
                    continue;
                }
                if( !tag_in && !tag_value && tail.equals("<") ){ // tag de abertura ou tag unica
                    sb.append(tail);                
                    tail=entrada;
                    tag_in=true;                
                    continue;
                }
                if ( tag_in && tail.equals("/") && entrada.equals(">") ){ // tag unica            
                    if ( tag_finish ){ // nao pode haver finish com tag unica
                        erroFatal(3);
                    }
                    sb.append(tail);
                    sb.append(entrada);
                    tail=null;
                    tag_in=false;
                    tag_finish=false; // segurança
                    addLista(sb.toString(),nivel,mostraEstrutura,exportSheetCSV,out,suprimeHeader);
                    sb=new StringBuilder();
                    tail_tag_abertura=false;
                    continue;                
                }
                if ( tag_in && entrada.equals(">") ){ // tag abertura ou tag fechamento
                    sb.append(tail);
                    sb.append(entrada);
                    tail=null;
                    tag_in=false;                
                    addLista(sb.toString(),nivel,mostraEstrutura,exportSheetCSV,out,suprimeHeader);
                    sb=new StringBuilder();
                    if ( tag_finish ){
                        //nivel--; foi decrementado em outro local
                        tail_tag_abertura=false;
                    }else{
                        nivel++;
                        tail_tag_abertura=true;
                    }
                    tag_finish=false;
                    continue;                
                }
                if ( !tag_in && !tag_value && entrada.equals("<") ){ // inicio e fim de value bem rapido ex: ...>5<...
                    if ( ! tail_tag_abertura ){
                        // nao eh possivel iniciar value
                        tail=entrada;
                        continue;
                    }
                    tag_value=true;                
                    sb.append(tail);                    
                    tail=entrada;
                    addLista(sb.toString(),nivel,mostraEstrutura,exportSheetCSV,out,suprimeHeader);
                    sb=new StringBuilder();
                    tag_value=false;
                    tail_tag_abertura=false;
                    continue;
                }
                if ( !tag_in && !tag_value ){ // iniciando value
                    if ( ! tail_tag_abertura ){
                        // nao eh possivel iniciar value
                        tail=entrada;
                        continue;
                    }                
                    tag_value=true;                
                    sb.append(tail);                    
                    tail=entrada;
                    continue;
                }
                if( tag_value && entrada.equals("<") ){ // finalizando processamento de value
                    tag_value=false;
                    sb.append(tail);                    
                    tail=entrada;
                    addLista(sb.toString(),nivel,mostraEstrutura,exportSheetCSV,out,suprimeHeader);
                    sb=new StringBuilder();
                    continue;            
                }
                sb.append(tail);                    
                tail=entrada;
                continue;            
            }            
        }
        closeLine();
        
        if ( exportSheetCSV )
            processaCelulaFlush(out);
        
        if ( tail != null ){
            erroFatal(4);
        }        
        if ( mostraTags )
            for (int i=0;i<controleTags_tags.size();i++ )            
                System.out.println(controleTags_tags.get(i));
    }
        
    private static void resetLista() {
        listaTxt=new ArrayList<String>();
        listaNivel=new ArrayList<Integer>();
    }
    
    private void addLista(String txt, int nivel, boolean mostraEstrutura, boolean exportSheetCSV,OutputStream out, boolean suprimeHeader) throws Exception{
        if ( mostraEstrutura ){
            if ( ! txt.trim().equals("") ){
                for (int j=0;j<nivel-1;j++ )
                    System.out.print("\t");
                System.out.println(txt);
            }
        }
        controleTags(txt.trim(),nivel,exportSheetCSV);
        
        if ( exportSheetCSV ){
            if ( pivo_txt != null ){
                if ( pivo_t != null && pivo_t.equals("s") ){
                    processaCelula(
                        pivo_r
                        ,shared.get(Integer.parseInt(pivo_txt))
                        ,out
                        ,suprimeHeader
                    );
                }else{
                    if ( pivo_s != null && pivo_s.equals("2") && ( pivo_txt.contains("E") || ( txt.contains(".") && txt.split("\\.")[1].length() >= 15 ) ) ){ 
                        processaCelula(
                            pivo_r
                            ,arredondamentoNumber(pivo_txt)
                            ,out
                            ,suprimeHeader
                        );
                    }else{
                        processaCelula(
                            pivo_r
                            ,pivo_txt
                            ,out
                            ,suprimeHeader
                        );
                    }
                }
            }
        }else{
            // processamento cache
            listaTxt.add(txt.trim());
            listaNivel.add(nivel);        
        }
    }
    
    private static StringBuilder processaCelula_sb=new StringBuilder();
    private static int processaCelula_tail_linha=-1;
    private static int processaCelula_tail_coluna=-1;
    private static int processaCelula_max_tail_coluna=-1;
    private static int countWrited=0;
    private static void processaCelulaInit(){
        processaCelula_sb=new StringBuilder();
        processaCelula_tail_linha=-1;
        processaCelula_tail_coluna=-1;
        processaCelula_max_tail_coluna=-1;
        countWrited=0;
    }
    
    private static void processaCelula(String localCelula, String valor, OutputStream out, boolean suprimeHeader) throws Exception {
        //public static String linhasExcel="0123456789";    
        //public static String colunasExcel="ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        int linha=0;
        int linha_exp=0;
        int coluna=0;
        int coluna_exp=0;    
        
        int len=localCelula.length();
        String entrada="";
        int pos=0;
        
        if ( valor == null )
            valor="";
        valor=valor.replace("&lt;","<").replace("&gt;",">").replace("&amp;","&").replace("\"","\"\"");
        
        for ( int i=len-1;i>=0;i-- ){ // obs: no excel a primeira linha é 1. A primeira coluna é A(aqui representada com 0)
            entrada=localCelula.substring(i,i+1);
            pos=linhasExcel.indexOf(entrada);
            if ( pos != -1 ){ // linha
                linha+=Math.pow(linhasExcel_len, linha_exp++)*pos;
            }else{ // coluna
                pos=colunasExcel.indexOf(entrada);
                if ( pos != -1 ){ 
                    coluna+=Math.pow(colunasExcel_len, coluna_exp++)*pos;
                }else{
                    erroFatal(15);
                }
            }
        }

        if ( processaCelula_tail_linha == -1 ){
            processaCelula_tail_linha=linha;
            processaCelula_tail_coluna=-1;
            if ( processaCelula_tail_coluna > processaCelula_max_tail_coluna )
                processaCelula_max_tail_coluna=coluna;        
        }else{
            if ( processaCelula_tail_linha > linha ){
                erroFatal(14);
            }
            while(processaCelula_tail_linha < linha){
                while(processaCelula_tail_coluna<processaCelula_max_tail_coluna){
                    processaCelula_sb.append("\"\"");
                    processaCelula_sb.append(sepCSV);
                    processaCelula_tail_coluna++;
                }
                processaCelula_tail_coluna=-1;
                countWrited++;
                if ( suprimeHeader && countWrited == 1 ){
                    // suprime
                }else{
                    out.write(processaCelula_sb.toString().getBytes());
                    out.write("\n".getBytes());
                }
                processaCelula_sb=new StringBuilder();
                processaCelula_tail_linha++;
            }
        }
        while(processaCelula_tail_coluna<coluna-1){
            processaCelula_sb.append("\"\"");
            processaCelula_sb.append(sepCSV);
            processaCelula_tail_coluna++;
        }
        
        processaCelula_sb.append("\"");
        processaCelula_sb.append(valor);
        processaCelula_sb.append("\"");
        processaCelula_sb.append(sepCSV);
        
        processaCelula_tail_linha=linha;
        processaCelula_tail_coluna=coluna;
        if ( processaCelula_tail_coluna > processaCelula_max_tail_coluna ){
            processaCelula_max_tail_coluna=coluna;        
        }
    }

    private static void processaCelulaFlush(OutputStream out) throws Exception{
        if ( processaCelula_sb.length() > 0 ){
            while(processaCelula_tail_coluna<processaCelula_max_tail_coluna){
                processaCelula_sb.append("\"\"");
                processaCelula_sb.append(sepCSV);
                processaCelula_tail_coluna++;
            }
            out.write(processaCelula_sb.toString().getBytes());
            out.write("\n".getBytes());
        }
    }
    
    public static XML getXML(){
        return ((ArrayList<XML>)getXML(1,0,listaTxt.size()-1)).get(0);
    }    
    
    public static Object getXML(int nivel,int ini,int fim){
        // retorno pode ser ArrayList<XML> ou String
        // nivel inicia em 1
        // int inicia em 0        
        String tag="";
        String tipoTag=""; // inicio fim unica
        if ( ini == fim && !listaTxt.get(ini).startsWith("<") )
            return listaTxt.get(ini);        
        ArrayList<XML> lista=new ArrayList<XML>();
        XML xml=null;        
        int inicio_n=0;
        String inicio_tag="";
        for(int i=ini;i<=fim;i++ ){
            if ( listaNivel.get(i) == nivel && xml == null ){
                if ( listaTxt.get(i).trim().equals("") )
                    continue;
                xml=new XML();
                tag=XML.getTagFromLine(listaTxt.get(i));
                tipoTag=XML.getTipoTagFromLine(listaTxt.get(i));
                if ( tipoTag.equals("fim") )
                    erroFatal(8);
                xml.addAtributoAll(XML.getAtributosFromLine(listaTxt.get(i)));
                if ( tipoTag.equals("unica") ){
                    xml.setTag(tag);
                    lista.add(xml);
                    xml=null;                    
                }else{
                    inicio_n=i;
                    inicio_tag=tag;
                    xml.setTag(tag);
                }
                continue;
            }
            if ( listaNivel.get(i) == nivel && xml != null ){
                tag=XML.getTagFromLine(listaTxt.get(i));
                tipoTag=XML.getTipoTagFromLine(listaTxt.get(i));
                if ( !tipoTag.equals("fim") )
                    erroFatal(9);                
                if ( ! tag.equals(inicio_tag) )
                    erroFatal(10);
                if ( (i-inicio_n) > 1 ){
                    Object interno=getXML(nivel+1,inicio_n+1,i-1);
                    try{
                        xml.addFilhos((ArrayList<XML>)interno);
                    }catch(Exception e){
                        xml.value=(String)interno;
                    }
                }
                lista.add(xml);
                xml=null;                
            }
        }
        return lista;
    }
    
    private static String getTagFromLine(String line) {
        String tag=line.replace("<","").replace(">","").replace("/","").split(" ")[0];
        if ( tag.length() == 0 )
            erroFatal(12);
        return tag;
    }

    private static String getTipoTagFromLine(String line) {
        String tipoTag=null;        
        if ( line.startsWith("</") )
            tipoTag="fim";
        else{            
            if ( line.endsWith("/>") )
                tipoTag="unica";
            else{
                if ( !line.startsWith("<") || !line.endsWith(">") )
                    erroFatal(11);
                tipoTag="inicio";
            }
        }
        return tipoTag;
    }

    private static HashMap getAtributosFromLine(String a) {
        ArrayList<String> partes=new ArrayList<String>();
        a=a.replace("<","").replace(">","").replace("/","");
        int len=a.length();
        boolean aspas_in=false;
        String entrada="";
        StringBuilder sb=new StringBuilder();
        HashMap retorno=new HashMap();
        
        for ( int i=0;i<len;i++ ){
            entrada=a.substring(i,i+1);
            if(entrada.equals("\""))
                aspas_in=!aspas_in;
            if ( !aspas_in && entrada.equals(" ") ){
                partes.add(sb.toString());
                sb=new StringBuilder();
                continue;
            }
            sb.append(entrada);
        }
        if ( sb.toString().length() > 0 )
            partes.add(sb.toString());
        
        String k="";
        String v="";
        for(int i=1;i<partes.size();i++){
            try{
                k=partes.get(i).split("=")[0];
                v=partes.get(i).split("=")[1].replace("\"","");
                if ( k.length() > 0 && v.length() > 0 ){
                    retorno.put(k, v);
                }
            }catch(Exception e){}
        }
        return retorno;
    }

    public void setTag(String tag){
        this.tag=tag;
    }
    
    public String getTag(){
        return tag;
    }
    
    public String getAtributo(String a){
        return (String)atributos.get(a);
    }
    
    public void addAtributoAll(HashMap a) {
        atributos.putAll(a);
    }    
    
    public List<String> getAtributosNames() {
        return new ArrayList<String>(atributos.keySet());
    }
    
    public void setValue(String value){
        this.value=value;
    }
    
    public String getValue(){
        return value;
    }
    
    public void addFilhos(ArrayList<XML> a) {
        filhos.addAll(a);
    }
    
    public ArrayList<XML> getFilhos(){
        return filhos;
    }      
}

@SuppressWarnings({"unchecked", "deprecation"})
class PlaylistServer extends Util{
    File _cfg=null;
    final String [] identify_kill=new String[]{"ignoreIGNORE:INSTANTE:33:"};
    final Boolean[] new_order=new Boolean[]{false};
    final String[] instrucoes=new String[]{""};
    final String[] error=new String[]{""};
    final String[] trace=new String[]{"0"};
    final Integer[] play_faixa=new Integer[]{0};
    final Integer[] n_faixas=new Integer[]{0};
    final Long[] epochmili_started=new Long[]{0L};
    public PlaylistServer(String cfg){
        if ( cfg != null ){
            _cfg=new File(cfg);  
            kill_by_text(identify_kill[0]);
            new Thread(new Runnable() {
                Boolean waiting=true;
                String name_worker=null;
                Boolean worker_loop=null;
                String device=null;
                String [] faixa=null;
                Float vol_worker=null;
                Float [] vol_faixa=null;
                Integer [] sec_faixa=null;
                String path_vlc=null;
                Integer seconds_play_faixa=null;
                Boolean seconds_extra=null;
                public void init(){
                    name_worker=null;
                    worker_loop=null;
                    device=null;
                    faixa=null;
                    vol_worker=null;
                    vol_faixa=null;
                    sec_faixa=null;
                    path_vlc=null;
                    play_faixa[0]=null;
                    n_faixas[0]=null;
                    seconds_extra=false;
                }   
                public boolean ok(){
                    if ( name_worker == null
                         || worker_loop == null
                         || device == null
                         || faixa == null
                         || vol_worker == null
                         || vol_faixa == null
                         || sec_faixa == null
                         || path_vlc == null
                         || play_faixa[0] == null
                         || n_faixas[0] == null
                    )
                         return false;
                    return true;
                }
                public String especial_parm(String line, String [] partes, int n) throws Exception{
                    if ( n == 1 )
                        return line.substring(partes[0].length()+1);
                    if ( n == 2 )
                        return line.substring(partes[0].length()+1+partes[1].length()+1);
                    throw new Exception("Erro: erro interno! 0909");
                }
                public void run(){
                    try{
                        while(true){
                            if ( new_order[0] ){
                                new_order[0]=false;
                                if ( instrucoes[0].equals("") ){
                                    waiting=true;
                                    error[0]="";
                                    continue;
                                }else{
                                    waiting=false;
                                    init();
                                    // instrucoes                                    
                                    String [] lines=instrucoes[0].split("\\|");
                                    for ( int i=0;i<lines.length;i++ ){
                                        String [] partes=lines[i].split(" ");
                                        error[0]="Erro: analisando a linha " + lines[i];
                                        if ( partes.length == 0 || partes[0].trim().equals("") )
                                            continue;
                                        if ( partes[0].equals("name_worker") ){
                                            name_worker=especial_parm(lines[i], partes, 1);
                                            continue;
                                        }
                                        if ( partes[0].equals("worker_loop") ){
                                            worker_loop=partes[1].equals("yes");
                                            continue;
                                        }
                                        if ( partes[0].equals("device") ){
                                            device=especial_parm(lines[i], partes, 1);
                                            if ( device.equals("auto") )
                                                device=get_mixer(" TV ");
                                            if ( device.equals("tv") )
                                                device=get_mixer(" TV ");
                                            if ( device.equals("pc") )
                                                device=get_mixer("Alto-falantes (HUSKY)");
                                            continue;
                                        }
                                        if ( partes[0].equals("n_faixas") ){
                                            n_faixas[0]=Integer.parseInt(partes[1]);
                                            faixa=new String[n_faixas[0]];
                                            vol_faixa=new Float[n_faixas[0]];
                                            sec_faixa=new Integer[n_faixas[0]];
                                            continue;
                                        }
                                        if ( partes[0].equals("faixa") ){
                                            faixa[Integer.parseInt(partes[1])]=especial_parm(lines[i], partes, 2);
                                            faixa[Integer.parseInt(partes[1])]=faixa[Integer.parseInt(partes[1])].replaceAll("&amp;", "&");
                                            continue;
                                        }
                                        if ( partes[0].equals("vol") && partes[1].equals("worker") ){
                                            vol_worker=Float.parseFloat(partes[2]);
                                            continue;
                                        }
                                        if ( partes[0].equals("cfg") ){
                                            if ( partes[1].equals("faixa") ){
                                                Integer _faixa=Integer.parseInt(partes[2]);
                                                vol_faixa[_faixa]=Float.parseFloat(partes[3]);
                                                String [] h_m_s=partes[4].split(":");
                                                if ( h_m_s.length > 3 ){
                                                    throw new Exception("Erro: Erro fatal!, não foi possivel interpretar a linha " + lines[i]);
                                                }
                                                if ( h_m_s.length == 1 ){
                                                    sec_faixa[_faixa]=Integer.parseInt(h_m_s[0]);
                                                }else{
                                                    if ( h_m_s.length == 2 ){
                                                        sec_faixa[_faixa]=Integer.parseInt(h_m_s[0])*60+Integer.parseInt(h_m_s[1]);                                                        
                                                    }else{
                                                        sec_faixa[_faixa]=Integer.parseInt(h_m_s[0])*60*60+Integer.parseInt(h_m_s[1])*60+Integer.parseInt(h_m_s[2]);
                                                    }
                                                }                                                
                                                continue;
                                            }
                                        }
                                        if ( partes[0].equals("path_vlc") ){
                                            path_vlc=especial_parm(lines[i], partes, 1);
                                            continue;
                                        }
                                        if ( partes[0].equals("play") ){
                                            play_faixa[0]=Integer.parseInt(partes[2]);
                                            continue;
                                        }     
                                        if ( partes[0].equals("seconds_extra") ){
                                            seconds_extra=true;                                            
                                            //lines=removeParm(i, lines);
                                            //i--;
                                            continue;
                                        }     
                                        throw new Exception("Erro: Erro fatal!, não foi possivel interpretar a linha " + lines[i]);
                                    }
                                    instrucoes[0]=String.join("|", lines);
                                    if ( ok() )
                                        error[0]="";
                                    else{
                                        waiting=true;
                                        error[0]="Erro: comando incompleto ou incorreto! -> " + instrucoes[0];
                                        instrucoes[0]="";                                        
                                        continue;
                                    }
                                }                                
                            }
                            if ( waiting ){
                                try { Thread.sleep(50); } catch (Exception ee) {}
                                continue;
                            }
                            if ( vol_faixa[play_faixa[0]] == null )
                                vol_faixa[play_faixa[0]]=1F;
                            Float gain=vol_worker*vol_faixa[play_faixa[0]];
                            if ( gain < 0 )
                                gain=0F;
                            if ( gain > 1 )
                                gain=1F;
                            Integer _time=sec_faixa[play_faixa[0]];
                            if ( !seconds_extra )
                                epochmili_started[0]=epochmili(null);
                            else
                                _time+=(int)((epochmili(null)-epochmili_started[0])/1000);
                            String s=runtimeExec(null, new String[]{"cmd", "/c", "vlc", identify_kill[0], "--mmdevice-audio-device="+device, "--start-time="+_time, "--gain="+gain, "-Incurse", "--play-and-exit", "--no-video", faixa[play_faixa[0]] }, new File(path_vlc), null, null);
                            seconds_extra=false;
                            if ( new_order[0] || waiting ) // skip
                                continue;
                            seconds_play_faixa=0;
                            if ( runtimeExecError != null && !runtimeExecError.equals("") && !runtimeExecError.contains("main interface error: no suitable interface module") ){
                                waiting=true;
                                instrucoes[0]="";
                                error[0]=runtimeExecError;
                                continue;
                            }
                            if ( play_faixa[0]+1 >= n_faixas[0] ){
                                if ( !worker_loop ){
                                    waiting=true;
                                    instrucoes[0]="";
                                    continue;
                                }
                                play_faixa[0]=0;
                            }else{
                                play_faixa[0]++;
                            }
                        }
                    }catch(Exception e){
                        if ( error[0].startsWith("Erro: " ) )
                            error[0]+=" - excp: " + e.toString();
                        else
                            error[0]="Erro:: " + e.toString();
                        if ( !trace[0].equals("") )
                            error[0]+=" - trace: " + trace[0];
                        return;
                    }
                }
            }).start();
            if ( _cfg.exists() ){
                String pergunta=lendo_arquivo(cfg);
                String resposta=perguntando(pergunta, true);
            }            
        }
    }
    
    public ArrayList<String> getFilesCustom(File f){
        ArrayList<String> lista=new ArrayList<String>();
        File [] files=f.listFiles();
        for ( int i=0;i<files.length;i++ ){
            if ( files[i].isFile() ){
                lista.add(files[i].getAbsolutePath());                
            }else{
                if ( files[i].isDirectory() )
                    lista.addAll(getFilesCustom(files[i]));
            }
        }
        return lista;
    }
    public String perguntando(String a, Boolean starting_server){
        String retorno_amigavel="..";
        if ( a.equals("ping") )
            return "pong";
        if ( a.equals("mixer") ){
            return get_mixer(" TV ");
        }
        if ( a.equals("list") ){
            String _f="D:\\ProgramFiles\\site\\musicas";
            File f=new File(_f);
            if ( !f.exists() )
                return "Erro: Não foi possível encontrar a pasta " + _f;
            if ( !f.isDirectory() )
                return "Erro: Esse caminho não é uma pasta: " + _f;
            return String.join("|", arrayList_to_array(getFilesCustom(f)));
        }
        if ( a.equals("status") ){
            if ( !error[0].equals("") )
                return error[0];
            if ( instrucoes[0].equals("") )
                return "stopped";
            return instrucoes[0];
        }
        if ( a.startsWith("vol worker ") ){
            if ( !error[0].equals("") )
                return error[0];
            if ( instrucoes[0].equals("") )
                return "stopped";
            String [] lines=instrucoes[0].split("\\|");
            boolean added=false;
            for ( int i=0;i<lines.length;i++ ){
                if ( lines[i].startsWith("vol worker ") ){
                    lines[i]=a;                    
                    continue;
                }
                if ( lines[i].startsWith("play faixa ") ){
                    lines[i]="play faixa " + play_faixa[0];
                    continue;
                }
                if ( lines[i].equals("seconds_extra") ){ // validacao de segurança.. provavelmente não deverá entrar aqui!
                    added=true;
                    continue;
                }
            }
            if ( !added )
                lines=addParm("seconds_extra", lines);
            instrucoes[0]="";
            new_order[0]=true;
            kill_by_text(identify_kill[0]);
            instrucoes[0]=String.join("|", lines);
            new_order[0]=true;                    
            return retorno_amigavel;
        }
        if ( a.equals("stop") || a.equals("") ){
            instrucoes[0]="";
            new_order[0]=true;
            if ( _cfg != null && !starting_server )
                salvando_file(instrucoes[0], _cfg);
            // kills
            kill_by_text("ignoreIGNORE:INSTANTE:33:", "cmd /c", "wmic ", false);
            return retorno_amigavel;
        }
        if ( a.equals("back") || a.equals("next") ){
            if ( instrucoes[0].contains("play faixa ") ){
                Integer _play_faixa=play_faixa[0];
                Integer _n_faixas=n_faixas[0];
                if ( _play_faixa != null && _n_faixas != null ){
                    String [] lines=instrucoes[0].split("\\|");
                    if ( a.equals("back") ){
                        _play_faixa--;
                        if ( _play_faixa < 0 )
                            _play_faixa=_n_faixas-1;
                    }else{
                        _play_faixa++;
                        if ( _play_faixa >= _n_faixas )
                            _play_faixa=0;
                    }
                    for ( int i=0;i<lines.length;i++ )
                        if ( lines[i].startsWith("play faixa ") )
                            lines[i]="play faixa "+_play_faixa;
                    instrucoes[0]="";
                    new_order[0]=true;
                    kill_by_text(identify_kill[0]);
                    instrucoes[0]=String.join("|", lines);
                    new_order[0]=true;                    
                }
            }
            return retorno_amigavel;
        }
        if ( a.startsWith("base64 ") ){
            a=a.substring("base64 ".length());
            try{
                a=base64(a, false);
            }catch(Exception e){
                return e.toString();
            }
        }
        // kills
        instrucoes[0]="";
        new_order[0]=true;
        kill_by_text(identify_kill[0]);
        instrucoes[0]=a.replaceAll("\r", "").replaceAll("\n", "|");
        new_order[0]=true;
        if ( _cfg != null && !starting_server ){
            if ( instrucoes[0].contains("worker_loop no") )
                salvando_file("", _cfg);
            else
                salvando_file(instrucoes[0], _cfg);            
        }
        return retorno_amigavel;
        /*
        Na acao status, retornar a lista completa de instruções e o play deve informar o time:
            play faixa 2 20
            ou
            stopped
            ou Error abced(em caso da faixa não existir o arquivo ou algum outro tipo de erro)

        Na acao next, deve ir para a proxima faixa baseado na qual esta tocando
        
        Na acao stop, deve para tudo.
        
        Na acao back, deve ir para musica anterior
        
        Na instrucao play deve haver várias linhas sendo a final play ...:
            name_worker Teste Miau
            worker_loop yes
            device {0.0.0.00000000}.{8eee1bfc-5bb7-47ce-ab43-2fb54956292e}
            n_faixas 4
            faixa 0 D:\ProgramFiles\site\musicas\classicas\12 Continent - The Journey.mkv
            faixa 1 D:\ProgramFiles\site\musicas\classicas\End Credits (From 'Pirates of the Caribbean - On Stranger Tides'_Score).mkv
            faixa 2 D:\ProgramFiles\site\musicas\classicas\Rhapsody In Blue - Gershwin.webm
            faixa 3 D:\ProgramFiles\site\musicas\classicas\Adagio for Strings, Op. 11.mkv
            vol worker 0.01
            cfg faixa 0 1 0
            cfg faixa 1 1 0
            cfg faixa 2 1 0
            cfg faixa 3 1 0
            path_vlc C:\Program Files\VideoLAN\VLC
            play faixa 0
            obs: play precisa ser a ultima linha necessariamente, senão o comando deve retornar erro
            obs2: se o worker_loop for no, então ao final da playlist, o sistema deverá ficar em stopped
            obs3: uma vez executada esse comando de play com sucesso e nao for starting_server e _cfg não for null, então: deverá armazenar a pergunta aqui recebida. salvando_file(String texto, File _cfg)
            obs4: formato do texto da pergunta: aa bb cc\ndd ee ff. Se for armazenar, guardar no mesmo formato!
        */
        
        /*
            var xmlHttp = new XMLHttpRequest();
            xmlHttp.open('GET', '/token', false);
            xmlHttp.setRequestHeader('acao', 'oi');
            xmlHttp.send(null);
            console.log(xmlHttp.responseText);
        
            var xmlHttp = new XMLHttpRequest();
            xmlHttp.open('GET', '/token', false);
            xmlHttp.setRequestHeader('acao', 'oi');
            xmlHttp.send(null);
            console.log(xmlHttp.responseText);
        
        
        */                
    }
    public String get_html_sem_acao(){
        if ( _cfg == null )
            return "nao existe html configurado!!";
        String _f=_cfg.getAbsolutePath()+".html";
        File f=new File(_f);
        if ( !f.exists() )
            return "O arquivo " + f.getAbsolutePath() + " ainda não foi criado!";
        return lendo_arquivo(_f);
    }
}

@SuppressWarnings({"unchecked", "deprecation"})
class yTerminal extends JFrame {
    @SuppressWarnings({"unchecked", "deprecation"})
    class UtilAux extends Util{}
    private BufferedImage image;
    private Point mouseOffset; // Para arrastar a janela
    private boolean isMaximized = false; // Estado de maximização da janela
    public String img64="/9j/4AAQSkZJRgABAQEAYABgAAD/2wBDAAMCAgMCAgMDAwMEAwMEBQgFBQQEBQoHBwYIDAoMDAsKCwsNDhIQDQ4RDgsLEBYQERMUFRUVDA8XGBYUGBIUFRT/2wBDAQMEBAUEBQkFBQkUDQsNFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBT/wAARCAH0A+gDASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD4dWlbtQoPpS169zIRactJTlpEi0UUUgFWnUR96dQWNoApWpaBjStKoxS0UCCiiiqC4UUUq0wuKtHcUtFOwDGpOcU8ijbQMYKO4pxFCrk0guN9aUA46U7btJoNSxXG7c+1Jjb3p4XJpGTmgBvXpQKXbiigLiinKD1pF6GpE6VpFEslVSV9Kt2y7Rk1Ci5XFWYxhce1dEI63JbMjxI37yGPoPmb+VYrfc/WtLxFLu1AL/dUVmVzS+JnoU/dgiu33TULdqmmojjLY4qGZl3TYd3NW7jEe6n2sYihHvUdwpcEA9aEel8NJmVOSTnrmmIpXnFTSKY2Ibj60menOaGeWJ6U5qTuaKtbAOjIByRmrPltJgsdq9gKqxruPWrKtx14FEUWE8Z2gKOBVXp1q1NOFUAcsagk2yNuUY9qJbkjN22l3Fm68U1uAfWljXdUXaAnji3MK1LWPbVe1iDYB4rSgiLOkaj7xxmtI6iZr+G7NJLkSNygGTV3Rbb/AISDX3mkOYIjgL9OlQs32OH7NHgPt+Zh710PgOwWzjmmkbamM8+gzk/St0ZSlyq7Oi1CR44IbeL77DzHA/uDoPx5/Kqag3UAUH5l4YGpNPdpBc38h2JMw8tW67BnH4daRpkTeYgvPcHrRNmMVbVkDWz2z7+/04ppj6uo3BatQ3BjxJIN3+zUUlwI4zIcYJ5FZm17ozJJJGbnao54asW7XaxI3M2ePStHUbpbiQ7Btz0rOZ9vDckUEdCJIVkX58h6qapozahCjRkLJEcjJ65//VWhGFCs2aIpgmTuzntTEr7nJXFiZL4O4IRRgqR3qjqFi0K5UZVsiuu1S1MgM0IDSKOV9fpXJ3TXEb75omQ54V1PX2rVtNXNY3PofwffT+I30FGhCDQdHW0LKPvzyNlifcKq/lWb8adHbSfFksYjxsjUEjkMSoOf1H51tfss+IBDYwWf2WKXy9Z8x7iUbjJvTaAR3Cjdgf7XtVP9orVBqHxP1hYLyO5sYHEEEUIG2FVUfLnuc1rUfuI4aaarNHjV5GyNuA+U1nMxz0rZkIZiuOKzZoSrkDpXAzsK+zd049aRoyuKdjaeuKVZOo4NIY2PKtzVpF3VEFVsc4qzDGeqndVIkb5eamjjK84zUiwncBjpVpYd3QU7AQJ0HG31prw7v/1VaKjoRzS/Zz1HNUBT27eo/OjyzJ93FWnhIHIpqoU5xigRSeFkbnr9KfGuCD1qaRS3PGah3FW+bj60CJvPPTGDRubgk0gUSYIxmmHerHI4oFYtLMGXY3ANNa1Qr8h5qJTnrUitigBseU4NWFXg1G3zYqVW4oFYhkfHFMWQ56US/fNNB5oGXYcyMv1roo7cTRrgZ4rnbbhga6XRrpCAj9e1BEhYLEZORwKvLDFIu1kCnHBq01uRCzqMj/Z5pLVFl27utBnc4nVY2FwxPTNVI+eK6HXrExzSLj3FYlvEdwXGSOtB09DStYf3PSl8r5+laun2fmQnI/hplzaeS447elUY31KseFVqr3C5Q8UsshSZV9alkXcrCmHUxGHJqMZ3VYlQLIajZRxUs3FIqKROlSZ96ZI+7FHQqO5CBinDPpSkdKctIvQWPvnilZd1CjJqzHGG60CKyx8c8U6rDWxJ4Oaatmxz1oM3uQH5iBVqKPatOjtDHyRk9q0rXTWk+ZhgDtTuQyksZbGATVmG13MB09a0V08R5bsOlPt4BhmIpkGRqjG3RUAwTWWW3Rgd+9betASSRhRnArL8k9wKspECsV6AYp+1Y7cvn5j61Yjt/nBYfLVbUZBtKr0FAzIuM+ZTFXNSPy2aFHWsx9B8aineWDTVqSkIgkULUDA+lWJBlqZtoAr7T6GnIGz6VMRikoAeIflzmopI+mBmrSfdFGzg0AUtu3tRUkic0UAY6g+lLT6K5zS2gzB9KVV9qetLQQkM2+1BXpxT6KC7CLS0UUDCiiigBVpWoWlppdRDKKfRVCGUq0rULTAWhetFKvemAYyaCtOFB61VgGgU5VopVoARlppXFSUjA+lSAxaVgfSnKD6UtUkBFg00feqcrmmOuMVLQDP4qnhGaiVSW6VYjUq1VEksxr0q1CvOPaq8fUVPv8uGV/7qk11LZkPc5DUrjz76V++dv5VW3ZprZZmcj7zE0nvXHuelskiNly3NXrO38yRRjNRW8PmvWpCBDIoHpU2tqOnHmkvUlKrGpGaiZgsZOKGbLnNVry42x4WoWp6FZcsWiCcJJKSTVfAUn0oZt3WhcetaHluPUbTgpbt+lKVPrmrMaEoCByKaQWKy4Qn1oZie/WluF2sD0J60kPynnBBqXe9ifIjVjkE9aaZDuJBqzNGmMqee9V/L+UnNTZiY5f3hFTwR/NT7OHjJFTWqbpMehqrAzVs7f5d3oOa0tKXbM0jjKKOOKpwxHaQP0rSthsj2BWG7jkVsjCUtS1Dam/ZV6yMfvDsK7S3s9lnDaRyDdMdp9do6/wA65qxs5LSEz+UTu+SNh0z3rsNB08pbi7n42pkH0x1/P+laxMJXkyPVo1V0t1IEUK7QPaqlusQOB0qhJdSTXE0hfKu3H0qwjcJgjPeoaNC1PI2CABx0qhNJLJbkY6feBFaX2qONV3Dk1Qui772I/d/wkdKkZhTfeOOv8qheRSoBGT61auIu4I/OqRXnFBQ4IQvHIqLnd6U7cyg+gqNW3NzxSEOLOM4yPwqRliuoWjljEgxk569D0o8xR70qlWOQcEUaiT1N74a61beA7q5DeY1pNIswVMko6jjH5n8qztY1JtW1S6vH+9PKzn8ap5zRnaRxVOTcbFcqvzFSdRnK9e9VZITJzjpV24y2Co+tQxsScEYrMqxSNnv7YNI2luFyK09q9SuasJB5q/KOPSixJz32OXk7SR9KuWkbR8kZNbC2+xeRx9Krtb7nJBwKZSZLC8ZXDryan+yowyjflUC2o29aBu" + 
            "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" + 
            "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" + 
            "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" + 
            "A1LS9GMvm/Y7GNyP+uhJ/pXAXVuI5So+71FeifGq+F58TdZClcQ7IEKn+FRgf1rgXUSZyckVtNamVBuVOLfUzJoetU2iKmtaRAOKrNHkkYNZHSNt4y2Mferbt4cxKcfMOtZ9igV637RQsgB+63WqijKYQw+YmcVDPY7jwvJrfi08Mw2j5T6VYFipyFTd6t6VrymPtOU406IGOWGKqyaOFHAru/7PjHU7n+nFMk03aQGjXd2FLlD6wcENH4J24NTW+lSLyRhfcV3i6CPL3yRjHanR+HfN52lFFTymUsQcfHYpJ8ojy3qBWjb6PF/EAG/u9zXUQ+HXlcJFFu9W9K0l8OQWqgsS8nfnGKpRMJYhdzif7FV24TbUsfh5+wJ/Cu2t9DEjbl2Y+lblr4Z84AlU/Gr9ncl4lRR55b+H5R2bPsK0rfT54WG4Nj2FekWfhMbgfLjrYbw9ZrCPNAQj+6MVapHHLGI8yhhdmHAx/tcYres4Y7iMJKADj73YfjXX23h3TNykIHY9NzCprjw5GzBYEVXGSVbgYA5z6Dvn2rRU7as5pYnZHI/YRYSOSBJGBksTwoHVifQV4P8AFr4wC9a50bw7O0dtylxfJ9+T/ZU/3eucdeKtfGz4wprRm8M+H7nGkxnF5fxnLXLA/cRh1Qcgkdc+1eHzNzsRQi/wqOcD6+ntXNUlb3Uerh6LfvTInk+bAORjGef602pPJOORyacI9i81zWO/Yamdwxyan8mRiMjH4UyAbXz1FWPtB8znpVxsFxn2VgcFCT24qdNPK4J6n1qf7Uqpk8HtVf7RIzbs8dq1shakioY25NNbDHg5pN5kzu4oUdaRSED7WFTLN8w5qsxpu7kZqGtS0zRaQsy4NXrdjtOTWZC1WzIYwBj71KxUZal9VDA1NZwFpBiorf5j+FaemIDJyKiW5pe2qLEZkt5AY2577q6rSFj1lB8wW4Qcqe9cvcqyyEgjFT6RMbW9jlViM8HnitLXRk53Y7XvDPk3rqdsKyc8nFTaLClgqqjlm6GtLxI0t5axF2BbJww/Cues7k2sbGT/AJZnIPrWcrtaG0LWPXvB+oFYlcDO0/PmvXLPS2vNLF5GFKkdP614X4I1GG7bKsNkqHjPQj/9dfRHhFlfwuEHJ29Kg5ahw/iTRUmsZIZm2SScxTE4Ab0zXl2ka/L4f1CaCZzIu84jk+Ur9M9q9u1qFL+dkP8Aq9uB/s+v49K8t1rwckuuedKGyflRQOWHrW8H0Muh6f8AD/xwhEYLMVPGxu30r1yzuEu7cNkHd7180+GLGTS9ZNtHmQqMkH+GvcPCt55ltGzy5bPKir2M5aia9Z/vSQMDkVyd1b7WB/2q9F1CGG8Rtp+YEcHrXN32mgK/TIOeaze5V7HMeRt3bRn5q3tADw3Z28DANQrZlpiMcYBrX02FYzuxyRikK9ztPD+szabcRyDJVuD6V6FYPZ6vatFKAGfn/driLG0T7DFwDuA59KveHGeS7Nu8jQzK37p+30PtUyjzK5I/W/D76XIUbmPqHxxXN32ncZFewra/bLDyrqMHPDd8H1B9K4jXtBbS5v70LZw1c8Zp6BqebzwmNiCDVSZSV2gfMa6bUrELufoKxJAIgWI57VoFjntVYQLtPIHX3rhPEEQutxY4TqFrsNemY7uK4HXLvG4buD1pHRFHJakqRs0rkBR92uW1LUJLlSitlB0Fa2s3RuHZV/1Y6VgTpn5U60zoijCveXYt1NYtwpVjwTmumurNm4Ay1VYdEkmYFgSc8Clsyzn3gMce88fWqwbdnmt7WLMxSCMIQo744rAkXaxA6VW5qthnXpTJG4FP3egpHhPBwfypldCsy96Y1WGXbVdqRBHTWYetDGo6BMfQaEXrmnbadyRozRTwKKBHNeZSq26o16UcjtXPY3sTUlIppaYgopaKkQq1Ivao1p6g+lNAWF6UtNjqTua1WwdBtKtKRRimSFSKaZ/CTTo/u5oAtwSAdat5G3pWapwatxy7lIzVJ9CWWFznOatxNuHUZqlGc1NG23oK2iF7Fl/m4IqB4RtxnAqRWLHBqQqrDGa1sO9zMeDb9KY0Y9qvvD1HWqzRbaTiiSjJA3ORmoDFWoBnIqCaH2qHHQaZR8oUvk1MV20lZcoMZGDE2e3etC3lDfQ1SOalhfYQDVREXWX2qEqVqVX3fSnMtXa4CIu5aGXGKVfl71KqbqaAlh+7VgqWjKhivuKhSPaOKsr90VaNY2sNaMMoHJ2/3qasP75nwWzgcngdak+lJtzhu46AVZXKUktZZALqeMR3W0oNp+VFHf6nv9KGhMkYBff8pBYdDVh5TLM8CcFcMzHp34zUjJ8oCrkdsdqLX0JacVzLc4nXrM7T8u4jjOK51WaOQbT0rvtYsH8l22NjucVw8kZWZuMj1rzPZ8s3E9apJVYxrQevUPnkf5/unnmnXGYUD42s3Qd8U9eo3dBz9faobybzoS54549hTaUTmlrqyBWxID6dTSXL+dJxUK5b6VLDHubb0rG1znu2uUlWPaox1PFW9M0m41bUYbO3Qs7HDN2XPc1NDZ5ZF27mPAH1r1bwH4Xj0HTxNMoa8kOSSOQO3866I0+ZhOXKtDovC9vHoOlwWESKVTq3Qs3f61L8SL+DTvA07OQ7XDKgjB568/0psMgjkAJwc5ya4f4wawl3cWOmxyeYkMe98HoWxx+la1IpLQujUdmmcJrU0kkNvMxPzJ905O3BNGn3pto5GGDuA6/jUGqM8kRUtlVAwB29apJnyRziuZbibuztPB0p1jWorYEB3PGK+vPgVo0eko0IXLhgzN+eK+PfhKUh8daa0iF134I+oPNfbnw7SLTbq6KgqJGypPTgV6GFR8/mUnycnc8O8cXDXvjTWpev+ksM/SsXkNWtrV1GdU1R2Tc0l1Jhsf7X/wBesgMGbjiiW7O6kuWEV5DJFPXFRN8wyBVvbuyOtV9uxyDWUtjYjiyrVvWebi33DhhWQseW6VvaIwt7hC4zG3B4ojuRLa5vaJM0i+Ww+YDg0az4y0bQbyCyv7owzSLuAVCePVsdB9fetm109I3SVRlevHcV5n8edJksfE9pqVtGTBeWSIpHIRkzuH1+cVvJ2jc4oRVapyHomm3un6tn+z7y2v3Iz5cL7nH1HWrsGnvGdxQvJnpjOK+V7TUDpbefDK320n5ZImKsh9a9z+FPxqdLqz0rxVKlzFN8sWpMoEsJJAzIehXJAz2/GqUk7XJr4edOPNHU9ItbAzYM0WV/Ste20WKb+Dy1rtYtIhjYxtEu5G2sR/EfWkvtBWVdqgo3bbXRy9jwZV1J2ehzcWkfMFiTAHfFT/8ACO7VBkIB7jHWpn0O7scsGZ27DNOsZJfM2ysfo/BpepfI3D2kXcopo7eYdqcL0wK0LO0YNjbgDvitiKzDNux9KlS3faRximcsqjejIEUxqMc/SqV9M0mUzj61q/MqkBQcVQuLd5skYVs4Geh+pp8xEbFC1tbiSZVziPuw6g9sV41+0V8YjBFc+DfD1wxJG3U76N/mxx+5Rh0J5z6YHrXU/GD4py+A9DaxtNp1y6UpDt5Fup4aX3IyMDvk+lfKnMjPvkaWRiSzscszdST61hOb2R6uFw6lL2s+mxnNhlI24OclvU/06U1YSPlAye5rSFsjAhRlzTo7MRqABz+tYRps9lszo4x/vGpBYmXOV4q39lxIVB/H0p+0pHt6kVXL3JuV009VXOOlVJoG8zcRwOgWtFEZjgnipTDGo6c0cqZUTJWF5Pv8DsKkaEbcY6VckXpxUT4UVJdioF" + 
            "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" + 
            "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" + 
            "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" + 
            "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" + 
            "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" + 
            "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" + 
            "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" + 
            "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";
      public String img64B="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" + 
            "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" + 
            "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" + 
            "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" + 
            "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" + 
            "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" + 
            "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" + 
            "3J7/AONcreftB+GLXVotOsVutYuZWC7bZBjJ+vX8K7C+t5tWsXsrmyhn84fMjEYT0IPrWX4J+DugeB7xr21gEmpSEs1zIQXUHsoPT+tO66mqil8R3liwazjnmja2Rl3eXJgFfY1E19DJGHjbeMkYI4pZb77PGVCj24z+JHrWFqepR2cLzzOI4V5ZgMfhUX7Exg2Y/jLwjaa9byPAi29yRkr/AAv9fTH9a8b1S4vtBvGtL0SCNf8Alnn5h6EHuK2/Ev7QkGl3TwabpBvCG2q9wWXmuijsbzx74XW41q1htr6UboVjyCq+hJ/CpOqCaPNYoVvJhNNfS3nOU+baE9v8+lad1cGaIxo7QORgOOeK5vXNNuvD96ww0e04ZcenSqkPiRl5cZH8qR3wj1RZ1nTTbW4ZJGuRn77cH8RWDNN9hySNy9/aulh1hLpOIw6t6mmzaHBeRF41I9VPU1HJ2OqMraM4HW7gzWklx5LSMvSOMZJ/CuZjRry3EhiMJb/lmwwfyr0a+0BYX8yFiQeGTFcndWki3TNGcJnHSp5JHVCaOVmhaJskZUH7tWEIbDjhT71Nr1w1kFRYVZ3NRC1KgMqlSwBK+lGqOjoP84Iwwau2spY5xkelZrrtYdiPapbe4KNjPFVck6m0vmVdpHyn36VdWVWU4dge1c/FcDbzzVuO8jC4zz7GkSbFrflUCySAYP8AFWha3yJIClyBnstcZcXOGyoP406G+ZSrAcioaYz1Sx1YbgrOJB3zwRWuupQrypMfvjg15rY6su5WcsMj+HmteHVFYZWbj+63FUpWM5QudXfapLHFuWQL6NXO32sSTSHzj5i9N3pVaXVcsAw4PTnisbULkhjgE57LyDSlIqEUh145VsqRKPbtVU6geBtGfrVGZpmbeQSB0UGqsl4zZGNhrE7Yl9rxpGI24HehpEVecAn3rI8+Tn5uaYZJGYDNIp7m/HcJ5fGM/WpY7kOvGRj0NYILKOpJ9qtWs7qRuHFAGyswGSxOPc1Kbm2VNwJZv0FYkxknY7Q2PQVfsbFk2tKcL3FItJmnHIk0XK9fSlXbGMY4+lPVo1GAPl7UvmDaeKRqvMzLxfMzsHNYl9YyFt21QfUnrWvqV2lvGSzbfpXIXmvDewG4j1zTWxk7X0Ibq3nZyDgD61lzblbBIA+tOuNYLE4zmqE9w8uCxA9qLgrkslxnAHFVJ5s8ZpPM9eKrsdzZoGiaOTjPU1KJc9aqqaWRzxikMlZi3Soiu2k87Ixmo2lA60ATLinmQLVNZDu4qfdkc9aAH+Zu7807zAqjB4qsw98Uit83tUuwyy0nygUVBu9KKsRVx7Uq57ChJB0NP+lRY7LDcZ61FJGVwRVjt0pVUMvNNCcblQDpkVOhFL5XWjaFxWhzv3WI0fnYAcp9KsxrLlssvl44yOagX73HFTl2UAAZB61cYjU9CN41eaNXKsWHp6VVvrZLyF0T761buVQrG+GLKfl2jP1pW/1bNGVBPOa8+tFxnc+uy9xxFBwktTFj09drxvgTAc1QkjMbENnHrXQyW63DJMr846r0NUbiNWkZWB+b1rNSObE4NRjorGRvLd84qSGXy2OB196bNC1vIUbr2NRk1upaHz8k46MuNch1wy8exqIOpzwQufWoN1PqrmZft7e0nIDTvG/ZscCi60u5tfmUedEekiDINZ7Nj3+lWbfUri2yElOz+63OaNBWI1k2sOmR2rQg1CN0KODER/EgzWdPcNOxcqqnviiHd94qdv0qouwrPodXYLaXEYdjGzngshwfyrSSBo4h5ZE0Q6g/eFcEC/G0lRnjBrTt9WnhVV8w5X7ren1rpjUEbtxG52yWpyV+8hPP5UltqgklCyDyLhDkBh8p+tQQ6utwQsoEV12k6K1PneK6/dzgRznpIOA341tzX1IZ0dxqkWsWhikVYrxBlGXgN7ViJMsxOVAkXqp4OazGme0PlSduQ/eo3upNwdHBfrjsfxqlUBRJ5JGlmy42jPFb+j3yx5DwrKCMEP6e1ct5wupQC3luP4M/y9a2bf8Ac7cn5scjvRGbuRy6noPhm3nki3abcJKvQ2twcfkTWjJeC4jktbyCS1nh5QN90evPvxXn9jqE1jIrrIUGfyrXvPF95eW43EfaEOA8YHI9D61fO0YSpyvoSX1xvkIxtAqr5x6CnSahFqRGFEUuOV9/XNV/uE92711qXMhJOOjB7jLYIOPemNJlelOdTjpmo/LbpUNGqG7flyOaVV6HpT1BCnIpfvAVGxRJG3rUvXpUW0hRzj8KkXK980iG9SZfu9DT1X2pkeWqZfeixABfbFOWOjAqWNR2qrGb3EWHPWplhHpmnKucd6mVMdaLEtkKxL/dp6xqP4alCjJp232p2IuQeWPSnLGPSpljLdsVIkBPWqUSSBYVPUVahXaKkSAr/AT+FWYYC3bFapMQ633L3xWnb3Sg/M+DVeG13cscCrUcMMbZK5+tCFcvw5mVSM8+1XEj2fM/z4/g6fnVGO/2sAihR71sWvlXCfvI9+RgjBx+dbXFqVbHzHtWe6giE0hZVZRkbD71H4d8KWPh/VLqfT99vLchPN8s53gEnB9uasLdWq3T2tojlIIxvx91Tzxn8Kuaahkka8ju/PjkXakfBVSPf/PSpbWl0J35WdJazBoYizljg53f3snI/LFWFneSJmCbkxkH+EAdSa52OaSG8eaS5xDsAEfACsOprz7WPH2p3mtTixmltrctsVD6DrxQrvcyjQlP4T1jw9ra69JcRRWzXdjG6obojCM/PyqfUYNdBeWMbxxOo2FcgjOfTHNef/s/3UM3jO88PajPsi1uBhAy8BLhPmX8SCwrvru48maWJ5SDC7R4x1wamV4yVjnqxmpcqexo6dCbVlKqDuGDxWnsMZGSBx0FYtv4kh0m1aS7YeUvOVGST2FcB4i+MF3DLctbWMlzEVIiAk8va3qw71le8rNmUMJiK6c4x91bs9XaXcd3XHWmGbzs4H5V4DZ/GvxVfKYx9gJUbTutufx9eler/D3xpc+NrJbq8sLOyngXynayXAl64Le/B/Or5XHUVTDypq7Ol8kNwRj61bhMdquNwHtUN1JtbI9Ones37QWc5JJrSMjks5I6KPUm25U8DpQ1/LnO/islbjaFHamzXBweaoz9nd7Gi2onzOWP51WutW2qw3bV9TWRJcdT1qL/AFynccCpk0dMKSWpaj1hoZgULSH+761rW/iAaer3t7NFYWiDdJJMQFUfU9K5iSRoYnMEJuJAMrEuMk/U15fqXhDXviLryx68l7Z6dHIGaBgQm0fwqR1zjn0wK5Zy7G3soz3Poqy8SWfiWxjvtOb7RaMSFn6A+49ar3U0w53k+gFc/plzb6PaxW8Mfkwwpsjgj+6qjoKkhuLi4Yu3AJ4FYnOqFnpsbkOqTeWdx2dvetKC5edlmeNC6gASbQWrIsbUTyKXzheorc2bV2xsUX2Gc1NwlFR0NCxkZ7lGfJ+prTuGVf3uKwrGQxSDc5x9cVemuTLdR5uBBCvWILy/19Mf1pGUo6jZZizEkEVm30MGoQywTxiWJ1I5AOD2P4VrTRmb7pAT2rLuB5bFQc1JcYnmlj8KH+2efrmrrqUSSl4re2thEAM/KGbvXctOUIAAUYAX2x2qw/PUVUmh3c55HTmi5ooGH4w8Nwa9aOTGPNx95a8E1/RbrRbxklHQ8Y6EV9Ff2h9mlZHPy45XvXLeNvDcer2rTwKsmBkr/EKLnTTfK7Hh0d0bRtyE+pFbWn+IvmG5evcnFU77TTHIQEx2FY02+1YnB/" + 
            "pVI7VFSO11C6jubJ2jPlsBkVxT2zkEpxk5571e0/V93ySD5KbMx+1B05QH7o5raLT3BLl2KN1ZozBpI1YqO46Vl30LxHewG3+EgcV6LqVpafZ4ZFK/OoLe1ctrNj5KFgRJD2x0FZpX1NYyOWkt0kk3EYJFUprNtxKnArTuI/LkxnKkfKV5FQtg4Oc1jK6Z0IqW7SIcMTVrzFLAE4NMaPcOOop8cJmxgDcvPNTdMqwkkbLk7sikjV1bBPWnrayxsxMLYPoCas2ke1sH7w7GpuJojimdBt3Ee9T/ANpvDgMQ4HTnmpZLVNwPO49RioZLPqSO3FToNF6O+NxHk/KewzVu3ufMAQctjoOTWOtu21OO1amiW5N1uI6dD2qCypNMIWfIO7PSs2YHdv6bq628hgbIeNd+exrOubJdvyLnP40hx3OeeQDHepbS3a5kG05+lE1iyyZccdAK6Xw7Yrbr5soCg9KDS5mf2XJIQqKS2a149HjtFGRvcj5q1YLi3d9iMvmE9OM028hdMhjzQ1oXDe7Mw+XCPuhaikulIwpzUz2Rk5ZsKKYqJC3ykcdWbtUpGrmgs4ZZGLMfl7CrMqIvDPg+xrH1TxdbaapRP3snt0FcreeJL3UCTu8qP/Z60yE3I6DXF0+Q4lm5HRQ1cNqctusxFuGAHXd3qeS7jUEuxdvUmsq4lWRsrQNxtqQtJuJpjNTW70h+6KLCH5yKjIOakWmuu3nNAEZbbUUlwF/+tT2YDiqczbmwKhspDvtGc4zTfMLdajpdp9Kgpk8bd80/zGJFRRrk81Nt2470CDcWzR9TS1G/FADt20jFFR8k0VQyPkdqmjYY5pjLSYxTOxImz6U5W5qMdaXuaYyX1oAyDUdSR4HAH500zKSTI5MqQehPrUi/MACWAz2pMszhQuU7k0CBmQlj37VrF2MuXsWPMxw3HB+Wqdoz+XKhHzRkgbuAa0EhikG1/lbGM1XunijuDEWVJcA49etY4pe6mj18rk41mm+hWiu9qqrxhH7qOlPmjSaMnHB7+lUrqSMzNtb5sdKpyalNu2ONsX61wKNz154qMU4z1Jprfz0MLf6wfdb1rHZDHIUbIYV0NnNFMFD4yP4qZqmmpcLuT5ZPX1p8zTszgr4X28PaU90YAxuqRe/NMaMx5U9aRfujmtkz59qzsx9FJ7ZzSMQBiquApY8Y5FXlvl+z+WqD3qgv1pc+lBcZuN7Egb5uKUNyfXt6VEH596dyxwAT9Ku/UyLUdyGULIuU7N3FWobtoV2ynz4P7w6rWYscjMEWNmY+xq+dHureMSBdw7gckfhVKpys0jRqTTcUWWkHlgE74z91uv51Tkc27EHlT0NQ+ecEdPXn+lMlkMiqDWrlcztqXLFftkhDtlR07MK1oWaE7Gk8wL0yefxrm1ZkYYLKfatO1vCrDzMjb1yOatSLNxZg25T8p+tOivCG2Px6H1rPmVZo92/J7MDgURzPH+7kAcdj3FPmdzM3rOEzT7RP5BP3WPQ+1aflt9yVfKkH8I5H1B71grlYVMb5z2zWjpupTR7VdfOh78ZIrohPlZnKNy+sJ2nuajZWHGMGrUcqvkxfOnrStGowW/nXbe5zXa0ZW2kLtK5NCwkZ4xV9Y0ki3KcEdqiEfmcEnIo5blKYkVq0mPSpTanBq/ZqFj+cYA6GrIjR84qTLmMmNSuAVwakZduMVoCBeS2M1FJa7j0pqxPNcqqpbtU8anHoamjtWTp+tS+X6jmqFcjjHT1qxjpxTFj796mjJVs/0q4pGbYLCzfwn8qnWHH8J/KnpceuKRpHzxWtkRqSxxr3/lU48tR03VR81x1pPtDCn7oGpGV+lSKU55rIW4Y96kjmc9GxS6Dsbkajbg/NnpViGyaf+EoO+ax4b+SEjaQa0Y9blbG4fpWHMHKzXttJiV1LOc1vLLHa2+I/m6ZxXLw63j+6D71O2seZHywP0pasnlLkgv8A+14pkmj+wMNk0BABY+tSrNFp6JBbwvsTJAwcDPvWfHqgaThS4FPl1IsCCPLHfHOavl1KZL/a3+kMGDIrcMKg/wCEX0+9kM0chjkHIZxwKms5luOEAPrkc1pJbhRgtgewpVIo1pYipQf7t2OduvC99bXENzYyo11buJYbiFsMrjpXc2t5OtpF9uZftjjdICe5/rWBcXjWqsYmwF6luKWzibXGjlnLRtGf4T1+tEU0tdhYiu8Q+ee/fudesiSx+VKqlW6qw6j1qWDwV4Y1uz8i7V9PuwciaM/Kw7Z/z3rO3LtGG4UdaiFz5bk72IPc/wBKwlFS0bIw1eeHk5U3vpY4HxR8PLrTNUd7CGS7g8zarRqVYZ7kd69h8AeHz4X8NW1q+5rhh5j5689qh0mYXBCyNvC8ncK0dS1pYlWOPq3O70FVzStZnLiqntpcsI2LV1eGPBKnJ9RVTzPm3YrMW8W6V5C7AqcYbilW83YCBm9cDNClY5lTNhbgMtRTSFuM1Vjk3Dj8akVWJ9K0UiOTlY1sdxxSH0AwKe0O7hulPjjVcCplPoaKxZsoFT5v4jTb+/Cfu05b1qGW78tSFODVJplU7mOT/OsNx2uXLaEyMpfkmteBQMKBWbZzeYowMbvWrzTJCmE5buaBSfQ0FvBB8qct3xWnYzPMwBbC965aORmk9c962rOZoYQmMDuxrKTMnHQ1jFHGxIQsx9TWRcWMtlM1zbM8i9Sjnn8BWpbMrLu5/GrXmRdCQtRfuZco/R9We+gwY2QjruGB+FQ30QWbr196kiuEghYK2PwrLurkqxLuH3ds4IoFGL5iZiFBxUexm/hyKrLeBXXKZQe9XG1KOOMAHJP6UGrutkYWtaa+DcRnBH3l7n0rFs9U+fCuPMHVWPFbt3OZnPzAj0zXG+JNHkhZ7203A/xIKroaxi+pd1PQbHWEe4towk2Pnjx0+g/OvIvElg1ndSBgAFJ4xXZ2/iCRZFYMyyJ1APX61l+OJbTWLUTxZhnGdygcN0oRvG8WeYXbOzfK20DtVOOd1kH7x/zrUuoh6YYDk+tZTcMcdqR2x7GrHrErbY2kII+76GpptW3w+VIn5dDWOuPKc/xdqg+0blwx5FVd2Eo6k8rbsg8L2oRVdTnAYVArh+hzTs49qh7GtrAYWU8A4+lA/wC+W7dqeszL7ipd0cnUc1l5F3RYsb4AhZDtx365rU+zQTjc5YA9GXisT7KG6Vcs1kX5MkD3qbElttNDAGOQOvsOR9aRbF42BfJX6VLDDJEeW/A8VrwTQSR7HXDdqVrsopLaRsNxGzaO4pmycoADkDptGMVe8QNZ+GbAXepXCWSsMhZxgkeoXqa811L46afp8xj0qyn1DHSR2MaflV+zk9jWMZS6HfIsy4Z4wwA79akht38hvOIgBNeXf8Lx1OZg0uj2Y5B2K5zjv1rs9L8XQeLdJjvoUkhVmKGI8hSMdKmUHFamsqc46s3UWztckOrtgks3IAHeuH1T4u6EysFe7aNGKbo4fkYjuD3rY1lXv9JvrWMYaS3dVYHB3Y4rwqORrcCx8gW80YG+OTqvHUg+vNTFJm1KmpHoi/Fuw+2Rx29jcOrMFMnClfevQtH8QRyRCT7QtxCTwwIb8M14r4b8M3OqI8/kGK2zlZm+XcR6ZrsbNE0228r5mduvPyr9KwdRRlyo9KWAkqPtpOyO61vxJA0IEQJbsFFc/JeXN0p/ehB2HrWT9oAHL8+5pf7QCxttIz65rb1PIUbFW8tysjGTBPbnmqPluxwo2j61dXEjFi24+9Q3EgjzikMzp4WjPI4qozc88VfbfcH0UVWl" + 
            "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" + 
            "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" + 
            "zqFA5GDuGRUGPLqS+E5WuNCsjkcrg/nXRR2q/SsOC4CBegVegUYH5VpxagZY8Bce+KkwncZeKm0/NzWSy7e+6rt1IP4eT3NZ0kjfSlqOKFLD1pI1MjjHIqvJNz0qxbzbaRo9jYt5Ft0Ax1pt1eblUZrNmuunNQ+YzZ5zipM+U17eXoc81t2rKqg55Nc5Yvu69a1Vm2r1oM5LoabXRGRnINM8/wCUg1RE/r0oml/dkryadyUi9BcbS2RzUktyBGwB4rGjuGZgScVGt024oTkZqepVi9dSEwisyS78mRGJyOc1eDB4WHWsO+/1bHPQ1Q1uWrzUnjjmZO8ZwK4Lxt8Up/EWkx6HplpJa2MYAnkIKtI3cH2rp5rjdHtyQcZBzVOJ40y7iMk9RtFVa50wsndo8507RE2gxxAv/s8ge1dn4f8ABMNwq3Gos0aA8Qgcn61q/ao0XaoQDqMKKbJqLvnnHpiosbSqSasdFayW+nQhY0REjHCqcf8A6657VtZmu5m+f92cjbUBupHDfNmqMv3ulTynPy63Zk3EfzmqUq7SK1LheapSR7qhjKnY0+JeRnkelIYyrU9WqBx3LBjQgFePam7B9abG3WlyaRvdEiYX2qZZiucVW3Zol3bflOKVxkskg+ZiRzxkdq5jxJ40TSXNlaoJrzHMjD5U9Pqa1JXK/eyeOlc1qPg99V1ae4mu9ttIQdiDnis2a04RerNTwbqV9eTtLdXHnIcbi3Uda6y6uvlKxj5R1rDsFg0q3jtoE2RAgAkfMfc1xeueKZ49awLh1gjkwFQZ3nsKUnrc66kVXlFQVrfidlJMqM5CqSarKxkfLfIKqR6qlwiSsuCwyfr3p099HJHhQQaRhy2epR8TM82mXFvbF3lZeNjYrh/C/hO7m1BJLzzLeFPmI8wksa7qJQ0md350+P8Adt+PpU9DqjLla0LKxuxAyFUdKWTzCu3PApQ+73pVOTU8xq6KlqjPmhePkg/NVGRsMe1dDMflGAGPvWDqbFpeAB9K0jLQ5JU3FlSSSohJubrTZGPHaljxRca2JfvdqFBzS+YEHrTGmH0oIsXrdgPanSOynIO6qCSj1qzHIrfxUBYmChlJK4OKjkZFX5RUg4Gd2R71BIw59KBCwwiTqRTjCAcGmJIBTvOB74xQBXlA3gDik2npUrMGOacrbTytAEUa/N0NX449y425/Cqyvvb5f0q5GpVe5xQJ3K9xb8ZIwaqtBuXpmrczFc/N19arSTnGBzQONynJGy8EVAW596mkkdm56UnkhiD3qGtTUiVmbtnFFWtipgYopWJaOVbpRjIooqDqFxinelFFJmi2Hxgc1E/3jRRQhvYarFSMVZSQ8DsaKK0Mhyk7mGSRTs0UVa2AcrGn0UUwHZ4pSxUbh1zj86KKpbA9i+2l22uaRcyXcQea34jmHDgeme/SuBnke0LGORsg45PWiivJn/Ese1X/AIVOXU0bPUZmwGIOfUVqKqybdyKc9eKKK2aR14duUNTE1SNI5cKoUe1Z8gyBRRVR2Pn8R/FY1elS26K0gUjINFFadTCOtSzLNxYxopcbge3NUFy2cn8aKKyXxGuJik1ZDpF27cHrSspRFIZjn1NFFV1MFo9BpXBFAzuOCR9KKKoz+0O3N03tj605VDUUUjNtuWo77RJH91yKsRXUkqkMdxHfvRRUs3i3dlnT7yXzypbco7Gr97EpUy4w3tRRUdTrTco6mX9okUxyBtrxyLtIr1u3kMkcLHqyAn60UV62E2Z5r6lyZyFTHFRbi3eiiu8y6CrM3mInarLOUkwOBRRQSPt8yZyenSpW+6eKKKCCu8hCgAAVEuGbkUUVSDoWJGO7HakZzwM0UUEgqhs55pk0aoyYHWiirWxSGSSMqHBxRb/MuTyaKKoXUesY8ytW3Y7AM5FFFKQnuWlPy4oXvRRQSDN0pNxooqSBisSTU9uN0gz60UUdCDWk+VlA6Ypu3c4zRRUjW5PnOKMkUUUGyHKx9at25NFFAmXFkZSuDWpbyttFFFM5au4snpVSboKKKye4RKhGWp0nyqcUUVLNGQxuW3ZNWIOaKKEQW7ZipGK0lY7aKKlmb3G7jyM06NjgjNFFSBFuIK/jSfxZoooH0J1cqDj0rGu2PzDtRRVRCJmOx5qpITzRRWjOhEYJxQzGiikWJvNNl6CiigGVJhmqciiiisZEkDCmKgbrRRWYEsahjyKJ41GKKKlmqGRqM0+b5Y+KKKhldGZ90xVximxsdjHuKKKg1pFa6ZjtYsc15vcfvdes0blWujmiiolseng/94ivNfmdldxqlwyKMKvQCodtFFNbEV/4svUliHU0rSEUUUzFDVncMcGrUczZFFFRI6obCXUzKpINYtxIzMcmiioWwVCo/Whe9FFWjmQtGM0UUxiLT0Yq3FFFLqSXc/u8VVmY4oorQhiR/NgGnycYxRRSARSeKduLAnvRRQImiG1xjireNyk5oooJZXPzk5qtMuMUUUAV5B0qW3UN1FFFBa2JZ41XbgUUUUCP/9k=";
    public void init() {
        javax.swing.SwingUtilities.invokeLater(() -> {
            yTerminal frame = new yTerminal();
            frame.load();
            frame.setVisible(true);            
        });
    }        
    public void load(){
        Util util=new Util();
        // Configurações básicas da janela
        setTitle("JFrame Translúcido com BMP e Barra de Título Personalizada");
        setSize(1000, 500);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setLocationRelativeTo(null);

        // Remove as decorações da janela (bordas, título, etc.)
        setUndecorated(true);

        // Configura a translucidez da janela (80% de opacidade)
        setOpacity(0.8f);

        // Carrega a imagem BMP
        try {
            image=javax.imageio.ImageIO.read(new ByteArrayInputStream(util.base64_S_B(img64+img64B, false)));
        }catch (Exception e){
            util.erroFatal(e);
        }
        
        // Painel principal
        JPanel mainPanel = new JPanel(new BorderLayout());
        mainPanel.setOpaque(false); // Torna o painel transparente

        // Barra de título personalizada
        JPanel titleBar = new JPanel();
        titleBar.setBackground(new Color(50, 50, 50, 200)); // Cor de fundo da barra de título
        titleBar.setPreferredSize(new Dimension(getWidth(), 30)); // Altura da barra de título
        titleBar.setLayout(new BorderLayout());

        // Painel para os botões da barra de título
        JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.RIGHT, 5, 0));
        buttonPanel.setOpaque(false); // Torna o painel transparente

        // Botão de minimizar
        JButton minimizeButton = new JButton("-");
        minimizeButton.setFont(new Font("Arial", Font.BOLD, 14));
        minimizeButton.setForeground(Color.WHITE);
        minimizeButton.setBackground(new Color(50, 50, 50)); // Cor do botão de minimizar
        minimizeButton.setFocusPainted(false); // Remove o foco do botão
        minimizeButton.setBorderPainted(false); // Remove a borda do botão
        minimizeButton.addActionListener(e -> setState(JFrame.ICONIFIED)); // Minimiza a janela

        // Botão de maximizar/restaurar
        JButton maximizeButton = new JButton("□");
        maximizeButton.setFont(new Font("Arial", Font.BOLD, 14));
        maximizeButton.setForeground(Color.WHITE);
        maximizeButton.setBackground(new Color(50, 50, 50)); // Cor do botão de maximizar
        maximizeButton.setFocusPainted(false); // Remove o foco do botão
        maximizeButton.setBorderPainted(false); // Remove a borda do botão
        maximizeButton.addActionListener(e -> toggleMaximize()); // Maximiza/Restaura a janela

        // Botão de fechar
        JButton closeButton = new JButton("X");
        closeButton.setFont(new Font("Arial", Font.BOLD, 14));
        closeButton.setForeground(Color.WHITE);
        closeButton.setBackground(new Color(200, 50, 50)); // Cor do botão de fechar
        closeButton.setFocusPainted(false); // Remove o foco do botão
        closeButton.setBorderPainted(false); // Remove a borda do botão
        closeButton.addActionListener(e -> System.exit(0)); // Fecha a aplicação

        // Adiciona os botões ao painel de botões
        buttonPanel.add(minimizeButton);
        buttonPanel.add(maximizeButton);
        buttonPanel.add(closeButton);

        // Adiciona o painel de botões à barra de título
        titleBar.add(buttonPanel, BorderLayout.EAST);

        // Adiciona listeners para arrastar a janela e maximizar com duplo clique
        titleBar.addMouseListener(new MouseAdapter() {
            @Override
            public void mousePressed(MouseEvent e) {
                mouseOffset = e.getPoint(); // Captura a posição do mouse
            }

            @Override
            public void mouseClicked(MouseEvent e) {
                if (e.getClickCount() == 2) { // Detecta duplo clique
                    toggleMaximize(); // Maximiza/Restaura a janela
                }
            }
        });

        titleBar.addMouseMotionListener(new MouseAdapter() {
            @Override
            public void mouseDragged(MouseEvent e) {
                Point newLocation = e.getLocationOnScreen();
                newLocation.translate(-mouseOffset.x, -mouseOffset.y);
                setLocation(newLocation); // Move a janela
            }
        });

        // Adiciona a barra de título ao painel principal
        mainPanel.add(titleBar, BorderLayout.NORTH);

        // Painel para exibir a imagem
        JPanel imagePanel = new JPanel() {
            @Override
            protected void paintComponent(Graphics g) {
                super.paintComponent(g);
                if (image != null) {
                    // Desenha a imagem centralizada no painel
                    int x = (getWidth() - image.getWidth()) / 2;
                    int y = (getHeight() - image.getHeight()) / 2;
                    g.drawImage(image, x, y, this);
                }
            }
        };

        imagePanel.setOpaque(false); // Torna o painel transparente
        mainPanel.add(imagePanel, BorderLayout.CENTER);

        // Configura o painel principal na janela
        setContentPane(mainPanel);

        // Configura o fundo da janela como transparente
        setBackground(new Color(0, 0, 0, 0));
    }

    // Alterna entre maximizar e restaurar a janela
    private void toggleMaximize() {
        if (isMaximized) {
            // Restaura o tamanho original da janela
            setExtendedState(JFrame.NORMAL);
            isMaximized = false;
        } else {
            // Maximiza a janela
            setExtendedState(JFrame.MAXIMIZED_BOTH);
            isMaximized = true;
        }
    }
}



@SuppressWarnings({"unchecked", "deprecation"})
class ExternalSort extends Util{
    private int MAX_TEMP_FILE_SIZE = 100 * 1024 * 1024; // 100MB

    public ExternalSort(InputStream is, OutputStream os) throws Exception {
        // Fase 1: Dividir o arquivo grande em partes menores e ordená-las
        java.util.List<java.io.File> sortedTempFiles = splitAndSort(is);
        
        // Fase 2: Fazer merge dos arquivos temporários ordenados
        mergeSortedFiles(sortedTempFiles, os);
        
        // Limpeza: Apagar arquivos temporários
        for (java.io.File file : sortedTempFiles) {
            file.delete();
        }
    }

    private java.util.List<java.io.File> splitAndSort(InputStream is) throws Exception {
        java.util.List<java.io.File> tempFiles = new java.util.ArrayList<>();
        java.io.BufferedReader reader = new java.io.BufferedReader(
            new java.io.InputStreamReader(is, java.nio.charset.StandardCharsets.UTF_8));

        java.util.List<String> lines = new java.util.ArrayList<>();
        String line;
        int currentSize = 0;

        while ((line = reader.readLine()) != null) {
            lines.add(line);
            currentSize += line.length() * 2 + 40; // Estimativa aproximada do tamanho em memória

            // Se atingiu o tamanho máximo, ordena e escreve em arquivo temporário
            if (currentSize >= MAX_TEMP_FILE_SIZE) {
                java.util.Collections.sort(lines);
                java.io.File tempFile = writeTempFile(lines);
                tempFiles.add(tempFile);
                lines.clear();
                currentSize = 0;
            }
        }

        // Ordena e escreve quaisquer linhas restantes
        if (!lines.isEmpty()) {
            java.util.Collections.sort(lines);
            java.io.File tempFile = writeTempFile(lines);
            tempFiles.add(tempFile);
        }

        reader.close();
        return tempFiles;
    }

    private java.io.File writeTempFile(java.util.List<String> lines) throws Exception {
        java.io.File tempFile = java.io.File.createTempFile("externalSort", ".tmp");
        tempFile.deleteOnExit();

        java.io.BufferedWriter writer = new java.io.BufferedWriter(
            new java.io.OutputStreamWriter(new java.io.FileOutputStream(tempFile), java.nio.charset.StandardCharsets.UTF_8));

        for (String line : lines) {
            writer.write(line);
            writer.newLine();
        }
        writer.close();
        return tempFile;
    }

    private void mergeSortedFiles(java.util.List<java.io.File> files, OutputStream os) throws Exception {
        // Lista de readers para cada arquivo
        java.util.List<java.io.BufferedReader> readers = new java.util.ArrayList<>();
        // Fila de prioridade para o merge
        java.util.PriorityQueue<FileLine> queue = new java.util.PriorityQueue<>();

        // Abre todos os arquivos e inicializa a fila de prioridade
        for (java.io.File file : files) {
            java.io.BufferedReader reader = new java.io.BufferedReader(
                new java.io.InputStreamReader(new java.io.FileInputStream(file), java.nio.charset.StandardCharsets.UTF_8));
            readers.add(reader);
            String line = reader.readLine();
            if (line != null) {
                queue.add(new FileLine(line, readers.size() - 1));
            }
        }

        // Abre o arquivo de saída
        java.io.BufferedWriter writer = new java.io.BufferedWriter(
            new java.io.OutputStreamWriter(os, java.nio.charset.StandardCharsets.UTF_8));

        // Faz o merge
        while (!queue.isEmpty()) {
            FileLine fileLine = queue.poll();
            writer.write(fileLine.line);
            writer.newLine();

            // Lê a próxima linha do mesmo arquivo
            java.io.BufferedReader reader = readers.get(fileLine.fileIndex);
            String nextLine = reader.readLine();
            if (nextLine != null) {
                queue.add(new FileLine(nextLine, fileLine.fileIndex));
            }
        }

        // Fecha todos os readers
        for (java.io.BufferedReader reader : readers) {
            reader.close();
        }
        writer.close();
    }

    // Classe auxiliar para armazenar a linha e o índice do arquivo
    @SuppressWarnings({"unchecked", "deprecation"})
    private class FileLine implements Comparable<FileLine> {
        String line;
        int fileIndex;

        FileLine(String line, int fileIndex) {
            this.line = line;
            this.fileIndex = fileIndex;
        }

        @Override
        public int compareTo(FileLine other) {
            return this.line.compareTo(other.line);
        }
    }

}

@SuppressWarnings({"unchecked", "deprecation"})
class Texto_longo extends Util{
    public String get_html_and_header_remote(String format_web){
        String result1="HTTP/1.1 200 OK\n" +
        "Content-Type: text/html; charset=UTF-8\n" +
        "Access-Control-Allow-Origin: *\n" +
        "X-Frame-Options: SAMEORIGIN\n" +
        "Content-Length: ?\n" +
        "\n";
        String result2="<script type=\"text/javascript\">\n" +
        "window.onload = function(){        \n" +
        "    var error_msg='<html><h1>Nao foi possivel se conectar!</h1></html>';\n" +
        "    var finish_msg='<html><h1>Conexao encerrada!</h1></html>';\n" +
        "    document.children[0].innerHTML='<html><body style=\"background-color: rgb(68, 87, 96);margin-left: 0px;margin-bottom: 0px;margin-right: 0px;margin-top: 0px;\"><img id=\"imgId\" style=\"height: 100%;\"></img></body></html>';\n" +
        "    var socket = null;\n" +
        "    var count_fps=0;\n" +
        "    try{\n" +
        "      socket = new WebSocket(\"ws://\"+window.location.href.split('://')[1].replace('/',''));\n" +
        "      socket.binaryType = \"arraybuffer\";\n" +
        "      socket.addEventListener(\"open\", (event) => {\n" +
        "        socket.send(\"1\");\n" +
        "      });\n" +
        "      socket.addEventListener(\"message\", (event) => {\n" +
        "        var sync=null;\n" +
        "        try{\n" +
        "          if ( event.data instanceof ArrayBuffer ){\n" +
        "            var s = event.data;\n" +
        "            var epoch = s.slice(0, 13);\n" +
        "            s = s.slice(13);\n" +
        "            epoch = new Uint8Array(epoch);\n" +
        "            menor=null;\n" +
        "            if ( sync == null )\n" +
        "              sync=epoch;\n" +
        "            else{\n" +
        "              for ( var i=0;i<sync.length;i++ ){\n" +
        "                if ( menor == null && epoch[i] != sync[i] )\n" +
        "                  menor = epoch[i] < sync[i];\n" +
        "              }\n" +
        "            }\n" +
        "            if ( menor == null || menor == false ){\n" +
        "              s = new Blob([s]);\n" +                
        "              var link = window.URL.createObjectURL(s);\n" +
        "              document.getElementById(\"imgId\").src = link;    \n" +
        "              socket.send('3');\n" +
        "              count_fps++;\n" +
        "            }else{\n" +
        "              console.log('skip');\n" +
        "            }\n" +
        "          }\n" +
        "          if ( event.data == '2' )\n" +
        "            socket.send('3');\n" +
        "        }catch(error){console.log(error + ' . ');}\n" +
        "      });\n" +
        "      socket.addEventListener(\"error\", (event) => {\n" +
        "        document.children[0].innerHTML=error_msg;\n" +
        "      });\n" +
        "    }catch(error){\n" +
        "      document.children[0].innerHTML=error_msg;\n" +
        "    }\n" +
        "    setInterval(function(){\n" +
        "      if ( socket != null && socket.readyState == WebSocket.CLOSED )\n" +
        "        document.children[0].innerHTML=finish_msg;\n" +
        "      else{\n" +
        "        if ( typeof fps_tail == 'undefined' )\n" +
        "          fps_tail=60;\n" +
        "        if ( fps_tail == 0 && count_fps == 0 )\n" +
        "          location.reload();\n" +
        "        fps_tail=count_fps;\n" +
        "        console.log('fps: '+count_fps);\n" +
        "        count_fps=0;\n" +
        "      }\n" +
        "        \n" +
        "    }, 1000);\n" +
        "    const toggleFullScreen = () => {\n" +
        "      if (!document.fullscreenElement) {\n" +
        "        element=document.children[0];\n" +
        "        if(element.requestFullscreen) element.requestFullscreen();\n" +
        "        else if(element.mozRequestFullScreen) element.mozRequestFullScreen();\n" +
        "        else if(element.webkitRequestFullscreen) element.webkitRequestFullscreen();\n" +
        "        else if(element.msRequestFullscreen) element.msRequestFullscreen();\n" +
        "      } else {\n" +
        "        document.exitFullscreen();\n" +
        "      }\n" +
        "    };\n" +
        "    document.addEventListener('dblclick', () => {\n" +
        "      toggleFullScreen();\n" +
        "    });\n" +
        "};\n" + 
        "</script>";
        // s = s.slice(0, s.size, "image/[FORMATWEB]");
        result2=result2.replace("[FORMATWEB]", format_web);        
        return result1.replace("Content-Length: ?","Content-Length: "+result2.getBytes().length)+result2; 
    }
    public String get_html_virtual_playlist(String host_display){
        String faixas="";
        String curl="";
        File [] f=new File(".").listFiles();
        for ( int i=0;i<f.length;i++ ){
            if ( f[i].isFile() && ! f[i].getName().endsWith(".bat") && ! f[i].getName().endsWith(".cfg") ){                
                String name_file = f[i].getName();
                curl += "curl \"" + host_display.replace("//renato:", "//203.cloudns.cl:").replace(" ", "%20") + "/" + encodeUrl(name_file) + "\" > \"" + name_file + "\"\n";
                int len_partes = name_file.split("\\.").length;
                int len_extension = name_file.split("\\.")[len_partes-1].length()+1;
                int len_tag = 12;
                if ( len_partes > 1 && name_file.length() > (len_extension+len_tag) && name_file.split("\\.")[len_partes-2].length() >= 12 && name_file.split("\\.")[len_partes-2].substring(name_file.split("\\.")[len_partes-2].length()-12, name_file.split("\\.")[len_partes-2].length()-11).equals("-") )
                    name_file=name_file.substring(0, name_file.length()-len_extension-len_tag);
                faixas += "<tr><td style=\"display: inline-block; cursor: pointer; color: white; width: 800px; font-size: 40px;\" onclick=\"click_faixa(this,'humanClick')\" name=\"" + f[i].getName() + "\" >" + name_file + "</td></tr>\n";
                File f2=new File(f[i].getName()+".cfg");
                if ( f2.exists() && f2.isFile() ){
                    String [] partes=lendo_arquivo(f[i].getName()+".cfg").split("\n");
                    for ( int j=0;j<partes.length;j++ ){
                        faixas += "<tr><td style=\"display: inline-block; cursor: pointer; color: white; width: 800px;\" onclick=\"click_faixa(this,'humanClick')\">" + partes[j] + "</td></tr>\n";
                    }
                }
            }
        };
        
        return "<html>\n" +
        "<head>\n" +
        "<body id=\"cursor\" onload=\"preparacao();\" style=\"background-color: rgb(0, 0, 0);\">\n" +
        "<style>canvas {position: relative;top: 0%;left: 50%;margin-left: -50vmin;width: 100vmin;height: 100vmin;}</style>\n" +
        "<div id=\"f11bg\" style=\"display: none\" >\n" +
        "  <canvas></canvas>\n" +
        "</div>\n" +
        "<div id=\"f11\" tailmousef11=\"n\" tailvideo=\"n\" onmousef11=\"n\" ocorr=\"0\" sz=\"40\" wi=\"800\">\n" +
        "<meta charset=\"utf-8\">\n" +
        "<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n" +
        "<div id=\"master\"></div>\n" +
        "<div><style>.bordered {border: solid #177 3px;border-radius: 6px;}.bordered tr:hover {background: #999;}.bordered td, .bordered th {border-left: 2px solid #177;border-top: 2px solid #177;padding: 10px;}audio::-webkit-media-controls-panel{background-color: #777;}</style>\n" +
        "<table id=\"tablebase\" class=\"bordered\" style=\"font-family:Verdana,sans-serif;font-size:10px;border-spacing: 0;margin-left: 20px; visibility: hidden;\"><tbody>\n" +
        "<!--\n" + 
        curl +
        "-->\n" + 
        faixas +
        "</tbody></table></div>\n" +
        "<script type=\"text/javascript\">\n" +
        "function remove_playlist(){\n" +
        "  document.getElementById('master').innerHTML='';\n" +
        "}\n" +
        "function create_playlist(){\n" +
        "  document.getElementById('master').innerHTML=`\n" +
        "    <br/>\n" +
        "    &nbsp;&nbsp;&nbsp;<a style=\"display: inline-block; cursor: pointer; font-size: 40px;\" onclick=\"troca_de_faixa_anterior()\">&#9194;</a>\n" +
        "    <a style=\"display: inline-block; cursor: pointer; font-size: 40px;\" onclick=\"troca_de_faixa()\">&#9193;</a>\n" +
        "    <br/>\n" +
        "    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a id=\"tocando\" style=\"display: inline-block; color: white; font-size: 32px;\"></a>\n" +
        "    <br/>\n" +
        "    <br/>\n" +
        "    &nbsp;&nbsp;&nbsp;&nbsp;<input type=\"button\" value=\"FULL_SCREEN\" onclick=\"Fullscreen(false);\" style=\"color: #333; font-size: 18px; background-color: rgb(0, 0, 0);\">\n" +
        "    <input type=\"button\" value=\"VIDEO\" onclick=\"Fullscreen(true);\" style=\"color: #333; font-size: 18px; background-color: rgb(0, 0, 0);\">\n" +
        "    <a style=\"display: inline-block; cursor: pointer; color: #333; font-size: 24px;\" onclick=\"A_mais()\">A+</a>\n" +
        "    <a style=\"display: inline-block; cursor: pointer; color: #333; font-size: 24px;\" onclick=\"A_menos()\">A-</a>\n" +
        "    <a style=\"display: inline-block; cursor: pointer; color: #333; font-size: 24px;\" onclick=\"W_mais()\">W+</a>\n" +
        "    <a style=\"display: inline-block; cursor: pointer; color: #333; font-size: 24px;\" onclick=\"W_menos()\">W-</a>\n" +
        "    <br/>\n" +
        "    &nbsp;&nbsp;&nbsp;&nbsp;<a style=\"color: #777; font-size: 8px;\">&nbsp;&nbsp;click no corpo da pagina para pausar/despausar</a>\n" +
        "    <br/>\n" +
        "    &nbsp;&nbsp;&nbsp;&nbsp;<audio id=\"p\" controls=\"controls\" preload=\"metadata\">\n" +
        "      <source src=\"\" type=\"audio/mp3\">\n" +
        "      seu navegador não suporta HTML5\n" +
        "    </audio>\n" +
        "    <br/>\n" +
        "    <br/>\n" +
        "  `;\n" +
        "}\n" +
        "function pause(){\n" +
        "  document.getElementById('p').pause();\n" +
        "}\n" +
        "function play(){\n" +
        "  var playPromise=document.getElementById('p').play();\n" +
        "}\n" +
        "function vai_pro_fim_da_faixa(){\n" +
        "  var d=document.getElementById('p').duration-1;\n" +
        "  document.getElementById('p').currentTime=d;\n" +
        "}\n" +
        "function first(){\n" +
        "  var t=document.getElementById('tablebase').children[0];\n" +
        "  e=t.children[0].children[0];\n" +
        "  var limit=1000;\n" +
        "  while( limit-- > 0 && isChildrenMusicNotActive(e) && dir(e) != null )\n" +
        "    e=dir(e);\n" +
        "  return e;\n" +
        "}\n" +
        "function tail(){\n" +
        "  var t=document.getElementById('tablebase').children[0];\n" +
        "  e=t.children[t.children.length-1].children[0];\n" +
        "  var limit=1000;\n" +
        "  while( limit-- > 0 && isChildrenMusicNotActive(e) && esq(e) != null )\n" +
        "    e=esq(e);\n" +
        "  return e;\n" +
        "}\n" +
        "function troca_de_faixa(){\n" +
        "  var e=get_playing() || first();\n" +
        "  var limit=1000;\n" +
        "  e=dir(e) || first(e);\n" +
        "  while( limit-- > 0 && isChildrenMusicNotActive(e) )\n" +
        "    e=dir(e) || first();\n" +
        "  if ( limit <= 0 ){\n" +
        "	console.log('Erro Fatal Loop.');\n" +
        "	return;\n" +
        "  }\n" +
        "  click_faixa(e);\n" +
        "}\n" +
        "function troca_de_faixa_anterior(){\n" +
        "  var e=get_playing() || tail();\n" +
        "  var limit=1000;\n" +
        "  e=esq(e) || tail(e);\n" +
        "  while( limit-- > 0 && isChildrenMusicNotActive(e) )\n" +
        "    e=esq(e) || tail();\n" +
        "  if ( limit <= 0 ){\n" +
        "    console.log('Erro Fatal Loop.');\n" +
        "    return;\n" +
        "  }\n" +
        "  click_faixa(e);\n" +
        "}\n" +
        "let cache_digest=null;\n" +
        "function getDigest(){\n" +
        "  if ( cache_digest != null )\n" +
        "    return cache_digest;\n" +
        "  let digest = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];\n" +
        "  let p_digest = 0;\n" +
        "  function updateDigest(a){\n" +
        "    for ( var i=0;i<a.length;i++ ){\n" +
        "      digest[p_digest]=(digest[p_digest]+a.charCodeAt(i))%52;\n" +
        "      p_digest++;\n" +
        "      if ( p_digest >= digest.length )\n" +
        "        p_digest=0;\n" +
        "    }\n" +
        "  }\n" +
        "  var a = document.getElementById('tablebase').children[0];\n" +
        "  for ( var i=0;i<a.children.length;i++ )\n" +
        "    updateDigest(a.children[i].children[0].innerText);\n" +
        "  var a='';\n" +
        "  for ( var i=0;i<digest.length;i++ ){\n" +
        "    if ( digest[i] >= 26 )\n" +
        "      a+=String.fromCharCode(digest[i]-26+97);\n" +
        "    else\n" +
        "      a+=String.fromCharCode(digest[i]+65);\n" +
        "  }\n" +
        "  cache_digest = a;\n" +
        "  return cache_digest;\n" +
        "}\n" +
        "function A_update(sz){\n" +
        "  let a = document.getElementById('tablebase').children[0];\n" +
        "  for ( let i=0;i<a.children.length;i++ )\n" +
        "    a.children[i].children[0].style.fontSize = sz + \"px\";\n" +
        "}\n" +
        "function A_mais(){\n" +
        "  let sz = 3 + parseInt(document.getElementById(\"f11\").getAttribute(\"sz\"));\n" +
        "  document.getElementById(\"f11\").setAttribute(\"sz\", sz);\n" +
        "  A_update(sz);\n" +
        "}\n" +
        "function A_menos(){\n" +
        "  let sz = -3 + parseInt(document.getElementById(\"f11\").getAttribute(\"sz\"));\n" +
        "  document.getElementById(\"f11\").setAttribute(\"sz\", sz);\n" +
        "  A_update(sz);\n" +
        "}\n" +
        "function W_update(wi){\n" +
        "  let a = document.getElementById('tablebase').children[0];\n" +
        "  for ( let i=0;i<a.children.length;i++ )\n" +
        "    a.children[i].children[0].style.width = wi + \"px\";\n" +
        "}\n" +
        "function W_mais(){\n" +
        "  let wi = 50 + parseInt(document.getElementById(\"f11\").getAttribute(\"wi\"));\n" +
        "  document.getElementById(\"f11\").setAttribute(\"wi\", wi);\n" +
        "  W_update(wi);\n" +
        "}\n" +
        "function W_menos(){\n" +
        "  let wi = -50 + parseInt(document.getElementById(\"f11\").getAttribute(\"wi\"));\n" +
        "  document.getElementById(\"f11\").setAttribute(\"wi\", wi);\n" +
        "  W_update(wi);\n" +
        "}\n" +
        "function save_station(){\n" +
        "  if ( get_playing() != null && getDigest() != null ){\n" +
        "    let digest = getDigest();\n" +
        "    let playing = get_playing().innerHTML;\n" +
        "    let currentTime=document.getElementById('p').currentTime;\n" +
        "    let volume=document.getElementById('p').volume;\n" +
        "    let a = document.getElementById('tablebase').children[0];\n" +
        "    let flags = '';\n" +
        "    for ( let i=0;i<a.children.length;i++ ){\n" +
        "      let b = a.children[i].children[0].innerText.substr(0,1);\n" +
        "      if ( b == '+' || b == '-' )\n" +
        "        flags+=b;\n" +
        "    }\n" +
        "    let sz = document.getElementById(\"f11\").getAttribute(\"sz\");\n" +
        "    let wi = document.getElementById(\"f11\").getAttribute(\"wi\");\n" +
        "    localStorage.setItem('playlist-v-20231018-'+digest,JSON.stringify({'playing': playing, 'currentTime': currentTime, 'volume': volume, 'flags': flags, 'sz': sz, 'wi': wi}));\n" +
        "  }\n" +
        "}\n" +
        "function load_station(){\n" +
        "  if ( getDigest() != null ){\n" +
        "    let a = localStorage.getItem('playlist-v-20231018-'+getDigest());\n" +
        "    if ( a != null ){\n" +
        "      let b = JSON.parse(a);\n" +
        "      let playing = b['playing'];\n" +
        "      let currentTime = b['currentTime'];\n" +
        "      let volume = b['volume'];\n" +
        "      let flags= b['flags'];\n" +
        "      let sz= b['sz'];\n" +
        "      let wi= b['wi'];\n" +
        "      document.getElementById(\"f11\").setAttribute(\"sz\", sz);\n" +
        "      document.getElementById(\"f11\").setAttribute(\"wi\", wi);\n" +
        "      a = document.getElementById('tablebase').children[0];\n" +
        "      for ( let i=0;i<a.children.length;i++ ){\n" +
        "        a.children[i].children[0].style.fontSize = sz + \"px\";\n" + 
        "        a.children[i].children[0].style.width = wi + \"px\";\n" + 
        "        b = a.children[i].children[0].innerText.substr(0,1);\n" +
        "        if ( ( b == '+' || b == '-' ) ){\n" +
        "          let c = flags.substr(0,1);\n" +
        "          flags = flags.substr(1);\n" +
        "          if ( c != b )\n" +
        "            a.children[i].children[0].innerText = c + a.children[i].children[0].innerText.substr(1);\n" +
        "  	    }\n" +
        "      }\n" +
        "      for ( let i=0;i<a.children.length;i++ ){\n" +
        "        if ( playing == a.children[i].children[0].innerText ){\n" +
        "          click_faixa(a.children[i].children[0]);\n" +
        "          break;\n" +
        "        }\n" +
        "      }\n" +
        "      document.getElementById('p').currentTime = currentTime;\n" +
        "      document.getElementById('p').volume = volume;\n" +
        "    }\n" +
        "  }\n" +
        "}\n" +
        "function preparacao(){\n" +
        "  create_playlist();\n" +
        "  document.getElementById('tablebase').style.visibility='';\n" +         
        "  console.log('playlistHash ' + getDigest());\n" +         
        "  add_listener();\n" +
        "  var t=document.getElementById('tablebase').children[0];\n" +
        "  trySetParm(window.location.href);\n" +
        "  click_faixa(t.children[0].children[0]);\n" +
        "  load_station();\n" + 
        "}\n" +
        "function trySetParm(url){\n" +
        "  if ( url.indexOf('?')  > -1 && url.split('?')[1].trim().length > 0 ){\n" +
        "    url=decodeURI(url.split('?')[1].trim())\n" +
        "    var t=document.getElementById('tablebase').children[0];\n" +
        "    e=t.children[0].children[0];\n" +
        "    var limit=500;\n" +
        "    while( limit-- > 0 && e != null){\n" +
        "	  if ( isChildrenMusic(e) && e.innerText.trim().substring('+ 00:00:00 '.length) == url ){\n" +
        "	    symbol_click(e);\n" +
        "	    break;\n" +
        "	  }\n" +
        "	  e=dir(e);\n" +
        "	}\n" +
        "  }\n" +
        "}\n" +
        "function pause_play(force){\n" +
        "  if ( document.getElementById('p').paused )\n" +
        "    play();\n" +
        "  else\n" +
        "    pause();\n" +
        "}\n" +
        "function add_listener(){\n" +
        "  document.getElementById('p').onended = function(){\n" +
        "    troca_de_faixa();\n" +
        "  };\n" +
        "  document.addEventListener('click', function(e) {  \n" +
        "       console.log('tagName clicked: ' + e.target.tagName);\n" +
        "       if ( e.target.tagName == 'CANVAS' || e.target.tagName == 'BODY' || e.target.tagName == 'DIV' || e.target.tagName == 'VIDEO' ){\n" +
        "         if ( document.getElementById(\"f11\").style.display == \"none\" ){\n" +
        "           DisableFullscreen();\n" +
        "         }else{\n" +
        "           pause_play(\"pause\");\n" +
        "         }\n" +
        "	}else{\n" +
        "         if ( e.target.tagName == 'INPUT' ){\n" +
        "           //nada\n" +
        "         }else{\n" +
        "	    if ( transfer_e != null ){\n" +
        "	      click_faixa(transfer_e,true,e.x);\n" +
        "             transfer_e=null;\n" +
        "           }\n" +
        "	  }\n" +
        "	}\n" +
        "  },false);  \n" +
        "  document.addEventListener(\n" +
        "    \"mouseover\",function(e){\n" +
        "      if ( e.target.getAttribute(\"value\") && ( e.target.getAttribute(\"value\") == \"FULL_SCREEN\" || e.target.getAttribute(\"value\") == \"VIDEO\" ) ){\n" +
        "        document.getElementById(\"f11\").setAttribute(\"tailmousef11\",\"s\");\n" +
        "        if( e.target.getAttribute(\"value\") == \"VIDEO\" )\n" +
        "          document.getElementById(\"f11\").setAttribute(\"tailvideo\",\"s\");\n" +
        "        else\n" +
        "          document.getElementById(\"f11\").setAttribute(\"tailvideo\",\"n\");\n" +
        "      }else{\n" +
        "        document.getElementById(\"f11\").setAttribute(\"tailmousef11\",\"n\");\n" +
        "        document.getElementById(\"f11\").setAttribute(\"tailvideo\",\"n\");\n" +
        "      }\n" +
        "      document.getElementById(\"f11\").setAttribute(\"onmousef11\",\"s\");\n" +
        "    },false\n" +
        "  );\n" +
        "}\n" +
        "function limpa_click_faixa(){\n" +
        "  var t=document.getElementById('tablebase').children[0];\n" +
        "  for ( var i=0;i<t.children.length;i++ )\n" +
        "    t.children[i].children[0].style.background='';\n" +
        "}\n" +
        "function isChildrenMusic(e){\n" +
        "  return e.innerText.trim().indexOf('+') == 0 || e.innerText.indexOf('-') == 0;\n" +
        "}\n" +
        "function isMasterMusic(e){\n" +
        "  return !isChildrenMusic(e);\n" +
        "}\n" +
        "function isChildrenMusicActive(e){\n" +
        "  return e.innerText.trim().indexOf('+') == 0;\n" +
        "}\n" +
        "function isChildrenMusicNotActive(e){\n" +
        "  return e.innerText.trim().indexOf('-') == 0;\n" +
        "}\n" +
        "function esq(e){\n" +
        "  if ( e.parentElement.previousElementSibling != null )\n" +
        "	return e.parentElement.previousElementSibling.children[0];\n" +
        "  return null;\n" +
        "}\n" +
        "function dir(e){\n" +
        "  if ( e.parentElement.nextElementSibling != null )\n" +
        "	return e.parentElement.nextElementSibling.children[0];\n" +
        "  return null;\n" +
        "}\n" +
        "function getNameHierarchy(e){\n" +
        "  if ( e.innerText == null )\n" +
        "    return 'null';\n" +
        "  if ( isChildrenMusic(e) )\n" +
        "    return getNameHierarchy(esq(e));\n" +
        "  if ( e.getAttribute('name') == null )\n" +
        "    return e.innerText.trim();\n" +
        "  else\n" +
        "    return e.getAttribute('name').trim();\n" +
        "}\n" +
        "function getFaixaChildrenToSeconds(p){\n" +
        "  p=p.split(' ')[1].split(':');\n" +
        "  return parseInt(p[2])+parseInt(p[1])*60+parseInt(p[0])*60*60;\n" +
        "}\n" +
        "function getStart(e){\n" +
        "  if ( ( e.innerText.trim().indexOf('-') == 0 || e.innerText.trim().indexOf('+') == 0 ) && e.innerText.trim().split(' ').length > 1 && e.innerText.trim().split(' ')[1].length == 8 && e.innerText.trim().split(' ')[1].split(':').length == 3 ){\n" +
        "	return getFaixaChildrenToSeconds(e.innerText.trim());\n" +
        "  }\n" +
        "  return 0;\n" +
        "}\n" +
        "function QtyChildrenByChildren(e){\n" +
        "  var qty=1;\n" +
        "  while( esq(e) != null && isChildrenMusic(esq(e)) )\n" +
        "    e=esq(e);\n" +
        "  while( dir(e) != null && isChildrenMusic(dir(e)) ){\n" +
        "	qty++;\n" +
        "    e=dir(e);\n" +
        "  }\n" +
        "  return qty;\n" +
        "}\n" +
        "function QtyChildrenActiveByChildren(e){\n" +
        "  var qty=0;\n" +
        "  while( esq(e) != null && isChildrenMusic(esq(e)) )\n" +
        "    e=esq(e);\n" +
        "  if ( isChildrenMusicActive(e) )\n" +
        "	qty++;\n" +
        "  while( dir(e) != null && isChildrenMusic(dir(e)) ){\n" +
        "    e=dir(e);\n" +
        "    if ( isChildrenMusicActive(e) )\n" +
        "	  qty++;\n" +
        "  }\n" +
        "  return qty;\n" +
        "}\n" +
        "function setForActive(e){\n" +
        "  e.innerText='+'+e.innerText.trim().substr(1);\n" +
        "}\n" +
        "function setForNotActive(e){\n" +
        "  e.innerText='-'+e.innerText.trim().substr(1);\n" +
        "}\n" +
        "function setAllForActive(e){\n" +
        "  while( esq(e) != null && isChildrenMusic(esq(e)) )\n" +
        "    e=esq(e);\n" +
        "  setForActive(e);\n" +
        "  while( dir(e) != null && isChildrenMusic(dir(e)) ){\n" +
        "    e=dir(e);\n" +
        "	setForActive(e);\n" +
        "  }	\n" +
        "}\n" +
        "function setAllForNotActive(e){\n" +
        "  while( esq(e) != null && isChildrenMusic(esq(e)) )\n" +
        "    e=esq(e);\n" +
        "  setForNotActive(e);\n" +
        "  while( dir(e) != null && isChildrenMusic(dir(e)) ){\n" +
        "    e=dir(e);\n" +
        "	setForNotActive(e);\n" +
        "  }		\n" +
        "}\n" +
        "var transfer_e=null;\n" +
        "function click_faixa(e,humanClick,humanClick_x){ // click td\n" +
        "  if ( humanClick && humanClick_x == null ){\n" +
        "    transfer_e=e;\n" +
        "    return;\n" +
        "  }\n" +
        "  if ( humanClick != null && isChildrenMusic(e) && humanClick_x <= 35 ){\n" +
        "    symbol_click(e);\n" +
        "	return;\n" +
        "  }\n" +
        "  // this is root and exists children +\n" +
        "  if ( isMasterMusic(e) && dir(e) != null && isChildrenMusic(dir(e)) ){    \n" +
        "    click_faixa(dir(e));\n" +
        "	return;\n" +
        "  }\n" +
        "  limpa_click_faixa();\n" +
        "  e.style.background='#999';  \n" +
        "  document.getElementById('p').src=getNameHierarchy(e);\n" +
        "  document.getElementById('tocando').innerText=e.innerText;  \n" +
        "  document.getElementById('p').currentTime=getStart(e);  \n" +
        "  play();  \n" +
        "  //if ( humanClick == null )  \n" +
        "  //  e.scrollIntoView(false);  \n" +
        "}\n" +
        "function symbol_click(e){\n" +
        "  var qty=QtyChildrenByChildren(e);\n" +
        "  var qtyActive=QtyChildrenActiveByChildren(e);\n" +
        "  var qtyNotActive=qty-qtyActive;\n" +
        "  var isActive=isChildrenMusicActive(e);\n" +
        "  if ( isActive ){\n" +
        "    if ( qty == 1 )\n" +
        "  	  return;\n" +
        "    if ( qtyActive == 1 ){\n" +
        "  	  setAllForActive(e);\n" +
        "  	  return;\n" +
        "    }\n" +
        "    if ( qtyActive == qty ){\n" +
        "  	  setAllForNotActive(e);\n" +
        "  	  setForActive(e);\n" +
        "  	  return;\n" +
        "    }\n" +
        "    setForNotActive(e);\n" +
        "  }else{\n" +
        "    setForActive(e);\n" +
        "  }\n" +
        "}\n" +
        "function tryUpdateStateChildren(){\n" +
        "  if ( document.getElementById('p') == null || document.getElementById('p').currentTime == null )\n" +
        "    return;\n" +
        "  e=get_playing() || first();\n" +
        "  while ( isChildrenMusic(e) && esq(e) != null && isChildrenMusic(esq(e)) && document.getElementById('p').currentTime < getFaixaChildrenToSeconds(e.innerText.trim()) ){\n" +
        "	e.style.background='';  \n" +
        "	esq(e).style.background='#999';  \n" +
        "	e=esq(e);\n" +
        "  }\n" +
        "  while ( isChildrenMusic(e) && dir(e) != null && isChildrenMusic(dir(e)) && document.getElementById('p').currentTime >= getFaixaChildrenToSeconds(dir(e).innerText.trim()) ){\n" +
        "	e.style.background='';  \n" +
        "	dir(e).style.background='#999';  \n" +
        "	e=dir(e);\n" +
        "  }\n" +
        "  if ( isChildrenMusicNotActive(e) ){\n" +
        "	troca_de_faixa();\n" +
        "  }\n" +
        "}\n" +
        "function get_playing(){\n" +
        "  var t=document.getElementById('tablebase').children[0];\n" +
        "  for ( var i=0;i<t.children.length;i++ )\n" +
        "    if ( t.children[i].children[0].style.background != '')\n" +
        "	  return t.children[i].children[0];\n" +
        "  return null;\n" +
        "}\n" +
        "function Fullscreen(videoOn) { // ocorre um erro se for invocado sem interação de tela(bloqueio nativo do browser)\n" +
        "  element=document.children[0];\n" +
        "  if(element.requestFullscreen) element.requestFullscreen();\n" +
        "  else if(element.mozRequestFullScreen) element.mozRequestFullScreen();\n" +
        "  else if(element.webkitRequestFullscreen) element.webkitRequestFullscreen();\n" +
        "  else if(element.msRequestFullscreen) element.msRequestFullscreen();\n" +
        "  document.getElementById(\"f11\").style.display=\"none\";\n" + 
        "  if(videoOn)\n" + 
        "    document.getElementById(\"f11bg\").style.display=\"\";\n" + 
        "  document.getElementById(\"cursor\").style.cursor=\"none\";\n" + 
        "}\n" +
        "function DisableFullscreen() {\n" +
        "  if(document.exitFullscreen) document.exitFullscreen();\n" +
        "  else if(document.mozCancelFullScreen) document.mozCancelFullScreen();\n" +
        "  else if(document.webkitExitFullscreen) document.webkitExitFullscreen();\n" +
        "  else if(document.msExitFullscreen) document.msExitFullscreen();\n" +
        "  document.getElementById(\"f11\").style.display=\"\";\n" + 
        "  document.getElementById(\"f11bg\").style.display=\"none\";\n" + 
        "  document.getElementById(\"cursor\").style.cursor=\"\";\n" + 
        "}\n" +
        "function mouseInFullscreen(e){\n" +
        "  if ( document.getElementById(\"f11\").style.display == \"none\" ){\n" +
        "    document.getElementById(\"f11\").setAttribute(\"onmousef11\",\"n\");\n" +
        "    document.getElementById(\"f11\").setAttribute(\"ocorr\",\"0\");\n" +
        "  }else{\n" +
        "    if ( e && document.getElementById(\"f11\").getAttribute(\"onmousef11\") == \"n\" ){\n" +
        "      document.getElementById(\"f11\").setAttribute(\"onmousef11\",\"s\");\n" +
        "      document.getElementById(\"f11\").setAttribute(\"ocorr\",\"0\");\n" +
        "    }else{\n" +
        "      if ( !e && document.getElementById(\"f11\").getAttribute(\"onmousef11\") == \"s\" ){\n" +
        "        document.getElementById(\"f11\").setAttribute(\"onmousef11\",\"n\");\n" +
        "        document.getElementById(\"f11\").setAttribute(\"ocorr\",\"0\");\n" +
        "      }\n" +
        "    }\n" +
        "    if ( document.getElementById(\"f11\").getAttribute(\"ocorr\") == \"2\" )\n" +
        "      document.getElementById(\"f11\").setAttribute(\"ocorr\",\"3\");\n" +
        "    if ( document.getElementById(\"f11\").getAttribute(\"ocorr\") == \"1\" )\n" +
        "      document.getElementById(\"f11\").setAttribute(\"ocorr\",\"2\");\n" +
        "    if ( document.getElementById(\"f11\").getAttribute(\"ocorr\") == \"0\" )\n" +
        "      document.getElementById(\"f11\").setAttribute(\"ocorr\",\"1\");\n" +
        "  }\n" +
        "}\n" +
        "function check_fullscreen(){\n" +
        "  if ( document.getElementById(\"f11\").style.display == \"\" && document.getElementById(\"f11\").getAttribute(\"onmousef11\") == \"s\" && document.getElementById(\"f11\").getAttribute(\"ocorr\") == \"3\" ){\n" +
        "    if ( document.getElementById(\"f11\").getAttribute(\"tailvideo\") == \"s\" )\n" +
        "      Fullscreen(true);\n" +
        "    else\n" +
        "      Fullscreen(false);\n" +
        "    document.getElementById(\"f11\").setAttribute(\"onmousef11\",\"n\");\n" +
        "    document.getElementById(\"f11\").setAttribute(\"ocorr\",\"0\");\n" +
        "  }\n" +
        "}\n" +
        "function interval_1000(){\n" +
        "  save_station();\n" +        
        "  mouseInFullscreen( document.getElementById(\"f11\").getAttribute(\"tailmousef11\") == \"s\" );\n" +
        "  check_fullscreen();\n" +
        "}\n" +
        "function interval_100(){\n" +
        "  tryUpdateStateChildren();\n" +
        "}\n" +
        "setInterval(interval_100, 100);\n" +
        "setInterval(interval_1000, 1000);\n" +
        "function initbg(){\n" + 
        "  const MAX = 50;var canvas, ctx;var count = 0;var points = [];function rus() {ctx.globalCompositeOperation = \"source-over\";ctx.fillStyle = \"rgba(0,0,0,0.03)\";ctx.fillRect(0, 0, canvas.width, canvas.height);ctx.globalCompositeOperation = \"lighter\";var tim = count / 5;for (var e = 0; e < 3; e++) {tim *= 1.7;var s = 1 - e / 3;a = tim / 59;var yp = Math.cos(a);\n" + 
        "  var yp2 = Math.sin(a);a = tim / 23;var xp = Math.cos(a);var xp2 = Math.sin(a);var p2 = [];for (var a = 0; a < points.length; a++) {var x = points[a][0];var y = points[a][1];var z = points[a][2];var y1 = y * yp + z * yp2;var z1 = y * yp2 - z * yp;var x1 = x * xp + z1 * xp2;z = x * xp2 - z1 * xp;z1 = Math.pow(2, z * s);x = x1 * z1;y = y1 * z1;\n" + 
        "  p2.push([x, y, z]);}s *= 120;for (var d = 0; d < 3; d++) {for (var a = 0; a < MAX; a++) {const b = p2[d * MAX + a];const c = p2[((a + 1) % MAX) + d * MAX];ctx.beginPath();ctx.strokeStyle = \"hsla(\" + (((a / MAX) * 360) | 0) + \",70%,60%,0.15)\";ctx.lineWidth = Math.pow(6, b[2]);ctx.lineTo(b[0] * s + 200, b[1] * s + 200);\n" + 
        "  ctx.lineTo(c[0] * s + 200, c[1] * s + 200);ctx.stroke();}}}count++;requestAnimationFrame(rus);}canvas = document.getElementsByTagName(\"canvas\")[0];ctx = canvas.getContext(\"2d\");canvas.width = canvas.height = 400;ctx.fillRect(0, 0, 400, 400);var r = 0;for (var a = 0; a < MAX; a++) {points.push([Math.cos(r), Math.sin(r), 0]);\n" + 
        "  r += (Math.PI * 2) / MAX;}for (var a = 0; a < MAX; a++) {points.push([0, points[a][0], points[a][1]]);}for (var a = 0; a < MAX; a++) {points.push([points[a][1], 0, points[a][0]]);}rus();\n" + 
        "}\n" + 
        "initbg();\n" + 
        "</script>\n" +
        "</div>\n" +
        "</body></head></html>\n";
    }    
    public String get_html_virtual_playlistmovie(String id){
        String js_compartilhado="" +
        "<script>\n" +
        /*
        "function user_click(p){\n" + 
        "  //aa();\n" + 
        "}\n" +
        "function save_station(){\n" + 
        "  localStorage.setItem('playlistmovie-v-20240612',JSON.stringify({'user': user, 'data': data}));\n" + 
        "}\n" +
        "function load_station(){\n" + 
        "  let a=localStorage.getItem('playlistmovie-v-20240612');\n" + 
        "  let b=JSON.parse(a);\n" + 
        "  user=b['user'];\n" + 
        "  console.log('user ' + user);\n" + 
        "  data=b['data'];\n" + 
        "}\n" +
        */
        "</script>\n";
        
        String tail_id="";
        String back="";
        String next="";
        int countSelect=0;
        int countFile=0;
        int countDirectory=0;
        ArrayList<String> elementos=new ArrayList<>();
        ArrayList<String> elementosIsFile=new ArrayList<>();
        String path=".";
        String prefix="/id/";
        int lenPrefixTag=prefix.length();
        if ( !id.equals("") )
            path=decodeUrl(id); 
        if ( path.contains("\\") || path.contains(":") || path.startsWith("/") || path.endsWith("/") )
            return "Parametro invalido";
        if ( path.split("/").length > 1 ){
            String [] partes=path.split("/");
            for ( int i=0;i<partes.length;i++ )
                if ( partes[i].equals(".") || partes[i].equals("..") )
                    return "Parametro invalido";
        }
        File f_=new File(path);
        if ( !f_.exists() )
            return "Parametro invalido";
        if ( f_.isFile() ){
            if ( path.lastIndexOf("/") == -1 )
                path=".";
            else{
                path=path.substring(countFile, path.lastIndexOf("/"));
                prefix="/id/"+path+"/";
            }
            f_=new File(path);
            id=id.split("/")[id.split("/").length-1];
        }else
            prefix="/id/"+path+"/";
        prefix=prefix.replace("/./", "/");
        File [] f=f_.listFiles();
        // NaturalHumanOrder
        Arrays.sort(f, new Comparator<File>() {
            public int compare(File f1, File f2) {
                return naturalOrder(f1.getName().toLowerCase(), f2.getName().toLowerCase(), 3);
            }
            private int naturalOrder(String s1, String s2, int n){
                s1=mix_n(s1, n);
                s2=mix_n(s2, n);
                return s1.compareTo(s2);
            }
            private String mix_n(String s, int n) {
                StringBuilder sb_tmp=new StringBuilder();
                StringBuilder sb=new StringBuilder();
                int pivo=0;
                for ( int i=0; i<s.length(); i++ ){
                    String t=s.substring(i, i+1);
                    if ( t.charAt(0) >= 48 && t.charAt(0) <= 57 ){
                        pivo++;
                        sb_tmp.append(t);
                    }else{
                        if ( pivo > 0 ){
                            while(pivo++ < n)
                                sb_tmp.insert(0, "0");
                            sb.append(sb_tmp);
                            sb_tmp=new StringBuilder();
                            pivo=0;
                        }
                        sb.append(t);
                    }
                }
                if ( pivo > 0 ){
                    while(pivo++ < n)
                        sb_tmp.insert(0, "0");
                    sb.append(sb_tmp);
                    pivo=0;
                }
                return sb.toString();
            }
        });    
        String curl="";        
        for ( int i=0;i<f.length;i++ ){
            if ( f[i].getName().endsWith(".bat") || f[i].getName().endsWith(".cfg") )
                continue;
            if ( f[i].isFile() && !f[i].getName().startsWith(".") && !f[i].getName().equals("index.html") )
                countFile++;
            if ( f[i].isDirectory())
                countDirectory++;
            if ( countSelect == 1 && next.equals("") ){
                next="next.addEventListener('click', function(){ window.location.href='" + prefix + encodeUrl(f[i].getName()) + "'; });\n";
                next+="video.onended = function(){next.click();};\n";
            }            
            if ( f[i].isFile() && decodeUrl(id).equals(f[i].getName()) )
                countSelect++;
            if ( countSelect == 0 )
                back="back.addEventListener('click', function(){ window.location.href='" + prefix + encodeUrl(f[i].getName()) + "'; });\n";
            elementos.add(f[i].getName());
            if ( f[i].isFile() ){
                elementosIsFile.add("S");
                curl += "curl \"" + (prefix.replace(" ", "%20") + encodeUrl(elementos.get(i))).replace("/id/", "http://203.cloudns.cl:8895/") + "\" > \"" + elementos.get(i) + "\"\n";
            }else
                elementosIsFile.add("N");
            tail_id=f[i].getName();
        };
        if ( countFile > 0 && countDirectory > 0 )
            return "Erro interno de estrutura. Existe arquivos e diretorios neste local.";
        if ( countFile == 0 && countDirectory == 0 )
            return "Pasta vazia";
        if ( countSelect == 1 || countFile == 1 ){
            if ( countFile == 1 ){
                id=tail_id;
                back="";
            }
        }else{
            String trs="";            
            String h1="<br>";
            String txt_item="";
            String format_h1=path;
            if ( format_h1.equals(".") )
                format_h1="";
            format_h1 = "/" + format_h1;
            h1="<a href=\"/\">" + 
               "  <svg width=\"44\" height=\"44\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><g clip-path=\"url(#clip0)\"> <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M12.5882 3.66429C12.2376 3.40927 11.7625 3.40927 11.4119 3.66429L5.00007 8.32743V20C5.00007 20.5523 5.44779 21 6.00007 21H8.00007V15C8.00007 13.3432 9.34322 12 11.0001 12H13.0001C14.6569 12 16.0001 13.3432 16.0001 15V21H18.0001C18.5524 21 19.0001 20.5523 19.0001 20V8.32743L12.5882 3.66429ZM21.0001 9.78198L22.4119 10.8088C22.8586 11.1336 23.484 11.0349 23.8088 10.5882C24.1336 10.1415 24.0349 9.51613 23.5882 9.19129L13.7646 2.04681C12.7126 1.28176 11.2875 1.28176 10.2356 2.04681L0.411899 9.19129C-0.0347537 9.51613 -0.133504 10.1415 0.191334 10.5882C0.516173 11.0349 1.14159 11.1336 1.58824 10.8088L3.00007 9.78198V20C3.00007 21.6569 4.34322 23 6.00007 23H18.0001C19.6569 23 21.0001 21.6569 21.0001 20V9.78198ZM14.0001 21V15C14.0001 14.4477 13.5524 14 13.0001 14H11.0001C10.4478 14 10.0001 14.4477 10.0001 15V21H14.0001Z\" fill=\"#293644\"></path> </g> <defs> <clipPath id=\"clip0\"> <rect width=\"24\" height=\"24\" fill=\"white\"></rect> </clipPath> </defs> </svg>" + 
               "</a>" +
               "<br>" +
               "<a style=\"display: inline-block; cursor: pointer; color: white; font-size: 24px;\" onclick=\"user_click()\">" +
               "  <div id=\"user_div1\">" + 
               "    <svg width=\"44\" height=\"44\" viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\"><g transform=\"translate(0 -1028.4)\"><path d=\"m8.4062 1041.1c-2.8856 1.3-4.9781 4-5.3437 7.3 0 1.1 0.8329 2 1.9375 2h14c1.105 0 1.938-0.9 1.938-2-0.366-3.3-2.459-6-5.344-7.3-0.649 1.3-2.011 2.3-3.594 2.3s-2.9453-1-3.5938-2.3z\" fill=\"#2c3e50\"/><path d=\"m17 4a5 5 0 1 1 -10 0 5 5 0 1 1 10 0z\" fill=\"#34495e\" transform=\"translate(0 1031.4)\"/><path d=\"m12 11c-1.277 0-2.4943 0.269-3.5938 0.75-2.8856 1.262-4.9781 3.997-5.3437 7.25 0 1.105 0.8329 2 1.9375 2h14c1.105 0 1.938-0.895 1.938-2-0.366-3.253-2.459-5.988-5.344-7.25-1.1-0.481-2.317-0.75-3.594-0.75z\" fill=\"#34495e\" transform=\"translate(0 1028.4)\"/></g></svg>" +
               "  </div>" + 
               "  <div id=\"user_div2\">offline</div>" +                   
               "</a>" +                     
               "<h1 style=\"color: white;\">&nbsp;" + format_h1 + "</h1>";
            for ( int i=0;i<elementos.size();i++ ){
                if ( elementosIsFile.get(i).equals("S") )                    
                    txt_item = elementos.get(i);
                else
                    txt_item = "<svg width=\"24px\" height=\"24px\" viewBox=\"0 0 100 100\" xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\"><path style=\"fill:#D9D58F;stroke:#222;stroke-width:2\" d=\"m 2,88 c 0,-1 0,-63 0,-63 0,0 -0.6,-5 4.4,-5 -1,0 5.6,0 5.6,0 l 0,-6 c 0,0 0,-3 3,-3 l 17,0 c 0,0 3,0 3,3 l 0,6 43,0 c 0,0 4,0 4,4 l 0,64 z\"></path><path style=\"fill:#E8DC88;stroke:#222;stroke-width:2;fill-opacity:0.7\" d=\"M 2,88 17,54 c 0,0 1,-5 9,-5 11,0 65,0 65,0 0,0 9,0 7,5 -2,5 -14,34 -14,34 z\"></path></svg><a> </a>" + elementos.get(i);
                trs += "<tr><td style=\"width: 1570px; display: inline-block; cursor: pointer; color: white; font-size: 24px;\" onclick=\"window.location.href='" + prefix + encodeUrl(elementos.get(i)) + "'\">" + txt_item + "</td></tr>\n";
            }
            return "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">\n" +
            "<html xmlns=\"http://www.w3.org/1999/xhtml\">\n" +
            "<body style=\"background-color: rgb(0, 0, 0);\">" + 
            "<meta charset='UTF-8' http-equiv='X-UA-Compatible' content='IE=9'>\n" +
            "<br>\n" +
            "<style>.bordered {border: solid #ccc 3px;border-radius: 6px;}.bordered td, .bordered th {border-left: 2px solid #ccc;border-top: 2px solid #ccc;padding: 10px;}</style>\n" + 
            h1 + 
            "<table id='tablebase' class='bordered' style='font-family:Verdana,sans-serif;font-size:10px;border-spacing: 0;'>\n" +
            "<!--\n" + 
            curl +
            "-->\n" + 
            trs +
            "</table></body></html>" + 
            js_compartilhado;
        }
        if ( back.equals("") )
            back="back.setAttribute('style', 'filter: blur(4px)');";       
        if ( next.equals("") )
            next="next.setAttribute('style', 'filter: blur(4px)');";        
        String id_display=decodeUrl(id);
        if ( id_display.split("\\.").length == 2 )
            id_display=id_display.split("\\.")[0];
        id=prefix.substring(lenPrefixTag-1)+id;
        return "<!-- creditos https://github.com/CodingGarden/css-challenges/blob/master/netflix-video-player/index.html -->\n" + 
        "<!--\n" + 
        curl +
        "-->\n" + 
        "<html lang=\"pt-BR\">\n" +
        "<head>\n" +
        "  <meta charset=\"UTF-8\">\n" +
        "  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n" +
        "  <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n" +
        "  <title>" + id_display + "</title>\n" +
        "  <link href=\"https://fonts.googleapis.com/css?family=Rubik&display=swap\" rel=\"stylesheet\">\n" +
        "</head>\n" +
        "<body onload=\"f_onload()\">\n" +
        "  <div class=\"video-container\">\n" +
        "    <video src=\"" + id + "\" id=\"video\"></video>\n" +
        "    <div class=\"controls-container\">\n" +
        "      <div id=\"cueTimer\" style=\"opacity: 0; left: 90px;\">00:00</div>\n" + 
        "      <div class=\"progress-controls\">\n" +
        "        <div class=\"progress-bar\">\n" +
        "          <div class=\"watched-bar\"></div>\n" +
        "          <div class=\"playhead\"></div>\n" +
        "        </div>\n" +
        "        <div class=\"time-remaining\">\n" +
        "          00:00\n" +
        "        </div>\n" +
        "      </div>\n" +
        "      <div class=\"controls\">\n" +
        "        <button class=\"play-pause\">\n" +
        "          <svg class=\"playing\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n" +
        "            <polygon points=\"5 3 19 12 5 21 5 3\"></polygon>\n" +
        "          </svg>\n" +
        "          <svg class=\"paused\" viewBox=\"0 0 24 24\">\n" +
        "            <rect x=\"6\" y=\"4\" width=\"4\" height=\"16\"></rect>\n" +
        "            <rect x=\"14\" y=\"4\" width=\"4\" height=\"16\"></rect>\n" +
        "          </svg>\n" +
        "        </button>\n" +
        "        <button class=\"rewind\">\n" +
        "          <svg viewBox=\"0 0 24 24\">\n" +
        "            <path fill=\"#ffffff\"\n" +
        "              d=\"M12.5,3C17.15,3 21.08,6.03 22.47,10.22L20.1,11C19.05,7.81 16.04,5.5 12.5,5.5C10.54,5.5 8.77,6.22 7.38,7.38L10,10H3V3L5.6,5.6C7.45,4 9.85,3 12.5,3M10,12V22H8V14H6V12H10M18,14V20C18,21.11 17.11,22 16,22H14A2,2 0 0,1 12,20V14A2,2 0 0,1 14,12H16C17.11,12 18,12.9 18,14M14,14V20H16V14H14Z\" />\n" +
        "          </svg>\n" +
        "        </button>\n" +
        "        <button class=\"fast-forward\">\n" +
        "          <svg viewBox=\"0 0 24 24\">\n" +
        "            <path fill=\"#ffffff\"\n" +
        "              d=\"M10,12V22H8V14H6V12H10M18,14V20C18,21.11 17.11,22 16,22H14A2,2 0 0,1 12,20V14A2,2 0 0,1 14,12H16C17.11,12 18,12.9 18,14M14,14V20H16V14H14M11.5,3C14.15,3 16.55,4 18.4,5.6L21,3V10H14L16.62,7.38C15.23,6.22 13.46,5.5 11.5,5.5C7.96,5.5 4.95,7.81 3.9,11L1.53,10.22C2.92,6.03 6.85,3 11.5,3Z\" />\n" +
        "          </svg>\n" +
        "        </button>\n" +
        "        <button id=\"volume\"></button>\n" +
        "        <p class=\"title\">\n" +
        "          <span class=\"series\"></span><span class=\"episode\">" + id_display + "</span>\n" +
        "        </p>\n" +
        "        <a href=\"/\">" + 
        "            <svg width=\"34\" height=\"34\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"> <g clip-path=\"url(#clip0)\"> <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M12.5882 3.66429C12.2376 3.40927 11.7625 3.40927 11.4119 3.66429L5.00007 8.32743V20C5.00007 20.5523 5.44779 21 6.00007 21H8.00007V15C8.00007 13.3432 9.34322 12 11.0001 12H13.0001C14.6569 12 16.0001 13.3432 16.0001 15V21H18.0001C18.5524 21 19.0001 20.5523 19.0001 20V8.32743L12.5882 3.66429ZM21.0001 9.78198L22.4119 10.8088C22.8586 11.1336 23.484 11.0349 23.8088 10.5882C24.1336 10.1415 24.0349 9.51613 23.5882 9.19129L13.7646 2.04681C12.7126 1.28176 11.2875 1.28176 10.2356 2.04681L0.411899 9.19129C-0.0347537 9.51613 -0.133504 10.1415 0.191334 10.5882C0.516173 11.0349 1.14159 11.1336 1.58824 10.8088L3.00007 9.78198V20C3.00007 21.6569 4.34322 23 6.00007 23H18.0001C19.6569 23 21.0001 21.6569 21.0001 20V9.78198ZM14.0001 21V15C14.0001 14.4477 13.5524 14 13.0001 14H11.0001C10.4478 14 10.0001 14.4477 10.0001 15V21H14.0001Z\" fill=\"#293644\"></path> </g> <defs> <clipPath id=\"clip0\"> <rect width=\"24\" height=\"24\" fill=\"white\"></rect> </clipPath> </defs> </svg>" +
        "        </a>" + 
        "        <button class=\"back\">\n" +
        "          <svg viewBox=\"0 0 24 24\">\n" +
        "            <line x1=\"5\" y1=\"5\" x2=\"5\" y2=\"19\"></line>\n" +
        "            <polygon points=\"19 20 9 12 19 4 19 20\"></polygon>\n" +
        "          </svg>\n" +
        "        </button>\n" +
        "        <button class=\"next\">\n" +
        "          <svg viewBox=\"0 0 24 24\">\n" +
        "            <polygon points=\"5 4 15 12 5 20 5 4\"></polygon>\n" +
        "            <line x1=\"19\" y1=\"5\" x2=\"19\" y2=\"19\"></line>\n" +
        "          </svg>\n" +
        "        </button>\n" +
        "        <button class=\"full-screen\">\n" +
        "          <svg class=\"maximize\" viewBox=\"0 0 24 24\">\n" +
        "            <path d=\"M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3\">\n" +
        "            </path>\n" +
        "          </svg>\n" +
        "          <svg class=\"minimize\" viewBox=\"0 0 24 24\">\n" +
        "            <path d=\"M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3\">\n" +
        "            </path>\n" +
        "          </svg>\n" +
        "        </button>\n" +
        "      </div>\n" +
        "    </div>\n" +
        "  </div>  \n" +
        "</body>\n" +
        "</html>\n" +
        "<script>\n" +
        "const data={};\n" + 
        "const videoContainer = document.querySelector('.video-container');\n" +
        "const video = document.querySelector('.video-container video');\n" +
        "\n" +
        "const controlsContainer = document.querySelector('.video-container .controls-container');\n" +
        "\n" +
        "const playPauseButton = document.querySelector('.video-container .controls button.play-pause');\n" +
        "const rewindButton = document.querySelector('.video-container .controls button.rewind');\n" +
        "const fastForwardButton = document.querySelector('.video-container .controls button.fast-forward');\n" +
        "const fullScreenButton = document.querySelector('.video-container .controls button.full-screen');\n" +
        "const playButton = playPauseButton.querySelector('.playing');\n" +
        "const pauseButton = playPauseButton.querySelector('.paused');\n" +
        "const maximizeButton = fullScreenButton.querySelector('.maximize');\n" +
        "const minimizeButton = fullScreenButton.querySelector('.minimize');\n" +
        "\n" +
        "\n" +
        "const progressBar = document.querySelector('.video-container .progress-controls .progress-bar');\n" +
        "const watchedBar = document.querySelector('.video-container .progress-controls .progress-bar .watched-bar');\n" +
        "const timeLeft = document.querySelector('.video-container .progress-controls .time-remaining');\n" +
        "const back = document.querySelector('.video-container .controls .back');\n" +
        "const next = document.querySelector('.video-container .controls .next');\n" +
        back + 
        next + 
        "let controlsTimeout;\n" +
        "controlsContainer.style.opacity = '0';\n" +
        "watchedBar.style.width = '0px';\n" +
        "pauseButton.style.display = 'none';\n" +
        "minimizeButton.style.display = 'none';\n" +
        "\n" +
        "const displayControls = () => {\n" +
        "  controlsContainer.style.opacity = '1';\n" +
        "  document.body.style.cursor = 'initial';\n" +
        "  if (controlsTimeout) {\n" +
        "    clearTimeout(controlsTimeout);\n" +
        "  }\n" +
        "  controlsTimeout = setTimeout(() => {\n" +
        "    controlsContainer.style.opacity = '0';\n" +
        "    document.body.style.cursor = 'none';\n" +
        "  }, 1100);\n" +
        "};\n" +
        "\n" +
        "const playPause = () => {\n" +
        "  try{\n" +
        "    if (video.paused) {\n" +
        "      video.play();\n" +
        "      playButton.style.display = 'none';\n" +
        "      pauseButton.style.display = '';\n" +
        "    }else{\n" +
        "      video.pause();\n" +
        "      playButton.style.display = '';\n" +
        "      pauseButton.style.display = 'none';\n" +
        "    }\n" +
        "  }catch(e){}\n" +
        "};\n" +
        "\n" +
        "const toggleFullScreen = () => {\n" +
        "  if (!document.fullscreenElement) {\n" +
        "    videoContainer.requestFullscreen();\n" +
        "  } else {\n" +
        "    document.exitFullscreen();\n" +
        "  }\n" +
        "};\n" +
        "function clickVideo(){\n" +
        "  playPause();\n" +
        "}\n" +
        "var mili_click=0;\n" +
        "var mili_dclick=0;\n" +
        "function clickingVideo(n){\n" +
        "  if ( n == 1 ){\n" +
        "    mili_click=Date.now();\n" +
        "    setTimeout(\n" +
        "      function (){\n" +
        "	    if ( mili_dclick < (mili_click - 250) )\n" +
        "          clickVideo();\n" +
        "      },\n" +
        "    250);\n" +
        "  }else\n" +
        "    mili_dclick=Date.now();\n" +
        "}\n" +                
        "document.addEventListener('click', function(e) {  \n" +
        "   console.log('tagName clicked: ' + e.target.tagName);\n" +
        "   if ( e.target.tagName == 'VIDEO' ){\n" +
        "     clickingVideo(e.detail); // 1 - click, 2 - doubleclick\n" +
        "   }\n" +
        "},false);  \n" +
        "\n" +
        "document.addEventListener('dragend', function(e) {  \n" +
        "   console.log('tagName dragend: ' + e.target.tagName);\n" +
        "   if ( e.target.tagName == 'VIDEO' ){\n" +
        "     clickingVideo(1); // 1 - click, 2 - doubleclick\n" +
        "   }\n" +
        "},false);  \n" +
        "\n" +
        "document.addEventListener('fullscreenchange', () => {\n" +
        "  if (!document.fullscreenElement) {\n" +
        "    maximizeButton.style.display = '';\n" +
        "    minimizeButton.style.display = 'none';\n" +
        "  } else {\n" +
        "    maximizeButton.style.display = 'none';\n" +
        "    minimizeButton.style.display = '';\n" +
        "  }\n" +
        "});\n" +
        "\n" +
        "document.addEventListener('keyup', (event) => {\n" +
        "  if (event.code === 'Space') {\n" +
        "    playPause(); \n" +
        "  }\n" +
        "  if (event.code === 'KeyM') {\n" +
        "    volumeclick();\n" +
        "  }\n" +
        "  if (event.code === 'KeyF') {\n" +
        "    toggleFullScreen();\n" +
        "  }\n" +
        "  if (event.code === 'ArrowLeft') {\n" +
        "    rewindButton.click();\n" +
        "  }\n" +
        "  if (event.code === 'ArrowRight') {\n" +
        "    fastForwardButton.click();\n" +
        "  }\n" +
        "  displayControls();\n" +
        "});\n" +
        "\n" +
        "document.addEventListener('mousemove', () => {\n" +
        "  displayControls();\n" +
        "});\n" +
        "document.addEventListener('dblclick', () => {\n" +
        "  toggleFullScreen();\n" +
        "});\n" +
        "\n" +
        "function cueTime(e){\n" +
        "  const pos = (e.pageX  - (progressBar.offsetLeft + progressBar.offsetParent.offsetLeft)) / progressBar.offsetWidth;\n" +
        "  document.getElementById('cueTimer').innerText=format_seconds(video.duration-pos*video.duration);\n" +
        "  z=document.createElement(\"canvas\").getContext('2d').measureText(document.getElementById('cueTimer').innerText).width;\n" +
        "  z=e.pageX-z*0.7;  \n" +
        "  document.getElementById('cueTimer').setAttribute('style', 'opacity: 1; margin: 0px ' + z + 'px 0px; color: #FEFEFE;');  \n" +
        "}\n" +
        "function format_seconds(seconds_){\n" +
        "  let seconds = parseInt(seconds_);\n" +
        "  if (seconds < 0)\n" +
        "    seconds=0;\n" +
        "  let hour=parseInt(seconds/(60*60));\n" +
        "  seconds-=hour*60*60;\n" +
        "  let minute=parseInt(seconds/60);\n" +
        "  seconds-=minute*60;\n" +
        "  second=seconds;\n" +
        "  if ( minute < 10 )\n" +
        "    minute='0'+minute;\n" +
        "  else\n" +
        "    minute=''+minute;\n" +
        "  if ( second < 10 )\n" +
        "    second='0'+second;\n" +
        "  else\n" +
        "    second=''+second;\n" +
        "  return hour+':'+minute+':'+second;\n" +
        "}\n" + 
        "function volumeclick(){\n" +
        "  let e=document.getElementById('volume');\n" +
        "  let state1='\\n          <svg data-s=\"1\" viewBox=\"0 0 24 24\">\\n            <polygon points=\"11 5 6 9 2 9 2 15 6 15 11 19 11 5\"></polygon>\\n            <path d=\"M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07\"></path>\\n          </svg>';\n" +
        "  let state2='\\n          <svg data-s=\"2\" viewBox=\"0 0 24 24\">\\n            <polygon points=\"11 5 6 9 2 9 2 15 6 15 11 19 11 5\"></polygon>\\n            </svg>';\n" +
        "  let state3='\\n          <svg data-s=\"3\" viewBox=\"0 0 24 24\">\\n            <polygon points=\"11 5 6 9 2 9 2 15 6 15 11 19 11 5\"></polygon>\\n            </svg>';\n" +
        "  let state4='\\n          <svg data-s=\"4\" viewBox=\"0 0 24 24\">\\n            <polygon points=\"11 5 6 9 2 9 2 15 6 15 11 19 11 5\"></polygon>\\n            </svg>';\n" +
        "  let state5='\\n          <svg data-s=\"5\" viewBox=\"0 0 24 24\">\\n            <polygon points=\"11 5 6 9 2 9 2 15 6 15 11 19 11 5\"></polygon>\\n            <line x1=\"23\" y1=\"9\" x2=\"17\" y2=\"15\"></line>\\n            <line x1=\"17\" y1=\"9\" x2=\"23\" y2=\"15\"></line>\\n          </svg>\\n        ';\n" +
        "  let volume1=1;\n" +
        "  let volume2=0.6;\n" +
        "  let volume3=0.4;\n" +
        "  let volume4=0.2;\n" +
        "  let volume5=0;  \n" +
        "  if ( e.innerHTML == state1 ){ e.innerHTML=state2;video.volume=volume2;return; }\n" +
        "  if ( e.innerHTML == state2 ){ e.innerHTML=state3;video.volume=volume3;return; }\n" +
        "  if ( e.innerHTML == state3 ){ e.innerHTML=state4;video.volume=volume4;return; }\n" +
        "  if ( e.innerHTML == state4 ){ e.innerHTML=state5;video.volume=volume5;return; }\n" +
        "  e.innerHTML=state1;\n" +
        "  video.volume=volume1;\n" +
        "}\n" +
        "video.addEventListener('timeupdate', () => {\n" +
        "  watchedBar.style.width = ((video.currentTime / video.duration) * 100) + '%';\n" +
        "  timeLeft.textContent = format_seconds(video.duration - video.currentTime);\n" +
        "});\n" +
        "progressBar.addEventListener('mousemove', function(e) { cueTime(e); });\n" +
        "progressBar.addEventListener('mouseleave', function(e) { document.getElementById('cueTimer').style.opacity = 0; });\n" +        
        "progressBar.addEventListener('click', (event) => {\n" +
        "  const pos = (event.pageX  - (progressBar.offsetLeft + progressBar.offsetParent.offsetLeft)) / progressBar.offsetWidth;\n" +
        "  video.currentTime = pos * video.duration;\n" +
        "});\n" +
        "\n" +
        "playPauseButton.addEventListener('click', playPause);\n" +
        "\n" +
        "rewindButton.addEventListener('click', () => {\n" +
        "  video.currentTime -= 10;\n" +
        "});\n" +
        "\n" +
        "fastForwardButton.addEventListener('click', () => {\n" +
        "  video.currentTime += 10;\n" +
        "});\n" +
        "\n" +
        "fullScreenButton.addEventListener('click', toggleFullScreen);\n" + 
        "document.getElementById('volume').addEventListener('click', volumeclick);\n" + 
        "var cache_digest=null;\n" +
        "function getDigest(){\n" +
        "  if ( cache_digest != null )\n" +
        "    return cache_digest;\n" +
        "  let digest = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];\n" +
        "  let p_digest = 0;\n" +
        "  function updateDigest(a){\n" +
        "    for ( var i=0;i<a.length;i++ ){\n" +
        "      digest[p_digest]=(digest[p_digest]+a.charCodeAt(i))%52;\n" +
        "      p_digest++;\n" +
        "      if ( p_digest >= digest.length )\n" +
        "        p_digest=0;\n" +
        "    }\n" +
        "  }\n" +
        "  var a = video.src;\n" +
        "  for ( var i=0;i<digest.length;i++ ){\n" +
        "    if ( digest[i] >= 26 )\n" +
        "      a+=String.fromCharCode(digest[i]-26+97);\n" +
        "    else\n" +
        "      a+=String.fromCharCode(digest[i]+65);\n" +
        "  }\n" +
        "  cache_digest = a;\n" +
        "  return cache_digest;\n" +
        "}\n" +
        "function save_station(){\n" +
        "  if ( getDigest() != null ){\n" +
        "    let digest = getDigest();\n" +
        "    let currentTime=document.getElementById('video').currentTime;\n" +
        "    let volume=document.getElementById('video').volume;\n" +
        "    localStorage.setItem('playlistmovie-v-20241014test-'+digest,JSON.stringify({'currentTime': currentTime}));\n" +
        "    localStorage.setItem('playlistmovie-v-20241014test-global',JSON.stringify({'volume': volume}));\n" +
        "  }\n" +
        "}\n" +
        "function load_station(){\n" +
        "  if ( getDigest() != null ){\n" +
        "    let a = localStorage.getItem('playlistmovie-v-20241014test-'+getDigest());\n" +
        "    if ( a != null ){\n" +
        "      let b = JSON.parse(a);\n" +
        "      let currentTime = b['currentTime'];\n" +
        "      document.getElementById('video').currentTime = currentTime;      \n" +
        "      if ( document.getElementById('video').currentTime > (document.getElementById('video').duration-10) )\n" +
        "        document.getElementById('video').currentTime = 0;      \n" +
        "    }\n" +
        "    a = localStorage.getItem('playlistmovie-v-20241014test-global');\n" +
        "    if ( a != null ){\n" +
        "      let b = JSON.parse(a);\n" +
        "      let volume = b['volume'];\n" +
        "      setvolume(volume);\n" +
        "    }\n" +
        "  }\n" +
        "}\n" +
        "function interval_1000(){\n" +
        "  save_station();\n" +
        "}\n" +
        "function setvolume(volume){\n" +
        "  let e=document.getElementById('volume');\n" +
        "  let state1='\\n          <svg data-s=\"1\" viewBox=\"0 0 24 24\">\\n            <polygon points=\"11 5 6 9 2 9 2 15 6 15 11 19 11 5\"></polygon>\\n            <path d=\"M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07\"></path>\\n          </svg>';\n" +
        "  let state2='\\n          <svg data-s=\"2\" viewBox=\"0 0 24 24\">\\n            <polygon points=\"11 5 6 9 2 9 2 15 6 15 11 19 11 5\"></polygon>\\n            </svg>';\n" +
        "  let state3='\\n          <svg data-s=\"3\" viewBox=\"0 0 24 24\">\\n            <polygon points=\"11 5 6 9 2 9 2 15 6 15 11 19 11 5\"></polygon>\\n            </svg>';\n" +
        "  let state4='\\n          <svg data-s=\"4\" viewBox=\"0 0 24 24\">\\n            <polygon points=\"11 5 6 9 2 9 2 15 6 15 11 19 11 5\"></polygon>\\n            </svg>';\n" +
        "  let state5='\\n          <svg data-s=\"5\" viewBox=\"0 0 24 24\">\\n            <polygon points=\"11 5 6 9 2 9 2 15 6 15 11 19 11 5\"></polygon>\\n            <line x1=\"23\" y1=\"9\" x2=\"17\" y2=\"15\"></line>\\n            <line x1=\"17\" y1=\"9\" x2=\"23\" y2=\"15\"></line>\\n          </svg>\\n        ';\n" +
        "  let volume1=1;\n" +
        "  let volume2=0.6;\n" +
        "  let volume3=0.4;\n" +
        "  let volume4=0.2;\n" +
        "  let volume5=0;  \n" +
        "  if ( volume == volume2 ){ e.innerHTML=state2;video.volume=volume2;return; }\n" +
        "  if ( volume == volume3 ){ e.innerHTML=state3;video.volume=volume3;return; }\n" +
        "  if ( volume == volume4 ){ e.innerHTML=state4;video.volume=volume4;return; }\n" +
        "  if ( volume == volume5 ){ e.innerHTML=state5;video.volume=volume5;return; }\n" +
        "  e.innerHTML=state1;\n" +
        "  video.volume=volume1;\n" +
        "}\n" +
        "function f_onload(){\n" +
        "  volumeclick();\n" +
        "  load_station();\n" +
        "  playPause();\n" +
        "}\n" +
        "setInterval(interval_1000, 1000);\n" +                
        "</script>\n" +
        "\n" +
        "<style>\n" +
        "body {\n" +
        "  margin: 0;\n" +
        "  padding: 0;\n" +
        "  width: 100vw;\n" +
        "  height: 100vh;\n" +
        "  overflow: hidden;\n" +
        "  background: black;\n" +
        "  font-family: 'Rubik', sans-serif;\n" +
        "}\n" +
        "\n" +
        ".video-container {\n" +
        "  width: 100%;\n" +
        "  height: 100%;\n" +
        "  display: flex;\n" +
        "  justify-content: center;\n" +
        "  align-items: center;\n" +
        "}\n" +
        "\n" +
        ".video-container video {\n" +
        "  width: 100%;\n" +
        "  height: 100%;\n" +
        "}\n" +
        "\n" +
        ".video-container .controls-container {\n" +
        "  position: fixed;\n" +
        "  bottom: 0px;\n" +
        "  width: 100%;\n" +
        "  display: flex;\n" +
        "  flex-direction: column;\n" +
        "  justify-content: flex-end;\n" +
        "  background: linear-gradient(rgba(0,0,0,0), rgba(0,0,0,0.9)); \n" +
        "  transition: opacity 0.5s linear;\n" +
        "}\n" +
        "\n" +
        ".video-container .progress-controls {\n" +
        "  width: 100%;\n" +
        "  display: flex;\n" +
        "  justify-content: center;\n" +
        "  align-items: center;\n" +
        "  color: white;\n" +
        "}\n" +
        "\n" +
        ".video-container .progress-controls .time-remaining {\n" +
        "  margin: 1vw;\n" +
        "  width: 4vw;\n" +
        "}\n" +
        "\n" +
        ".video-container .progress-controls .progress-bar {\n" +
        "  width: 90vw;\n" +
        "  height: 1vw;\n" +
        "  max-height: 7px;\n" +
        "  background: #5B5B5B;\n" +
        "  display: flex;\n" +
        "  align-items: center;\n" +
        "  cursor: pointer;\n" +
        "}\n" +
        "\n" +
        ".video-container .progress-controls .progress-bar .watched-bar,\n" +
        ".video-container .progress-controls .progress-bar .playhead {\n" +
        "  background: #E31221;\n" +
        "  display: inline-block;\n" +
        "  transition: all 0.2s;\n" +
        "}\n" +
        "\n" +
        ".video-container .progress-controls .progress-bar .watched-bar {\n" +
        "  height: 100%;\n" +
        "  width: 20%;\n" +
        "}\n" +
        "\n" +
        ".video-container .progress-controls .progress-bar .playhead {\n" +
        "  height: 3vw;\n" +
        "  width: 3vw;\n" +
        "  max-height: 25px;\n" +
        "  max-width: 25px;\n" +
        "  border-radius: 50%;\n" +
        "  transform: translateX(-50%);\n" +
        "}\n" +
        "\n" +
        ".video-container .controls {\n" +
        "  width: 100%;\n" +
        "  display: flex;\n" +
        "  justify-content: space-between;\n" +
        "  align-items: center;\n" +
        "}\n" +
        "\n" +
        ".video-container .controls button {\n" +
        "  background: none;\n" +
        "  outline: none;\n" +
        "  box-shadow: none;\n" +
        "  border: none;\n" +
        "  width: 5vw;\n" +
        "  height: 5vw;\n" +
        "  min-width: 50px;\n" +
        "  min-height: 50px;\n" +
        "  margin: 0px 1vw;\n" +
        "  opacity: 0.4;\n" +
        "  transform: scale(0.9);\n" +
        "  transition: all 0.2s ease-in-out;\n" +
        "  cursor: pointer;\n" +
        "}\n" +
        "\n" +
        ".video-container .controls button:hover {\n" +
        "  opacity: 1;\n" +
        "  transform: scale(1.2);\n" +
        "}\n" +
        "\n" +
        ".video-container .controls button svg {\n" +
        "  fill: white;\n" +
        "  stroke: white;\n" +
        "  stroke-width: 2;\n" +
        "  stroke-linecap: round;\n" +
        "  stroke-linejoin: round;\n" +
        "  width: 100%;\n" +
        "  height: 100%;\n" +
        "}\n" +
        "\n" +
        ".video-container .controls button.volume svg path,\n" +
        ".video-container .controls button.help svg,\n" +
        ".video-container .controls button.episodes svg,\n" +
        ".video-container .controls button.full-screen svg,\n" +
        ".video-container .controls button.volume svg path,\n" +
        ".video-container .controls button.cast svg {\n" +
        "  fill: none;\n" +
        "}\n" +
        "\n" +
        ".video-container .controls button.rewind svg,\n" +
        ".video-container .controls button.fast-forward svg {\n" +
        "  stroke: none;\n" +
        "}\n" +
        "\n" +
        ".video-container .controls button.captions svg {\n" +
        "  stroke: none;\n" +
        "}\n" +
        "\n" +
        ".video-container .controls .title {\n" +
        "  font-size: 2vw;\n" +
        "  width: 100%;\n" +
        "  height: 100%;\n" +
        "  display: flex;\n" +
        "  justify-content: flex-start;\n" +
        "  align-items: center;\n" +
        "}\n" +
        "\n" +
        "@media only screen and (max-width: 768px) {\n" +
        "  .video-container .controls .title {\n" +
        "    display: none;\n" +
        "  }\n" +
        "}\n" +
        "\n" +
        ".video-container .controls .title .series {\n" +
        "  color: #FEFEFE;\n" +
        "  font-weight: bold;\n" +
        "  font-size: 1em;\n" +
        "}\n" +
        "\n" +
        ".video-container .controls .title .episode {\n" +
        "  color: #A1A1A1;\n" +
        "  font-size: 0.75em;\n" +
        "  padding-left: 1vw;\n" +
        "}\n" +
        "</style>\n" + 
        js_compartilhado;
    }
}

/* 
//WASAPI C#
// install dotnet windows
winget install Microsoft.DotNet.SDK.8

y mkdir wasapi
cd wasapi
dotnet new console

dotnet add package NAudio.Wasapi --version 2.2.1

inclua a linha abaixo depois de TagetFramework em wasapi.csproj:
<PublishSingleFile>true</PublishSingleFile>

// roda
dotnet run > file.wav
// ouvindo mic em tempo real, delay 1 segundo
wasapi only_mic | "C:\\Program Files\\VideoLAN\\VLC\\vlc.exe" -I null --play-and-exit -

// publishs
dotnet publish
dotnet publish -c Release -r ubuntu.16.10-x64
dotnet publish -c Release -r win10-x64
dotnet publish -c Release -r osx.10.11-x64


salve o conteudo abaixo em Program.cs:
using NAudio.CoreAudioApi;
using NAudio.Wave;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading;

namespace LoopbackWithMic
{
    class Program
    {
        static void Main(string[] args)
        {
            bool flag_system=true;
            bool flag_mic=true;
            if ( args.Length > 0 )
            {
                if ( args[0] == "only_system" )
                {
                    flag_mic=false;
                }
                else
                {
                    if ( args[0] == "only_mic" )
                    {
                        flag_system=false;
                    }
                    else
                    {
                        Console.WriteLine("\nParametro incorreto, veja as opções:\nwasapi > file.wav\nwasapi only_mic > file.wav\nwasapi only_system > file.wav\nObs: only_system só envia dados enquanto houve som sendo propagado");
                        return;
                    }
                }
            }           
            var enumerator = new MMDeviceEnumerator();
            var output = enumerator.GetDefaultAudioEndpoint(DataFlow.Render, Role.Console);
            var output_false = enumerator.EnumerateAudioEndPoints(DataFlow.Render, DeviceState.Active).Where(x => x != output).FirstOrDefault();
            var input=enumerator.GetDefaultAudioEndpoint(DataFlow.Capture, Role.Console);
            List<IWaveProvider> pp = new List<IWaveProvider>();
            List<WasapiCapture> capture = new List<WasapiCapture>();

            if ( flag_system )
                capture.Add(new WasapiLoopbackCapture(output));           
            if ( flag_mic )
                capture.Add(new WasapiCapture(input));
            List<BufferedWaveProvider> provider = new List<BufferedWaveProvider>();
            for ( var i=0;i<capture.Count;i++ )
            {
                provider.Add(new BufferedWaveProvider(capture.ElementAt(i).WaveFormat));
                if(capture.ElementAt(i).WaveFormat.Channels > 1)
                {
                    var mon = new NAudio.Wave.SampleProviders.StereoToMonoSampleProvider(provider.ElementAt(i).ToSampleProvider());
                    pp.Add(mon.ToWaveProvider());
                }
                else
                {
                    pp.Add(provider.ElementAt(i));
                }
            }
            MixingWaveProvider32 mix = new MixingWaveProvider32(pp);                       
            MemoryStream ms=new MemoryStream();
            WaveRecorderMemory record = new WaveRecorderMemory(mix, ms);
            var speaker = new WasapiOut(output_false, AudioClientShareMode.Shared, true, 15);           
            speaker.Init(record);
            List<byte> bytes = new List<byte>();
            for ( var i=0;i<capture.Count;i++ )
            {
                var tmp=provider.ElementAt(i);
                capture.ElementAt(i).DataAvailable += (s, a) =>
                {
                    tmp.AddSamples(a.Buffer, 0, a.BytesRecorded);
                };
                capture.ElementAt(i).StartRecording();
            }
            speaker.Play();
            bool first=true;
            Stream stream_=Console.OpenStandardOutput();
            Byte [] buff;
            while(true)
            {
                if ( first )
                {
                    if ( ms.Length >= 1920*10 )
                    {
                        buff = ms.ToArray();                       
                        ms.SetLength(0);
                        stream_.Write(buff, 0, buff.Length);
                        stream_.Flush();
                        first=false;
                    }
                }
                else
                {
                    if ( ms.Length >= 1920*4 )
                    {
                        buff = ms.ToArray();                       
                        ms.SetLength(0);
                        stream_.Write(buff, 0, buff.Length);   
                        stream_.Flush();
                    }
                }
                Thread.Sleep(1);
            }           
        }
    }
   
    class WaveRecorderMemory : IWaveProvider, IDisposable
    {
        private WaveFileWriter writer;
        private IWaveProvider source;

        public WaveRecorderMemory(IWaveProvider source, Stream out_)
        {           
            this.source = source;
            this.writer = new WaveFileWriter(out_, source.WaveFormat);           
        }

        public int Read(byte[] buffer, int offset, int count)
        {
            int bytesRead = source.Read(buffer, offset, count);
            writer.Write(buffer, offset, bytesRead);
            return bytesRead;
        }

        public WaveFormat WaveFormat
        {
            get { return source.WaveFormat; }
        }

        public void Dispose()
        {
            if (writer != null)
            {
                writer.Dispose();
            }
        }
    }   
}
*/


/* class AES */ // echo TXT | openssl aes-256-cbc -base64 -pass pass:SENHA -md md5 -e
/* class AES */ // y echo PPP | openssl aes-256-cbc -md md5 -k SENHA -e | y base64
/* class AES */ // ===> ATENCAO, só é compativel com o openssl com o parametro -md md5
/* class AES */ // creditos: https://github.com/chmduquesne/minibackup/blob/master/samples/OpensslAES.java
/* class AES */ // new AES().encrypt(bytes,password);
/* class AES */ // new AES().decrypt(bytes,password);
/* class AES */ // txt=base64_B_S(new AES().encrypt(txt.getBytes(),senha,null,null) ,true);
/* class AES */ // new AES().encrypt(System.in,System.out,senha,null,null);
/* class AES */ // new AES().decrypt(System.in,System.out,senha,null);
/* class AES */ 
@SuppressWarnings({"unchecked", "deprecation"})
class AES{ byte [] deriveKeyAndIV(byte[] password, String md, byte[] salt) throws Exception{        if ( md == null || md.equals("") ) md="MD5"; byte[] res = new byte[48]; final java.security.MessageDigest md5 = java.security.MessageDigest.getInstance(md); md5.update(password); md5.update(salt); byte[] hash1 = md5.digest(); md5.reset(); md5.update(hash1); md5.update(password); md5.update(salt); byte[] hash2 = md5.digest(); md5.reset(); md5.update(hash2); md5.update(password); md5.update(salt); byte[] hash3 = md5.digest(); if ( md == null || md.equals("MD5")){ System.arraycopy(hash1, 0, res, 0, 16); System.arraycopy(hash2, 0, res, 16, 16); System.arraycopy(hash3, 0, res, 32, 16); }else{ System.arraycopy(hash1, 0, res, 0, 32); System.arraycopy(hash2, 0, res, 32, 16); } return res; } public void encrypt(java.io.InputStream pipe_in, java.io.OutputStream pipe_out, String senha, String md, byte[] salt) throws Exception { try{ byte[] salt_ = new byte[8]; java.security.SecureRandom sr = new java.security.SecureRandom(); sr.nextBytes(salt_); if ( salt==null ) salt=salt_; byte[] keyAndIV = deriveKeyAndIV(senha.getBytes(),md,salt); byte[] key = java.util.Arrays.copyOfRange(keyAndIV, 0, 32); byte[] iv = java.util.Arrays.copyOfRange(keyAndIV, 32, 48); javax.crypto.spec.SecretKeySpec skeySpec = new javax.crypto.spec.SecretKeySpec(key, "AES"); javax.crypto.spec.IvParameterSpec ivspec = new javax.crypto.spec.IvParameterSpec(iv); javax.crypto.Cipher cipher = javax.crypto.Cipher.getInstance("AES/CBC/PKCS5Padding"); cipher.init(javax.crypto.Cipher.ENCRYPT_MODE, skeySpec, ivspec); int BUFFER_SIZE=1024; byte[] buff=new byte[BUFFER_SIZE]; int len=0; pipe_out.write("Salted__".getBytes()); pipe_out.write(salt); while ( (len=pipe_in.read(buff,0,BUFFER_SIZE)) > 0 ) pipe_out.write( cipher.update(buff,0,len) ); pipe_out.write(cipher.doFinal()); pipe_out.flush(); }catch(Exception e){ if(e.toString().contains("java.security.InvalidKeyException: Illegal key size")) System.out.println("Erro conhecido no windows! - Considere utilizar outro jdk -> https://mega.nz/file/eYYjSTII#OXreG57QM6NQpykXSt5ojXclaBG7AQ8IGlA2oDDPdGo"); throw e; } } public byte[] encrypt(byte[] data, String senha, String md, byte[] salt) throws Exception{ java.io.ByteArrayInputStream bais=new java.io.ByteArrayInputStream(data); java.io.ByteArrayOutputStream baos=new java.io.ByteArrayOutputStream(); encrypt(bais,baos,senha,md,salt); return baos.toByteArray(); } public void decrypt(java.io.InputStream pipe_in,java.io.OutputStream pipe_out,String senha,String md) throws Exception { try{ int p=0; p=pipe_in.read(new byte[8]); if ( p != 8 ){ System.err.println("Erro fatal 0!"); System.exit(1); } byte[] salt=new byte[8]; p=pipe_in.read(salt); if ( p != 8 ){ System.err.println("Erro fatal 0!"); System.exit(1); }        byte[] keyAndIV=deriveKeyAndIV(senha.getBytes(),md,salt); byte[] key=java.util.Arrays.copyOfRange(keyAndIV, 0, 32); byte[] iv=java.util.Arrays.copyOfRange(keyAndIV, 32, 48); javax.crypto.spec.SecretKeySpec skeySpec = new javax.crypto.spec.SecretKeySpec(key, "AES"); javax.crypto.spec.IvParameterSpec ivspec = new javax.crypto.spec.IvParameterSpec(iv); javax.crypto.Cipher cipher; cipher=javax.crypto.Cipher.getInstance("AES/CBC/PKCS5Padding"); cipher.init(javax.crypto.Cipher.DECRYPT_MODE, skeySpec, ivspec); int BUFFER_SIZE=1024; byte[] buff=new byte[BUFFER_SIZE]; int len=0; while ( (len=pipe_in.read(buff,0,BUFFER_SIZE)) > 0 ) pipe_out.write( cipher.update(buff,0,len) ); pipe_out.write(cipher.doFinal()); pipe_out.flush(); }catch(Exception e){ if(e.toString().contains("java.security.InvalidKeyException: Illegal key size")) System.out.println("Erro conhecido no windows! - Considere utilizar outro jdk -> https://mega.nz/file/eYYjSTII#OXreG57QM6NQpykXSt5ojXclaBG7AQ8IGlA2oDDPdGo"); throw e; } } public byte[] decrypt(byte[] data, String senha, String md) throws Exception{ java.io.ByteArrayInputStream bais=new java.io.ByteArrayInputStream(data); java.io.ByteArrayOutputStream baos=new java.io.ByteArrayOutputStream(); decrypt(bais,baos,senha,md); return baos.toByteArray(); } private static String bytesToHex(byte[] a){ StringBuilder sb = new StringBuilder(); for (byte b : a) { sb.append(String.format("%02X", b)); } return sb.toString(); } private static byte[] hexTobytes(String s) { int len = s.length(); byte[] data = new byte[len / 2]; for (int i = 0; i < len; i += 2) { data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4) + Character.digit(s.charAt(i+1), 16)); } return data;}}


/* class Utilonsole */ // String senha=Utilonsole.getPasswordConsole("Digite a senha: ");
/* class Utilonsole */ // String texto=Utilonsole.getTextConsole("Digite o texto: ");
/* class Utilonsole */ 
@SuppressWarnings({"unchecked", "deprecation"})
class Utilonsole{ public static String getPasswordConsole(String txt) { String retorno=""; java.io.Console console=System.console(); if ( console == null ){ System.out.println("Error, input nao suportado nesse ambiente, rodando no netbeans?..."); System.exit(1); } char [] passChar = System.console().readPassword(txt); if ( passChar != null ) retorno=new String(passChar); if ( retorno == null ){ System.out.println("Error, not input found"); System.exit(1); } return retorno;}public static String getTextConsole(String txt) { String retorno=""; java.io.Console console=System.console(); if ( console == null ){ System.out.println("Error, input nao suportado nesse ambiente, rodando no netbeans?..."); System.exit(1); } System.out.print(txt);retorno=System.console().readLine();if ( retorno == null ){ System.out.println("Error, not input found"); System.exit(1); } return retorno;}}

//REMOVED_GRAAL_START
/* class JSchCustom */ 
@SuppressWarnings({"unchecked", "deprecation"})
class JSchCustom { void scpFrom(String[] args, String senha, int port) { ScpFrom.custom(args, senha, port); } void scpTo(String[] args, String senha, int port) { ScpTo.custom(args, senha, port); } void execSsh(String[] args, String senha, int port) { ExecSsh.custom(args, senha, port); } void ssh(String[] args, String senha, int port) { Ssh.custom(args, senha, port); } void sftp(String[] args, String senha, int port) { Sftp.custom(args, senha, port); } } 
@SuppressWarnings({"unchecked", "deprecation"})
class ScpFrom { public static void custom(String[] arg, String senha, int port) { if (arg.length != 2 || !arg[0].contains("@")) { System.err.println("usage: y scp user,pass@remotehost:file1 file2"); System.exit(-1); } FileOutputStream fos = null; try { String user = arg[0].substring(0, arg[0].indexOf('@')); arg[0] = arg[0].substring(arg[0].indexOf('@') + 1); String host = arg[0].substring(0, arg[0].indexOf(':'));  String rfile = arg[0].substring(arg[0].indexOf(':') + 1); String lfile = arg[1]; String prefix = null; if (new File(lfile).isDirectory()) { prefix = lfile + File.separator; } JSch jsch = new JSch(); Session session = jsch.getSession(user, host, port); UserInfo ui = new MyUserInfo(senha); session.setUserInfo(ui); session.connect(); String command = "scp -f " + rfile; Channel channel = session.openChannel("exec"); ((ChannelExec) channel).setCommand(command); OutputStream out = channel.getOutputStream(); InputStream in = channel.getInputStream(); channel.connect(); byte[] buf = new byte[1024]; buf[0] = 0; out.write(buf, 0, 1); out.flush(); while (true) { int c = checkAck( in ); if (c != 'C') { break; }  in.read(buf, 0, 5); long filesize = 0L; while (true) { if ( in .read(buf, 0, 1) < 0) { break; } if (buf[0] == ' ') break; filesize = filesize * 10L + (long)(buf[0] - '0'); } String file = null; for (int i = 0;; i++) { in .read(buf, i, 1); if (buf[i] == (byte) 0x0a) { file = new String(buf, 0, i); break; } } buf[0] = 0; out.write(buf, 0, 1); out.flush(); fos = new FileOutputStream(prefix == null ? lfile : prefix + file); int foo; while (true) { if (buf.length < filesize) foo = buf.length; else foo = (int) filesize; foo = in .read(buf, 0, foo); if (foo < 0) { break; } fos.write(buf, 0, foo); filesize -= foo; if (filesize == 0L) break; } fos.close(); fos = null; if (checkAck( in ) != 0) { System.exit(0); } buf[0] = 0; out.write(buf, 0, 1); out.flush(); } session.disconnect(); System.exit(0); } catch (Exception e) { System.out.println(e); try { if (fos != null) fos.close(); } catch (Exception ee) {} } } static int checkAck(InputStream in ) throws IOException { int b = in .read(); if (b == 0) return b; if (b == -1) return b; if (b == 1 || b == 2) { StringBuffer sb = new StringBuffer(); int c; do { c = in .read(); sb.append((char) c); } while (c != '\n'); if (b == 1) { System.out.print(sb.toString()); } if (b == 2) { System.out.print(sb.toString()); } } return b; } 
@SuppressWarnings({"unchecked", "deprecation"})
public static class MyUserInfo implements UserInfo, UIKeyboardInteractive { String passwd; String senha; private MyUserInfo(String senha) { this.senha = senha; } public String getPassword() { return passwd; } public boolean promptYesNo(String str) { return true; } JTextField passwordField = (JTextField) new JPasswordField(20); public String getPassphrase() { return null; } public boolean promptPassphrase(String message) { return true; } public boolean promptPassword(String message) { passwd = senha; return true; } public void showMessage(String message) { System.err.println("nao implementado! cod 1"); System.exit(1); } 
/* class JSchCustom */ final GridBagConstraints gbc = new GridBagConstraints(0, 0, 1, 1, 1, 1, GridBagConstraints.NORTHWEST, GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0); private Container panel; public String[] promptKeyboardInteractive(String destination, String name, String instruction, String[] prompt, boolean[] echo) { return null; } } } 
@SuppressWarnings({"unchecked", "deprecation"})
class ScpTo { public static void custom(String[] arg, String senha, int port) { if (arg.length != 2 || !arg[1].contains("@")) { System.err.println("usage: y scp file1 user,pass@remotehost:file2"); System.exit(-1); } FileInputStream fis = null; try { String lfile = arg[0]; String user = arg[1].substring(0, arg[1].indexOf('@')); arg[1] = arg[1].substring(arg[1].indexOf('@') + 1); String host = arg[1].substring(0, arg[1].indexOf(':')); String rfile = arg[1].substring(arg[1].indexOf(':') + 1); JSch jsch = new JSch(); Session session = jsch.getSession(user, host, 22); UserInfo ui = new MyUserInfo(senha); session.setUserInfo(ui); session.connect(); boolean ptimestamp = true; String command = "scp " + (ptimestamp ? "-p" : "") + " -t " + rfile; Channel channel = session.openChannel("exec"); ((ChannelExec) channel).setCommand(command); OutputStream out = channel.getOutputStream(); InputStream in = channel.getInputStream(); channel.connect(); if (checkAck( in ) != 0) { System.exit(0); } File _lfile = new File(lfile); if (ptimestamp) { command = "T" + (_lfile.lastModified() / 1000) + " 0"; command += (" " + (_lfile.lastModified() / 1000) + " 0\n"); out.write(command.getBytes()); out.flush(); if (checkAck( in ) != 0) { System.exit(0); } } long filesize = _lfile.length(); command = "C0644 " + filesize + " "; if (lfile.lastIndexOf('/') > 0) { command += lfile.substring(lfile.lastIndexOf('/') + 1); } else { command += lfile; } command += "\n"; out.write(command.getBytes()); out.flush(); if (checkAck( in ) != 0) { System.exit(0); } fis = new FileInputStream(lfile); byte[] buf = new byte[1024]; while (true) { int len = fis.read(buf, 0, buf.length); if (len <= 0) break; out.write(buf, 0, len); } fis.close(); fis = null; buf[0] = 0; out.write(buf, 0, 1); out.flush(); if (checkAck( in ) != 0) { System.exit(0); } out.close(); channel.disconnect(); session.disconnect(); System.exit(0); } catch (Exception e) { System.out.println(e); try { if (fis != null) fis.close(); } catch (Exception ee) {} } } static int checkAck(InputStream in ) throws IOException { int b = in .read(); if (b == 0) return b; if (b == -1) return b; if (b == 1 || b == 2) { StringBuffer sb = new StringBuffer(); int c; do { c = in .read(); sb.append((char) c); } while (c != '\n'); if (b == 1) { System.out.print(sb.toString()); } if (b == 2) { System.out.print(sb.toString()); } } return b; } 
@SuppressWarnings({"unchecked", "deprecation"})
public static class MyUserInfo implements UserInfo, UIKeyboardInteractive { String passwd; String senha; private MyUserInfo(String senha) { this.senha = senha; } public String getPassword() { return passwd; } public boolean promptYesNo(String str) { return true; } JTextField passwordField = (JTextField) new JPasswordField(20); public String getPassphrase() { return null; } public boolean promptPassphrase(String message) { return true; } public boolean promptPassword(String message) { passwd = senha; return true; } public void showMessage(String message) { System.err.println("nao implementado! cod 3"); System.exit(1); } final GridBagConstraints gbc = new GridBagConstraints(0, 0, 1, 1, 1, 1, GridBagConstraints.NORTHWEST, GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0); 
/* class JSchCustom */ private Container panel; public String[] promptKeyboardInteractive(String destination, String name, String instruction, String[] prompt, boolean[] echo) { return null; } } } 
@SuppressWarnings({"unchecked", "deprecation"})
class ExecSsh { public static void custom(String[] arg, String senha, int port) { try { JSch jsch = new JSch(); if (arg.length != 2 || !arg[0].contains("@")) { System.err.println("usage: y execSsh user,pass@remotehost command"); System.exit(-1); } String user = arg[0].split("@")[0]; String host = arg[0].split("@")[1]; String command = arg[1]; Session session = jsch.getSession(user, host, port); UserInfo ui = new MyUserInfo(senha); session.setUserInfo(ui); session.connect(); Channel channel = session.openChannel("exec"); ((ChannelExec) channel).setCommand(command); channel.setInputStream(null); ((ChannelExec) channel).setErrStream(System.err); InputStream in = channel.getInputStream(); channel.connect(); byte[] tmp = new byte[1024]; while (true) { while ( in .available() > 0) { int i = in .read(tmp, 0, 1024); if (i < 0) break; System.out.print(new String(tmp, 0, i)); } if (channel.isClosed()) { if ( in .available() > 0) continue; break; } try { Thread.sleep(1000); } catch (Exception ee) {} } channel.disconnect(); session.disconnect(); } catch (Exception e) { System.out.println(e); } } 
@SuppressWarnings({"unchecked", "deprecation"})
public static class MyUserInfo implements UserInfo, UIKeyboardInteractive { String passwd; String senha; private MyUserInfo(String senha) { this.senha = senha; } public String getPassword() { return passwd; } public boolean promptYesNo(String str) { return true; } JTextField passwordField = (JTextField) new JPasswordField(20); public String getPassphrase() { return null; } public boolean promptPassphrase(String message) { return true; } public boolean promptPassword(String message) { passwd = senha; return true; } public void showMessage(String message) { System.err.println("nao implementado! cod 5"); System.exit(1); } final GridBagConstraints gbc = new GridBagConstraints(0, 0, 1, 1, 1, 1, GridBagConstraints.NORTHWEST, GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0); private Container panel; public String[] promptKeyboardInteractive(String destination, String name, String instruction, String[] prompt, boolean[] echo) { return null; } } } 
@SuppressWarnings({"unchecked", "deprecation"})
class Ssh { public static void custom(String[] arg, String senha, int port) { Channel channel = null; try {     JSch jsch = new JSch(); if (arg.length != 1 || !arg[0].contains("@")) { System.err.println("usage: y ssh user,pass@remotehost"); System.exit(-1); } String user = arg[0].split("@")[0]; String host = arg[0].split("@")[1]; Session session = jsch.getSession(user, host, port); session.setPassword(senha); UserInfo ui = new MyUserInfo() { public void showMessage(String message) { JOptionPane.showMessageDialog(null, message); } public boolean promptYesNo(String message) { return true; } }; session.setUserInfo(ui); session.connect(30000); channel = session.openChannel("shell"); channel.setInputStream(System.in); channel.setOutputStream(System.out); channel.connect(3 * 1000); } catch (Exception e) { System.out.println(e); } while (channel != null && !channel.isEOF()) {} } 
@SuppressWarnings({"unchecked", "deprecation"})
public static abstract class MyUserInfo implements UserInfo, UIKeyboardInteractive { public String getPassword() { return null; } public boolean promptYesNo(String str) { return false; } public String getPassphrase() { return null; } public boolean promptPassphrase(String message) { return false; } 
/* class JSchCustom */ public boolean promptPassword(String message) { return false; } public void showMessage(String message) {} public String[] promptKeyboardInteractive(String destination, String name, String instruction, String[] prompt, boolean[] echo) { return null; } } } 
@SuppressWarnings({"unchecked", "deprecation"})
class Sftp { public static void custom(String[] arg, String senha, int port) { try { JSch jsch = new JSch(); if (arg.length != 1 || !arg[0].contains("@")) { System.err.println("usage: y sftp user,pass@remotehost"); System.err.println("usage: y sftp user,pass@remotehost 22"); System.exit(-1); } String user = arg[0].split("@")[0]; String host = arg[0].split("@")[1]; Session session = jsch.getSession(user, host, port); UserInfo ui = new MyUserInfo(senha); session.setUserInfo(ui); session.connect(); Channel channel = session.openChannel("sftp"); channel.connect(); ChannelSftp c = (ChannelSftp) channel; java.io.InputStream in = System.in; java.io.PrintStream out = System.out; java.util.Vector cmds = new java.util.Vector(); byte[] buf = new byte[1024]; int i; String str; int level = 0; while (true) { out.print("sftp> "); cmds.removeAllElements(); i = in .read(buf, 0, 1024); if (i <= 0) break; i--; if (i > 0 && buf[i - 1] == 0x0d) i--; int s = 0; for (int ii = 0; ii < i; ii++) { if (buf[ii] == ' ') { if (ii - s > 0) { cmds.addElement(new String(buf, s, ii - s)); } while (ii < i) { if (buf[ii] != ' ') break; ii++; } s = ii; } } if (s < i) { cmds.addElement(new String(buf, s, i - s)); } if (cmds.size() == 0) continue; String cmd = (String) cmds.elementAt(0); if (cmd.equals("quit")) { c.quit(); break; } if (cmd.equals("exit")) { c.exit(); break; } if (cmd.equals("rekey")) { session.rekey(); continue; } if (cmd.equals("compression")) { if (cmds.size() < 2) { out.println("compression level: " + level); continue; } try { level = Integer.parseInt((String) cmds.elementAt(1)); if (level == 0) { session.setConfig("compression.s2c", "none"); session.setConfig("compression.c2s", "none"); } else { session.setConfig("compression.s2c", "zlib@openssh.com,zlib,none"); session.setConfig("compression.c2s", "zlib@openssh.com,zlib,none"); } } catch (Exception e) {} session.rekey(); continue; } if (cmd.equals("cd") || cmd.equals("lcd")) { if (cmds.size() < 2) continue; String path = (String) cmds.elementAt(1); try { if (cmd.equals("cd")) c.cd(path); else c.lcd(path); } catch (SftpException e) { System.out.println(e.toString()); } continue; } if (cmd.equals("rm") || cmd.equals("rmdir") || cmd.equals("mkdir")) { if (cmds.size() < 2) continue; String path = (String) cmds.elementAt(1); try { if (cmd.equals("rm")) c.rm(path); else if (cmd.equals("rmdir")) c.rmdir(path); else c.mkdir(path); } catch (SftpException e) { System.out.println(e.toString()); } continue; } if (cmd.equals("chgrp") || cmd.equals("chown") || cmd.equals("chmod")) { if (cmds.size() != 3) continue; String path = (String) cmds.elementAt(2); int foo = 0; if (cmd.equals("chmod")) { byte[] bar = ((String) cmds.elementAt(1)).getBytes(); int k; for (int j = 0; j < bar.length; j++) { k = bar[j]; if (k < '0' || k > '7') { foo = -1; break; } foo <<= 3; foo |= (k - '0'); } if (foo == -1) continue; } else { try { foo = Integer.parseInt((String) cmds.elementAt(1)); } catch (Exception e) { continue; } } try { if (cmd.equals("chgrp")) { c.chgrp(foo, path); } else if (cmd.equals("chown")) { c.chown(foo, path); } else if (cmd.equals("chmod")) { c.chmod(foo, path); } } catch (SftpException e) { System.out.println(e.toString()); } continue; } 
/* class JSchCustom */ if (cmd.equals("pwd") || cmd.equals("lpwd")) { str = (cmd.equals("pwd") ? "Remote" : "Local"); str += " working directory: "; if (cmd.equals("pwd")) str += c.pwd(); else str += c.lpwd(); out.println(str); continue; } if (cmd.equals("ls") || cmd.equals("dir")) { String path = "."; if (cmds.size() == 2) path = (String) cmds.elementAt(1); try { java.util.Vector vv = c.ls(path); if (vv != null) { for (int ii = 0; ii < vv.size(); ii++) { Object obj = vv.elementAt(ii); if (obj instanceof com.jcraft.jsch.ChannelSftp.LsEntry) { out.println(((com.jcraft.jsch.ChannelSftp.LsEntry) obj).getLongname()); } } } } catch (SftpException e) { System.out.println(e.toString()); } continue; } if (cmd.equals("lls") || cmd.equals("ldir")) { String path = "."; if (cmds.size() == 2) path = (String) cmds.elementAt(1); try { java.io.File file = new java.io.File(path); if (!file.exists()) { out.println(path + ": No such file or directory"); continue; } if (file.isDirectory()) { String[] list = file.list(); for (int ii = 0; ii < list.length; ii++) { out.println(list[ii]); } continue; } out.println(path); } catch (Exception e) { System.out.println(e); } continue; } if (cmd.equals("get") || cmd.equals("get-resume") || cmd.equals("get-append") || cmd.equals("put") || cmd.equals("put-resume") || cmd.equals("put-append")) { if (cmds.size() != 2 && cmds.size() != 3) continue; String p1 = (String) cmds.elementAt(1); String p2 = "."; if (cmds.size() == 3) p2 = (String) cmds.elementAt(2); try { SftpProgressMonitor monitor = new MyProgressMonitor(); if (cmd.startsWith("get")) { int mode = ChannelSftp.OVERWRITE; if (cmd.equals("get-resume")) { mode = ChannelSftp.RESUME; } else if (cmd.equals("get-append")) { mode = ChannelSftp.APPEND; } c.get(p1, p2, monitor, mode); } else { int mode = ChannelSftp.OVERWRITE; if (cmd.equals("put-resume")) { mode = ChannelSftp.RESUME; } else if (cmd.equals("put-append")) { mode = ChannelSftp.APPEND; } c.put(p1, p2, monitor, mode); } } catch (SftpException e) { System.out.println(e.toString()); } continue; } if (cmd.equals("ln") || cmd.equals("symlink") || cmd.equals("rename") || cmd.equals("hardlink")) { if (cmds.size() != 3) continue; String p1 = (String) cmds.elementAt(1); String p2 = (String) cmds.elementAt(2); try { if (cmd.equals("hardlink")) { c.hardlink(p1, p2); } else if (cmd.equals("rename")) c.rename(p1, p2); else c.symlink(p1, p2); } catch (SftpException e) { System.out.println(e.toString()); } continue; } if (cmd.equals("df")) { if (cmds.size() > 2) continue; String p1 = cmds.size() == 1 ? "." : (String) cmds.elementAt(1); SftpStatVFS stat = c.statVFS(p1); long size = stat.getSize(); long used = stat.getUsed(); long avail = stat.getAvailForNonRoot(); long root_avail = stat.getAvail(); long capacity = stat.getCapacity(); System.out.println("Size: " + size); System.out.println("Used: " + used); System.out.println("Avail: " + avail); System.out.println("(root): " + root_avail); System.out.println("%Capacity: " + capacity); continue; } if (cmd.equals("stat") || cmd.equals("lstat")) { if (cmds.size() != 2) continue; String p1 = (String) cmds.elementAt(1); SftpATTRS attrs = null; try { if (cmd.equals("stat")) attrs = c.stat(p1); else attrs = c.lstat(p1); } catch (SftpException e) { System.out.println(e.toString()); } if (attrs != null) { out.println(attrs); } else {} continue; } if (cmd.equals("readlink")) { if (cmds.size() != 2) continue; String p1 = (String) cmds.elementAt(1); String filename = null; 
/* class JSchCustom */ try { filename = c.readlink(p1); out.println(filename); } catch (SftpException e) { System.out.println(e.toString()); } continue; } if (cmd.equals("realpath")) { if (cmds.size() != 2) continue; String p1 = (String) cmds.elementAt(1); String filename = null; try { filename = c.realpath(p1); out.println(filename); } catch (SftpException e) { System.out.println(e.toString()); } continue; } if (cmd.equals("version")) { out.println("SFTP protocol version " + c.version()); continue; } if (cmd.equals("help") || cmd.equals("?")) { out.println(help); continue; } out.println("unimplemented command: " + cmd); } session.disconnect(); } catch (Exception e) { System.out.println(e); } System.exit(0); } private static String help = "      Available commands:\n" + "      * means unimplemented command.\n" + "cd path                       Change remote directory to 'path'\n" + "lcd path                      Change local directory to 'path'\n" + "chgrp grp path                Change group of file 'path' to 'grp'\n" + "chmod mode path               Change permissions of file 'path' to 'mode'\n" + "chown own path                Change owner of file 'path' to 'own'\n" + "df [path]                     Display statistics for current directory or\n" + "                              filesystem containing 'path'\n" + "help                          Display this help text\n" + "get remote-path [local-path]  Download file\n" + "get-resume remote-path [local-path]  Resume to download file.\n" + "get-append remote-path [local-path]  Append remote file to local file\n" + "hardlink oldpath newpath      Hardlink remote file\n" + "*lls [ls-options [path]]      Display local directory listing\n" + "ln oldpath newpath            Symlink remote file\n" + "*lmkdir path                  Create local directory\n" + "lpwd                          Print local working directory\n" + "ls [path]                     Display remote directory listing\n" + "*lumask umask                 Set local umask to 'umask'\n" + "mkdir path                    Create remote directory\n" + "put local-path [remote-path]  Upload file\n" + "put-resume local-path [remote-path]  Resume to upload file\n" + "put-append local-path [remote-path]  Append local file to remote file.\n" + "pwd                           Display remote working directory\n" + "stat path                     Display info about path\n" + "exit                          Quit sftp\n" + "quit                          Quit sftp\n" + "rename oldpath newpath        Rename remote file\n" + "rmdir path                    Remove remote directory\n" + "rm path                       Delete remote file\n" + "symlink oldpath newpath       Symlink remote file\n" + "readlink path                 Check the target of a symbolic link\n" + "realpath path                 Canonicalize the path\n" + "rekey                         Key re-exchanging\n" + "compression level             Packet compression will be enabled\n" + "version                       Show SFTP version\n" + "?                             Synonym for help"; 
@SuppressWarnings({"unchecked", "deprecation"})
public static class MyProgressMonitor implements SftpProgressMonitor { ProgressMonitor monitor; long count = 0; long max = 0; public void init(int op, String src, String dest, long max) { this.max = max; monitor = new ProgressMonitor(null, ((op == SftpProgressMonitor.PUT) ? "put" : "get") + ": " + src, "", 0, (int) max); count = 0; percent = -1; monitor.setProgress((int) this.count); 
/* class JSchCustom */ monitor.setMillisToDecideToPopup(1000); } private long percent = -1; public boolean count(long count) { this.count += count; if (percent >= this.count * 100 / max) { return true; } percent = this.count * 100 / max; monitor.setNote("Completed " + this.count + "(" + percent + "%) out of " + max + "."); monitor.setProgress((int) this.count); return !(monitor.isCanceled()); } public void end() { monitor.close(); } } 
@SuppressWarnings({"unchecked", "deprecation"})
public static class MyUserInfo implements UserInfo, UIKeyboardInteractive { String passwd; String senha; private MyUserInfo(String senha) { this.senha = senha; } public String getPassword() { return passwd; } public boolean promptYesNo(String str) { return true; } JTextField passwordField = (JTextField) new JPasswordField(20); public String getPassphrase() { return null; } public boolean promptPassphrase(String message) { return true; } public boolean promptPassword(String message) { passwd = senha; return true; } public void showMessage(String message) { System.err.println("nao implementado! cod 7"); System.exit(1); } final GridBagConstraints gbc = new GridBagConstraints(0, 0, 1, 1, 1, 1, GridBagConstraints.NORTHWEST, GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0); private Container panel; public String[] promptKeyboardInteractive(String destination, String name, String instruction, String[] prompt, boolean[] echo) { return null; } } } 
//REMOVED_GRAAL_END

/* class WebSocket */
/* class WebSocket */
/* class WebSocket 
                        class WebSocketModelo {
                            public static void main(String[] args) {
                                WebSocketServer wss=new WebSocketServer(new InetSocketAddress("localhost", 7777), null) {
                                    public void onOpen(WebSocket conn, ClientHandshake handshake) {
                                        //System.out.println("onOpen");
                                    }
                                    public void onClose(WebSocket conn, int code, String reason, boolean remote) {
                                        //System.out.println("onClose");
                                    }
                                    public void onMessage(WebSocket conn, String message) {
                                        //System.out.println("message: " + message);
                                        if ( message.equals("1") )
                                            conn.send("2");
                                        try{
                                            if ( message.equals("3") )
                                                conn.send(getImg(-1));
                                        }catch(Exception e){
                                            System.err.println("Error " + e.toString());
                                        }
                                    }
                                    public void onError(WebSocket conn, Exception ex) {
                                        System.out.println("error: " + ex.toString());
                                    }
                                    public void onStart() {
                                    }
                                };
                                wss.start();        
                            }
                        }
                        // browser - http://localhost:7777/
                        document.children[0].innerHTML='<html><img id="imgId"></img></html>';
                        const socket = new WebSocket("ws://localhost:7777");
                        socket.binaryType = "blob";
                        socket.addEventListener("open", (event) => {
                          socket.send("1");
                        });
                        socket.addEventListener("message", (event) => {
                          //console.log("message " + event.data);
                          // recebendo pequeno bmp
                          if ( event.data instanceof Blob ){
                                  var s = event.data;
                                  s = s.slice(0, s.size, "image/bmp");
                                  var link = window.URL.createObjectURL(s);
                                  document.getElementById("imgId").src = link;    
                                  socket.send('3');
                          }
                          if ( event.data == '2' )
                            socket.send('3');
                        });
                        // socket.readyState == WebSocket.CLOSED
                        // socket.readyState == WebSocket.OPEN
*/
/* class WebSocket */ // // creditos: https://github.com/TooTallNate/Java-WebSocket/tree/master
/* class WebSocket */ 
@SuppressWarnings({"unchecked", "deprecation"})
abstract class AbstractWebSocket extends WebSocketAdapter { private boolean tcpNoDelay; private boolean reuseAddr; private ScheduledExecutorService connectionLostCheckerService; private ScheduledFuture<?> connectionLostCheckerFuture; private long connectionLostTimeout = TimeUnit.SECONDS.toNanos(60); private boolean websocketRunning = false; private boolean daemon = false; private final Object syncConnectionLost = new Object(); public int getConnectionLostTimeout() { synchronized (syncConnectionLost) { return (int) TimeUnit.NANOSECONDS.toSeconds(connectionLostTimeout); } } public void setConnectionLostTimeout(int connectionLostTimeout) { synchronized (syncConnectionLost) { this.connectionLostTimeout = TimeUnit.SECONDS.toNanos(connectionLostTimeout); if (this.connectionLostTimeout <= 0) { cancelConnectionLostTimer(); return; } if (this.websocketRunning) { try { ArrayList<WebSocket> connections = new ArrayList<>(getConnections()); WebSocketImpl webSocketImpl; for (WebSocket conn : connections) { if (conn instanceof WebSocketImpl) { webSocketImpl = (WebSocketImpl) conn; webSocketImpl.updateLastPong(); } } } catch (Exception e) { } restartConnectionLostTimer(); } } } protected void stopConnectionLostTimer() { synchronized (syncConnectionLost) { if (connectionLostCheckerService != null || connectionLostCheckerFuture != null) { this.websocketRunning = false; cancelConnectionLostTimer(); } } } protected void startConnectionLostTimer() { synchronized (syncConnectionLost) { if (this.connectionLostTimeout <= 0) { return; } this.websocketRunning = true; restartConnectionLostTimer(); } } private void restartConnectionLostTimer() { cancelConnectionLostTimer(); connectionLostCheckerService = Executors .newSingleThreadScheduledExecutor(new NamedThreadFactory("connectionLostChecker", daemon)); Runnable connectionLostChecker = new Runnable() { private ArrayList<WebSocket> connections = new ArrayList<>(); public void run() { connections.clear(); try { connections.addAll(getConnections()); long minimumPongTime; synchronized (syncConnectionLost) { minimumPongTime = (long) (System.nanoTime() - (connectionLostTimeout * 1.5)); } for (WebSocket conn : connections) { executeConnectionLostDetection(conn, minimumPongTime); } } catch (Exception e) { } connections.clear(); } }; connectionLostCheckerFuture = connectionLostCheckerService .scheduleAtFixedRate(connectionLostChecker, connectionLostTimeout, connectionLostTimeout, TimeUnit.NANOSECONDS); } private void executeConnectionLostDetection(WebSocket webSocket, long minimumPongTime) { if (!(webSocket instanceof WebSocketImpl)) { return; } WebSocketImpl webSocketImpl = (WebSocketImpl) webSocket; if (webSocketImpl.getLastPong() < minimumPongTime) { webSocketImpl.closeConnection(CloseFrame.ABNORMAL_CLOSE, "The connection was closed because the other endpoint did not respond with a pong in time. For more information check: https://github.com/TooTallNate/Java-WebSocket/wiki/Lost-connection-detection"); } else { if (webSocketImpl.isOpen()) { webSocketImpl.sendPing(); } else { } } } protected abstract Collection<WebSocket> getConnections(); private void cancelConnectionLostTimer() { if (connectionLostCheckerService != null) { connectionLostCheckerService.shutdownNow(); connectionLostCheckerService = null; } if (connectionLostCheckerFuture != null) { connectionLostCheckerFuture.cancel(false); connectionLostCheckerFuture = null; } } public boolean isTcpNoDelay() { return tcpNoDelay; } public void setTcpNoDelay(boolean tcpNoDelay) { 
/* class WebSocket */ this.tcpNoDelay = tcpNoDelay; } public boolean isReuseAddr() { return reuseAddr; } public void setReuseAddr(boolean reuseAddr) { this.reuseAddr = reuseAddr; } public boolean isDaemon() { return daemon; } public void setDaemon(boolean daemon) { this.daemon = daemon; } } 
@SuppressWarnings({"unchecked", "deprecation"})
class AbstractWrappedByteChannel implements WrappedByteChannel { private final ByteChannel channel;  @Deprecated  public AbstractWrappedByteChannel(ByteChannel towrap) { this.channel = towrap; } @Deprecated public AbstractWrappedByteChannel(WrappedByteChannel towrap) { this.channel = towrap; } public int read(ByteBuffer dst) throws IOException { return channel.read(dst); } public boolean isOpen() { return channel.isOpen(); } public void close() throws IOException { channel.close(); } public int write(ByteBuffer src) throws IOException { return channel.write(src); } public boolean isNeedWrite() { return channel instanceof WrappedByteChannel && ((WrappedByteChannel) channel).isNeedWrite(); } public void writeMore() throws IOException { if (channel instanceof WrappedByteChannel) { ((WrappedByteChannel) channel).writeMore(); } } public boolean isNeedRead() { return channel instanceof WrappedByteChannel && ((WrappedByteChannel) channel).isNeedRead(); } public int readMore(ByteBuffer dst) throws IOException { return channel instanceof WrappedByteChannel ? ((WrappedByteChannel) channel).readMore(dst) : 0; } public boolean isBlocking() { if (channel instanceof SocketChannel) { return ((SocketChannel) channel).isBlocking(); } else if (channel instanceof WrappedByteChannel) { return ((WrappedByteChannel) channel).isBlocking(); } return false; } } 
@SuppressWarnings({"unchecked", "deprecation"})
class WS_Base64 { public static final int NO_OPTIONS = 0; public static final int ENCODE = 1; public static final int GZIP = 2; public static final int DO_BREAK_LINES = 8; public static final int URL_SAFE = 16; public static final int ORDERED = 32; private static final int MAX_LINE_LENGTH = 76; private static final byte EQUALS_SIGN = (byte) '='; private static final byte NEW_LINE = (byte) '\n'; private static final String PREFERRED_ENCODING = "US-ASCII"; private static final byte WHITE_SPACE_ENC = -5; private static final byte[] _STANDARD_ALPHABET = { (byte) 'A', (byte) 'B', (byte) 'C', (byte) 'D', (byte) 'E', (byte) 'F', (byte) 'G', (byte) 'H', (byte) 'I', (byte) 'J', (byte) 'K', (byte) 'L', (byte) 'M', (byte) 'N', (byte) 'O', (byte) 'P', (byte) 'Q', (byte) 'R', (byte) 'S', (byte) 'T', (byte) 'U', (byte) 'V', (byte) 'W', (byte) 'X', (byte) 'Y', (byte) 'Z', (byte) 'a', (byte) 'b', (byte) 'c', (byte) 'd', (byte) 'e', (byte) 'f', (byte) 'g', (byte) 'h', (byte) 'i', (byte) 'j', (byte) 'k', (byte) 'l', (byte) 'm', (byte) 'n', (byte) 'o', (byte) 'p', (byte) 'q', (byte) 'r', (byte) 's', (byte) 't', (byte) 'u', (byte) 'v', (byte) 'w', (byte) 'x', (byte) 'y', (byte) 'z', (byte) '0', (byte) '1', (byte) '2', (byte) '3', (byte) '4', (byte) '5', (byte) '6', (byte) '7', (byte) '8', (byte) '9', (byte) '+', (byte) '/' }; private static final byte[] _STANDARD_DECODABET = {-9,-9,-9,-9,-9,-9,-9,-9,-9,-5,-5,-9,-9,-5,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-5,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,62,-9,-9,-9,63,52,53,54,55,56,57,58,59,60,61,-9,-9,-9,-1,-9,-9,-9,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,-9,-9,-9,-9,-9,-9,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,
/* class WebSocket */ -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9}; private static final byte[] _URL_SAFE_ALPHABET = { (byte) 'A', (byte) 'B', (byte) 'C', (byte) 'D', (byte) 'E', (byte) 'F', (byte) 'G', (byte) 'H', (byte) 'I', (byte) 'J', (byte) 'K', (byte) 'L', (byte) 'M', (byte) 'N', (byte) 'O', (byte) 'P', (byte) 'Q', (byte) 'R', (byte) 'S', (byte) 'T', (byte) 'U', (byte) 'V', (byte) 'W', (byte) 'X', (byte) 'Y', (byte) 'Z', (byte) 'a', (byte) 'b', (byte) 'c', (byte) 'd', (byte) 'e', (byte) 'f', (byte) 'g', (byte) 'h', (byte) 'i', (byte) 'j', (byte) 'k', (byte) 'l', (byte) 'm', (byte) 'n', (byte) 'o', (byte) 'p', (byte) 'q', (byte) 'r', (byte) 's', (byte) 't', (byte) 'u', (byte) 'v', (byte) 'w', (byte) 'x', (byte) 'y', (byte) 'z', (byte) '0', (byte) '1', (byte) '2', (byte) '3', (byte) '4', (byte) '5', (byte) '6', (byte) '7', (byte) '8', (byte) '9', (byte) '-', (byte) '_' }; private static final byte[] _URL_SAFE_DECODABET = {-9,-9,-9,-9,-9,-9,-9,-9,-9,-5,-5,-9,-9,-5,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-5,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,62,-9,-9,52,53,54,55,56,57,58,59,60,61,-9,-9,-9,-1,-9,-9,-9,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,-9,-9,-9,-9,63,-9,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9}; private static final byte[] _ORDERED_ALPHABET = { (byte) '-', (byte) '0', (byte) '1', (byte) '2', (byte) '3', (byte) '4', (byte) '5', (byte) '6', (byte) '7', (byte) '8', (byte) '9', (byte) 'A', (byte) 'B', (byte) 'C', (byte) 'D', (byte) 'E', (byte) 'F', (byte) 'G', (byte) 'H', (byte) 'I', (byte) 'J', (byte) 'K', (byte) 'L', (byte) 'M', (byte) 'N', (byte) 'O', (byte) 'P', (byte) 'Q', (byte) 'R', (byte) 'S', (byte) 'T', (byte) 'U', (byte) 'V', (byte) 'W', (byte) 'X', (byte) 'Y', (byte) 'Z', (byte) '_', (byte) 'a', (byte) 'b', (byte) 'c', (byte) 'd', (byte) 'e', (byte) 'f', (byte) 'g', (byte) 'h', (byte) 'i', (byte) 'j', (byte) 'k', (byte) 'l', (byte) 'm', (byte) 'n', (byte) 'o', (byte) 'p', (byte) 'q', (byte) 'r', (byte) 's', (byte) 't', (byte) 'u', (byte) 'v', (byte) 'w', (byte) 'x', (byte) 'y', (byte) 'z' }; private static final byte[] _ORDERED_DECODABET = {-9,-9,-9,-9,-9,-9,-9,-9,-9,-5,-5,-9,-9,-5,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-5,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,0,-9,-9,1,2,3,4,5,6,7,8,9,10,-9,-9,-9,-1,-9,-9,-9,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,-9,-9,-9,-9,37,-9,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,
/* class WebSocket */ -9,-9,-9,-9,-9}; private static final byte[] getAlphabet(int options) { if ((options & URL_SAFE) == URL_SAFE) { return _URL_SAFE_ALPHABET; } else if ((options & ORDERED) == ORDERED) { return _ORDERED_ALPHABET; } else { return _STANDARD_ALPHABET; } } private static final byte[] getDecodabet(int options) { if ((options & URL_SAFE) == URL_SAFE) { return _URL_SAFE_DECODABET; } else if ((options & ORDERED) == ORDERED) { return _ORDERED_DECODABET; } else { return _STANDARD_DECODABET; } } private WS_Base64() { } private static byte[] encode3to4(byte[] b4, byte[] threeBytes, int numSigBytes, int options) { encode3to4(threeBytes, 0, numSigBytes, b4, 0, options); return b4; } private static byte[] encode3to4( byte[] source, int srcOffset, int numSigBytes, byte[] destination, int destOffset, int options) { final byte[] ALPHABET = getAlphabet(options); int inBuff = (numSigBytes > 0 ? ((source[srcOffset] << 24) >>> 8) : 0) | (numSigBytes > 1 ? ((source[srcOffset + 1] << 24) >>> 16) : 0) | (numSigBytes > 2 ? ((source[srcOffset + 2] << 24) >>> 24) : 0); switch (numSigBytes) { case 3: destination[destOffset] = ALPHABET[(inBuff >>> 18)]; destination[destOffset + 1] = ALPHABET[(inBuff >>> 12) & 0x3f]; destination[destOffset + 2] = ALPHABET[(inBuff >>> 6) & 0x3f]; destination[destOffset + 3] = ALPHABET[(inBuff) & 0x3f]; return destination; case 2: destination[destOffset] = ALPHABET[(inBuff >>> 18)]; destination[destOffset + 1] = ALPHABET[(inBuff >>> 12) & 0x3f]; destination[destOffset + 2] = ALPHABET[(inBuff >>> 6) & 0x3f]; destination[destOffset + 3] = EQUALS_SIGN; return destination; case 1: destination[destOffset] = ALPHABET[(inBuff >>> 18)]; destination[destOffset + 1] = ALPHABET[(inBuff >>> 12) & 0x3f]; destination[destOffset + 2] = EQUALS_SIGN; destination[destOffset + 3] = EQUALS_SIGN; return destination; default: return destination; } } public static String encodeBytes(byte[] source) { String encoded = null;try { encoded = encodeBytes(source, 0, source.length, NO_OPTIONS); } catch (java.io.IOException ex) { assert false : ex.getMessage(); } assert encoded != null; return encoded; } public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException { byte[] encoded = encodeBytesToBytes(source, off, len, options); try { return new String(encoded, PREFERRED_ENCODING); } catch (java.io.UnsupportedEncodingException uue) { return new String(encoded); } } public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException { if (source == null) { throw new IllegalArgumentException("Cannot serialize a null array."); } if (off < 0) { throw new IllegalArgumentException("Cannot have negative offset: " + off); } if (len < 0) { throw new IllegalArgumentException("Cannot have length offset: " + len); } if (off + len > source.length) { throw new IllegalArgumentException( String .format("Cannot have offset of %d and length of %d with array of length %d", off, len, source.length)); } if ((options & GZIP) != 0) { java.io.ByteArrayOutputStream baos = null; java.util.zip.GZIPOutputStream gzos = null; WS_Base64.OutputStream b64os = null; try { baos = new java.io.ByteArrayOutputStream(); b64os = new WS_Base64.OutputStream(baos, ENCODE | options); gzos = new java.util.zip.GZIPOutputStream(b64os); gzos.write(source, off, len); gzos.close(); } catch (java.io.IOException e) { throw e; } finally { try { if (gzos != null) { gzos.close(); } } catch (Exception e) { } try { if (b64os != null) { 
/* class WebSocket */ b64os.close(); } } catch (Exception e) { } try { if (baos != null) { baos.close(); } } catch (Exception e) { } } return baos.toByteArray(); } else { boolean breakLines = (options & DO_BREAK_LINES) != 0; int encLen = (len / 3) * 4 + (len % 3 > 0 ? 4 : 0);  if (breakLines) { encLen += encLen / MAX_LINE_LENGTH;  } byte[] outBuff = new byte[encLen]; int d = 0; int e = 0; int len2 = len - 2; int lineLength = 0; for (; d < len2; d += 3, e += 4) { encode3to4(source, d + off, 3, outBuff, e, options); lineLength += 4; if (breakLines && lineLength >= MAX_LINE_LENGTH) { outBuff[e + 4] = NEW_LINE; e++; lineLength = 0; } } if (d < len) { encode3to4(source, d + off, len - d, outBuff, e, options); e += 4; } if (e <= outBuff.length - 1) { byte[] finalOut = new byte[e]; System.arraycopy(outBuff, 0, finalOut, 0, e); return finalOut; } else { return outBuff; } } } private static int decode4to3( byte[] source, int srcOffset, byte[] destination, int destOffset, int options) { if (source == null) { throw new IllegalArgumentException("Source array was null."); } if (destination == null) { throw new IllegalArgumentException("Destination array was null."); } if (srcOffset < 0 || srcOffset + 3 >= source.length) { throw new IllegalArgumentException(String.format( "Source array with length %d cannot have offset of %d and still process four bytes.", source.length, srcOffset)); } if (destOffset < 0 || destOffset + 2 >= destination.length) { throw new IllegalArgumentException(String.format( "Destination array with length %d cannot have offset of %d and still store three bytes.", destination.length, destOffset)); } final byte[] DECODABET = getDecodabet(options); if (source[srcOffset + 2] == EQUALS_SIGN) { int outBuff = ((DECODABET[source[srcOffset]] & 0xFF) << 18) | ((DECODABET[source[srcOffset + 1]] & 0xFF) << 12); destination[destOffset] = (byte) (outBuff >>> 16); return 1; } else if (source[srcOffset + 3] == EQUALS_SIGN) { int outBuff = ((DECODABET[source[srcOffset]] & 0xFF) << 18) | ((DECODABET[source[srcOffset + 1]] & 0xFF) << 12) | ((DECODABET[source[srcOffset + 2]] & 0xFF) << 6); destination[destOffset] = (byte) (outBuff >>> 16); destination[destOffset + 1] = (byte) (outBuff >>> 8); return 2; } else { int outBuff = ((DECODABET[source[srcOffset]] & 0xFF) << 18) | ((DECODABET[source[srcOffset + 1]] & 0xFF) << 12) | ((DECODABET[source[srcOffset + 2]] & 0xFF) << 6) | ((DECODABET[source[srcOffset + 3]] & 0xFF)); destination[destOffset] = (byte) (outBuff >> 16); destination[destOffset + 1] = (byte) (outBuff >> 8); destination[destOffset + 2] = (byte) (outBuff); return 3; } } 
@SuppressWarnings({"unchecked", "deprecation"})
public static class OutputStream extends java.io.FilterOutputStream { private boolean encode; private int position; private byte[] buffer; private int bufferLength; private int lineLength; private boolean breakLines; private byte[] b4; private boolean suspendEncoding; private int options; private byte[] decodabet; public OutputStream(java.io.OutputStream out) { this(out, ENCODE); } public OutputStream(java.io.OutputStream out, int options) { super(out); this.breakLines = (options & DO_BREAK_LINES) != 0; this.encode = (options & ENCODE) != 0; this.bufferLength = encode ? 3 : 4; this.buffer = new byte[bufferLength]; this.position = 0; this.lineLength = 0; this.suspendEncoding = false; this.b4 = new byte[4]; this.options = options; this.decodabet = getDecodabet(options); } public void write(int theByte) throws java.io.IOException { if (suspendEncoding) { this.out.write(theByte); return; } 
/* class WebSocket */ if (encode) { buffer[position++] = (byte) theByte; if (position >= bufferLength) {  this.out.write(encode3to4(b4, buffer, bufferLength, options)); lineLength += 4; if (breakLines && lineLength >= MAX_LINE_LENGTH) { this.out.write(NEW_LINE); lineLength = 0; } position = 0; } } else { if (decodabet[theByte & 0x7f] > WHITE_SPACE_ENC) { buffer[position++] = (byte) theByte; if (position >= bufferLength){ int len = WS_Base64.decode4to3(buffer, 0, b4, 0, options); out.write(b4, 0, len); position = 0; } } else if (decodabet[theByte & 0x7f] != WHITE_SPACE_ENC) { throw new java.io.IOException("Invalid character in Base64 data."); } } } public void write(byte[] theBytes, int off, int len) throws java.io.IOException { if (suspendEncoding) { this.out.write(theBytes, off, len); return; } for (int i = 0; i < len; i++) { write(theBytes[off + i]); } } public void flushBase64() throws java.io.IOException { if (position > 0) { if (encode) { out.write(encode3to4(b4, buffer, position, options)); position = 0; } else { throw new java.io.IOException("Base64 input not properly padded."); } } } public void close() throws java.io.IOException { flushBase64(); super.close(); buffer = null; out = null; } } } 
@SuppressWarnings({"unchecked", "deprecation"})
class BinaryFrame extends DataFrame { public BinaryFrame() { super(Opcode.BINARY); } } 
@SuppressWarnings({"unchecked", "deprecation"})
class ByteBufferUtils { private ByteBufferUtils() { } public static int transferByteBuffer(ByteBuffer source, ByteBuffer dest) { if (source == null || dest == null) { throw new IllegalArgumentException(); } int fremain = source.remaining(); int toremain = dest.remaining(); if (fremain > toremain) { int limit = Math.min(fremain, toremain); source.limit(limit); dest.put(source); return limit; } else { dest.put(source); return fremain; } } public static ByteBuffer getEmptyByteBuffer() { return ByteBuffer.allocate(0); } } 
@SuppressWarnings({"unchecked", "deprecation"})
class Charsetfunctions { private Charsetfunctions() { } private static final CodingErrorAction codingErrorAction = CodingErrorAction.REPORT; public static byte[] utf8Bytes(String s) { return s.getBytes(StandardCharsets.UTF_8); } public static byte[] asciiBytes(String s) { return s.getBytes(StandardCharsets.US_ASCII); } public static String stringAscii(byte[] bytes) { return stringAscii(bytes, 0, bytes.length); } public static String stringAscii(byte[] bytes, int offset, int length) { return new String(bytes, offset, length, StandardCharsets.US_ASCII); } public static String stringUtf8(byte[] bytes) throws InvalidDataException { return stringUtf8(ByteBuffer.wrap(bytes)); } public static String stringUtf8(ByteBuffer bytes) throws InvalidDataException { CharsetDecoder decode = StandardCharsets.UTF_8.newDecoder(); decode.onMalformedInput(codingErrorAction); decode.onUnmappableCharacter(codingErrorAction); String s; try { bytes.mark(); s = decode.decode(bytes).toString(); bytes.reset(); } catch (CharacterCodingException e) { throw new InvalidDataException(CloseFrame.NO_UTF8, e); } return s; } private static final int[] utf8d = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
/* class WebSocket */ 7, 7, 7, 7, 7, 7, 7, 7,  8, 8, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,  0xa, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x4, 0x3, 0x3,  0xb, 0x6, 0x6, 0x6, 0x5, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8,  0x0, 0x1, 0x2, 0x3, 0x5, 0x8, 0x7, 0x1, 0x1, 0x1, 0x4, 0x6, 0x1, 0x1, 0x1, 0x1,  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1,  1, 2, 1, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1,  1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 3, 1, 1, 1, 1, 1, 1,  1, 3, 1, 1, 1, 1, 1, 3, 1, 3, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 }; public static boolean isValidUTF8(ByteBuffer data, int off) { int len = data.remaining(); if (len < off) { return false; } int state = 0; for (int i = off; i < len; ++i) { state = utf8d[256 + (state << 4) + utf8d[(0xff & data.get(i))]]; if (state == 1) { return false; } } return true; } public static boolean isValidUTF8(ByteBuffer data) { return isValidUTF8(data, 0); } } interface ClientHandshake extends Handshakedata { String getResourceDescriptor(); } interface ClientHandshakeBuilder extends HandshakeBuilder, ClientHandshake { void setResourceDescriptor(String resourceDescriptor); } 
@SuppressWarnings({"unchecked", "deprecation"})
class CloseFrame extends ControlFrame { public static final int NORMAL = 1000; public static final int GOING_AWAY = 1001; public static final int PROTOCOL_ERROR = 1002; public static final int REFUSE = 1003; public static final int NOCODE = 1005; public static final int ABNORMAL_CLOSE = 1006; public static final int NO_UTF8 = 1007; public static final int POLICY_VALIDATION = 1008; public static final int TOOBIG = 1009; public static final int EXTENSION = 1010; public static final int UNEXPECTED_CONDITION = 1011; public static final int SERVICE_RESTART = 1012; public static final int TRY_AGAIN_LATER = 1013; public static final int BAD_GATEWAY = 1014; public static final int TLS_ERROR = 1015; public static final int NEVER_CONNECTED = -1; public static final int BUGGYCLOSE = -2; public static final int FLASHPOLICY = -3; private int code; private String reason; public CloseFrame() { super(Opcode.CLOSING); setReason(""); setCode(CloseFrame.NORMAL); } public void setCode(int code) { this.code = code; if (code == CloseFrame.TLS_ERROR) { this.code = CloseFrame.NOCODE; this.reason = ""; } updatePayload(); } public void setReason(String reason) { if (reason == null) { reason = ""; } this.reason = reason; updatePayload(); } public int getCloseCode() { return code; } public String getMessage() { return reason; } public String toString() { return super.toString() + "code: " + code; } public void isValid() throws InvalidDataException { super.isValid(); if (code == CloseFrame.NO_UTF8 && reason.isEmpty()) { throw new InvalidDataException(CloseFrame.NO_UTF8, "Received text is no valid utf8 string!"); } if (code == CloseFrame.NOCODE && 0 < reason.length()) { throw new InvalidDataException(PROTOCOL_ERROR, "A close frame must have a closecode if it has a reason"); } if ((code > CloseFrame.TLS_ERROR && code < 3000)) { throw new InvalidDataException(PROTOCOL_ERROR, "Trying to send an illegal close code!"); } if (code == CloseFrame.ABNORMAL_CLOSE || code == CloseFrame.TLS_ERROR || code == CloseFrame.NOCODE || code > 4999 || code < 1000 || code == 1004) { throw new InvalidFrameException("closecode must not be sent over the wire: " + code); } } 
/* class WebSocket */ public void setPayload(ByteBuffer payload) { code = CloseFrame.NOCODE; reason = ""; payload.mark(); if (payload.remaining() == 0) { code = CloseFrame.NORMAL; } else if (payload.remaining() == 1) { code = CloseFrame.PROTOCOL_ERROR; } else { if (payload.remaining() >= 2) { ByteBuffer bb = ByteBuffer.allocate(4); bb.position(2); bb.putShort(payload.getShort()); bb.position(0); code = bb.getInt(); } payload.reset(); try { int mark = payload.position(); validateUtf8(payload, mark); } catch (InvalidDataException e) { code = CloseFrame.NO_UTF8; reason = null; } } } private void validateUtf8(ByteBuffer payload, int mark) throws InvalidDataException { try { payload.position(payload.position() + 2); reason = Charsetfunctions.stringUtf8(payload); } catch (IllegalArgumentException e) { throw new InvalidDataException(CloseFrame.NO_UTF8); } finally { payload.position(mark); } } private void updatePayload() { byte[] by = Charsetfunctions.utf8Bytes(reason); ByteBuffer buf = ByteBuffer.allocate(4); buf.putInt(code); buf.position(2); ByteBuffer pay = ByteBuffer.allocate(2 + by.length); pay.put(buf); pay.put(by); pay.rewind(); super.setPayload(pay); } public ByteBuffer getPayloadData() { if (code == NOCODE) { return ByteBufferUtils.getEmptyByteBuffer(); } return super.getPayloadData(); } public boolean equals(Object o) { if (this == o) { return true; } if (o == null || getClass() != o.getClass()) { return false; } if (!super.equals(o)) { return false; } CloseFrame that = (CloseFrame) o; if (code != that.code) { return false; } return reason != null ? reason.equals(that.reason) : that.reason == null; } public int hashCode() { int result = super.hashCode(); result = 31 * result + code; result = 31 * result + (reason != null ? reason.hashCode() : 0); return result; } } enum CloseHandshakeType { NONE, ONEWAY, TWOWAY } 
@SuppressWarnings({"unchecked", "deprecation"})
abstract class CompressionExtension extends DefaultExtension { public void isFrameValid(Framedata inputFrame) throws InvalidDataException { if ((inputFrame instanceof DataFrame) && (inputFrame.isRSV2() || inputFrame.isRSV3())) { throw new InvalidFrameException( "bad rsv RSV1: " + inputFrame.isRSV1() + " RSV2: " + inputFrame.isRSV2() + " RSV3: " + inputFrame.isRSV3()); } if ((inputFrame instanceof ControlFrame) && (inputFrame.isRSV1() || inputFrame.isRSV2() || inputFrame.isRSV3())) { throw new InvalidFrameException( "bad rsv RSV1: " + inputFrame.isRSV1() + " RSV2: " + inputFrame.isRSV2() + " RSV3: " + inputFrame.isRSV3()); } } } 
@SuppressWarnings({"unchecked", "deprecation"})
class ContinuousFrame extends DataFrame { public ContinuousFrame() { super(Opcode.CONTINUOUS); } } 
@SuppressWarnings({"unchecked", "deprecation"})
abstract class ControlFrame extends FramedataImpl1 { public ControlFrame(Opcode opcode) { super(opcode); } public void isValid() throws InvalidDataException { if (!isFin()) { throw new InvalidFrameException("Control frame can't have fin==false set"); } if (isRSV1()) { throw new InvalidFrameException("Control frame can't have rsv1==true set"); } if (isRSV2()) { throw new InvalidFrameException("Control frame can't have rsv2==true set"); } if (isRSV3()) { throw new InvalidFrameException("Control frame can't have rsv3==true set"); } } } 
@SuppressWarnings({"unchecked", "deprecation"})
class CustomSSLWebSocketServerFactory extends DefaultSSLWebSocketServerFactory { private final String[] enabledProtocols; private final String[] enabledCiphersuites; public CustomSSLWebSocketServerFactory(SSLContext sslContext, String[] enabledProtocols, String[] enabledCiphersuites) { this(sslContext, Executors.newSingleThreadScheduledExecutor(), enabledProtocols, enabledCiphersuites); } 
/* class WebSocket */ public CustomSSLWebSocketServerFactory(SSLContext sslContext, ExecutorService executerService, String[] enabledProtocols, String[] enabledCiphersuites) { super(sslContext, executerService); this.enabledProtocols = enabledProtocols; this.enabledCiphersuites = enabledCiphersuites; } public ByteChannel wrapChannel(SocketChannel channel, SelectionKey key) throws IOException { SSLEngine e = sslcontext.createSSLEngine(); if (enabledProtocols != null) { e.setEnabledProtocols(enabledProtocols); } if (enabledCiphersuites != null) { e.setEnabledCipherSuites(enabledCiphersuites); } e.setUseClientMode(false); return new SSLSocketChannel2(channel, e, exec, key); } } 
@SuppressWarnings({"unchecked", "deprecation"})
abstract class DataFrame extends FramedataImpl1 { public DataFrame(Opcode opcode) { super(opcode); } public void isValid() throws InvalidDataException { } } 
@SuppressWarnings({"unchecked", "deprecation"})
class DefaultExtension implements IExtension { public void decodeFrame(Framedata inputFrame) throws InvalidDataException { } public void encodeFrame(Framedata inputFrame) { } public boolean acceptProvidedExtensionAsServer(String inputExtension) { return true; } public boolean acceptProvidedExtensionAsClient(String inputExtension) { return true; } public void isFrameValid(Framedata inputFrame) throws InvalidDataException { if (inputFrame.isRSV1() || inputFrame.isRSV2() || inputFrame.isRSV3()) { throw new InvalidFrameException( "bad rsv RSV1: " + inputFrame.isRSV1() + " RSV2: " + inputFrame.isRSV2() + " RSV3: " + inputFrame.isRSV3()); } } public String getProvidedExtensionAsClient() { return ""; } public String getProvidedExtensionAsServer() { return ""; } public IExtension copyInstance() { return new DefaultExtension(); } public void reset() { } public String toString() { return getClass().getSimpleName(); } public int hashCode() { return getClass().hashCode(); } public boolean equals(Object o) { return this == o || o != null && getClass() == o.getClass(); } } 
@SuppressWarnings({"unchecked", "deprecation"})
class DefaultSSLWebSocketServerFactory implements WebSocketServerFactory { protected SSLContext sslcontext; protected ExecutorService exec; public DefaultSSLWebSocketServerFactory(SSLContext sslContext) { this(sslContext, Executors.newSingleThreadScheduledExecutor()); } public DefaultSSLWebSocketServerFactory(SSLContext sslContext, ExecutorService exec) { if (sslContext == null || exec == null) { throw new IllegalArgumentException(); } this.sslcontext = sslContext; this.exec = exec; } public ByteChannel wrapChannel(SocketChannel channel, SelectionKey key) throws IOException { SSLEngine e = sslcontext.createSSLEngine(); List<String> ciphers = new ArrayList<>(Arrays.asList(e.getEnabledCipherSuites())); ciphers.remove("TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256"); e.setEnabledCipherSuites(ciphers.toArray(new String[ciphers.size()])); e.setUseClientMode(false); return new SSLSocketChannel2(channel, e, exec, key); } public WebSocketImpl createWebSocket(WebSocketAdapter a, Draft d) { return new WebSocketImpl(a, d); } public WebSocketImpl createWebSocket(WebSocketAdapter a, List<Draft> d) { return new WebSocketImpl(a, d); } public void close() { exec.shutdown(); } } 
@SuppressWarnings({"unchecked", "deprecation"})
class DefaultWebSocketServerFactory implements WebSocketServerFactory { public WebSocketImpl createWebSocket(WebSocketAdapter a, Draft d) { return new WebSocketImpl(a, d); } public WebSocketImpl createWebSocket(WebSocketAdapter a, List<Draft> d) { return new WebSocketImpl(a, d); } public SocketChannel wrapChannel(SocketChannel channel, SelectionKey key) { return channel; } public void close() { } } interface DnsResolver { InetAddress 
/* class WebSocket */ resolve(URI uri) throws UnknownHostException; } 
@SuppressWarnings({"unchecked", "deprecation"})
abstract class Draft { protected Role role = null; protected Opcode continuousFrameType = null; public static ByteBuffer readLine(ByteBuffer buf) { ByteBuffer sbuf = ByteBuffer.allocate(buf.remaining()); byte prev; byte cur = '0'; while (buf.hasRemaining()) { prev = cur; cur = buf.get(); sbuf.put(cur); if (prev == (byte) '\r' && cur == (byte) '\n') { sbuf.limit(sbuf.position() - 2); sbuf.position(0); return sbuf; } } buf.position(buf.position() - sbuf.position()); return null; } public static String readStringLine(ByteBuffer buf) { ByteBuffer b = readLine(buf); return b == null ? null : Charsetfunctions.stringAscii(b.array(), 0, b.limit()); } public static HandshakeBuilder translateHandshakeHttp(ByteBuffer buf, Role role) throws InvalidHandshakeException { HandshakeBuilder handshake; String line = readStringLine(buf); if (line == null) { throw new IncompleteHandshakeException(buf.capacity() + 128); } String[] firstLineTokens = line.split(" ", 3); if (firstLineTokens.length != 3) { throw new InvalidHandshakeException(); } if (role == Role.CLIENT) { handshake = translateHandshakeHttpClient(firstLineTokens, line); } else { handshake = translateHandshakeHttpServer(firstLineTokens, line); } line = readStringLine(buf); while (line != null && line.length() > 0) { String[] pair = line.split(":", 2); if (pair.length != 2) { throw new InvalidHandshakeException("not an http header"); } if (handshake.hasFieldValue(pair[0])) { handshake.put(pair[0], handshake.getFieldValue(pair[0]) + "; " + pair[1].replaceFirst("^ +", "")); } else { handshake.put(pair[0], pair[1].replaceFirst("^ +", "")); } line = readStringLine(buf); } if (line == null) { throw new IncompleteHandshakeException(); } return handshake; } private static HandshakeBuilder translateHandshakeHttpServer(String[] firstLineTokens, String line) throws InvalidHandshakeException { if (!"GET".equalsIgnoreCase(firstLineTokens[0])) { throw new InvalidHandshakeException(String .format("Invalid request method received: %s Status line: %s", firstLineTokens[0], line)); } if (!"HTTP/1.1".equalsIgnoreCase(firstLineTokens[2])) { throw new InvalidHandshakeException(String .format("Invalid status line received: %s Status line: %s", firstLineTokens[2], line)); } ClientHandshakeBuilder clienthandshake = new HandshakeImpl1Client(); clienthandshake.setResourceDescriptor(firstLineTokens[1]); return clienthandshake; } private static HandshakeBuilder translateHandshakeHttpClient(String[] firstLineTokens, String line) throws InvalidHandshakeException { if (!"101".equals(firstLineTokens[1])) { throw new InvalidHandshakeException(String .format("Invalid status code received: %s Status line: %s", firstLineTokens[1], line)); } if (!"HTTP/1.1".equalsIgnoreCase(firstLineTokens[0])) { throw new InvalidHandshakeException(String .format("Invalid status line received: %s Status line: %s", firstLineTokens[0], line)); } HandshakeBuilder handshake = new HandshakeImpl1Server(); ServerHandshakeBuilder serverhandshake = (ServerHandshakeBuilder) handshake; serverhandshake.setHttpStatus(Short.parseShort(firstLineTokens[1])); serverhandshake.setHttpStatusMessage(firstLineTokens[2]); return handshake; } public abstract HandshakeState acceptHandshakeAsClient(ClientHandshake request, ServerHandshake response) throws InvalidHandshakeException; public abstract HandshakeState acceptHandshakeAsServer(ClientHandshake handshakedata) throws InvalidHandshakeException; protected boolean 
/* class WebSocket */ basicAccept(Handshakedata handshakedata) { return handshakedata.getFieldValue("Upgrade").equalsIgnoreCase("websocket") && handshakedata .getFieldValue("Connection").toLowerCase(Locale.ENGLISH).contains("upgrade"); } public abstract ByteBuffer createBinaryFrame(Framedata framedata); public abstract List<Framedata> createFrames(ByteBuffer binary, boolean mask); public abstract List<Framedata> createFrames(String text, boolean mask); public abstract void processFrame(WebSocketImpl webSocketImpl, Framedata frame) throws InvalidDataException; public List<Framedata> continuousFrame(Opcode op, ByteBuffer buffer, boolean fin) { if (op != Opcode.BINARY && op != Opcode.TEXT) { throw new IllegalArgumentException("Only Opcode.BINARY or  Opcode.TEXT are allowed"); } DataFrame bui = null; if (continuousFrameType != null) { bui = new ContinuousFrame(); } else { continuousFrameType = op; if (op == Opcode.BINARY) { bui = new BinaryFrame(); } else if (op == Opcode.TEXT) { bui = new TextFrame(); } } bui.setPayload(buffer); bui.setFin(fin); try { bui.isValid(); } catch (InvalidDataException e) { throw new IllegalArgumentException(e); } if (fin) { continuousFrameType = null; } else { continuousFrameType = op; } return Collections.singletonList((Framedata) bui); } public abstract void reset(); @Deprecated public List<ByteBuffer> createHandshake(Handshakedata handshakedata, Role ownrole) { return createHandshake(handshakedata); } public List<ByteBuffer> createHandshake(Handshakedata handshakedata) { return createHandshake(handshakedata, true); } @Deprecated public List<ByteBuffer> createHandshake(Handshakedata handshakedata, Role ownrole, boolean withcontent) { return createHandshake(handshakedata, withcontent); } public List<ByteBuffer> createHandshake(Handshakedata handshakedata, boolean withcontent) { StringBuilder bui = new StringBuilder(100); if (handshakedata instanceof ClientHandshake) { bui.append("GET ").append(((ClientHandshake) handshakedata).getResourceDescriptor()) .append(" HTTP/1.1"); } else if (handshakedata instanceof ServerHandshake) { bui.append("HTTP/1.1 101 ").append(((ServerHandshake) handshakedata).getHttpStatusMessage()); } else { throw new IllegalArgumentException("unknown role"); } bui.append("\r\n"); Iterator<String> it = handshakedata.iterateHttpFields(); while (it.hasNext()) { String fieldname = it.next(); String fieldvalue = handshakedata.getFieldValue(fieldname); bui.append(fieldname); bui.append(": "); bui.append(fieldvalue); bui.append("\r\n"); } bui.append("\r\n"); byte[] httpheader = Charsetfunctions.asciiBytes(bui.toString()); byte[] content = withcontent ? handshakedata.getContent() : null; ByteBuffer bytebuffer = ByteBuffer .allocate((content == null ? 0 : content.length) + httpheader.length); bytebuffer.put(httpheader); if (content != null) { bytebuffer.put(content); } bytebuffer.flip(); return Collections.singletonList(bytebuffer); } public abstract ClientHandshakeBuilder postProcessHandshakeRequestAsClient( ClientHandshakeBuilder request) throws InvalidHandshakeException; public abstract HandshakeBuilder postProcessHandshakeResponseAsServer(ClientHandshake request, ServerHandshakeBuilder response) throws InvalidHandshakeException; public abstract List<Framedata> translateFrame(ByteBuffer buffer) throws InvalidDataException; public abstract CloseHandshakeType getCloseHandshakeType(); public abstract Draft copyInstance(); public Handshakedata translateHandshake(ByteBuffer buf) throws InvalidHandshakeException { return 
/* class WebSocket */ translateHandshakeHttp(buf, role); } public int checkAlloc(int bytecount) throws InvalidDataException { if (bytecount < 0) { throw new InvalidDataException(CloseFrame.PROTOCOL_ERROR, "Negative count"); } return bytecount; } int readVersion(Handshakedata handshakedata) { String vers = handshakedata.getFieldValue("Sec-WebSocket-Version"); if (vers.length() > 0) { int v; try { v = Integer.parseInt(vers.trim()); return v; } catch (NumberFormatException e) { return -1; } } return -1; } public void setParseMode(Role role) { this.role = role; } public Role getRole() { return role; } public String toString() { return getClass().getSimpleName(); } } 
@SuppressWarnings({"unchecked", "deprecation"})
class Draft_6455 extends Draft { private static final String SEC_WEB_SOCKET_KEY = "Sec-WebSocket-Key"; private static final String SEC_WEB_SOCKET_PROTOCOL = "Sec-WebSocket-Protocol"; private static final String SEC_WEB_SOCKET_EXTENSIONS = "Sec-WebSocket-Extensions"; private static final String SEC_WEB_SOCKET_ACCEPT = "Sec-WebSocket-Accept"; private static final String UPGRADE = "Upgrade"; private static final String CONNECTION = "Connection"; private IExtension negotiatedExtension = new DefaultExtension(); private IExtension defaultExtension = new DefaultExtension(); private List<IExtension> knownExtensions; private IExtension currentDecodingExtension; private IProtocol protocol; private List<IProtocol> knownProtocols; private Framedata currentContinuousFrame; private final List<ByteBuffer> byteBufferList; private ByteBuffer incompleteframe; private final SecureRandom reuseableRandom = new SecureRandom(); private int maxFrameSize; public Draft_6455() { this(Collections.<IExtension>emptyList()); } public Draft_6455(IExtension inputExtension) { this(Collections.singletonList(inputExtension)); } public Draft_6455(List<IExtension> inputExtensions) { this(inputExtensions, Collections.<IProtocol>singletonList(new Protocol(""))); } public Draft_6455(List<IExtension> inputExtensions, List<IProtocol> inputProtocols) { this(inputExtensions, inputProtocols, Integer.MAX_VALUE); } public Draft_6455(List<IExtension> inputExtensions, int inputMaxFrameSize) { this(inputExtensions, Collections.<IProtocol>singletonList(new Protocol("")), inputMaxFrameSize); } public Draft_6455(List<IExtension> inputExtensions, List<IProtocol> inputProtocols, int inputMaxFrameSize) { if (inputExtensions == null || inputProtocols == null || inputMaxFrameSize < 1) { throw new IllegalArgumentException(); } knownExtensions = new ArrayList<>(inputExtensions.size()); knownProtocols = new ArrayList<>(inputProtocols.size()); boolean hasDefault = false; byteBufferList = new ArrayList<>(); for (IExtension inputExtension : inputExtensions) { if (inputExtension.getClass().equals(DefaultExtension.class)) { hasDefault = true; } } knownExtensions.addAll(inputExtensions); if (!hasDefault) { knownExtensions.add(this.knownExtensions.size(), negotiatedExtension); } knownProtocols.addAll(inputProtocols); maxFrameSize = inputMaxFrameSize; currentDecodingExtension = null; } public HandshakeState acceptHandshakeAsServer(ClientHandshake handshakedata) throws InvalidHandshakeException { int v = readVersion(handshakedata); if (v != 13) { return HandshakeState.NOT_MATCHED; } HandshakeState extensionState = HandshakeState.NOT_MATCHED; String requestedExtension = handshakedata.getFieldValue(SEC_WEB_SOCKET_EXTENSIONS); for (IExtension knownExtension : knownExtensions) { if (knownExtension.acceptProvidedExtensionAsServer(requestedExtension)) { 
/* class WebSocket */ negotiatedExtension = knownExtension; extensionState = HandshakeState.MATCHED; break; } } HandshakeState protocolState = containsRequestedProtocol( handshakedata.getFieldValue(SEC_WEB_SOCKET_PROTOCOL)); if (protocolState == HandshakeState.MATCHED && extensionState == HandshakeState.MATCHED) { return HandshakeState.MATCHED; } return HandshakeState.NOT_MATCHED; } private HandshakeState containsRequestedProtocol(String requestedProtocol) { for (IProtocol knownProtocol : knownProtocols) { if (knownProtocol.acceptProvidedProtocol(requestedProtocol)) { protocol = knownProtocol; return HandshakeState.MATCHED; } } return HandshakeState.NOT_MATCHED; } public HandshakeState acceptHandshakeAsClient(ClientHandshake request, ServerHandshake response) throws InvalidHandshakeException { if (!basicAccept(response)) { return HandshakeState.NOT_MATCHED; } if (!request.hasFieldValue(SEC_WEB_SOCKET_KEY) || !response .hasFieldValue(SEC_WEB_SOCKET_ACCEPT)) { return HandshakeState.NOT_MATCHED; } String seckeyAnswer = response.getFieldValue(SEC_WEB_SOCKET_ACCEPT); String seckeyChallenge = request.getFieldValue(SEC_WEB_SOCKET_KEY); seckeyChallenge = generateFinalKey(seckeyChallenge); if (!seckeyChallenge.equals(seckeyAnswer)) { return HandshakeState.NOT_MATCHED; } HandshakeState extensionState = HandshakeState.NOT_MATCHED; String requestedExtension = response.getFieldValue(SEC_WEB_SOCKET_EXTENSIONS); for (IExtension knownExtension : knownExtensions) { if (knownExtension.acceptProvidedExtensionAsClient(requestedExtension)) { negotiatedExtension = knownExtension; extensionState = HandshakeState.MATCHED; break; } } HandshakeState protocolState = containsRequestedProtocol( response.getFieldValue(SEC_WEB_SOCKET_PROTOCOL)); if (protocolState == HandshakeState.MATCHED && extensionState == HandshakeState.MATCHED) { return HandshakeState.MATCHED; } return HandshakeState.NOT_MATCHED; } public IExtension getExtension() { return negotiatedExtension; } public List<IExtension> getKnownExtensions() { return knownExtensions; } public IProtocol getProtocol() { return protocol; } public int getMaxFrameSize() { return maxFrameSize; } public List<IProtocol> getKnownProtocols() { return knownProtocols; } public ClientHandshakeBuilder postProcessHandshakeRequestAsClient( ClientHandshakeBuilder request) { request.put(UPGRADE, "websocket"); request.put(CONNECTION, UPGRADE);  byte[] random = new byte[16]; reuseableRandom.nextBytes(random); request.put(SEC_WEB_SOCKET_KEY, WS_Base64.encodeBytes(random)); request.put("Sec-WebSocket-Version", "13"); StringBuilder requestedExtensions = new StringBuilder(); for (IExtension knownExtension : knownExtensions) { if (knownExtension.getProvidedExtensionAsClient() != null && knownExtension.getProvidedExtensionAsClient().length() != 0) { if (requestedExtensions.length() > 0) { requestedExtensions.append(", "); } requestedExtensions.append(knownExtension.getProvidedExtensionAsClient()); } } if (requestedExtensions.length() != 0) { request.put(SEC_WEB_SOCKET_EXTENSIONS, requestedExtensions.toString()); } StringBuilder requestedProtocols = new StringBuilder(); for (IProtocol knownProtocol : knownProtocols) { if (knownProtocol.getProvidedProtocol().length() != 0) { if (requestedProtocols.length() > 0) { requestedProtocols.append(", "); } requestedProtocols.append(knownProtocol.getProvidedProtocol()); } } if (requestedProtocols.length() != 0) { request.put(SEC_WEB_SOCKET_PROTOCOL, requestedProtocols.toString()); } return request; 
/* class WebSocket */ } public HandshakeBuilder postProcessHandshakeResponseAsServer(ClientHandshake request, ServerHandshakeBuilder response) throws InvalidHandshakeException { response.put(UPGRADE, "websocket"); response.put(CONNECTION, request.getFieldValue(CONNECTION));  String seckey = request.getFieldValue(SEC_WEB_SOCKET_KEY); if (seckey == null || "".equals(seckey)) { throw new InvalidHandshakeException("missing Sec-WebSocket-Key"); } response.put(SEC_WEB_SOCKET_ACCEPT, generateFinalKey(seckey)); if (getExtension().getProvidedExtensionAsServer().length() != 0) { response.put(SEC_WEB_SOCKET_EXTENSIONS, getExtension().getProvidedExtensionAsServer()); } if (getProtocol() != null && getProtocol().getProvidedProtocol().length() != 0) { response.put(SEC_WEB_SOCKET_PROTOCOL, getProtocol().getProvidedProtocol()); } response.setHttpStatusMessage("Web Socket Protocol Handshake"); response.put("Server", "TooTallNate Java-WebSocket"); response.put("Date", getServerTime()); return response; } public Draft copyInstance() { ArrayList<IExtension> newExtensions = new ArrayList<>(); for (IExtension knownExtension : getKnownExtensions()) { newExtensions.add(knownExtension.copyInstance()); } ArrayList<IProtocol> newProtocols = new ArrayList<>(); for (IProtocol knownProtocol : getKnownProtocols()) { newProtocols.add(knownProtocol.copyInstance()); } return new Draft_6455(newExtensions, newProtocols, maxFrameSize); } public ByteBuffer createBinaryFrame(Framedata framedata) { getExtension().encodeFrame(framedata); return createByteBufferFromFramedata(framedata); } private ByteBuffer createByteBufferFromFramedata(Framedata framedata) { ByteBuffer mes = framedata.getPayloadData(); boolean mask = role == Role.CLIENT; int sizebytes = getSizeBytes(mes); ByteBuffer buf = ByteBuffer.allocate( 1 + (sizebytes > 1 ? sizebytes + 1 : sizebytes) + (mask ? 4 : 0) + mes.remaining()); byte optcode = fromOpcode(framedata.getOpcode()); byte one = (byte) (framedata.isFin() ? -128 : 0); one |= optcode; if (framedata.isRSV1()) { one |= getRSVByte(1); } if (framedata.isRSV2()) { one |= getRSVByte(2); } if (framedata.isRSV3()) { one |= getRSVByte(3); } buf.put(one); byte[] payloadlengthbytes = toByteArray(mes.remaining(), sizebytes); assert (payloadlengthbytes.length == sizebytes); if (sizebytes == 1) { buf.put((byte) (payloadlengthbytes[0] | getMaskByte(mask))); } else if (sizebytes == 2) { buf.put((byte) ((byte) 126 | getMaskByte(mask))); buf.put(payloadlengthbytes); } else if (sizebytes == 8) { buf.put((byte) ((byte) 127 | getMaskByte(mask))); buf.put(payloadlengthbytes); } else { throw new IllegalStateException("Size representation not supported/specified"); } if (mask) { ByteBuffer maskkey = ByteBuffer.allocate(4); maskkey.putInt(reuseableRandom.nextInt()); buf.put(maskkey.array()); for (int i = 0; mes.hasRemaining(); i++) { buf.put((byte) (mes.get() ^ maskkey.get(i % 4))); } } else { buf.put(mes); mes.flip(); } assert (buf.remaining() == 0) : buf.remaining(); buf.flip(); return buf; } private Framedata translateSingleFrame(ByteBuffer buffer) throws IncompleteException, InvalidDataException { if (buffer == null) { throw new IllegalArgumentException(); } int maxpacketsize = buffer.remaining(); int realpacketsize = 2; translateSingleFrameCheckPacketSize(maxpacketsize, realpacketsize); byte b1 = buffer.get(); boolean fin = b1 >> 8 != 0; boolean rsv1 = (b1 & 0x40) != 0; boolean rsv2 = (b1 & 0x20) != 0; boolean rsv3 = (b1 & 0x10) != 0; byte b2 = buffer.get(); 
/* class WebSocket */ boolean mask = (b2 & -128) != 0; int payloadlength = (byte) (b2 & ~(byte) 128); Opcode optcode = toOpcode((byte) (b1 & 15)); if (!(payloadlength >= 0 && payloadlength <= 125)) { TranslatedPayloadMetaData payloadData = translateSingleFramePayloadLength(buffer, optcode, payloadlength, maxpacketsize, realpacketsize); payloadlength = payloadData.getPayloadLength(); realpacketsize = payloadData.getRealPackageSize(); } translateSingleFrameCheckLengthLimit(payloadlength); realpacketsize += (mask ? 4 : 0); realpacketsize += payloadlength; translateSingleFrameCheckPacketSize(maxpacketsize, realpacketsize); ByteBuffer payload = ByteBuffer.allocate(checkAlloc(payloadlength)); if (mask) { byte[] maskskey = new byte[4]; buffer.get(maskskey); for (int i = 0; i < payloadlength; i++) { payload.put((byte) (buffer.get() ^ maskskey[i % 4])); } } else { payload.put(buffer.array(), buffer.position(), payload.limit()); buffer.position(buffer.position() + payload.limit()); } FramedataImpl1 frame = FramedataImpl1.get(optcode); frame.setFin(fin); frame.setRSV1(rsv1); frame.setRSV2(rsv2); frame.setRSV3(rsv3); payload.flip(); frame.setPayload(payload); if (frame.getOpcode() != Opcode.CONTINUOUS) { if (frame.isRSV1() || frame.isRSV2() || frame.isRSV3()) { currentDecodingExtension = getExtension(); } else { currentDecodingExtension = defaultExtension; } } if (currentDecodingExtension == null) { currentDecodingExtension = defaultExtension; } currentDecodingExtension.isFrameValid(frame); currentDecodingExtension.decodeFrame(frame); frame.isValid(); return frame; } private TranslatedPayloadMetaData translateSingleFramePayloadLength(ByteBuffer buffer, Opcode optcode, int oldPayloadlength, int maxpacketsize, int oldRealpacketsize) throws InvalidFrameException, IncompleteException, LimitExceededException { int payloadlength = oldPayloadlength; int realpacketsize = oldRealpacketsize; if (optcode == Opcode.PING || optcode == Opcode.PONG || optcode == Opcode.CLOSING) { throw new InvalidFrameException("more than 125 octets"); } if (payloadlength == 126) { realpacketsize += 2; translateSingleFrameCheckPacketSize(maxpacketsize, realpacketsize); byte[] sizebytes = new byte[3]; sizebytes[1] = buffer.get(); sizebytes[2] = buffer.get(); payloadlength = new BigInteger(sizebytes).intValue(); } else { realpacketsize += 8; translateSingleFrameCheckPacketSize(maxpacketsize, realpacketsize); byte[] bytes = new byte[8]; for (int i = 0; i < 8; i++) { bytes[i] = buffer.get(); } long length = new BigInteger(bytes).longValue(); translateSingleFrameCheckLengthLimit(length); payloadlength = (int) length; } return new TranslatedPayloadMetaData(payloadlength, realpacketsize); } private void translateSingleFrameCheckLengthLimit(long length) throws LimitExceededException { if (length > Integer.MAX_VALUE) { throw new LimitExceededException("Payloadsize is to big..."); } if (length > maxFrameSize) { throw new LimitExceededException("Payload limit reached.", maxFrameSize); } if (length < 0) { throw new LimitExceededException("Payloadsize is to little..."); } } private void translateSingleFrameCheckPacketSize(int maxpacketsize, int realpacketsize) throws IncompleteException { if (maxpacketsize < realpacketsize) { throw new IncompleteException(realpacketsize); } } private byte getRSVByte(int rsv) { switch (rsv) { case 1 : return 0x40; case 2 : return 0x20; case 3 : return 0x10; default: return 0; } } private byte getMaskByte(boolean mask) { return mask ? (byte) -128 : 0; } private int getSizeBytes(ByteBuffer mes) { 
/* class WebSocket */ if (mes.remaining() <= 125) { return 1; } else if (mes.remaining() <= 65535) { return 2; } return 8; } public List<Framedata> translateFrame(ByteBuffer buffer) throws InvalidDataException { while (true) { List<Framedata> frames = new LinkedList<>(); Framedata cur; if (incompleteframe != null) { try { buffer.mark(); int availableNextByteCount = buffer.remaining(); int expectedNextByteCount = incompleteframe .remaining(); if (expectedNextByteCount > availableNextByteCount) { incompleteframe.put(buffer.array(), buffer.position(), availableNextByteCount); buffer.position(buffer.position() + availableNextByteCount); return Collections.emptyList(); } incompleteframe.put(buffer.array(), buffer.position(), expectedNextByteCount); buffer.position(buffer.position() + expectedNextByteCount); cur = translateSingleFrame((ByteBuffer) incompleteframe.duplicate().position(0)); frames.add(cur); incompleteframe = null; } catch (IncompleteException e) { ByteBuffer extendedframe = ByteBuffer.allocate(checkAlloc(e.getPreferredSize())); assert (extendedframe.limit() > incompleteframe.limit()); incompleteframe.rewind(); extendedframe.put(incompleteframe); incompleteframe = extendedframe; continue; } } while (buffer.hasRemaining()) { buffer.mark(); try { cur = translateSingleFrame(buffer); frames.add(cur); } catch (IncompleteException e) { buffer.reset(); int pref = e.getPreferredSize(); incompleteframe = ByteBuffer.allocate(checkAlloc(pref)); incompleteframe.put(buffer); break; } } return frames; } } public List<Framedata> createFrames(ByteBuffer binary, boolean mask) { BinaryFrame curframe = new BinaryFrame(); curframe.setPayload(binary); curframe.setTransferemasked(mask); try { curframe.isValid(); } catch (InvalidDataException e) { throw new NotSendableException(e); } return Collections.singletonList((Framedata) curframe); } public List<Framedata> createFrames(String text, boolean mask) { TextFrame curframe = new TextFrame(); curframe.setPayload(ByteBuffer.wrap(Charsetfunctions.utf8Bytes(text))); curframe.setTransferemasked(mask); try { curframe.isValid(); } catch (InvalidDataException e) { throw new NotSendableException(e); } return Collections.singletonList((Framedata) curframe); } public void reset() { incompleteframe = null; if (negotiatedExtension != null) { negotiatedExtension.reset(); } negotiatedExtension = new DefaultExtension(); protocol = null; } private String getServerTime() { Calendar calendar = Calendar.getInstance(); SimpleDateFormat dateFormat = new SimpleDateFormat( "EEE, dd MMM yyyy HH:mm:ss z", Locale.US); dateFormat.setTimeZone(TimeZone.getTimeZone("GMT")); return dateFormat.format(calendar.getTime()); } private String generateFinalKey(String in) { String seckey = in.trim(); String acc = seckey + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11"; MessageDigest sh1; try { sh1 = MessageDigest.getInstance("SHA1"); } catch (NoSuchAlgorithmException e) { throw new IllegalStateException(e); } return WS_Base64.encodeBytes(sh1.digest(acc.getBytes())); } private byte[] toByteArray(long val, int bytecount) { byte[] buffer = new byte[bytecount]; int highest = 8 * bytecount - 8; for (int i = 0; i < bytecount; i++) { buffer[i] = (byte) (val >>> (highest - 8 * i)); } return buffer; } private byte fromOpcode(Opcode opcode) { if (opcode == Opcode.CONTINUOUS) { return 0; } else if (opcode == Opcode.TEXT) { return 1; } else if (opcode == Opcode.BINARY) { return 2; } else if (opcode == Opcode.CLOSING) { return 8; } else if (opcode == Opcode.PING) { return 9; } else 
/* class WebSocket */ if (opcode == Opcode.PONG) { return 10; } throw new IllegalArgumentException("Don't know how to handle " + opcode.toString()); } private Opcode toOpcode(byte opcode) throws InvalidFrameException { switch (opcode) { case 0: return Opcode.CONTINUOUS; case 1: return Opcode.TEXT; case 2: return Opcode.BINARY; case 8: return Opcode.CLOSING; case 9: return Opcode.PING; case 10: return Opcode.PONG; default: throw new InvalidFrameException("Unknown opcode " + (short) opcode); } } public void processFrame(WebSocketImpl webSocketImpl, Framedata frame) throws InvalidDataException { Opcode curop = frame.getOpcode(); if (curop == Opcode.CLOSING) { processFrameClosing(webSocketImpl, frame); } else if (curop == Opcode.PING) { webSocketImpl.getWebSocketListener().onWebsocketPing(webSocketImpl, frame); } else if (curop == Opcode.PONG) { webSocketImpl.updateLastPong(); webSocketImpl.getWebSocketListener().onWebsocketPong(webSocketImpl, frame); } else if (!frame.isFin() || curop == Opcode.CONTINUOUS) { processFrameContinuousAndNonFin(webSocketImpl, frame, curop); } else if (currentContinuousFrame != null) { throw new InvalidDataException(CloseFrame.PROTOCOL_ERROR, "Continuous frame sequence not completed."); } else if (curop == Opcode.TEXT) { processFrameText(webSocketImpl, frame); } else if (curop == Opcode.BINARY) { processFrameBinary(webSocketImpl, frame); } else { throw new InvalidDataException(CloseFrame.PROTOCOL_ERROR, "non control or continious frame expected"); } } private void processFrameContinuousAndNonFin(WebSocketImpl webSocketImpl, Framedata frame, Opcode curop) throws InvalidDataException { if (curop != Opcode.CONTINUOUS) { processFrameIsNotFin(frame); } else if (frame.isFin()) { processFrameIsFin(webSocketImpl, frame); } else if (currentContinuousFrame == null) { throw new InvalidDataException(CloseFrame.PROTOCOL_ERROR, "Continuous frame sequence was not started."); } if (curop == Opcode.TEXT && !Charsetfunctions.isValidUTF8(frame.getPayloadData())) { throw new InvalidDataException(CloseFrame.NO_UTF8); } if (curop == Opcode.CONTINUOUS && currentContinuousFrame != null) { addToBufferList(frame.getPayloadData()); } } private void processFrameBinary(WebSocketImpl webSocketImpl, Framedata frame) { try { webSocketImpl.getWebSocketListener() .onWebsocketMessage(webSocketImpl, frame.getPayloadData()); } catch (RuntimeException e) { logRuntimeException(webSocketImpl, e); } } private void logRuntimeException(WebSocketImpl webSocketImpl, RuntimeException e) { webSocketImpl.getWebSocketListener().onWebsocketError(webSocketImpl, e); } private void processFrameText(WebSocketImpl webSocketImpl, Framedata frame) throws InvalidDataException { try { webSocketImpl.getWebSocketListener() .onWebsocketMessage(webSocketImpl, Charsetfunctions.stringUtf8(frame.getPayloadData())); } catch (RuntimeException e) { logRuntimeException(webSocketImpl, e); } } private void processFrameIsFin(WebSocketImpl webSocketImpl, Framedata frame) throws InvalidDataException { if (currentContinuousFrame == null) { throw new InvalidDataException(CloseFrame.PROTOCOL_ERROR, "Continuous frame sequence was not started."); } addToBufferList(frame.getPayloadData()); checkBufferLimit(); if (currentContinuousFrame.getOpcode() == Opcode.TEXT) { ((FramedataImpl1) currentContinuousFrame).setPayload(getPayloadFromByteBufferList()); ((FramedataImpl1) currentContinuousFrame).isValid(); try { webSocketImpl.getWebSocketListener().onWebsocketMessage(webSocketImpl, Charsetfunctions.stringUtf8(
/* class WebSocket */ currentContinuousFrame.getPayloadData())); } catch (RuntimeException e) { logRuntimeException(webSocketImpl, e); } } else if (currentContinuousFrame.getOpcode() == Opcode.BINARY) { ((FramedataImpl1) currentContinuousFrame).setPayload(getPayloadFromByteBufferList()); ((FramedataImpl1) currentContinuousFrame).isValid(); try { webSocketImpl.getWebSocketListener() .onWebsocketMessage(webSocketImpl, currentContinuousFrame.getPayloadData()); } catch (RuntimeException e) { logRuntimeException(webSocketImpl, e); } } currentContinuousFrame = null; clearBufferList(); } private void processFrameIsNotFin(Framedata frame) throws InvalidDataException { if (currentContinuousFrame != null) { throw new InvalidDataException(CloseFrame.PROTOCOL_ERROR, "Previous continuous frame sequence not completed."); } currentContinuousFrame = frame; addToBufferList(frame.getPayloadData()); checkBufferLimit(); } private void processFrameClosing(WebSocketImpl webSocketImpl, Framedata frame) { int code = CloseFrame.NOCODE; String reason = ""; if (frame instanceof CloseFrame) { CloseFrame cf = (CloseFrame) frame; code = cf.getCloseCode(); reason = cf.getMessage(); } if (webSocketImpl.getReadyState() == ReadyState.CLOSING) { webSocketImpl.closeConnection(code, reason, true); } else { if (getCloseHandshakeType() == CloseHandshakeType.TWOWAY) { webSocketImpl.close(code, reason, true); } else { webSocketImpl.flushAndClose(code, reason, false); } } } private void clearBufferList() { synchronized (byteBufferList) { byteBufferList.clear(); } } private void addToBufferList(ByteBuffer payloadData) { synchronized (byteBufferList) { byteBufferList.add(payloadData); } } private void checkBufferLimit() throws LimitExceededException { long totalSize = getByteBufferListSize(); if (totalSize > maxFrameSize) { clearBufferList(); throw new LimitExceededException(maxFrameSize); } } public CloseHandshakeType getCloseHandshakeType() { return CloseHandshakeType.TWOWAY; } public String toString() { String result = super.toString(); if (getExtension() != null) { result += " extension: " + getExtension().toString(); } if (getProtocol() != null) { result += " protocol: " + getProtocol().toString(); } result += " max frame size: " + this.maxFrameSize; return result; } public boolean equals(Object o) { if (this == o) { return true; } if (o == null || getClass() != o.getClass()) { return false; } Draft_6455 that = (Draft_6455) o; if (maxFrameSize != that.getMaxFrameSize()) { return false; } if (negotiatedExtension != null ? !negotiatedExtension.equals(that.getExtension()) : that.getExtension() != null) { return false; } return protocol != null ? protocol.equals(that.getProtocol()) : that.getProtocol() == null; } public int hashCode() { int result = negotiatedExtension != null ? negotiatedExtension.hashCode() : 0; result = 31 * result + (protocol != null ? protocol.hashCode() : 0); result = 31 * result + (maxFrameSize ^ (maxFrameSize >>> 32)); return result; } private ByteBuffer getPayloadFromByteBufferList() throws LimitExceededException { long totalSize = 0; ByteBuffer resultingByteBuffer; synchronized (byteBufferList) { for (ByteBuffer buffer : byteBufferList) { totalSize += buffer.limit(); } checkBufferLimit(); resultingByteBuffer = ByteBuffer.allocate((int) totalSize); for (ByteBuffer buffer : byteBufferList) { resultingByteBuffer.put(buffer); } } resultingByteBuffer.flip(); return resultingByteBuffer; } private long getByteBufferListSize() { long totalSize = 0; synchronized (byteBufferList) { for (
/* class WebSocket */ ByteBuffer buffer : byteBufferList) { totalSize += buffer.limit(); } } return totalSize; } 
@SuppressWarnings({"unchecked", "deprecation"})
private class TranslatedPayloadMetaData { private int payloadLength; private int realPackageSize; private int getPayloadLength() { return payloadLength; } private int getRealPackageSize() { return realPackageSize; } TranslatedPayloadMetaData(int newPayloadLength, int newRealPackageSize) { this.payloadLength = newPayloadLength; this.realPackageSize = newRealPackageSize; } } } 
@SuppressWarnings({"unchecked", "deprecation"})
class ExtensionRequestData { public static final String EMPTY_VALUE = ""; private Map<String, String> extensionParameters; private String extensionName; private ExtensionRequestData() { extensionParameters = new LinkedHashMap<>(); } public static ExtensionRequestData parseExtensionRequest(String extensionRequest) { ExtensionRequestData extensionData = new ExtensionRequestData(); String[] parts = extensionRequest.split(";"); extensionData.extensionName = parts[0].trim(); for (int i = 1; i < parts.length; i++) { String[] keyValue = parts[i].split("="); String value = EMPTY_VALUE; if (keyValue.length > 1) { String tempValue = keyValue[1].trim(); if ((tempValue.startsWith("\"") && tempValue.endsWith("\"")) || (tempValue.startsWith("'") && tempValue.endsWith("'")) && tempValue.length() > 2) { tempValue = tempValue.substring(1, tempValue.length() - 1); } value = tempValue; } extensionData.extensionParameters.put(keyValue[0].trim(), value); } return extensionData; } public String getExtensionName() { return extensionName; } public Map<String, String> getExtensionParameters() { return extensionParameters; } } interface Framedata { boolean isFin(); boolean isRSV1(); boolean isRSV2(); boolean isRSV3(); boolean getTransfereMasked(); Opcode getOpcode(); ByteBuffer getPayloadData(); void append(Framedata nextframe); } 
@SuppressWarnings({"unchecked", "deprecation"})
abstract class FramedataImpl1 implements Framedata { private boolean fin; private Opcode optcode; private ByteBuffer unmaskedpayload; private boolean transferemasked; private boolean rsv1; private boolean rsv2; private boolean rsv3; public abstract void isValid() throws InvalidDataException; public FramedataImpl1(Opcode op) { optcode = op; unmaskedpayload = ByteBufferUtils.getEmptyByteBuffer(); fin = true; transferemasked = false; rsv1 = false; rsv2 = false; rsv3 = false; } public boolean isRSV1() { return rsv1; } public boolean isRSV2() { return rsv2; } public boolean isRSV3() { return rsv3; } public boolean isFin() { return fin; } public Opcode getOpcode() { return optcode; } public boolean getTransfereMasked() { return transferemasked; } public ByteBuffer getPayloadData() { return unmaskedpayload; } public void append(Framedata nextframe) { ByteBuffer b = nextframe.getPayloadData(); if (unmaskedpayload == null) { unmaskedpayload = ByteBuffer.allocate(b.remaining()); b.mark(); unmaskedpayload.put(b); b.reset(); } else { b.mark(); unmaskedpayload.position(unmaskedpayload.limit()); unmaskedpayload.limit(unmaskedpayload.capacity()); if (b.remaining() > unmaskedpayload.remaining()) { ByteBuffer tmp = ByteBuffer.allocate(b.remaining() + unmaskedpayload.capacity()); unmaskedpayload.flip(); tmp.put(unmaskedpayload); tmp.put(b); unmaskedpayload = tmp; } else { unmaskedpayload.put(b); } unmaskedpayload.rewind(); b.reset(); } fin = nextframe.isFin(); } public String toString() { return "Framedata{ opcode:" + getOpcode() + ", fin:" + isFin() + ", rsv1:" + isRSV1() + ", rsv2:" + isRSV2() + ", rsv3:" + isRSV3() + ", payload length:[pos:" + unmaskedpayload .position() + ", len:" + 
/* class WebSocket */ unmaskedpayload.remaining() + "], payload:" + ( unmaskedpayload.remaining() > 1000 ? "(too big to display)" : new String(unmaskedpayload.array())) + '}'; } public void setPayload(ByteBuffer payload) { this.unmaskedpayload = payload; } public void setFin(boolean fin) { this.fin = fin; } public void setRSV1(boolean rsv1) { this.rsv1 = rsv1; } public void setRSV2(boolean rsv2) { this.rsv2 = rsv2; } public void setRSV3(boolean rsv3) { this.rsv3 = rsv3; } public void setTransferemasked(boolean transferemasked) { this.transferemasked = transferemasked; } public static FramedataImpl1 get(Opcode opcode) { if (opcode == null) { throw new IllegalArgumentException("Supplied opcode cannot be null"); } switch (opcode) { case PING: return new PingFrame(); case PONG: return new PongFrame(); case TEXT: return new TextFrame(); case BINARY: return new BinaryFrame(); case CLOSING: return new CloseFrame(); case CONTINUOUS: return new ContinuousFrame(); default: throw new IllegalArgumentException("Supplied opcode is invalid"); } } public boolean equals(Object o) { if (this == o) { return true; } if (o == null || getClass() != o.getClass()) { return false; } FramedataImpl1 that = (FramedataImpl1) o; if (fin != that.fin) { return false; } if (transferemasked != that.transferemasked) { return false; } if (rsv1 != that.rsv1) { return false; } if (rsv2 != that.rsv2) { return false; } if (rsv3 != that.rsv3) { return false; } if (optcode != that.optcode) { return false; } return unmaskedpayload != null ? unmaskedpayload.equals(that.unmaskedpayload) : that.unmaskedpayload == null; } public int hashCode() { int result = (fin ? 1 : 0); result = 31 * result + optcode.hashCode(); result = 31 * result + (unmaskedpayload != null ? unmaskedpayload.hashCode() : 0); result = 31 * result + (transferemasked ? 1 : 0); result = 31 * result + (rsv1 ? 1 : 0); result = 31 * result + (rsv2 ? 1 : 0); result = 31 * result + (rsv3 ? 1 : 0); return result; } } interface HandshakeBuilder extends Handshakedata { void setContent(byte[] content); void put(String name, String value); } interface Handshakedata { Iterator<String> iterateHttpFields(); String getFieldValue(String name); boolean hasFieldValue(String name); byte[] getContent(); } 
@SuppressWarnings({"unchecked", "deprecation"})
class HandshakedataImpl1 implements HandshakeBuilder { private byte[] content; private TreeMap<String, String> map; public HandshakedataImpl1() { map = new TreeMap<>(String.CASE_INSENSITIVE_ORDER); }   public Iterator<String> iterateHttpFields() { return Collections.unmodifiableSet(map.keySet()).iterator(); } public String getFieldValue(String name) { String s = map.get(name); if (s == null) { return ""; } return s; } public byte[] getContent() { return content; } public void setContent(byte[] content) { this.content = content; } public void put(String name, String value) { map.put(name, value); } public boolean hasFieldValue(String name) { return map.containsKey(name); } } 
@SuppressWarnings({"unchecked", "deprecation"})
class HandshakeImpl1Client extends HandshakedataImpl1 implements ClientHandshakeBuilder { private String resourceDescriptor = "*"; public void setResourceDescriptor(String resourceDescriptor) { if (resourceDescriptor == null) { throw new IllegalArgumentException("http resource descriptor must not be null"); } this.resourceDescriptor = resourceDescriptor; } public String getResourceDescriptor() { return resourceDescriptor; } } 
@SuppressWarnings({"unchecked", "deprecation"})
class HandshakeImpl1Server extends HandshakedataImpl1 implements ServerHandshakeBuilder { private short httpstatus; private String httpstatusmessage; 
/* class WebSocket */ public String getHttpStatusMessage() { return httpstatusmessage; } public short getHttpStatus() { return httpstatus; } public void setHttpStatusMessage(String message) { this.httpstatusmessage = message; } public void setHttpStatus(short status) { httpstatus = status; } } enum HandshakeState { MATCHED, NOT_MATCHED } interface IExtension { void decodeFrame(Framedata inputFrame) throws InvalidDataException; void encodeFrame(Framedata inputFrame); boolean acceptProvidedExtensionAsServer(String inputExtensionHeader); boolean acceptProvidedExtensionAsClient(String inputExtensionHeader); void isFrameValid(Framedata inputFrame) throws InvalidDataException; String getProvidedExtensionAsClient(); String getProvidedExtensionAsServer(); IExtension copyInstance(); void reset(); String toString(); } 
@SuppressWarnings({"unchecked", "deprecation"})
class IncompleteException extends Exception { private static final long serialVersionUID = 7330519489840500997L; private final int preferredSize; public IncompleteException(int preferredSize) { this.preferredSize = preferredSize; } public int getPreferredSize() { return preferredSize; } } 
@SuppressWarnings({"unchecked", "deprecation"})
class IncompleteHandshakeException extends RuntimeException { private static final long serialVersionUID = 7906596804233893092L; private final int preferredSize; public IncompleteHandshakeException(int preferredSize) { this.preferredSize = preferredSize; } public IncompleteHandshakeException() { this.preferredSize = 0; } public int getPreferredSize() { return preferredSize; } } 
@SuppressWarnings({"unchecked", "deprecation"})
class InvalidDataException extends Exception { private static final long serialVersionUID = 3731842424390998726L; private final int closecode; public InvalidDataException(int closecode) { this.closecode = closecode; } public InvalidDataException(int closecode, String s) { super(s); this.closecode = closecode; } public InvalidDataException(int closecode, Throwable t) { super(t); this.closecode = closecode; } public InvalidDataException(int closecode, String s, Throwable t) { super(s, t); this.closecode = closecode; } public int getCloseCode() { return closecode; } } 
@SuppressWarnings({"unchecked", "deprecation"})
class InvalidEncodingException extends RuntimeException { private final UnsupportedEncodingException encodingException; public InvalidEncodingException(UnsupportedEncodingException encodingException) { if (encodingException == null) { throw new IllegalArgumentException(); } this.encodingException = encodingException; } public UnsupportedEncodingException getEncodingException() { return encodingException; } } 
@SuppressWarnings({"unchecked", "deprecation"})
class InvalidFrameException extends InvalidDataException { private static final long serialVersionUID = -9016496369828887591L; public InvalidFrameException() { super(CloseFrame.PROTOCOL_ERROR); } public InvalidFrameException(String s) { super(CloseFrame.PROTOCOL_ERROR, s); } public InvalidFrameException(Throwable t) { super(CloseFrame.PROTOCOL_ERROR, t); } public InvalidFrameException(String s, Throwable t) { super(CloseFrame.PROTOCOL_ERROR, s, t); } } 
@SuppressWarnings({"unchecked", "deprecation"})
class InvalidHandshakeException extends InvalidDataException { private static final long serialVersionUID = -1426533877490484964L; public InvalidHandshakeException() { super(CloseFrame.PROTOCOL_ERROR); } public InvalidHandshakeException(String s, Throwable t) { super(CloseFrame.PROTOCOL_ERROR, s, t); } public InvalidHandshakeException(String s) { super(CloseFrame.PROTOCOL_ERROR, s); } public InvalidHandshakeException(Throwable t) { super(CloseFrame.PROTOCOL_ERROR, t); } } interface IProtocol { boolean acceptProvidedProtocol(String inputProtocolHeader); 
/* class WebSocket */ String getProvidedProtocol(); IProtocol copyInstance(); String toString(); } interface ISSLChannel { SSLEngine getSSLEngine(); } 
@SuppressWarnings({"unchecked", "deprecation"})
class LimitExceededException extends InvalidDataException { private static final long serialVersionUID = 6908339749836826785L; private final int limit; public LimitExceededException() { this(Integer.MAX_VALUE); } public LimitExceededException(int limit) { super(CloseFrame.TOOBIG); this.limit = limit; } public LimitExceededException(String s, int limit) { super(CloseFrame.TOOBIG, s); this.limit = limit; } public LimitExceededException(String s) { this(s, Integer.MAX_VALUE); } public int getLimit() { return limit; } } 
@SuppressWarnings({"unchecked", "deprecation"})
class NamedThreadFactory implements ThreadFactory { private final ThreadFactory defaultThreadFactory = Executors.defaultThreadFactory(); private final AtomicInteger threadNumber = new AtomicInteger(1); private final String threadPrefix; private final boolean daemon; public NamedThreadFactory(String threadPrefix) { this.threadPrefix = threadPrefix; this.daemon = false; } public NamedThreadFactory(String threadPrefix, boolean daemon) { this.threadPrefix = threadPrefix; this.daemon = daemon; } public Thread newThread(Runnable runnable) { Thread thread = defaultThreadFactory.newThread(runnable); thread.setDaemon(daemon); thread.setName(threadPrefix + "-" + threadNumber); return thread; } } 
@SuppressWarnings({"unchecked", "deprecation"})
class NotSendableException extends RuntimeException { private static final long serialVersionUID = -6468967874576651628L; public NotSendableException(String s) { super(s); } public NotSendableException(Throwable t) { super(t); } public NotSendableException(String s, Throwable t) { super(s, t); } } enum Opcode { CONTINUOUS, TEXT, BINARY, PING, PONG, CLOSING } 
@SuppressWarnings({"unchecked", "deprecation"})
class PerMessageDeflateExtension extends CompressionExtension { private static final String EXTENSION_REGISTERED_NAME = "permessage-deflate"; private static final String SERVER_NO_CONTEXT_TAKEOVER = "server_no_context_takeover"; private static final String CLIENT_NO_CONTEXT_TAKEOVER = "client_no_context_takeover"; private static final String SERVER_MAX_WINDOW_BITS = "server_max_window_bits"; private static final String CLIENT_MAX_WINDOW_BITS = "client_max_window_bits"; private static final int serverMaxWindowBits = 1 << 15; private static final int clientMaxWindowBits = 1 << 15; private static final byte[] TAIL_BYTES = {(byte) 0x00, (byte) 0x00, (byte) 0xFF, (byte) 0xFF}; private static final int BUFFER_SIZE = 1 << 10; private int threshold = 1024; private boolean serverNoContextTakeover = true; private boolean clientNoContextTakeover = false; private Map<String, String> requestedParameters = new LinkedHashMap<>(); private Inflater inflater = new Inflater(true); private Deflater deflater = new Deflater(Deflater.DEFAULT_COMPRESSION, true); public Inflater getInflater() { return inflater; } public void setInflater(Inflater inflater) { this.inflater = inflater; } public Deflater getDeflater() { return deflater; } public void setDeflater(Deflater deflater) { this.deflater = deflater; } public int getThreshold() { return threshold; } public void setThreshold(int threshold) { this.threshold = threshold; } public boolean isServerNoContextTakeover() { return serverNoContextTakeover; } public void setServerNoContextTakeover(boolean serverNoContextTakeover) { this.serverNoContextTakeover = serverNoContextTakeover; } public boolean isClientNoContextTakeover() { return clientNoContextTakeover; } public void setClientNoContextTakeover(boolean clientNoContextTakeover) { 
/* class WebSocket */ this.clientNoContextTakeover = clientNoContextTakeover; } public void decodeFrame(Framedata inputFrame) throws InvalidDataException { if (!(inputFrame instanceof DataFrame)) { return; } if (!inputFrame.isRSV1() && inputFrame.getOpcode() != Opcode.CONTINUOUS) { return; } if (inputFrame.getOpcode() == Opcode.CONTINUOUS && inputFrame.isRSV1()) { throw new InvalidDataException(CloseFrame.POLICY_VALIDATION, "RSV1 bit can only be set for the first frame."); } ByteArrayOutputStream output = new ByteArrayOutputStream(); try { decompress(inputFrame.getPayloadData().array(), output); if (inflater.getRemaining() > 0) { inflater = new Inflater(true); decompress(inputFrame.getPayloadData().array(), output); } if (inputFrame.isFin()) { decompress(TAIL_BYTES, output); if (clientNoContextTakeover) { inflater = new Inflater(true); } } } catch (DataFormatException e) { throw new InvalidDataException(CloseFrame.POLICY_VALIDATION, e.getMessage()); } ((FramedataImpl1) inputFrame) .setPayload(ByteBuffer.wrap(output.toByteArray(), 0, output.size())); } private void decompress(byte[] data, ByteArrayOutputStream outputBuffer) throws DataFormatException { inflater.setInput(data); byte[] buffer = new byte[BUFFER_SIZE]; int bytesInflated; while ((bytesInflated = inflater.inflate(buffer)) > 0) { outputBuffer.write(buffer, 0, bytesInflated); } } public void encodeFrame(Framedata inputFrame) { if (!(inputFrame instanceof DataFrame)) { return; } byte[] payloadData = inputFrame.getPayloadData().array(); if (payloadData.length < threshold) { return; } if (!(inputFrame instanceof ContinuousFrame)) { ((DataFrame) inputFrame).setRSV1(true); } deflater.setInput(payloadData); ByteArrayOutputStream output = new ByteArrayOutputStream(); byte[] buffer = new byte[1024]; int bytesCompressed; while ((bytesCompressed = deflater.deflate(buffer, 0, buffer.length, Deflater.SYNC_FLUSH)) > 0) { output.write(buffer, 0, bytesCompressed); } byte[] outputBytes = output.toByteArray(); int outputLength = outputBytes.length; if (inputFrame.isFin()) { if (endsWithTail(outputBytes)) { outputLength -= TAIL_BYTES.length; } if (serverNoContextTakeover) { deflater.end(); deflater = new Deflater(Deflater.DEFAULT_COMPRESSION, true); } } ((FramedataImpl1) inputFrame).setPayload(ByteBuffer.wrap(outputBytes, 0, outputLength)); } private static boolean endsWithTail(byte[] data) { if (data.length < 4) { return false; } int length = data.length; for (int i = 0; i < TAIL_BYTES.length; i++) { if (TAIL_BYTES[i] != data[length - TAIL_BYTES.length + i]) { return false; } } return true; } public boolean acceptProvidedExtensionAsServer(String inputExtension) { String[] requestedExtensions = inputExtension.split(","); for (String extension : requestedExtensions) { ExtensionRequestData extensionData = ExtensionRequestData.parseExtensionRequest(extension); if (!EXTENSION_REGISTERED_NAME.equalsIgnoreCase(extensionData.getExtensionName())) { continue; } Map<String, String> headers = extensionData.getExtensionParameters(); requestedParameters.putAll(headers); if (requestedParameters.containsKey(CLIENT_NO_CONTEXT_TAKEOVER)) { clientNoContextTakeover = true; } return true; } return false; } public boolean acceptProvidedExtensionAsClient(String inputExtension) { String[] requestedExtensions = inputExtension.split(","); for (String extension : requestedExtensions) { ExtensionRequestData extensionData = ExtensionRequestData.parseExtensionRequest(extension); if (!EXTENSION_REGISTERED_NAME.equalsIgnoreCase(
/* class WebSocket */ extensionData.getExtensionName())) { continue; } Map<String, String> headers = extensionData.getExtensionParameters(); return true; } return false; } public String getProvidedExtensionAsClient() { requestedParameters.put(CLIENT_NO_CONTEXT_TAKEOVER, ExtensionRequestData.EMPTY_VALUE); requestedParameters.put(SERVER_NO_CONTEXT_TAKEOVER, ExtensionRequestData.EMPTY_VALUE); return EXTENSION_REGISTERED_NAME + "; " + SERVER_NO_CONTEXT_TAKEOVER + "; " + CLIENT_NO_CONTEXT_TAKEOVER; } public String getProvidedExtensionAsServer() { return EXTENSION_REGISTERED_NAME + "; " + SERVER_NO_CONTEXT_TAKEOVER + (clientNoContextTakeover ? "; " + CLIENT_NO_CONTEXT_TAKEOVER : ""); } public IExtension copyInstance() { return new PerMessageDeflateExtension(); } public void isFrameValid(Framedata inputFrame) throws InvalidDataException { if ((inputFrame instanceof ContinuousFrame) && (inputFrame.isRSV1() || inputFrame.isRSV2() || inputFrame.isRSV3())) { throw new InvalidFrameException( "bad rsv RSV1: " + inputFrame.isRSV1() + " RSV2: " + inputFrame.isRSV2() + " RSV3: " + inputFrame.isRSV3()); } super.isFrameValid(inputFrame); } public String toString() { return "PerMessageDeflateExtension"; } } 
@SuppressWarnings({"unchecked", "deprecation"})
class PingFrame extends ControlFrame { public PingFrame() { super(Opcode.PING); } } 
@SuppressWarnings({"unchecked", "deprecation"})
class PongFrame extends ControlFrame { public PongFrame() { super(Opcode.PONG); } public PongFrame(PingFrame pingFrame) { super(Opcode.PONG); setPayload(pingFrame.getPayloadData()); } } 
@SuppressWarnings({"unchecked", "deprecation"})
class Protocol implements IProtocol { private static final Pattern patternSpace = Pattern.compile(" "); private static final Pattern patternComma = Pattern.compile(","); private final String providedProtocol; public Protocol(String providedProtocol) { if (providedProtocol == null) { throw new IllegalArgumentException(); } this.providedProtocol = providedProtocol; } public boolean acceptProvidedProtocol(String inputProtocolHeader) { if ("".equals(providedProtocol)) { return true; } String protocolHeader = patternSpace.matcher(inputProtocolHeader).replaceAll(""); String[] headers = patternComma.split(protocolHeader); for (String header : headers) { if (providedProtocol.equals(header)) { return true; } } return false; } public String getProvidedProtocol() { return this.providedProtocol; } public IProtocol copyInstance() { return new Protocol(getProvidedProtocol()); } public String toString() { return getProvidedProtocol(); } public boolean equals(Object o) { if (this == o) { return true; } if (o == null || getClass() != o.getClass()) { return false; } Protocol protocol = (Protocol) o; return providedProtocol.equals(protocol.providedProtocol); } public int hashCode() { return providedProtocol.hashCode(); } } enum ReadyState { NOT_YET_CONNECTED, OPEN, CLOSING, CLOSED } enum Role { CLIENT, SERVER } interface ServerHandshake extends Handshakedata { short getHttpStatus(); String getHttpStatusMessage(); } interface ServerHandshakeBuilder extends HandshakeBuilder, ServerHandshake { void setHttpStatus(short status); void setHttpStatusMessage(String message); } 
@SuppressWarnings({"unchecked", "deprecation"})
class SocketChannelIOHelper { private SocketChannelIOHelper() { throw new IllegalStateException("Utility class"); } public static boolean read(final ByteBuffer buf, WebSocketImpl ws, ByteChannel channel) throws IOException { buf.clear(); int read = channel.read(buf); buf.flip(); if (read == -1) { ws.eot(); return false; } return read != 0; } public static boolean readMore(final ByteBuffer buf, WebSocketImpl ws, WrappedByteChannel channel) 
/* class WebSocket */ throws IOException { buf.clear(); int read = channel.readMore(buf); buf.flip(); if (read == -1) { ws.eot(); return false; } return channel.isNeedRead(); } public static boolean batch(WebSocketImpl ws, ByteChannel sockchannel) throws IOException { if (ws == null) { return false; } ByteBuffer buffer = ws.outQueue.peek(); WrappedByteChannel c = null; if (buffer == null) { if (sockchannel instanceof WrappedByteChannel) { c = (WrappedByteChannel) sockchannel; if (c.isNeedWrite()) { c.writeMore(); } } } else { do { sockchannel.write(buffer); if (buffer.remaining() > 0) { return false; } else { ws.outQueue.poll();  buffer = ws.outQueue.peek(); } } while (buffer != null); } if (ws.outQueue.isEmpty() && ws.isFlushAndClose() && ws.getDraft() != null && ws.getDraft().getRole() != null && ws.getDraft().getRole() == Role.SERVER) { ws.closeConnection(); } return c == null || !((WrappedByteChannel) sockchannel).isNeedWrite(); } } 
@SuppressWarnings({"unchecked", "deprecation"})
class SSLParametersWebSocketServerFactory extends DefaultSSLWebSocketServerFactory { private final SSLParameters sslParameters; public SSLParametersWebSocketServerFactory(SSLContext sslContext, SSLParameters sslParameters) { this(sslContext, Executors.newSingleThreadScheduledExecutor(), sslParameters); } public SSLParametersWebSocketServerFactory(SSLContext sslContext, ExecutorService executerService, SSLParameters sslParameters) { super(sslContext, executerService); if (sslParameters == null) { throw new IllegalArgumentException(); } this.sslParameters = sslParameters; } public ByteChannel wrapChannel(SocketChannel channel, SelectionKey key) throws IOException { SSLEngine e = sslcontext.createSSLEngine(); e.setUseClientMode(false); e.setSSLParameters(sslParameters); return new SSLSocketChannel2(channel, e, exec, key); } } 
@SuppressWarnings({"unchecked", "deprecation"})
class SSLSocketChannel implements WrappedByteChannel, ByteChannel, ISSLChannel { private final SocketChannel socketChannel; private final SSLEngine engine; private ByteBuffer myAppData; private ByteBuffer myNetData; private ByteBuffer peerAppData; private ByteBuffer peerNetData; private ExecutorService executor; public SSLSocketChannel(SocketChannel inputSocketChannel, SSLEngine inputEngine, ExecutorService inputExecutor, SelectionKey key) throws IOException { if (inputSocketChannel == null || inputEngine == null || executor == inputExecutor) { throw new IllegalArgumentException("parameter must not be null"); } this.socketChannel = inputSocketChannel; this.engine = inputEngine; this.executor = inputExecutor; myNetData = ByteBuffer.allocate(engine.getSession().getPacketBufferSize()); peerNetData = ByteBuffer.allocate(engine.getSession().getPacketBufferSize()); this.engine.beginHandshake(); if (doHandshake()) { if (key != null) { key.interestOps(key.interestOps() | SelectionKey.OP_WRITE); } } else { try { socketChannel.close(); } catch (IOException e) { } } } public synchronized int read(ByteBuffer dst) throws IOException { if (!dst.hasRemaining()) { return 0; } if (peerAppData.hasRemaining()) { peerAppData.flip(); return ByteBufferUtils.transferByteBuffer(peerAppData, dst); } peerNetData.compact(); int bytesRead = socketChannel.read(peerNetData); if (bytesRead > 0 || peerNetData.hasRemaining()) { peerNetData.flip(); while (peerNetData.hasRemaining()) { peerAppData.compact(); SSLEngineResult result; try { result = engine.unwrap(peerNetData, peerAppData); } catch (SSLException e) { throw e; } switch (result.getStatus()) { case OK: peerAppData.flip(); 
/* class WebSocket */ return ByteBufferUtils.transferByteBuffer(peerAppData, dst); case BUFFER_UNDERFLOW: peerAppData.flip(); return ByteBufferUtils.transferByteBuffer(peerAppData, dst); case BUFFER_OVERFLOW: peerAppData = enlargeApplicationBuffer(peerAppData); return read(dst); case CLOSED: closeConnection(); dst.clear(); return -1; default: throw new IllegalStateException("Invalid SSL status: " + result.getStatus()); } } } else if (bytesRead < 0) { handleEndOfStream(); } ByteBufferUtils.transferByteBuffer(peerAppData, dst); return bytesRead; } public synchronized int write(ByteBuffer output) throws IOException { int num = 0; while (output.hasRemaining()) { myNetData.clear(); SSLEngineResult result = engine.wrap(output, myNetData); switch (result.getStatus()) { case OK: myNetData.flip(); while (myNetData.hasRemaining()) { num += socketChannel.write(myNetData); } break; case BUFFER_OVERFLOW: myNetData = enlargePacketBuffer(myNetData); break; case BUFFER_UNDERFLOW: throw new SSLException( "Buffer underflow occurred after a wrap. I don't think we should ever get here."); case CLOSED: closeConnection(); return 0; default: throw new IllegalStateException("Invalid SSL status: " + result.getStatus()); } } return num; } private boolean doHandshake() throws IOException { SSLEngineResult result; SSLEngineResult.HandshakeStatus handshakeStatus; int appBufferSize = engine.getSession().getApplicationBufferSize(); myAppData = ByteBuffer.allocate(appBufferSize); peerAppData = ByteBuffer.allocate(appBufferSize); myNetData.clear(); peerNetData.clear(); handshakeStatus = engine.getHandshakeStatus(); boolean handshakeComplete = false; while (!handshakeComplete) { switch (handshakeStatus) { case FINISHED: handshakeComplete = !this.peerNetData.hasRemaining(); if (handshakeComplete) { return true; } socketChannel.write(this.peerNetData); break; case NEED_UNWRAP: if (socketChannel.read(peerNetData) < 0) { if (engine.isInboundDone() && engine.isOutboundDone()) { return false; } try { engine.closeInbound(); } catch (SSLException e) { } engine.closeOutbound(); handshakeStatus = engine.getHandshakeStatus(); break; } peerNetData.flip(); try { result = engine.unwrap(peerNetData, peerAppData); peerNetData.compact(); handshakeStatus = result.getHandshakeStatus(); } catch (SSLException sslException) { engine.closeOutbound(); handshakeStatus = engine.getHandshakeStatus(); break; } switch (result.getStatus()) { case OK: break; case BUFFER_OVERFLOW: peerAppData = enlargeApplicationBuffer(peerAppData); break; case BUFFER_UNDERFLOW: peerNetData = handleBufferUnderflow(peerNetData); break; case CLOSED: if (engine.isOutboundDone()) { return false; } else { engine.closeOutbound(); handshakeStatus = engine.getHandshakeStatus(); break; } default: throw new IllegalStateException("Invalid SSL status: " + result.getStatus()); } break; case NEED_WRAP: myNetData.clear(); try { result = engine.wrap(myAppData, myNetData); handshakeStatus = result.getHandshakeStatus(); } catch (SSLException sslException) { engine.closeOutbound(); handshakeStatus = engine.getHandshakeStatus(); break; } switch (result.getStatus()) { case OK: myNetData.flip(); while (myNetData.hasRemaining()) { socketChannel.write(myNetData); } break; case BUFFER_OVERFLOW: myNetData = enlargePacketBuffer(myNetData); break; case BUFFER_UNDERFLOW: throw new SSLException( "Buffer underflow occurred after a wrap. I don't think we should ever get here."); case CLOSED: try { myNetData.flip(); 
/* class WebSocket */ while (myNetData.hasRemaining()) { socketChannel.write(myNetData); } peerNetData.clear(); } catch (Exception e) { handshakeStatus = engine.getHandshakeStatus(); } break; default: throw new IllegalStateException("Invalid SSL status: " + result.getStatus()); } break; case NEED_TASK: Runnable task; while ((task = engine.getDelegatedTask()) != null) { executor.execute(task); } handshakeStatus = engine.getHandshakeStatus(); break; case NOT_HANDSHAKING: break; default: throw new IllegalStateException("Invalid SSL status: " + handshakeStatus); } } return true; } private ByteBuffer enlargePacketBuffer(ByteBuffer buffer) { return enlargeBuffer(buffer, engine.getSession().getPacketBufferSize()); } private ByteBuffer enlargeApplicationBuffer(ByteBuffer buffer) { return enlargeBuffer(buffer, engine.getSession().getApplicationBufferSize()); } private ByteBuffer enlargeBuffer(ByteBuffer buffer, int sessionProposedCapacity) { if (sessionProposedCapacity > buffer.capacity()) { buffer = ByteBuffer.allocate(sessionProposedCapacity); } else { buffer = ByteBuffer.allocate(buffer.capacity() * 2); } return buffer; } private ByteBuffer handleBufferUnderflow(ByteBuffer buffer) { if (engine.getSession().getPacketBufferSize() < buffer.limit()) { return buffer; } else { ByteBuffer replaceBuffer = enlargePacketBuffer(buffer); buffer.flip(); replaceBuffer.put(buffer); return replaceBuffer; } } private void closeConnection() throws IOException { engine.closeOutbound(); try { doHandshake(); } catch (IOException e) { } socketChannel.close(); } private void handleEndOfStream() throws IOException { try { engine.closeInbound(); } catch (Exception e) { } closeConnection(); } public boolean isNeedWrite() { return false; } public void writeMore() throws IOException { } public boolean isNeedRead() { return peerNetData.hasRemaining() || peerAppData.hasRemaining(); } public int readMore(ByteBuffer dst) throws IOException { return read(dst); } public boolean isBlocking() { return socketChannel.isBlocking(); } public boolean isOpen() { return socketChannel.isOpen(); } public void close() throws IOException { closeConnection(); } public SSLEngine getSSLEngine() { return engine; } } 
@SuppressWarnings({"unchecked", "deprecation"})
class SSLSocketChannel2 implements ByteChannel, WrappedByteChannel, ISSLChannel { protected static ByteBuffer emptybuffer = ByteBuffer.allocate(0); protected ExecutorService exec; protected List<Future<?>> tasks; protected ByteBuffer inData; protected ByteBuffer outCrypt; protected ByteBuffer inCrypt; protected SocketChannel socketChannel; protected SelectionKey selectionKey; protected SSLEngine sslEngine; protected SSLEngineResult readEngineResult; protected SSLEngineResult writeEngineResult; protected int bufferallocations = 0; public SSLSocketChannel2(SocketChannel channel, SSLEngine sslEngine, ExecutorService exec, SelectionKey key) throws IOException { if (channel == null || sslEngine == null || exec == null) { throw new IllegalArgumentException("parameter must not be null"); } this.socketChannel = channel; this.sslEngine = sslEngine; this.exec = exec; readEngineResult = writeEngineResult = new SSLEngineResult(SSLEngineResult.Status.BUFFER_UNDERFLOW, sslEngine.getHandshakeStatus(), 0, 0); tasks = new ArrayList<Future<?>>(3); if (key != null) { key.interestOps(key.interestOps() | SelectionKey.OP_WRITE); this.selectionKey = key; } createBuffers(sslEngine.getSession()); socketChannel.write(wrap(emptybuffer)); processHandshake(); } 
/* class WebSocket */ private void consumeFutureUninterruptible(Future<?> f) { try { while (true) { try { f.get(); break; } catch (InterruptedException e) { Thread.currentThread().interrupt(); } } } catch (ExecutionException e) { throw new RuntimeException(e); } } private synchronized void processHandshake() throws IOException { if (sslEngine.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) { return;  } if (!tasks.isEmpty()) { Iterator<Future<?>> it = tasks.iterator(); while (it.hasNext()) { Future<?> f = it.next(); if (f.isDone()) { it.remove(); } else { if (isBlocking()) { consumeFutureUninterruptible(f); } return; } } } if (sslEngine.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_UNWRAP) { if (!isBlocking() || readEngineResult.getStatus() == SSLEngineResult.Status.BUFFER_UNDERFLOW) { inCrypt.compact(); int read = socketChannel.read(inCrypt); if (read == -1) { throw new IOException("connection closed unexpectedly by peer"); } inCrypt.flip(); } inData.compact(); unwrap(); if (readEngineResult.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.FINISHED) { createBuffers(sslEngine.getSession()); return; } } consumeDelegatedTasks(); if (tasks.isEmpty() || sslEngine.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_WRAP) { socketChannel.write(wrap(emptybuffer)); if (writeEngineResult.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.FINISHED) { createBuffers(sslEngine.getSession()); return; } } assert (sslEngine.getHandshakeStatus() != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING); bufferallocations = 1; } private synchronized ByteBuffer wrap(ByteBuffer b) throws SSLException { outCrypt.compact(); writeEngineResult = sslEngine.wrap(b, outCrypt); outCrypt.flip(); return outCrypt; } private synchronized ByteBuffer unwrap() throws SSLException { int rem; if (readEngineResult.getStatus() == SSLEngineResult.Status.CLOSED && sslEngine.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) { try { close(); } catch (IOException e) { } } do { rem = inData.remaining(); readEngineResult = sslEngine.unwrap(inCrypt, inData); } while (readEngineResult.getStatus() == SSLEngineResult.Status.OK && (rem != inData.remaining() || sslEngine.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_UNWRAP)); inData.flip(); return inData; } protected void consumeDelegatedTasks() { Runnable task; while ((task = sslEngine.getDelegatedTask()) != null) { tasks.add(exec.submit(task)); } } protected void createBuffers(SSLSession session) { saveCryptedData();  int netBufferMax = session.getPacketBufferSize(); int appBufferMax = Math.max(session.getApplicationBufferSize(), netBufferMax); if (inData == null) { inData = ByteBuffer.allocate(appBufferMax); outCrypt = ByteBuffer.allocate(netBufferMax); inCrypt = ByteBuffer.allocate(netBufferMax); } else { if (inData.capacity() != appBufferMax) { inData = ByteBuffer.allocate(appBufferMax); } if (outCrypt.capacity() != netBufferMax) { outCrypt = ByteBuffer.allocate(netBufferMax); } if (inCrypt.capacity() != netBufferMax) { inCrypt = ByteBuffer.allocate(netBufferMax); } } inData.rewind(); inData.flip(); inCrypt.rewind(); inCrypt.flip(); outCrypt.rewind(); outCrypt.flip(); bufferallocations++; } public int write(ByteBuffer src) throws IOException { if (!isHandShakeComplete()) { processHandshake(); return 0; } int num = socketChannel.write(wrap(src)); if (writeEngineResult.getStatus() == SSLEngineResult.Status.CLOSED) { throw new EOFException("Connection is closed"); } return num; } 
/* class WebSocket */ public int read(ByteBuffer dst) throws IOException { tryRestoreCryptedData(); while (true) { if (!dst.hasRemaining()) { return 0; } if (!isHandShakeComplete()) { if (isBlocking()) { while (!isHandShakeComplete()) { processHandshake(); } } else { processHandshake(); if (!isHandShakeComplete()) { return 0; } } } int purged = readRemaining(dst); if (purged != 0) { return purged; } assert (inData.position() == 0); inData.clear(); if (!inCrypt.hasRemaining()) { inCrypt.clear(); } else { inCrypt.compact(); } if (isBlocking() || readEngineResult.getStatus() == SSLEngineResult.Status.BUFFER_UNDERFLOW) { if (socketChannel.read(inCrypt) == -1) { return -1; } } inCrypt.flip(); unwrap(); int transferred = transfereTo(inData, dst); if (transferred == 0 && isBlocking()) { continue; } return transferred; } } private int readRemaining(ByteBuffer dst) throws SSLException { if (inData.hasRemaining()) { return transfereTo(inData, dst); } if (!inData.hasRemaining()) { inData.clear(); } tryRestoreCryptedData(); if (inCrypt.hasRemaining()) { unwrap(); int amount = transfereTo(inData, dst); if (readEngineResult.getStatus() == SSLEngineResult.Status.CLOSED) { return -1; } if (amount > 0) { return amount; } } return 0; } public boolean isConnected() { return socketChannel.isConnected(); } public void close() throws IOException { sslEngine.closeOutbound(); sslEngine.getSession().invalidate(); try { if (socketChannel.isOpen()) { socketChannel.write(wrap(emptybuffer)); } } finally {  socketChannel.close(); } } private boolean isHandShakeComplete() { SSLEngineResult.HandshakeStatus status = sslEngine.getHandshakeStatus(); return status == SSLEngineResult.HandshakeStatus.FINISHED || status == SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING; } public SelectableChannel configureBlocking(boolean b) throws IOException { return socketChannel.configureBlocking(b); } public boolean connect(SocketAddress remote) throws IOException { return socketChannel.connect(remote); } public boolean finishConnect() throws IOException { return socketChannel.finishConnect(); } public Socket socket() { return socketChannel.socket(); } public boolean isInboundDone() { return sslEngine.isInboundDone(); } public boolean isOpen() { return socketChannel.isOpen(); } public boolean isNeedWrite() { return outCrypt.hasRemaining() || !isHandShakeComplete();  } public void writeMore() throws IOException { write(outCrypt); } public boolean isNeedRead() { return saveCryptData != null || inData.hasRemaining() || (inCrypt.hasRemaining() && readEngineResult.getStatus() != SSLEngineResult.Status.BUFFER_UNDERFLOW && readEngineResult.getStatus() != SSLEngineResult.Status.CLOSED); } public int readMore(ByteBuffer dst) throws SSLException { return readRemaining(dst); } private int transfereTo(ByteBuffer from, ByteBuffer to) { int fremain = from.remaining(); int toremain = to.remaining(); if (fremain > toremain) { int limit = Math.min(fremain, toremain); for (int i = 0; i < limit; i++) { to.put(from.get()); } return limit; } else { to.put(from); return fremain; } } public boolean isBlocking() { return socketChannel.isBlocking(); } public SSLEngine getSSLEngine() { return sslEngine; } private byte[] saveCryptData = null; private void saveCryptedData() { if (inCrypt != null && inCrypt.remaining() > 0) { int saveCryptSize = inCrypt.remaining(); saveCryptData = new byte[saveCryptSize]; inCrypt.get(saveCryptData); } } private void tryRestoreCryptedData() { if (saveCryptData != null) { inCrypt.clear(); inCrypt.put(saveCryptData); inCrypt.flip(); saveCryptData = null; } } } 
/* class WebSocket */ 
@SuppressWarnings({"unchecked", "deprecation"})
class TextFrame extends DataFrame { public TextFrame() { super(Opcode.TEXT); } public void isValid() throws InvalidDataException { super.isValid(); if (!Charsetfunctions.isValidUTF8(getPayloadData())) { throw new InvalidDataException(CloseFrame.NO_UTF8, "Received text is no valid utf8 string!"); } } } interface WebSocket { void close(int code, String message); void close(int code); void close(); void closeConnection(int code, String message); void send(String text); void send(ByteBuffer bytes); void send(byte[] bytes); void sendFrame(Framedata framedata); void sendFrame(Collection<Framedata> frames); void sendPing(); void sendFragmentedFrame(Opcode op, ByteBuffer buffer, boolean fin); boolean hasBufferedData(); InetSocketAddress getRemoteSocketAddress(); InetSocketAddress getLocalSocketAddress(); boolean isOpen(); boolean isClosing(); boolean isFlushAndClose(); boolean isClosed(); Draft getDraft(); ReadyState getReadyState(); String getResourceDescriptor(); <T> void setAttachment(T attachment); <T> T getAttachment(); boolean hasSSLSupport(); SSLSession getSSLSession() throws IllegalArgumentException; IProtocol getProtocol(); } 
@SuppressWarnings({"unchecked", "deprecation"})
abstract class WebSocketAdapter implements WebSocketListener { private PingFrame pingFrame; public ServerHandshakeBuilder onWebsocketHandshakeReceivedAsServer(WebSocket conn, Draft draft, ClientHandshake request) throws InvalidDataException { return new HandshakeImpl1Server(); } public void onWebsocketHandshakeReceivedAsClient(WebSocket conn, ClientHandshake request, ServerHandshake response) throws InvalidDataException { } public void onWebsocketHandshakeSentAsClient(WebSocket conn, ClientHandshake request) throws InvalidDataException { } public void onWebsocketPing(WebSocket conn, Framedata f) { conn.sendFrame(new PongFrame((PingFrame) f)); } public void onWebsocketPong(WebSocket conn, Framedata f) { } public PingFrame onPreparePing(WebSocket conn) { if (pingFrame == null) { pingFrame = new PingFrame(); } return pingFrame; } } 
@SuppressWarnings({"unchecked", "deprecation"})
abstract class WebSocketClient extends AbstractWebSocket implements Runnable, WebSocket { protected URI uri = null; private WebSocketImpl engine = null; private Socket socket = null; private javax.net.SocketFactory socketFactory = null; private OutputStream ostream; private Proxy proxy = Proxy.NO_PROXY; private Thread writeThread; private Thread connectReadThread; private Draft draft; private Map<String, String> headers; private CountDownLatch connectLatch = new CountDownLatch(1); private CountDownLatch closeLatch = new CountDownLatch(1); private int connectTimeout = 0; private DnsResolver dnsResolver = null; public WebSocketClient(URI serverUri) { this(serverUri, new Draft_6455()); } public WebSocketClient(URI serverUri, Draft protocolDraft) { this(serverUri, protocolDraft, null, 0); } public WebSocketClient(URI serverUri, Map<String, String> httpHeaders) { this(serverUri, new Draft_6455(), httpHeaders); } public WebSocketClient(URI serverUri, Draft protocolDraft, Map<String, String> httpHeaders) { this(serverUri, protocolDraft, httpHeaders, 0); } public WebSocketClient(URI serverUri, Draft protocolDraft, Map<String, String> httpHeaders, int connectTimeout) { if (serverUri == null) { throw new IllegalArgumentException(); } else if (protocolDraft == null) { throw new IllegalArgumentException("null as draft is permitted for `WebSocketServer` only!"); } this.uri = serverUri; this.draft = protocolDraft; this.dnsResolver = new DnsResolver() { public InetAddress resolve(URI uri) 
/* class WebSocket */ throws UnknownHostException { return InetAddress.getByName(uri.getHost()); } }; if (httpHeaders != null) { headers = new TreeMap<>(String.CASE_INSENSITIVE_ORDER); headers.putAll(httpHeaders); } this.connectTimeout = connectTimeout; setTcpNoDelay(false); setReuseAddr(false); this.engine = new WebSocketImpl(this, protocolDraft); } public URI getURI() { return uri; } public Draft getDraft() { return draft; } public Socket getSocket() { return socket; } public void addHeader(String key, String value) { if (headers == null) { headers = new TreeMap<>(String.CASE_INSENSITIVE_ORDER); } headers.put(key, value); } public String removeHeader(String key) { if (headers == null) { return null; } return headers.remove(key); } public void clearHeaders() { headers = null; } public void setDnsResolver(DnsResolver dnsResolver) { this.dnsResolver = dnsResolver; } public void reconnect() { reset(); connect(); } public boolean reconnectBlocking() throws InterruptedException { reset(); return connectBlocking(); } private void reset() { Thread current = Thread.currentThread(); if (current == writeThread || current == connectReadThread) { throw new IllegalStateException( "You cannot initialize a reconnect out of the websocket thread. Use reconnect in another thread to ensure a successful cleanup."); } try { if (engine.getReadyState() == ReadyState.NOT_YET_CONNECTED && socket != null) { socket.close(); } closeBlocking(); if (writeThread != null) { this.writeThread.interrupt(); this.writeThread.join(); this.writeThread = null; } if (connectReadThread != null) { this.connectReadThread.interrupt(); this.connectReadThread.join(); this.connectReadThread = null; } this.draft.reset(); if (this.socket != null) { this.socket.close(); this.socket = null; } } catch (Exception e) { onError(e); engine.closeConnection(CloseFrame.ABNORMAL_CLOSE, e.getMessage()); return; } connectLatch = new CountDownLatch(1); closeLatch = new CountDownLatch(1); this.engine = new WebSocketImpl(this, this.draft); } public void connect() { if (connectReadThread != null) { throw new IllegalStateException("WebSocketClient objects are not reuseable"); } connectReadThread = new Thread(this); connectReadThread.setDaemon(isDaemon()); connectReadThread.setName("WebSocketConnectReadThread-" + connectReadThread.getId()); connectReadThread.start(); } public boolean connectBlocking() throws InterruptedException { connect(); connectLatch.await(); return engine.isOpen(); } public boolean connectBlocking(long timeout, TimeUnit timeUnit) throws InterruptedException { connect(); boolean connected = connectLatch.await(timeout, timeUnit); if (!connected) { reset(); } return connected && engine.isOpen(); } public void close() { if (writeThread != null) { engine.close(CloseFrame.NORMAL); } } public void closeBlocking() throws InterruptedException { close(); closeLatch.await(); } public void send(String text) { engine.send(text); } public void send(byte[] data) { engine.send(data); } public <T> T getAttachment() { return engine.getAttachment(); } public <T> void setAttachment(T attachment) { engine.setAttachment(attachment); } protected Collection<WebSocket> getConnections() { return Collections.singletonList((WebSocket) engine); } public void sendPing() { engine.sendPing(); } public void run() { InputStream istream; try { boolean upgradeSocketToSSLSocket = prepareSocket(); socket.setTcpNoDelay(isTcpNoDelay()); socket.setReuseAddress(isReuseAddr()); if (!socket.isConnected()) { 
/* class WebSocket */ InetSocketAddress addr = dnsResolver == null ? InetSocketAddress.createUnresolved(uri.getHost(), getPort()) : new InetSocketAddress(dnsResolver.resolve(uri), this.getPort()); socket.connect(addr, connectTimeout); } if (upgradeSocketToSSLSocket && "wss".equals(uri.getScheme())) { upgradeSocketToSSL(); } if (socket instanceof SSLSocket) { SSLSocket sslSocket = (SSLSocket) socket; SSLParameters sslParameters = sslSocket.getSSLParameters(); onSetSSLParameters(sslParameters); sslSocket.setSSLParameters(sslParameters); } istream = socket.getInputStream(); ostream = socket.getOutputStream(); sendHandshake(); } catch (Exception e) { onWebsocketError(engine, e); engine.closeConnection(CloseFrame.NEVER_CONNECTED, e.getMessage()); return; } catch (InternalError e) { if (e.getCause() instanceof InvocationTargetException && e.getCause() .getCause() instanceof IOException) { IOException cause = (IOException) e.getCause().getCause(); onWebsocketError(engine, cause); engine.closeConnection(CloseFrame.NEVER_CONNECTED, cause.getMessage()); return; } throw e; } if (writeThread != null) { writeThread.interrupt(); try { writeThread.join(); } catch (InterruptedException e) { } } writeThread = new Thread(new WebsocketWriteThread(this)); writeThread.setDaemon(isDaemon()); writeThread.start(); byte[] rawbuffer = new byte[WebSocketImpl.RCVBUF]; int readBytes; try { while (!isClosing() && !isClosed() && (readBytes = istream.read(rawbuffer)) != -1) { engine.decode(ByteBuffer.wrap(rawbuffer, 0, readBytes)); } engine.eot(); } catch (IOException e) { handleIOException(e); } catch (RuntimeException e) { onError(e); engine.closeConnection(CloseFrame.ABNORMAL_CLOSE, e.getMessage()); } } private void upgradeSocketToSSL() throws NoSuchAlgorithmException, KeyManagementException, IOException { SSLSocketFactory factory; if (socketFactory instanceof SSLSocketFactory) { factory = (SSLSocketFactory) socketFactory; } else { factory = (SSLSocketFactory) SSLSocketFactory.getDefault(); } socket = factory.createSocket(socket, uri.getHost(), getPort(), true); } private boolean prepareSocket() throws IOException { boolean upgradeSocketToSSLSocket = false; if (proxy != Proxy.NO_PROXY) { socket = new Socket(proxy); upgradeSocketToSSLSocket = true; } else if (socketFactory != null) { socket = socketFactory.createSocket(); } else if (socket == null) { socket = new Socket(proxy); upgradeSocketToSSLSocket = true; } else if (socket.isClosed()) { throw new IOException(); } return upgradeSocketToSSLSocket; } protected void onSetSSLParameters(SSLParameters sslParameters) { sslParameters.setEndpointIdentificationAlgorithm("HTTPS"); } private int getPort() { int port = uri.getPort(); String scheme = uri.getScheme(); if ("wss".equals(scheme)) { return port == -1 ? WebSocketImpl.DEFAULT_WSS_PORT : port; } else if ("ws".equals(scheme)) { return port == -1 ? WebSocketImpl.DEFAULT_PORT : port; } else { throw new IllegalArgumentException("unknown scheme: " + scheme); } } private void sendHandshake() throws InvalidHandshakeException { String path; String part1 = uri.getRawPath(); String part2 = uri.getRawQuery(); if (part1 == null || part1.length() == 0) { path = "/"; } else { path = part1; } if (part2 != null) { path += '?' + part2; } int port = getPort(); String host = uri.getHost() + ( (port != WebSocketImpl.DEFAULT_PORT && port != WebSocketImpl.DEFAULT_WSS_PORT) ? ":" + port : ""); HandshakeImpl1Client handshake = new HandshakeImpl1Client(); handshake.setResourceDescriptor(path); handshake.put("Host", host); 
/* class WebSocket */ if (headers != null) { for (Map.Entry<String, String> kv : headers.entrySet()) { handshake.put(kv.getKey(), kv.getValue()); } } engine.startHandshake(handshake); } public ReadyState getReadyState() { return engine.getReadyState(); } public final void onWebsocketMessage(WebSocket conn, String message) { onMessage(message); } public final void onWebsocketMessage(WebSocket conn, ByteBuffer blob) { onMessage(blob); } public final void onWebsocketOpen(WebSocket conn, Handshakedata handshake) { startConnectionLostTimer(); onOpen((ServerHandshake) handshake); connectLatch.countDown(); } public final void onWebsocketClose(WebSocket conn, int code, String reason, boolean remote) { stopConnectionLostTimer(); if (writeThread != null) { writeThread.interrupt(); } onClose(code, reason, remote); connectLatch.countDown(); closeLatch.countDown(); } public final void onWebsocketError(WebSocket conn, Exception ex) { onError(ex); } public final void onWriteDemand(WebSocket conn) { } public void onWebsocketCloseInitiated(WebSocket conn, int code, String reason) { onCloseInitiated(code, reason); } public void onWebsocketClosing(WebSocket conn, int code, String reason, boolean remote) { onClosing(code, reason, remote); } public void onCloseInitiated(int code, String reason) { } public void onClosing(int code, String reason, boolean remote) { } public WebSocket getConnection() { return engine; } public InetSocketAddress getLocalSocketAddress(WebSocket conn) { if (socket != null) { return (InetSocketAddress) socket.getLocalSocketAddress(); } return null; } public InetSocketAddress getRemoteSocketAddress(WebSocket conn) { if (socket != null) { return (InetSocketAddress) socket.getRemoteSocketAddress(); } return null; } public abstract void onOpen(ServerHandshake handshakedata); public abstract void onMessage(String message); public abstract void onClose(int code, String reason, boolean remote); public abstract void onError(Exception ex); public void onMessage(ByteBuffer bytes) { } 
@SuppressWarnings({"unchecked", "deprecation"})
private class WebsocketWriteThread implements Runnable { private final WebSocketClient webSocketClient; WebsocketWriteThread(WebSocketClient webSocketClient) { this.webSocketClient = webSocketClient; } public void run() { Thread.currentThread().setName("WebSocketWriteThread-" + Thread.currentThread().getId()); try { runWriteData(); } catch (IOException e) { handleIOException(e); } finally { closeSocket(); } } private void runWriteData() throws IOException { try { while (!Thread.interrupted()) { ByteBuffer buffer = engine.outQueue.take(); ostream.write(buffer.array(), 0, buffer.limit()); ostream.flush(); } } catch (InterruptedException e) { for (ByteBuffer buffer : engine.outQueue) { ostream.write(buffer.array(), 0, buffer.limit()); ostream.flush(); } Thread.currentThread().interrupt(); } } private void closeSocket() { try { if (socket != null) { socket.close(); } } catch (IOException ex) { onWebsocketError(webSocketClient, ex); } } } public void setProxy(Proxy proxy) { if (proxy == null) { throw new IllegalArgumentException(); } this.proxy = proxy; } @Deprecated public void setSocket(Socket socket) { if (this.socket != null) { throw new IllegalStateException("socket has already been set"); } this.socket = socket; } public void setSocketFactory(javax.net.SocketFactory socketFactory) { this.socketFactory = socketFactory; } public void sendFragmentedFrame(Opcode op, ByteBuffer buffer, boolean fin) { engine.sendFragmentedFrame(op, buffer, fin); } public boolean isOpen() { return engine.isOpen(); } 
/* class WebSocket */ public boolean isFlushAndClose() { return engine.isFlushAndClose(); } public boolean isClosed() { return engine.isClosed(); } public boolean isClosing() { return engine.isClosing(); } public boolean hasBufferedData() { return engine.hasBufferedData(); } public void close(int code) { engine.close(code); } public void close(int code, String message) { engine.close(code, message); } public void closeConnection(int code, String message) { engine.closeConnection(code, message); } public void send(ByteBuffer bytes) { engine.send(bytes); } public void sendFrame(Framedata framedata) { engine.sendFrame(framedata); } public void sendFrame(Collection<Framedata> frames) { engine.sendFrame(frames); } public InetSocketAddress getLocalSocketAddress() { return engine.getLocalSocketAddress(); } public InetSocketAddress getRemoteSocketAddress() { return engine.getRemoteSocketAddress(); } public String getResourceDescriptor() { return uri.getPath(); } public boolean hasSSLSupport() { return socket instanceof SSLSocket; } public SSLSession getSSLSession() { if (!hasSSLSupport()) { throw new IllegalArgumentException( "This websocket uses ws instead of wss. No SSLSession available."); } return ((SSLSocket)socket).getSession(); } public IProtocol getProtocol() { return engine.getProtocol(); } private void handleIOException(IOException e) { if (e instanceof SSLException) { onError(e); } engine.eot(); } } interface WebSocketFactory { WebSocket createWebSocket(WebSocketAdapter a, Draft d); WebSocket createWebSocket(WebSocketAdapter a, List<Draft> drafts); } 
@SuppressWarnings({"unchecked", "deprecation"})
class WebSocketImpl implements WebSocket { public static final int DEFAULT_PORT = 80; public static final int DEFAULT_WSS_PORT = 443; public static final int RCVBUF = 16384; public final BlockingQueue<ByteBuffer> outQueue; public final BlockingQueue<ByteBuffer> inQueue; private final WebSocketListener wsl; private SelectionKey key; private ByteChannel channel; private WebSocketServer.WebSocketWorker workerThread; private boolean flushandclosestate = false; private volatile ReadyState readyState = ReadyState.NOT_YET_CONNECTED; private List<Draft> knownDrafts; private Draft draft = null; private Role role; private ByteBuffer tmpHandshakeBytes = ByteBuffer.allocate(0); private ClientHandshake handshakerequest = null; private String closemessage = null; private Integer closecode = null; private Boolean closedremotely = null; private String resourceDescriptor = null; private long lastPong = System.nanoTime(); private final Object synchronizeWriteObject = new Object(); private Object attachment; public WebSocketImpl(WebSocketListener listener, List<Draft> drafts) { this(listener, (Draft) null); this.role = Role.SERVER; if (drafts == null || drafts.isEmpty()) { knownDrafts = new ArrayList<>(); knownDrafts.add(new Draft_6455()); } else { knownDrafts = drafts; } } public WebSocketImpl(WebSocketListener listener, Draft draft) { if (listener == null || (draft == null && role == Role.SERVER)) { throw new IllegalArgumentException("parameters must not be null"); } this.outQueue = new LinkedBlockingQueue<>(); inQueue = new LinkedBlockingQueue<>(); this.wsl = listener; this.role = Role.CLIENT; if (draft != null) { this.draft = draft.copyInstance(); } } public void decode(ByteBuffer socketBuffer) { assert (socketBuffer.hasRemaining()); if (readyState != ReadyState.NOT_YET_CONNECTED) { if (readyState == ReadyState.OPEN) { decodeFrames(socketBuffer); } } else { if (decodeHandshake(socketBuffer) && (!isClosing() && !isClosed())) { 
/* class WebSocket */ assert (tmpHandshakeBytes.hasRemaining() != socketBuffer.hasRemaining() || !socketBuffer .hasRemaining());  if (socketBuffer.hasRemaining()) { decodeFrames(socketBuffer); } else if (tmpHandshakeBytes.hasRemaining()) { decodeFrames(tmpHandshakeBytes); } } } } private boolean decodeHandshake(ByteBuffer socketBufferNew) { ByteBuffer socketBuffer; if (tmpHandshakeBytes.capacity() == 0) { socketBuffer = socketBufferNew; } else { if (tmpHandshakeBytes.remaining() < socketBufferNew.remaining()) { ByteBuffer buf = ByteBuffer .allocate(tmpHandshakeBytes.capacity() + socketBufferNew.remaining()); tmpHandshakeBytes.flip(); buf.put(tmpHandshakeBytes); tmpHandshakeBytes = buf; } tmpHandshakeBytes.put(socketBufferNew); tmpHandshakeBytes.flip(); socketBuffer = tmpHandshakeBytes; } socketBuffer.mark(); try { HandshakeState handshakestate; try { if (role == Role.SERVER) { if (draft == null) { for (Draft d : knownDrafts) { d = d.copyInstance(); try { d.setParseMode(role); socketBuffer.reset(); Handshakedata tmphandshake = d.translateHandshake(socketBuffer); if (!(tmphandshake instanceof ClientHandshake)) { closeConnectionDueToWrongHandshake( new InvalidDataException(CloseFrame.PROTOCOL_ERROR, "wrong http function")); return false; } ClientHandshake handshake = (ClientHandshake) tmphandshake; handshakestate = d.acceptHandshakeAsServer(handshake); if (handshakestate == HandshakeState.MATCHED) { resourceDescriptor = handshake.getResourceDescriptor(); ServerHandshakeBuilder response; try { response = wsl.onWebsocketHandshakeReceivedAsServer(this, d, handshake); } catch (InvalidDataException e) { closeConnectionDueToWrongHandshake(e); return false; } catch (RuntimeException e) { wsl.onWebsocketError(this, e); closeConnectionDueToInternalServerError(e); return false; } write(d.createHandshake( d.postProcessHandshakeResponseAsServer(handshake, response))); draft = d; open(handshake); return true; } } catch (InvalidHandshakeException e) { } } if (draft == null) { closeConnectionDueToWrongHandshake( new InvalidDataException(CloseFrame.PROTOCOL_ERROR, "no draft matches")); } return false; } else { Handshakedata tmphandshake = draft.translateHandshake(socketBuffer); if (!(tmphandshake instanceof ClientHandshake)) { flushAndClose(CloseFrame.PROTOCOL_ERROR, "wrong http function", false); return false; } ClientHandshake handshake = (ClientHandshake) tmphandshake; handshakestate = draft.acceptHandshakeAsServer(handshake); if (handshakestate == HandshakeState.MATCHED) { open(handshake); return true; } else { close(CloseFrame.PROTOCOL_ERROR, "the handshake did finally not match"); } return false; } } else if (role == Role.CLIENT) { draft.setParseMode(role); Handshakedata tmphandshake = draft.translateHandshake(socketBuffer); if (!(tmphandshake instanceof ServerHandshake)) { flushAndClose(CloseFrame.PROTOCOL_ERROR, "wrong http function", false); return false; } ServerHandshake handshake = (ServerHandshake) tmphandshake; handshakestate = draft.acceptHandshakeAsClient(handshakerequest, handshake); if (handshakestate == HandshakeState.MATCHED) { try { wsl.onWebsocketHandshakeReceivedAsClient(this, handshakerequest, handshake); } catch (InvalidDataException e) { flushAndClose(e.getCloseCode(), e.getMessage(), false); return false; } catch (RuntimeException e) { wsl.onWebsocketError(this, e); flushAndClose(CloseFrame.NEVER_CONNECTED, e.getMessage(), false); return false; } open(handshake); return true; } else { close(CloseFrame.PROTOCOL_ERROR, "draft " + draft + " refuses handshake"
/* class WebSocket */ ); } } } catch (InvalidHandshakeException e) { close(e); } } catch (IncompleteHandshakeException e) { if (tmpHandshakeBytes.capacity() == 0) { socketBuffer.reset(); int newsize = e.getPreferredSize(); if (newsize == 0) { newsize = socketBuffer.capacity() + 16; } else { assert (e.getPreferredSize() >= socketBuffer.remaining()); } tmpHandshakeBytes = ByteBuffer.allocate(newsize); tmpHandshakeBytes.put(socketBufferNew); } else { tmpHandshakeBytes.position(tmpHandshakeBytes.limit()); tmpHandshakeBytes.limit(tmpHandshakeBytes.capacity()); } } return false; } private void decodeFrames(ByteBuffer socketBuffer) { List<Framedata> frames; try { frames = draft.translateFrame(socketBuffer); for (Framedata f : frames) { draft.processFrame(this, f); } } catch (LimitExceededException e) { if (e.getLimit() == Integer.MAX_VALUE) { wsl.onWebsocketError(this, e); } close(e); } catch (InvalidDataException e) { wsl.onWebsocketError(this, e); close(e); } catch (VirtualMachineError | LinkageError e) { throw e; } catch (Error e) { Exception exception = new Exception(e); wsl.onWebsocketError(this, exception); String errorMessage = "Got error " + e.getClass().getName(); close(CloseFrame.UNEXPECTED_CONDITION, errorMessage); } } private void closeConnectionDueToWrongHandshake(InvalidDataException exception) { write(generateHttpResponseDueToError(404)); flushAndClose(exception.getCloseCode(), exception.getMessage(), false); } private void closeConnectionDueToInternalServerError(RuntimeException exception) { write(generateHttpResponseDueToError(500)); flushAndClose(CloseFrame.NEVER_CONNECTED, exception.getMessage(), false); } private ByteBuffer generateHttpResponseDueToError(int errorCode) { String errorCodeDescription; switch (errorCode) { case 404: errorCodeDescription = "404 WebSocket Upgrade Failure"; break; case 500: default: errorCodeDescription = "500 Internal Server Error"; } return WebSocketServer.prepara404(errorCodeDescription);} public synchronized void close(int code, String message, boolean remote) { if (readyState != ReadyState.CLOSING && readyState != ReadyState.CLOSED) { if (readyState == ReadyState.OPEN) { if (code == CloseFrame.ABNORMAL_CLOSE) { assert (!remote); readyState = ReadyState.CLOSING; flushAndClose(code, message, false); return; } if (draft.getCloseHandshakeType() != CloseHandshakeType.NONE) { try { if (!remote) { try { wsl.onWebsocketCloseInitiated(this, code, message); } catch (RuntimeException e) { wsl.onWebsocketError(this, e); } } if (isOpen()) { CloseFrame closeFrame = new CloseFrame(); closeFrame.setReason(message); closeFrame.setCode(code); closeFrame.isValid(); sendFrame(closeFrame); } } catch (InvalidDataException e) { wsl.onWebsocketError(this, e); flushAndClose(CloseFrame.ABNORMAL_CLOSE, "generated frame is invalid", false); } } flushAndClose(code, message, remote); } else if (code == CloseFrame.FLASHPOLICY) { assert (remote); flushAndClose(CloseFrame.FLASHPOLICY, message, true); } else if (code == CloseFrame.PROTOCOL_ERROR) {  flushAndClose(code, message, remote); } else { flushAndClose(CloseFrame.NEVER_CONNECTED, message, false); } readyState = ReadyState.CLOSING; tmpHandshakeBytes = null; return; } } public void close(int code, String message) { close(code, 
/* class WebSocket */ message, false); } public synchronized void closeConnection(int code, String message, boolean remote) { if (readyState == ReadyState.CLOSED) { return; } if (readyState == ReadyState.OPEN) { if (code == CloseFrame.ABNORMAL_CLOSE) { readyState = ReadyState.CLOSING; } } if (key != null) { key.cancel(); } if (channel != null) { try { channel.close(); } catch (IOException e) { if (e.getMessage() != null && e.getMessage().equals("Broken pipe")) { } else { wsl.onWebsocketError(this, e); } } } try { this.wsl.onWebsocketClose(this, code, message, remote); } catch (RuntimeException e) { wsl.onWebsocketError(this, e); } if (draft != null) { draft.reset(); } handshakerequest = null; readyState = ReadyState.CLOSED; } protected void closeConnection(int code, boolean remote) { closeConnection(code, "", remote); } public void closeConnection() { if (closedremotely == null) { throw new IllegalStateException("this method must be used in conjunction with flushAndClose"); } closeConnection(closecode, closemessage, closedremotely); } public void closeConnection(int code, String message) { closeConnection(code, message, false); } public synchronized void flushAndClose(int code, String message, boolean remote) { if (flushandclosestate) { return; } closecode = code; closemessage = message; closedremotely = remote; flushandclosestate = true; wsl.onWriteDemand( this); try { wsl.onWebsocketClosing(this, code, message, remote); } catch (RuntimeException e) { wsl.onWebsocketError(this, e); } if (draft != null) { draft.reset(); } handshakerequest = null; } public void eot() { if (readyState == ReadyState.NOT_YET_CONNECTED) { closeConnection(CloseFrame.NEVER_CONNECTED, true); } else if (flushandclosestate) { closeConnection(closecode, closemessage, closedremotely); } else if (draft.getCloseHandshakeType() == CloseHandshakeType.NONE) { closeConnection(CloseFrame.NORMAL, true); } else if (draft.getCloseHandshakeType() == CloseHandshakeType.ONEWAY) { if (role == Role.SERVER) { closeConnection(CloseFrame.ABNORMAL_CLOSE, true); } else { closeConnection(CloseFrame.NORMAL, true); } } else { closeConnection(CloseFrame.ABNORMAL_CLOSE, true); } } public void close(int code) { close(code, "", false); } public void close(InvalidDataException e) { close(e.getCloseCode(), e.getMessage(), false); } public void send(String text) { if (text == null) { throw new IllegalArgumentException("Cannot send 'null' data to a WebSocketImpl."); } send(draft.createFrames(text, role == Role.CLIENT)); } public void send(ByteBuffer bytes) { if (bytes == null) { throw new IllegalArgumentException("Cannot send 'null' data to a WebSocketImpl."); } send(draft.createFrames(bytes, role == Role.CLIENT)); } public void send(byte[] bytes) { send(ByteBuffer.wrap(bytes)); } private void send(Collection<Framedata> frames) { if (!isOpen()) { throw new WebsocketNotConnectedException(); } if (frames == null) { throw new IllegalArgumentException(); } ArrayList<ByteBuffer> outgoingFrames = new ArrayList<>(); for (Framedata f : frames) { outgoingFrames.add(draft.createBinaryFrame(f)); } write(outgoingFrames); } public void sendFragmentedFrame(Opcode op, ByteBuffer buffer, boolean fin) { send(draft.continuousFrame(op, buffer, fin)); } public void sendFrame(Collection<Framedata> frames) { send(frames); } public void sendFrame(Framedata framedata) { send(Collections.singletonList(framedata)); } public void sendPing() throws NullPointerException { PingFrame pingFrame = wsl.onPreparePing(this); if (pingFrame == null) { 
/* class WebSocket */ throw new NullPointerException( "onPreparePing(WebSocket) returned null. PingFrame to sent can't be null."); } sendFrame(pingFrame); } public boolean hasBufferedData() { return !this.outQueue.isEmpty(); } public void startHandshake(ClientHandshakeBuilder handshakedata) throws InvalidHandshakeException { this.handshakerequest = draft.postProcessHandshakeRequestAsClient(handshakedata); resourceDescriptor = handshakedata.getResourceDescriptor(); assert (resourceDescriptor != null); try { wsl.onWebsocketHandshakeSentAsClient(this, this.handshakerequest); } catch (InvalidDataException e) { throw new InvalidHandshakeException("Handshake data rejected by client."); } catch (RuntimeException e) { wsl.onWebsocketError(this, e); throw new InvalidHandshakeException("rejected because of " + e); } write(draft.createHandshake(this.handshakerequest)); } private void write(ByteBuffer buf) { outQueue.add(buf); wsl.onWriteDemand(this); } private void write(List<ByteBuffer> bufs) { synchronized (synchronizeWriteObject) { for (ByteBuffer b : bufs) { write(b); } } } private void open(Handshakedata d) { readyState = ReadyState.OPEN; updateLastPong(); try { wsl.onWebsocketOpen(this, d); } catch (RuntimeException e) { wsl.onWebsocketError(this, e); } } public boolean isOpen() { return readyState == ReadyState.OPEN; } public boolean isClosing() { return readyState == ReadyState.CLOSING; } public boolean isFlushAndClose() { return flushandclosestate; } public boolean isClosed() { return readyState == ReadyState.CLOSED; } public ReadyState getReadyState() { return readyState; } public void setSelectionKey(SelectionKey key) { this.key = key; } public SelectionKey getSelectionKey() { return key; } public String toString() { return super.toString(); } public InetSocketAddress getRemoteSocketAddress() { return wsl.getRemoteSocketAddress(this); } public InetSocketAddress getLocalSocketAddress() { return wsl.getLocalSocketAddress(this); } public Draft getDraft() { return draft; } public void close() { close(CloseFrame.NORMAL); } public String getResourceDescriptor() { return resourceDescriptor; } long getLastPong() { return lastPong; } public void updateLastPong() { this.lastPong = System.nanoTime(); } public WebSocketListener getWebSocketListener() { return wsl; } public <T> T getAttachment() { return (T) attachment; } public boolean hasSSLSupport() { return channel instanceof ISSLChannel; } public SSLSession getSSLSession() { if (!hasSSLSupport()) { throw new IllegalArgumentException( "This websocket uses ws instead of wss. No SSLSession available."); } return ((ISSLChannel) channel).getSSLEngine().getSession(); } public IProtocol getProtocol() { if (draft == null) { return null; } if (!(draft instanceof Draft_6455)) { throw new IllegalArgumentException("This draft does not support Sec-WebSocket-Protocol"); } return ((Draft_6455) draft).getProtocol(); } public <T> void setAttachment(T attachment) { this.attachment = attachment; } public ByteChannel getChannel() { return channel; } public void setChannel(ByteChannel channel) { this.channel = channel; } public WebSocketServer.WebSocketWorker getWorkerThread() { return workerThread; } public void setWorkerThread(WebSocketServer.WebSocketWorker workerThread) { this.workerThread = workerThread; } } interface WebSocketListener { ServerHandshakeBuilder onWebsocketHandshakeReceivedAsServer(WebSocket conn, Draft draft, ClientHandshake request) throws InvalidDataException; void onWebsocketHandshakeReceivedAsClient(WebSocket conn, 
/* class WebSocket */ ClientHandshake request, ServerHandshake response) throws InvalidDataException; void onWebsocketHandshakeSentAsClient(WebSocket conn, ClientHandshake request) throws InvalidDataException; void onWebsocketMessage(WebSocket conn, String message); void onWebsocketMessage(WebSocket conn, ByteBuffer blob); void onWebsocketOpen(WebSocket conn, Handshakedata d); void onWebsocketClose(WebSocket ws, int code, String reason, boolean remote); void onWebsocketClosing(WebSocket ws, int code, String reason, boolean remote); void onWebsocketCloseInitiated(WebSocket ws, int code, String reason); void onWebsocketError(WebSocket conn, Exception ex); void onWebsocketPing(WebSocket conn, Framedata f); PingFrame onPreparePing(WebSocket conn); void onWebsocketPong(WebSocket conn, Framedata f); void onWriteDemand(WebSocket conn); InetSocketAddress getLocalSocketAddress(WebSocket conn); InetSocketAddress getRemoteSocketAddress(WebSocket conn); } 
@SuppressWarnings({"unchecked", "deprecation"})
class WebsocketNotConnectedException extends RuntimeException { private static final long serialVersionUID = -785314021592982715L; } 
@SuppressWarnings({"unchecked", "deprecation"})
abstract class WebSocketServer extends AbstractWebSocket implements Runnable { private static final int AVAILABLE_PROCESSORS = Runtime.getRuntime().availableProcessors();  static String custom404=null; static ByteBuffer prepara404(String errorCodeDescription ){  if ( custom404 == null ) return ByteBuffer.wrap(Charsetfunctions.asciiBytes("HTTP/1.1 " + errorCodeDescription + "\r\nContent-Type: text/html\r\nServer: TooTallNate Java-WebSocket\r\nContent-Length: " + (48 + errorCodeDescription.length()) + "\r\n\r\n<html><head></head><body><h1>" + errorCodeDescription + "</h1></body></html>")); else return ByteBuffer.wrap(Charsetfunctions.asciiBytes(custom404)); } private final Collection<WebSocket> connections; private final InetSocketAddress address; private ServerSocketChannel server; private Selector selector; private List<Draft> drafts; private Thread selectorthread; private final AtomicBoolean isclosed = new AtomicBoolean(false); protected List<WebSocketWorker> decoders; private List<WebSocketImpl> iqueue; private BlockingQueue<ByteBuffer> buffers; private int queueinvokes = 0; private final AtomicInteger queuesize = new AtomicInteger(0); private WebSocketServerFactory wsf = new DefaultWebSocketServerFactory(); private int maxPendingConnections = -1; public WebSocketServer() { this(new InetSocketAddress(WebSocketImpl.DEFAULT_PORT), AVAILABLE_PROCESSORS, null); } public WebSocketServer(InetSocketAddress address, String custom404) { this(address, AVAILABLE_PROCESSORS, null, custom404); } public WebSocketServer(InetSocketAddress address, int decodercount, String custom404) { this(address, decodercount, null, custom404); } public WebSocketServer(InetSocketAddress address, List<Draft> drafts, String custom404) { this(address, AVAILABLE_PROCESSORS, drafts, custom404); } public WebSocketServer(InetSocketAddress address, int decodercount, List<Draft> drafts, String custom404) { this(address, decodercount, drafts, new HashSet<WebSocket>(), custom404); } public WebSocketServer(InetSocketAddress address, int decodercount, List<Draft> drafts, Collection<WebSocket> connectionscontainer, String custom404) { this.custom404=custom404;if (address == null || decodercount < 1 || connectionscontainer == null) { throw new IllegalArgumentException( "address and connectionscontainer must not be null and you need at least 1 decoder"); } if (drafts == null) { this.drafts = Collections.emptyList(); } else { this.drafts = drafts; } this.address = address; this.connections = connectionscontainer; setTcpNoDelay(false); setReuseAddr(false); iqueue = new LinkedList<>(); decoders = new ArrayList<>(decodercount); buffers = new LinkedBlockingQueue<>(); for (int i = 0; i < decodercount; i++) { WebSocketWorker ex = new WebSocketWorker(); decoders.add(ex); } } public void start() { if (selectorthread != null) { throw new IllegalStateException(getClass().getName() + " can only be started once."); } Thread t = new Thread(this); t.setDaemon(isDaemon()); t.start(); } public void stop(int timeout) throws InterruptedException { stop(timeout, ""); } public void stop(int timeout, 
/* class WebSocket */ String closeMessage) throws InterruptedException { if (!isclosed.compareAndSet(false, true)) {  return; } List<WebSocket> socketsToClose; synchronized (connections) { socketsToClose = new ArrayList<>(connections); } for (WebSocket ws : socketsToClose) { ws.close(CloseFrame.GOING_AWAY, closeMessage); } wsf.close(); synchronized (this) { if (selectorthread != null && selector != null) { selector.wakeup(); selectorthread.join(timeout); } } } public void stop() throws InterruptedException { stop(0); } public Collection<WebSocket> getConnections() { synchronized (connections) { return Collections.unmodifiableCollection(new ArrayList<>(connections)); } } public InetSocketAddress getAddress() { return this.address; } public int getPort() { int port = getAddress().getPort(); if (port == 0 && server != null) { port = server.socket().getLocalPort(); } return port; } public void setDaemon(boolean daemon) { super.setDaemon(daemon); for (WebSocketWorker w : decoders) { if (w.isAlive()) { throw new IllegalStateException("Cannot call setDaemon after server is already started!"); } else { w.setDaemon(daemon); } } } public List<Draft> getDraft() { return Collections.unmodifiableList(drafts); } public void setMaxPendingConnections(int numberOfConnections) { maxPendingConnections = numberOfConnections; } public int getMaxPendingConnections() { return maxPendingConnections; } public void run() { if (!doEnsureSingleThread()) { return; } if (!doSetupSelectorAndServerThread()) { return; } try { int shutdownCount = 5; int selectTimeout = 0; while (!selectorthread.isInterrupted() && shutdownCount != 0) { SelectionKey key = null; try { if (isclosed.get()) { selectTimeout = 5; } int keyCount = selector.select(selectTimeout); if (keyCount == 0 && isclosed.get()) { shutdownCount--; } Set<SelectionKey> keys = selector.selectedKeys(); Iterator<SelectionKey> i = keys.iterator(); while (i.hasNext()) { key = i.next(); if (!key.isValid()) { continue; } if (key.isAcceptable()) { doAccept(key, i); continue; } if (key.isReadable() && !doRead(key, i)) { continue; } if (key.isWritable()) { doWrite(key); } } doAdditionalRead(); } catch (CancelledKeyException e) { } catch (ClosedByInterruptException e) { return; } catch (WrappedIOException ex) { handleIOException(key, ex.getConnection(), ex.getIOException()); } catch (IOException ex) { handleIOException(key, null, ex); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } } } catch (RuntimeException e) { handleFatal(null, e); } finally { doServerShutdown(); } } private void doAdditionalRead() throws InterruptedException, IOException { WebSocketImpl conn; while (!iqueue.isEmpty()) { conn = iqueue.remove(0); WrappedByteChannel c = ((WrappedByteChannel) conn.getChannel()); ByteBuffer buf = takeBuffer(); try { if (SocketChannelIOHelper.readMore(buf, conn, c)) { iqueue.add(conn); } if (buf.hasRemaining()) { conn.inQueue.put(buf); queue(conn); } else { pushBuffer(buf); } } catch (IOException e) { pushBuffer(buf); throw e; } } } private void doAccept(SelectionKey key, Iterator<SelectionKey> i) throws IOException, InterruptedException { if (!onConnect(key)) { key.cancel(); return; } SocketChannel channel = server.accept(); if (channel == null) { return; } channel.configureBlocking(false); Socket socket = channel.socket(); socket.setTcpNoDelay(isTcpNoDelay()); socket.setKeepAlive(true); WebSocketImpl w = wsf.createWebSocket(this, drafts); w.setSelectionKey(channel.register(selector, SelectionKey.OP_READ, w)); try { 
/* class WebSocket */ w.setChannel(wsf.wrapChannel(channel, w.getSelectionKey())); i.remove(); allocateBuffers(w); } catch (IOException ex) { if (w.getSelectionKey() != null) { w.getSelectionKey().cancel(); } handleIOException(w.getSelectionKey(), null, ex); } } private boolean doRead(SelectionKey key, Iterator<SelectionKey> i) throws InterruptedException, WrappedIOException { WebSocketImpl conn = (WebSocketImpl) key.attachment(); ByteBuffer buf = takeBuffer(); if (conn.getChannel() == null) { key.cancel(); handleIOException(key, conn, new IOException()); return false; } try { if (SocketChannelIOHelper.read(buf, conn, conn.getChannel())) { if (buf.hasRemaining()) { conn.inQueue.put(buf); queue(conn); i.remove(); if (conn.getChannel() instanceof WrappedByteChannel && ((WrappedByteChannel) conn .getChannel()).isNeedRead()) { iqueue.add(conn); } } else { pushBuffer(buf); } } else { pushBuffer(buf); } } catch (IOException e) { pushBuffer(buf); throw new WrappedIOException(conn, e); } return true; } private void doWrite(SelectionKey key) throws WrappedIOException { WebSocketImpl conn = (WebSocketImpl) key.attachment(); try { if (SocketChannelIOHelper.batch(conn, conn.getChannel()) && key.isValid()) { key.interestOps(SelectionKey.OP_READ); } } catch (IOException e) { throw new WrappedIOException(conn, e); } } private boolean doSetupSelectorAndServerThread() { selectorthread.setName("WebSocketSelector-" + selectorthread.getId()); try { server = ServerSocketChannel.open(); server.configureBlocking(false); ServerSocket socket = server.socket(); socket.setReceiveBufferSize(WebSocketImpl.RCVBUF); socket.setReuseAddress(isReuseAddr()); socket.bind(address, getMaxPendingConnections()); selector = Selector.open(); server.register(selector, server.validOps()); startConnectionLostTimer(); for (WebSocketWorker ex : decoders) { ex.start(); } onStart(); } catch (IOException ex) { handleFatal(null, ex); return false; } return true; } private boolean doEnsureSingleThread() { synchronized (this) { if (selectorthread != null) { throw new IllegalStateException(getClass().getName() + " can only be started once."); } selectorthread = Thread.currentThread(); if (isclosed.get()) { return false; } } return true; } private void doServerShutdown() { stopConnectionLostTimer(); if (decoders != null) { for (WebSocketWorker w : decoders) { w.interrupt(); } } if (selector != null) { try { selector.close(); } catch (IOException e) { onError(null, e); } } if (server != null) { try { server.close(); } catch (IOException e) { onError(null, e); } } } protected void allocateBuffers(WebSocket c) throws InterruptedException { if (queuesize.get() >= 2 * decoders.size() + 1) { return; } queuesize.incrementAndGet(); buffers.put(createBuffer()); } protected void releaseBuffers(WebSocket c) throws InterruptedException { } public ByteBuffer createBuffer() { return ByteBuffer.allocate(WebSocketImpl.RCVBUF); } protected void queue(WebSocketImpl ws) throws InterruptedException { if (ws.getWorkerThread() == null) { ws.setWorkerThread(decoders.get(queueinvokes % decoders.size())); queueinvokes++; } ws.getWorkerThread().put(ws); } private ByteBuffer takeBuffer() throws InterruptedException { return buffers.take(); } private void pushBuffer(ByteBuffer buf) throws InterruptedException { if (buffers.size() > queuesize.intValue()) { return; } buffers.put(buf); } private void handleIOException(SelectionKey key, WebSocket conn, IOException ex) { if (key != null) { key.cancel(); } if (conn != null) { 
/* class WebSocket */ conn.closeConnection(CloseFrame.ABNORMAL_CLOSE, ex.getMessage()); } else if (key != null) { SelectableChannel channel = key.channel(); if (channel != null && channel .isOpen()) { try { channel.close(); } catch (IOException e) { } } } } private void handleFatal(WebSocket conn, Exception e) { onError(conn, e); String causeMessage = e.getCause() != null ? " caused by " + e.getCause().getClass().getName() : ""; String errorMessage = "Got error on server side: " + e.getClass().getName() + causeMessage; try { stop(0, errorMessage); } catch (InterruptedException e1) { Thread.currentThread().interrupt(); onError(null, e1); } if (decoders != null) { for (WebSocketWorker w : decoders) { w.interrupt(); } } if (selectorthread != null) { selectorthread.interrupt(); } } public final void onWebsocketMessage(WebSocket conn, String message) { onMessage(conn, message); } public final void onWebsocketMessage(WebSocket conn, ByteBuffer blob) { onMessage(conn, blob); } public final void onWebsocketOpen(WebSocket conn, Handshakedata handshake) { if (addConnection(conn)) { onOpen(conn, (ClientHandshake) handshake); } } public final void onWebsocketClose(WebSocket conn, int code, String reason, boolean remote) { selector.wakeup(); try { if (removeConnection(conn)) { onClose(conn, code, reason, remote); } } finally { try { releaseBuffers(conn); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } } } protected boolean removeConnection(WebSocket ws) { boolean removed = false; synchronized (connections) { if (this.connections.contains(ws)) { removed = this.connections.remove(ws); } else { } } if (isclosed.get() && connections.isEmpty()) { selectorthread.interrupt(); } return removed; } protected boolean addConnection(WebSocket ws) { if (!isclosed.get()) { synchronized (connections) { return this.connections.add(ws); } } else { ws.close(CloseFrame.GOING_AWAY); return true; } } public final void onWebsocketError(WebSocket conn, Exception ex) { onError(conn, ex); } public final void onWriteDemand(WebSocket w) { WebSocketImpl conn = (WebSocketImpl) w; try { conn.getSelectionKey().interestOps(SelectionKey.OP_READ | SelectionKey.OP_WRITE); } catch (CancelledKeyException e) { conn.outQueue.clear(); } selector.wakeup(); } public void onWebsocketCloseInitiated(WebSocket conn, int code, String reason) { onCloseInitiated(conn, code, reason); } public void onWebsocketClosing(WebSocket conn, int code, String reason, boolean remote) { onClosing(conn, code, reason, remote); } public void onCloseInitiated(WebSocket conn, int code, String reason) { } public void onClosing(WebSocket conn, int code, String reason, boolean remote) { } public final void setWebSocketFactory(WebSocketServerFactory wsf) { if (this.wsf != null) { this.wsf.close(); } this.wsf = wsf; } public final WebSocketFactory getWebSocketFactory() { return wsf; } protected boolean onConnect(SelectionKey key) { return true; } private Socket getSocket(WebSocket conn) { WebSocketImpl impl = (WebSocketImpl) conn; return ((SocketChannel) impl.getSelectionKey().channel()).socket(); } public InetSocketAddress getLocalSocketAddress(WebSocket conn) { return (InetSocketAddress) getSocket(conn).getLocalSocketAddress(); } public InetSocketAddress getRemoteSocketAddress(WebSocket conn) { return (InetSocketAddress) getSocket(conn).getRemoteSocketAddress(); } public abstract void onOpen(WebSocket conn, ClientHandshake handshake); public abstract void onClose(WebSocket conn, int code, String reason, boolean remote); 
/* class WebSocket */ public abstract void onMessage(WebSocket conn, String message); public abstract void onError(WebSocket conn, Exception ex); public abstract void onStart(); public void onMessage(WebSocket conn, ByteBuffer message) { } public void broadcast(String text) { broadcast(text, connections); } public void broadcast(byte[] data) { broadcast(data, connections); } public void broadcast(ByteBuffer data) { broadcast(data, connections); } public void broadcast(byte[] data, Collection<WebSocket> clients) { if (data == null || clients == null) { throw new IllegalArgumentException(); } broadcast(ByteBuffer.wrap(data), clients); } public void broadcast(ByteBuffer data, Collection<WebSocket> clients) { if (data == null || clients == null) { throw new IllegalArgumentException(); } doBroadcast(data, clients); } public void broadcast(String text, Collection<WebSocket> clients) { if (text == null || clients == null) { throw new IllegalArgumentException(); } doBroadcast(text, clients); } private void doBroadcast(Object data, Collection<WebSocket> clients) { String strData = null; if (data instanceof String) { strData = (String) data; } ByteBuffer byteData = null; if (data instanceof ByteBuffer) { byteData = (ByteBuffer) data; } if (strData == null && byteData == null) { return; } Map<Draft, List<Framedata>> draftFrames = new HashMap<>(); List<WebSocket> clientCopy; synchronized (clients) { clientCopy = new ArrayList<>(clients); } for (WebSocket client : clientCopy) { if (client != null) { Draft draft = client.getDraft(); fillFrames(draft, draftFrames, strData, byteData); try { client.sendFrame(draftFrames.get(draft)); } catch (WebsocketNotConnectedException e) { } } } } private void fillFrames(Draft draft, Map<Draft, List<Framedata>> draftFrames, String strData, ByteBuffer byteData) { if (!draftFrames.containsKey(draft)) { List<Framedata> frames = null; if (strData != null) { frames = draft.createFrames(strData, false); } if (byteData != null) { frames = draft.createFrames(byteData, false); } if (frames != null) { draftFrames.put(draft, frames); } } } 
@SuppressWarnings({"unchecked", "deprecation"})
class WebSocketWorker extends Thread { private BlockingQueue<WebSocketImpl> iqueue; public WebSocketWorker() { iqueue = new LinkedBlockingQueue<>(); setName("WebSocketWorker-" + getId()); setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() { public void uncaughtException(Thread t, Throwable e) { } }); } public void put(WebSocketImpl ws) throws InterruptedException { iqueue.put(ws); } public void run() { WebSocketImpl ws = null; try { while (true) { ByteBuffer buf; ws = iqueue.take(); buf = ws.inQueue.poll(); assert (buf != null); doDecode(ws, buf); ws = null; } } catch (InterruptedException e) { Thread.currentThread().interrupt(); } catch (VirtualMachineError | LinkageError e) { Exception exception = new Exception(e); handleFatal(ws, exception); } catch (Throwable e) { if (ws != null) { Exception exception = new Exception(e); onWebsocketError(ws, exception); ws.close(); } } } private void doDecode(WebSocketImpl ws, ByteBuffer buf) throws InterruptedException { try { ws.decode(buf); } catch (Exception e) { } finally { pushBuffer(buf); } } } } interface WebSocketServerFactory extends WebSocketFactory { WebSocketImpl createWebSocket(WebSocketAdapter a, Draft d); WebSocketImpl createWebSocket(WebSocketAdapter a, List<Draft> drafts); ByteChannel wrapChannel(SocketChannel channel, SelectionKey key) throws IOException; void close(); } interface WrappedByteChannel extends ByteChannel { boolean isNeedWrite(); 
/* class WebSocket */ void writeMore() throws IOException; boolean isNeedRead(); int readMore(ByteBuffer dst) throws IOException; boolean isBlocking(); } 
@SuppressWarnings({"unchecked", "deprecation"})
class WrappedIOException extends Exception { private final transient WebSocket connection; private final IOException ioException; public WrappedIOException(WebSocket connection, IOException ioException) { this.connection = connection; this.ioException = ioException; } public WebSocket getConnection() { return connection; } public IOException getIOException() { return ioException; } } 


// parametros
// new HttpServer(...)
// host(pode ser ""), port, titulo_url, titulo, dir, endsWiths(ex: "","jar,zip"), ips_banidos(ex: "","8.8.8.8,4.4.4.4")
@SuppressWarnings({"unchecked", "deprecation"})
class HttpServer extends Util{
    String mode, host, pass, titulo_url, titulo, dir, nav, endsWiths, ips_banidos, log_ips, cfg;
    int port;
    Boolean noLogLocal=false;
    Socket socket = null;    
    public HttpServer(String mode, String host, Integer port, String pass, String titulo_url, String titulo, String dir, 
                      String endsWiths, String ips_banidos, String log_ips, Boolean noLogLocal, String cfg, 
                      String redisDir, Long redisSeconds, String redisAll, String redisLike){
        this.mode = mode;
        this.host = host;
        this.port = port;
        this.pass = pass; // ainda não implementado aqui
        this.titulo_url = titulo_url;
        this.titulo = titulo;
        this.dir = dir;
        this.endsWiths = endsWiths;
        this.ips_banidos = ips_banidos;
        this.log_ips = log_ips;
        this.noLogLocal = noLogLocal;
        this.cfg = cfg;
        try{
            if ( redisDir != null )
                redis=new Redis(redisDir, redisSeconds, redisAll, redisLike);
            serve();
        }catch(Exception e){
            System.err.println(e.toString());
            System.exit(1);
        }
    }
    public void serve() throws Exception {
        ServerSocket serverSocket = null;
        String ip_origem = "";
        String host_display = "";
        try {
            serverSocket = new ServerSocket(port, 1, InetAddress.getByName(host));
            host_display="http://" + host + ":" + port;
            if (host.contains(":"))
                host_display="http://[" + host + "]:" + port;
            if (mode == null)
                System.out.println("Service opened: " + host_display + "/" + titulo_url);
            else
                System.out.println("Service opened: \n" + host_display + "\nFiles:\n" + host_display + "/" + titulo_url);
            System.out.println("Path work: " + dir + "\n");
            if ( mode != null && mode.equals("playlistserver") )
                playlistserver=new PlaylistServer(cfg);
        }catch(Exception e){
            throw new Exception("erro na inicialização: " + e.toString());
        }
        while (true) {
            try {
                socket = serverSocket.accept();
                ip_origem = get_ip_origem_by_socket(socket);
                boolean is_ip_banido = ip_banido(ips_banidos, ip_origem);
                if ( log_ips != null )
                    log_serverRouter(log_ips, noLogLocal, ip_origem, is_ip_banido);
                if ( is_ip_banido ){
                    System.out.println("Conexao de origem BANIDO: " + ip_origem + ", data:" + (new Date()));
                    continue;
                }else
                    System.out.println("Conexao de origem: " + ip_origem + ", data:" + (new Date()));
                new ClientThread(mode, socket, titulo_url, titulo, dir, endsWiths, host_display, cfg);
            } catch (Exception e) {
                System.out.println("Erro ao executar servidor:" + e.toString());
            }
        }
    }
}

@SuppressWarnings({"unchecked", "deprecation"})
class ClientThread extends Util{
    String header_redis_id, header_redis_sign, header_redis_key, header_redis_value, header_redis_del, header_userAgent, header_acao, mode, method, uri, protocol, titulo_url, titulo, dir, endsWiths, cfg;
    long header_range=-1;
    long lenTarget=-1;
    String nav;
    InputStream input = null;
    OutputStream output = null;
    char[] buffer = new char[2048];
    Writer writer;
    InputStreamReader isr = null;
    Reader reader = null;
    BufferedInputStream bis = null;
    String host_display=null;
    Y y=new Y();
    public ClientThread(String mode, final Socket socket, String titulo_url, String titulo, String dir, String endsWiths, String host_display, String cfg) {
        this.titulo_url = titulo_url;
        this.titulo = titulo;
        this.dir = dir;
        this.endsWiths = endsWiths;
        this.mode = mode;
        this.host_display = host_display;
        this.cfg = cfg;
        new Thread() {
            public void run() {
                try {
                    input = socket.getInputStream();
                    output = socket.getOutputStream();
                    if (input != null) {
                        writer = new StringWriter();
                        lendo();
                        gravando();
                        socket.close();
                        writer.close();
                        if ( reader != null )
                            reader.close();
                        if ( isr != null )
                            isr.close();
                        if ( bis != null )
                            bis.close();
                    }
                } catch (Exception e) {
                    System.out.println("----------> Erro ao executar servidor:" + e.toString());
                }
            }
        }.start();
    }
    
    private String [] lendo_linhas() throws Exception {
        isr = new InputStreamReader(input);
        reader = new BufferedReader(isr);
                        
        int i = 0;            
        CharArrayWriter caw=new CharArrayWriter();            
        while(true){
            i = reader.read(buffer);
            if (i < 0 ) 
                break;
            else
                caw.write(buffer, 0, i);
            if ( reader.ready() )
                continue;            
            sleepMillis(1);
            if ( reader.ready() )
                continue;
            break;
        }
        BufferedReader br = new BufferedReader(new StringReader(caw.toString()));
        ArrayList<String> lines=new ArrayList<>();
        String line=null;
        while ((line = br.readLine()) != null)
            lines.add(line);
        
        return arrayList_to_array(lines);        
    }
    
    // nao apagar!!!
    private String [] lendo_linhasB() throws Exception {
        bis = new BufferedInputStream(input);
        byte [] buff=new byte[BUFFER_SIZE];        
        int len_in=0;
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        while(true){
            len_in=bis.read(buff,0,BUFFER_SIZE);
            if ( len_in < 0 ){
                break;
            }else{
                baos.write(buff, 0, len_in);
            }
            if ( bis.available() > 0 )
                continue;
            break;
        }
        return baos.toString().split("\r\n");        
    }
    
    private void lendo() throws Exception { // refatorar depois, isso aqui ta muito ruim!!
        try { 
            // lendo_linhas(); falha as vezes
            // lendo_linhasB(); falha as vezes
            // header grande falha na leitura com mobile... não sei porque!!
            String [] partes=lendo_linhas();

            String line = null;
            int lineNumber = 0;
            this.header_range = -1;
            this.header_userAgent = null;
            this.header_acao = null;
            this.header_redis_id=null;
            this.header_redis_sign=null;
            this.header_redis_key=null;
            this.header_redis_value=null;            
            this.header_redis_del=null;
            for ( int i=0;i<partes.length;i++ ){
                line=partes[i];
                System.out.println("<---|    " + line.replace("\n","\n          "));
                if (lineNumber == 0 && line.split(" ").length == 3) {
                    this.method = line.split(" ")[0];
                    this.uri = line.split(" ")[1];
                    if ( this.uri.startsWith("/k=") && this.uri.length() > "/k=".length() && this.uri.replaceAll("/k=", "").replaceAll("I", "").replaceAll("l", "").equals("") && this.uri.length()%8 == 3 ){
                        int _len=this.uri.length();
                        int _p=3;
                        StringBuilder _sb=new StringBuilder("/");
                        while ( _p < _len ){
                            _sb.append((char)(Integer.parseInt(this.uri.substring(_p, _p+8).replaceAll("I", "0").replaceAll("l", "1"), 2)));
                            _p+=8;
                        }
                        this.uri=_sb.toString();
                    }                        
                    if ( this.uri.indexOf("?") > -1 )
                        this.uri = this.uri.split("\\?")[0];
                    this.protocol = line.split(" ")[2];
                }
                if (line.startsWith("Range: bytes=") && line.endsWith("-") )
                  this.header_range = Long.parseLong(line.split("=")[1].replace("-", ""));
                if (line.startsWith("User-Agent: ") )
                  this.header_userAgent = line.substring(12);
                if (line.startsWith("acao: ") )
                  this.header_acao = line.substring(6);
                if (line.startsWith("Redis-ID: ") )
                  this.header_redis_id = line.substring(10);
                if (line.startsWith("Redis-SIGN: ") )
                  this.header_redis_sign = line.substring(12);
                if (line.startsWith("Redis-KEY: ") )
                  this.header_redis_key = line.substring(11);
                if (line.startsWith("Redis-VALUE: ") )
                  this.header_redis_value = line.substring(13);
                if (line.startsWith("Redis-DEL: ") )
                  this.header_redis_del = line.substring(11);
                lineNumber++;
            }
            System.out.println("    |");
        } catch (IOException e) {
            throw new Exception("Erro ao converter stream para string:" + e.toString());
        }
    }
    private void gravando() throws Exception {
        StringBuilder sb = new StringBuilder();
        
        // OPTIONS - options precisa retornar 200 para não dar o erro "blocked by CORS policy: Response to preflight" em caso de XMLHttpRequest com setRequestHeader
        if (method.equals("OPTIONS")) {
            for (String line: new String[] {
                    "HTTP/1.1 200\r\n", 
                    "Access-Control-Allow-Origin: *\r\n",
                    "Access-Control-Allow-Headers: *\r\n",
                    "X-Frame-Options: SAMEORIGIN\r\n",
                    "\r\n",
                }) {
                sb.append(line);
                System.out.print("    |---> " + line);
            }
            System.out.println("    |");
            output.write(sb.toString().getBytes());
            return;
        }
                
        // redis
        if ( redis != null && !method.equals("OPTIONS") ){
            if ( header_redis_del != null ){
                redis.del(header_redis_del.split(" "));
                output.write(  ("HTTP/1.1 200 OK\r\nAccess-Control-Allow-Origin: *\r\n\r\n+OK").getBytes() );
                return;                    
            }
            if ( header_redis_key != null && header_redis_key.length() >= 255 )
                header_redis_key=header_redis_key.substring(0, 255);
            if ( header_redis_key != null && !header_redis_key.equals("") && !header_redis_key.contains(" ") && header_redis_key.equals(fixNameFile(header_redis_key)) ){
                // getAll
                if ( header_redis_key.equals(redis.redisAll) ){                    
                    output.write(  ("HTTP/1.1 200 OK\r\nAccess-Control-Allow-Origin: *\r\n\r\n"+redis.getAll()).getBytes() );
                    return;                    
                }
                // getLike e get 
                if ( header_redis_value == null ){                    
                    if ( header_redis_key.endsWith("*") ){
                        if ( header_redis_key.replaceAll("\\*", "").length() != header_redis_key.length()-1 ){
                            output.write(  ("HTTP/1.1 203 OK\r\nAccess-Control-Allow-Origin: *\r\n\r\ncomando invalido!! assinatura mal formada de like!").getBytes() );
                            return;
                        }
                        if ( !header_redis_key.contains(redis.redisLike) ){
                            output.write(  ("HTTP/1.1 203 OK\r\nAccess-Control-Allow-Origin: *\r\n\r\ncomando invalido!! assinatura mal formada de like!!").getBytes() );
                            return;
                        }
                        // getLike
                        output.write(  ("HTTP/1.1 200 OK\r\nAccess-Control-Allow-Origin: *\r\n\r\n"+redis.getLike(header_redis_key.substring(0, header_redis_key.length()-1))).getBytes() );
                        return;
                    }
                    // get
                    output.write(  ("HTTP/1.1 200 OK\r\nAccess-Control-Allow-Origin: *\r\n\r\n"+redis.get(header_redis_key)).getBytes() );
                    return;                    
                }
                // add
                if ( header_redis_id == null ){
                    redis.add(header_redis_key, header_redis_value);
                    output.write(  ("HTTP/1.1 200 OK\r\nAccess-Control-Allow-Origin: *\r\n\r\n+OK").getBytes() );
                    return;                    
                }
                // addConcorrenteSign false
                if ( header_redis_sign == null || !header_redis_sign.equals("Y") ){
                    if ( redis.addConcorrenteSign(header_redis_id, false, header_redis_key, header_redis_value) == 0 )
                        output.write(  ("HTTP/1.1 200 OK\r\nAccess-Control-Allow-Origin: *\r\n\r\n+OK").getBytes() );
                    else
                        output.write(  ("HTTP/1.1 200 OK\r\nAccess-Control-Allow-Origin: *\r\n\r\n+NOK").getBytes() );
                    return;
                }
                // addConcorrenteSign true
                redis.addConcorrenteSign(header_redis_id, true, header_redis_key, header_redis_value);
                output.write(  ("HTTP/1.1 200 OK\r\nAccess-Control-Allow-Origin: *\r\n\r\n+OK").getBytes() );
                return;
            }
            
            // 404
            output.write(  ("HTTP/1.1 404 Not Found\r\nAccess-Control-Allow-Origin: *\r\n\r\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">\n<html xmlns=\"http://www.w3.org/1999/xhtml\">\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=iso-8859-1\"/>\n<title>404 - File or directory not found.</title>\n<style type=\"text/css\">\n\nbody{margin:0;font-size:.7em;font-family:Verdana, Arial, Helvetica, sans-serif;background:#EEEEEE;}\nfieldset{padding:0 15px 10px 15px;} \nh1{font-size:2.4em;margin:0;color:#FFF;}\nh2{font-size:1.7em;margin:0;color:#CC0000;} \nh3{font-size:1.2em;margin:10px 0 0 0;color:#000000;} \n#header{width:96%;margin:0 0 0 0;padding:6px 2% 6px 2%;font-family:\"trebuchet MS\", Verdana, sans-serif;color:#FFF;\nbackground-color:#555555;}\n#content{margin:0 0 0 2%;position:relative;}\n.content-container{background:#FFF;width:96%;margin-top:8px;padding:10px;position:relative;}\n\n</style>\n</head>\n<body>\n<div id=\"header\"><h1>Server Error</h1></div>\n<div id=\"content\">\n<div class=\"content-container\"><fieldset>\n<h2>404 - File or directory not found.</h2>\n<h3>The resource you are looking for might have been removed, had its name changed, or is temporarily unavailable.</h3>\n</fieldset></div>\n</div>\n</body>\n</html>").getBytes() );
            return;
        }

        // nav playlist ou playlistmovie
        if ( nav == null 
            && mode != null 
            && ( mode.equals("playlist") || mode.equals("playlistmovie") ) 
            && ( uri.equals("/") || uri.equals("/id") || uri.equals("/id/") || uri.startsWith("/id/") ) 
        ){
            if ( uri.length() > 1 && uri.endsWith("/") ){
                redirect(output, uri.substring(0, uri.length()-1));
                return;
            }
            if ( uri.equals("/id") ){
                redirect(output, "/");
                return;
            }
            String txt="Erro interno 37676.";
            String id="";
            if ( uri.startsWith("/id/") )
               id=uri.substring(4);
            if ( mode.equals("playlist") )
               txt=new Texto_longo().get_html_virtual_playlist(host_display);
            if ( mode.equals("playlistmovie") )
               txt=new Texto_longo().get_html_virtual_playlistmovie(id);
            sb = new StringBuilder();
            for (String line: new String[] {
                    "HTTP/1.1 200 OK\r\n",
                    "Content-Type: text/html; charset=UTF-8\r\n",
                    "Access-Control-Allow-Origin: *\r\n",
                    "X-Frame-Options: SAMEORIGIN\r\n",
                    "\r\n",
                    txt
                }) {
                sb.append(line);
                System.out.print("    |---> " + line);
            }
            System.out.println("    |");
            output.write(sb.toString().getBytes());
            return;
        }
        
        // nav playlistserver
        if ( nav == null 
            && mode != null 
            && mode.equals("playlistserver")
            && uri.equals("/"+titulo_url)
        ){
            String txt="HTTP/1.1 200 OK\r\n";
            txt+="Content-Type: text/html; charset=UTF-8\r\n";
            txt+="Access-Control-Allow-Origin: *\r\n";
            txt+="X-Frame-Options: SAMEORIGIN\r\n";
            txt+="\r\n";
            if ( playlistserver == null )
                txt+="erro interno 435353";
            else{
                if ( header_acao == null )
                    txt+=playlistserver.get_html_sem_acao();
                else
                    txt+=playlistserver.perguntando(header_acao, false);
            }
            output.write(txt.getBytes());
            return;
        }
        sb = new StringBuilder();
        nav = dir + uri.replace("//", "/").trim();
        if ( titulo_url.length() > 0 ){
            if ( uri.startsWith("/"+titulo_url) )
                nav = dir + uri.substring(titulo_url.length()+1).replace("//", "/").trim(); 
            else
                nav = "[invalido]";
        }
        nav = nav.replace("//", "/");
        nav = decodeUrl(nav);
        // nav detect index
        if (!new File(nav).isFile()) {
            nav += "/";
            int c = 9;
            while (nav.contains("//") && c-- > 0) nav = nav.replace("//", "/");
            for (
                String index: new String[] {
                    "index.html",
                    "index.htm"
                }) {
                if (new File(nav + index).exists()) {
                    nav += index;
                    String tmp=lendo_arquivo(nav);
                    // if [GLOBAL]
                    if ( tmp.contains("[GLOBAL]") ){
                        String inject_global=getListaCompleta(new File(dir), 0)                        
                                + "`;\nthis.epoch_load=" + epochmili(null)
                                + ";\nthis.epoch_delta=this.epoch_load-(new Date).valueOf()"
                                + ";\nthis.fim_inject=`";
                        
                        tmp=tmp.replace("[GLOBAL]",inject_global);
                        sb = new StringBuilder();
                        for (String line: new String[] {
                                "HTTP/1.1 200 OK\r\n",
                                "Content-Type: text/html; charset=UTF-8\r\n",
                                "Access-Control-Allow-Origin: *\r\n",
                                "X-Frame-Options: SAMEORIGIN\r\n",
                                "\r\n"
                            }) {
                            sb.append(line);
                            System.out.print("    |---> " + line);
                        }
                        System.out.println("    |---> index text global suprimido.");
                        sb.append(tmp);
                        output.write(sb.toString().getBytes());
                        return;
                    }
                    break;
                }
            }
        }
        // stream tv
        if ( uri.startsWith("/onplaytv.net/") 
             || uri.startsWith("/embtv.site/")
             || uri.startsWith("/chaturbate.com/") 
             || uri.startsWith("/embedcanaistv.com/")     
             || uri.startsWith("/embedtv.digital/")                     
             || uri.startsWith("/s2.100mundial.icu/")                     
             || uri.startsWith("/fazoeli.fun/")                     
             || uri.startsWith("/cdn.fazoeli.fun/") // fazueli
             || uri.startsWith("/s2.fazoeli.fun/")                     
             || uri.contains("embedtv")
             || uri.contains("/redirect_stream_tv/") // definitivo
        ){
            String header="";
            if ( uri.startsWith("/onplaytv.net/") || uri.startsWith("/embtv.site/") )
                header="referer: https://embedcanaistv.com/\n";
            if ( uri.startsWith("/embedcanaistv.com/") )
                header="accept: text/html\n";
            if ( uri.startsWith("/embedtv.digital/") 
                 || uri.startsWith("/s2.100mundial.icu/") 
                 || uri.startsWith("/fazoeli.fun/") 
                 || uri.startsWith("/cdn.fazoeli.fun/") 
                 || uri.startsWith("/s2.fazoeli.fun/") 
                 || uri.contains("/redirect_stream_tv/") // definitivo
            )
                header="origin: https://embedtv-3.icu\nreferer: https://embedtv-3.icu/\n";
            ByteArrayOutputStream baos=new ByteArrayOutputStream();
            y.curl_timeout=3000;
            y.curl(baos, header, "GET", false, false, "https:/"+uri.replaceAll("/redirect_stream_tv/", "/"), null, null, null, null, null, null);
            byte [] bytes=baos.toByteArray();
            output.write(y.curl_response_header.getBytes());
            output.write(bytes);
            return;
        }
        // favicon
        if ( ! uri.equals("/favicon.ico"))
            System.out.println("nav: " + nav + ";uri: " + uri);
        // nav file
        if (new File(nav).exists() && new File(nav).isFile() && endsWith_OK(nav, endsWiths)) {
            long lenFile = new File(nav).length();
            if ( header_range > -1 && header_range >= lenFile)
                header_range = -1;
            if ( header_range > -1){
                if ( header_userAgent.contains(" TV ") )
                    lenTarget=lenFile-header_range;
                else
                    lenTarget=25000000; // 25MB
                if ( (header_range + lenTarget) > lenFile )
                    lenTarget=lenFile-header_range;
                for (String line: new String[] {
                        "HTTP/1.1 206 OK\r\n",
                        "Content-Type: " + getContentType(nav) + "; charset=UTF-8\r\n",
                        "accept-ranges: bytes\r\n",
                        "Content-Length: " + lenTarget + "\r\n",
                        "Content-Range: bytes " + header_range + "-" + (header_range+lenTarget-1) + "/" + lenFile + "\r\n",
                        "Connection: close\r\n",
                        "Access-Control-Allow-Origin: *\r\n",
                        "X-Frame-Options: SAMEORIGIN\r\n",
                        "\r\n"
                    }) {
                    sb.append(line);
                    System.out.print("    |---> " + line);
                }
            }else{  
                for (String line: new String[] {
                        "HTTP/1.1 200 OK\r\n",
                        "Content-Type: " + getContentType(nav) + "; charset=UTF-8\r\n",
                        "Content-Length: " + lenFile + "\r\n",
                        "Access-Control-Allow-Origin: *\r\n",
                        "X-Frame-Options: SAMEORIGIN\r\n",
                        "\r\n"
                    }) {
                    sb.append(line);
                    System.out.print("    |---> " + line);
                }
            }    
            System.out.println("    |");
            output.write(sb.toString().getBytes());
            try {
                System.out.println("iniciando leitura do arquivo: " + nav);
                transf_bytes(output, nav, header_range, lenTarget);
                System.out.println("finalizando leitura do arquivo: " + nav);
                return;
            } catch (Exception e) {
                if ( e.toString().contains("Software caused connection abort: socket write error") ){}else{
                    System.out.println("erro 404, a leitura parou do nada, o browser parou de ler ela: " + nav + " - " + e.toString());                    
                }
                return;
            }
        } else {
            if (uri.equals("/favicon.ico")) {
                return;
            }else{
                System.out.println("nao encontrou o arquivo: " + nav);
            }
        }
        // list files
        if (  
                !uri.contains("..")
                && uri.startsWith("/" + titulo_url)
                && new File(dir+ decodeUrl(uri.substring(titulo_url.length()>0?(titulo_url.length()+1):0)) ).isDirectory() 
        ){
            sb = new StringBuilder();
            for (String line: new String[] {
                    "HTTP/1.1 200 OK\r\n",
                    "Content-Type: text/html; charset=UTF-8\r\n",
                    "Access-Control-Allow-Origin: *\r\n",
                    "X-Frame-Options: SAMEORIGIN\r\n",
                    "\r\n",
                    "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">\n",
                    "<html xmlns=\"http://www.w3.org/1999/xhtml\">\n",
                    "<meta charset='UTF-8' http-equiv='X-UA-Compatible' content='IE=9'>\n",
                    "<br>\n",
                    "&nbsp;" + titulo + "<br>\n"
                }) {
                sb.append(line);
                System.out.print("    |---> " + line);
            }
            String token="/"+titulo_url;
            if ( titulo_url.equals("") )
                token="";
            String pre=uri.substring(token.length());
            if ( !pre.endsWith("/") )
                pre+="/";
            File[] files = new File(dir+decodeUrl(pre)).listFiles();
            Arrays.sort(files, new Comparator < File > () {
                public int compare(File f1, File f2) {
                    if (f1.lastModified() < f2.lastModified()) return 1;
                    if (f1.lastModified() > f2.lastModified()) return -1;
                    return 0;
                }
            });
            sb.append("<style>.bordered {border: solid #ccc 3px;border-radius: 6px;}.bordered tr:hover {background: #fbf8e9;}.bordered td, .bordered th {border-left: 2px solid #ccc;border-top: 2px solid #ccc;padding: 10px;}</style>");
            System.out.println("<style>.bordered {border: solid #ccc 3px;border-radius: 6px;}.bordered tr:hover {background: #fbf8e9;}.bordered td, .bordered th {border-left: 2px solid #ccc;border-top: 2px solid #ccc;padding: 10px;}</style>");
            sb.append("<table id='tablebase' class='bordered' style='font-family:Verdana,sans-serif;font-size:10px;border-spacing: 0;'>");
            System.out.println("<table id='tablebase' class='bordered' style='font-family:Verdana,sans-serif;font-size:10px;border-spacing: 0;'>");
            for (File p: files) {
                //if (!p.isFile()) continue;
                if (!endsWith_OK(p.getName(), endsWiths)) continue;
                sb.append("<tr><td dd='"+uri.substring(1) + "/"+"'>" + new SimpleDateFormat("dd/MM/yyyy HH:mm:ss").format(new Date(p.lastModified())).toString() + "</td><td>" + "<a href=\"" + token + pre + p.getName() + "\">" + p.getName() + "</a></td></tr>\n");
                System.out.println("<tr><td>" + new SimpleDateFormat("dd/MM/yyyy HH:mm:ss").format(new Date(p.lastModified())).toString() + "</td><td>" + "<a href=\"" + token + pre + p.getName() + "\">" + p.getName() + "</a></td></tr>\n");
            }
            sb.append("</table></html>");
            System.out.println("</table></html>");
            System.out.println("    |");
            output.write(sb.toString().getBytes());
            return;
        }
        if ( uri.equals("/duolingo") ){            
            File f=new File("D:\\ProgramFiles\\log_duolingo\\logs");            
            if ( f.exists() ){
                File [] items=f.listFiles();
                for ( int i=0;i<items.length;i++ ){
                    if ( items[i].isFile() ){
                        if ( cache_duolingo_hashmap.containsKey( items[i].getName() ) )
                            continue;
                        else{
                            cache_duolingo_hashmap.put(items[i].getName(), true);
                            cache_duolingo_sb.append(items[i].getName());
                            cache_duolingo_sb.append("\n");
                            readLine(items[i].getAbsolutePath());
                            ArrayList<String> lines=readAllLines();
                            for ( int j=0;j<lines.size();j++ ){                        
                                cache_duolingo_sb.append(lines.get(j));
                                cache_duolingo_sb.append("\n");
                            }
                            closeLine();
                        }
                    }
                }

                String result="""
HTTP/1.1 200 OK

<!doctype html><html lang="pt-BR"><head><meta charset='utf-8'><title>Score Duolingo
</title><script src='https://cdn.jsdelivr.net/npm/chart.js'></script></head><body><h2></h2><p></p><p></p>
<canvas id='chart' width='1200' height='450'></canvas>
<script>const data=`""" + cache_duolingo_sb.toString() +
"""
`;
const labels = ['2025-12-03','2025-12-04','2025-12-05','2025-12-06','2025-12-07','2025-12-08','2025-12-09','2025-12-10','2025-12-11','2025-12-12'];
const datasets = [
{ label: 'ana paula Ara\u00fajo', data: [855, 855, null, null, null, null, null, null, null, 855] }
,{ label: 'Belle Fontes', data: [null, null, null, null, null, null, null, null, null, 921] }
,{ label: 'Bruno', data: [null, null, null, null, null, null, null, null, null, 496] }
,{ label: 'Chris Hodges', data: [null, null, null, null, null, null, null, null, null, 1210] }
,{ label: 'Cley Bolivar', data: [null, null, null, null, null, null, null, null, null, 3462] }
,{ label: 'Cris Alc\u00e2ntara', data: [null, null, null, null, null, null, null, null, null, 345] }
,{ label: 'Giuliano Calzetta', data: [null, null, null, null, null, null, null, null, null, 1569] }
,{ label: 'Jacob', data: [null, null, null, null, null, null, null, null, null, 1117] }
,{ label: 'Jessica', data: [null, null, null, null, null, null, null, null, null, 1799] }
,{ label: 'Katie', data: [null, null, null, null, null, null, null, null, null, 1566] }
,{ label: 'Kerventz Metellus', data: [null, null, null, null, null, null, null, null, null, 2733] }
,{ label: 'larissa-pedrini', data: [null, null, null, null, null, null, null, null, null, 380] }
,{ label: 'Leoc\u00edlia', data: [null, null, null, null, null, null, null, null, null, 1345] }
,{ label: 'liliana', data: [null, null, null, null, null, null, null, null, null, 937] }
,{ label: 'Lusia Ribeiro', data: [null, null, null, null, null, null, null, null, null, 1464] }
,{ label: 'NicoyAry Illanes', data: [null, null, null, null, null, null, null, null, null, 1152] }
,{ label: 'Oliver', data: [null, null, null, null, null, null, null, null, null, 2835] }
,{ label: 'Pierre', data: [null, null, null, null, null, null, null, null, null, 1232] }
,{ label: 'severino Gomes do Nascimento', data: [null, null, null, null, null, null, null, null, null, 659] }
,{ label: 'y y', data: [null, null, null, null, null, null, null, null, null, 2946] },
];
function ultimoDomingo19h(str){ // console.log(ultimoDomingo19h("20251212_182352"));
    // Extrai partes da data (AAAAMMDD_HHMMSS)
    const ano = Number(str.slice(0, 4));
    const mes = Number(str.slice(4, 6)) - 1; // JS usa 0-11
    const dia = Number(str.slice(6, 8));

    const hora = Number(str.slice(9, 11));
    const min = Number(str.slice(11, 13));
    const seg = Number(str.slice(13, 15));

    // Data base
    const dt = new Date(ano, mes, dia, hora, min, seg);

    // Calcula o último domingo
    const domingo = new Date(dt);
    const diasAtras = domingo.getDay(); // 0=domingo
    domingo.setDate(domingo.getDate() - diasAtras);

    // Ajusta para 19:00
    domingo.setHours(19, 0, 0, 0);

    // Se for >= a data base, volta 7 dias
    if (domingo >= dt) {
        domingo.setDate(domingo.getDate() - 7);
    }

    // Formata para AAAAMMDD_HHMMSS
    const pad = n => String(n).padStart(2, '0');

    return (
        domingo.getFullYear().toString() +
        pad(domingo.getMonth() + 1) +
        pad(domingo.getDate()) +
        "_" +
        pad(domingo.getHours()) +
        pad(domingo.getMinutes()) +
        pad(domingo.getSeconds())
    );
}
function diff(str, segundosDiff){ // console.log(diff("20251212_182352", -3));
    // Extrai partes da data (AAAAMMDD_HHMMSS)
    const ano = Number(str.slice(0, 4));
    const mes = Number(str.slice(4, 6)) - 1;
    const dia = Number(str.slice(6, 8));

    const hora = Number(str.slice(9, 11));
    const min = Number(str.slice(11, 13));
    const seg = Number(str.slice(13, 15));

    // Cria o Date correspondente
    const dt = new Date(ano, mes, dia, hora, min, seg);

    // Aplica diferença em segundos
    dt.setSeconds(dt.getSeconds() + segundosDiff);

    // Função para completar com 2 dígitos
    const pad = n => String(n).padStart(2, '0');

    // Retorna no formato AAAAMMDD_HHMMSS
    return (
        dt.getFullYear().toString() +
        pad(dt.getMonth() + 1) +
        pad(dt.getDate()) +
        "_" +
        pad(dt.getHours()) +
        pad(dt.getMinutes()) +
        pad(dt.getSeconds())
    );
}
console.log(`new Chart(document.getElementById('chart'), {type:'line',data:{labels:labels,datasets:datasets}});`);
</script>
</body>
</html>                          
""";
                output.write(result.getBytes());
                return;
            }            
            output.write("HTTP/1.1 404 Not Found\r\n\r\n404".getBytes());
            return;
        }
        output_404(output);
    }
    private void output_404(OutputStream output) throws Exception{
        StringBuilder sb = new StringBuilder();
        for(String line: new String[]{
                "HTTP/1.1 404 Not Found\r\n",
                "Content-Type: text/html; charset=UTF-8\r\n",
                "Access-Control-Allow-Origin: *\r\n",
                "X-Frame-Options: SAMEORIGIN\r\n",
                "\r\n",
                "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">\n<html xmlns=\"http://www.w3.org/1999/xhtml\">\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=iso-8859-1\"/>\n<title>404 - File or directory not found.</title>\n<style type=\"text/css\">\n\nbody{margin:0;font-size:.7em;font-family:Verdana, Arial, Helvetica, sans-serif;background:#EEEEEE;}\nfieldset{padding:0 15px 10px 15px;} \nh1{font-size:2.4em;margin:0;color:#FFF;}\nh2{font-size:1.7em;margin:0;color:#CC0000;} \nh3{font-size:1.2em;margin:10px 0 0 0;color:#000000;} \n#header{width:96%;margin:0 0 0 0;padding:6px 2% 6px 2%;font-family:\"trebuchet MS\", Verdana, sans-serif;color:#FFF;\nbackground-color:#555555;}\n#content{margin:0 0 0 2%;position:relative;}\n.content-container{background:#FFF;width:96%;margin-top:8px;padding:10px;position:relative;}\n\n</style>\n</head>\n<body>\n<div id=\"header\"><h1>Server Error</h1></div>\n<div id=\"content\">\n<div class=\"content-container\"><fieldset>\n<h2>404 - File or directory not found.</h2>\n<h3>The resource you are looking for might have been removed, had its name changed, or is temporarily unavailable.</h3>\n</fieldset></div>\n</div>\n</body>\n</html>"
        }){
            sb.append(line);
            System.out.print("    |---> " + line);
        }
        System.out.println("    |");
        output.write(sb.toString().getBytes());
    }
    
    private String getContentType(String caminho) {
        // https://mimetype.io/all-types
        if (caminho.endsWith(".html") || caminho.endsWith(".htm")) return "text/html";
        if (caminho.endsWith(".css")) return "text/css";
        if (caminho.endsWith(".js")) return "text/javascript";
        if (caminho.endsWith(".txt")) return "text/plain";
        if (caminho.endsWith(".png")) return "image/png";
        if (caminho.endsWith(".ico")) return "image/x-icon";
        if (caminho.endsWith(".jpg")) return "image/jpeg";
        if (caminho.endsWith(".jpeg")) return "image/jpeg";
        if (caminho.endsWith(".webp")) return "image/webp";
        if (caminho.endsWith(".gif")) return "image/gif";
        if (caminho.endsWith(".mkv")) return "video/x-matroska";
        if (caminho.endsWith(".avi")) return "video/x-msvideo";
        if (caminho.endsWith(".movie")) return "video/x-sgi-movie";
        if (caminho.endsWith(".webm")) return "video/webm";
        if (caminho.endsWith(".mp4")) return "audio/aac";
        if (caminho.endsWith(".mp3")) return "audio/mpeg";
        if (caminho.endsWith(".ogg")) return "audio/ogg";
        if (caminho.endsWith(".wma")) return "audio/x-ms-wma";
        if (caminho.endsWith(".pdf")) return "application/pdf";
        return "application/octet-stream";
    }
    public ArrayList < String > lendo_arquivo_display(String caminho) throws Exception {
        ArrayList < String > result = new ArrayList < String > ();
        String strLine;
        try {
            FileReader rf = new FileReader(caminho);
            BufferedReader in = new BufferedReader(rf);
            while ((strLine = in .readLine()) != null) result.add(strLine); in .close();
            rf.close();
        } catch (Exception e) {
            throw new Exception("nao foi possivel encontrar o arquivo " + caminho);
        }
        return result;
    }
    private void transf_bytes_old(OutputStream output, String nav, long header_range_resume, long lenTarget) throws Exception {
        int count;
        DataInputStream dis = new DataInputStream(new FileInputStream(nav));
        byte[] buffer = new byte[8192];
        if ( header_range_resume > 0 ) 
            dis.skip(header_range_resume);
        if ( header_range_resume > 0 && lenTarget < buffer.length )
            buffer = new byte[(int)lenTarget];
        while ((count = dis.read(buffer)) > 0){
            //gera lentidao para teste
            //sleepMillis(50);
            output.write(buffer, 0, count);
            if ( header_range_resume > 0 ){
                lenTarget-=count;
                if ( lenTarget <= 0 )
                    break;    
                if ( lenTarget < buffer.length )
                    buffer = new byte[(int)lenTarget];
            }
        }
        dis.close();
    }
    private void transf_bytes(OutputStream output, String nav, long header_range_resume, long lenTarget) throws Exception {
        int count;
        RandomAccessFile raf = new RandomAccessFile(nav, "r");
        byte[] buffer = new byte[8192];
        try {
            if (header_range_resume > 0) {
                raf.seek(header_range_resume);
            }
            while (true) {
                int bytesToRead = buffer.length;
                if (header_range_resume > 0 && lenTarget < buffer.length) {
                    bytesToRead = (int) lenTarget;
                }
                count = raf.read(buffer, 0, bytesToRead);
                if (count < 0) {
                    break;
                }
                output.write(buffer, 0, count);
                if (header_range_resume > 0) {
                    lenTarget -= count;
                    if (lenTarget <= 0) {
                        break;
                    }
                }
            }
        } finally {
            raf.close();
        }
    }
    private boolean endsWith_OK(String url, String ends) {
        if (ends.equals("")) return true;
        String[] partes = ends.split(",");
        for (int i = 0; i < partes.length; i++)
            if (url.endsWith("." + partes[i])) return true;
        return false;
    }
    private void redirect(OutputStream output, String uri) throws Exception{
        // clean cache redirect -> fonte: https://superuser.com/questions/304589/how-can-i-make-chrome-stop-caching-redirects
        output.write(("HTTP/1.1 301 Moved Permanently\nLocation: " + uri + "\n\n").getBytes());
    }
}

@SuppressWarnings({"unchecked", "deprecation"})
class ConnGui extends javax.swing.JFrame {
    public ConnGui() {
        System.out.println("Somente 1 server ou 1 connect eh permitido!");
        initComponents();
        setVisible(true);
    }
    
    private void insert_error(String a){
        if ( a.equals("java.net.ConnectException: Connection refused: connect") ){
            label_status.setText("Nao foi possivel conectar!");
            insert_list("Nao foi possivel conectar!");
            label_status.setForeground(java.awt.Color.red);
            return;
        }    
        if ( a.equals("java.net.SocketException: Connection reset") ){
            label_status.setText("Desconectado!");
            insert_list("Desconectado!");
            label_status.setForeground(java.awt.Color.red);
            return;
        }
        if ( a.equals("java.net.BindException: Cannot assign requested address: bind") ){
            label_status.setText("Porta nao disponivel!");
            insert_list("Porta nao disponivel!");
            label_status.setForeground(java.awt.Color.red);
            return;
        }     
        if ( a.equals("java.net.BindException: Address already in use: bind") ){
            label_status.setText("Porta em uso!");
            insert_list("Porta em uso!");
            label_status.setForeground(java.awt.Color.red);
            return;
        }             
        insert_list("Erro: " + a);
    }
    private void btn_connectActionPerformed(java.awt.event.ActionEvent e) {                                            
        clicked++;
        if ( clicked > 1 ){
            label_status.setText("feche o programa!");
            label_status.setForeground(java.awt.Color.red);
            insert_list("connect ou server ja foi usado!, feche o programa!");
            return;
        }
        btn_connect.setEnabled(false);
        btn_server.setEnabled(false);        
        try{
            socket=new java.net.Socket(txt_ip.getText(), Integer.parseInt(txt_port.getText()));            
            label_status.setText("connected");
            label_status.setForeground(java.awt.Color.green);
            new Thread() {
                public void run() {
                    try {
                        java.io.InputStream input = socket.getInputStream();
                        output = socket.getOutputStream();
                        byte [] buff=new byte[1024];
                        while(true){
                            int len=input.read(buff, 0, buff.length);
                            if ( len < 0 )                                
                                break;
                            if ( len == 0 )
                                continue;
                            String s="receive: ";
                            for ( int i=0;i<len;i++ ){
                                int p=(int)buff[i];
                                if ( p < 0 )
                                    p+=128;
                                s+=" "+p;
                            }                        
                            insert_list(s);
                        }  
                    }catch(Exception ee){
                        insert_error(ee.toString());
                        try{
                            socket.close();
                        }catch(Exception eee){
                            
                        }
                    }
                }
            }.start();            
        }catch(Exception ee){
            insert_error(ee.toString());
        }                
    }                                           
    
    private javax.swing.DefaultListModel<String> model = null;
    private void insert_list(String a){
        if ( model == null ){
            model = new javax.swing.DefaultListModel<>();        
            list.setModel(model);        
        }
        model.add(0, a);
        System.out.println(a);
    }
    
    private java.net.Socket socket = null;
    private java.net.ServerSocket serverSocket = null;
    private java.io.OutputStream output=null;
    private int clicked=0;
    private void btn_serverActionPerformed(java.awt.event.ActionEvent e){
        clicked++;
        if ( clicked > 1 ){
            label_status.setText("feche o programa!");
            label_status.setForeground(java.awt.Color.red);
            insert_list("connect ou server ja foi usado!, feche o programa!");
            return;
        }
        btn_connect.setEnabled(false);
        btn_server.setEnabled(false);
        try {
            serverSocket = new java.net.ServerSocket(Integer.parseInt(txt_port.getText()), 1, java.net.InetAddress.getByName(txt_ip.getText()));
            label_status.setText("server on");
            label_status.setForeground(java.awt.Color.green);
            new Thread() {
                public void run() {
                    try {
                        socket = serverSocket.accept();                                                                        
                        try{
                            serverSocket.close();
                        }catch(Exception ee){
                            
                        }                                
                        java.io.InputStream input = socket.getInputStream();
                        output = socket.getOutputStream();
                        byte [] buff=new byte[1024];
                        while(true){
                            int len=input.read(buff, 0, buff.length);
                            if ( len < 0 )                                
                                break;
                            if ( len == 0 )
                                continue;
                            String s="recebido: ";
                            for ( int i=0;i<len;i++ ){
                                int p=(int)buff[i];
                                if ( p < 0 )
                                    p+=128;
                                s+=" "+p;
                            }                        
                            insert_list(s);
                        }  
                    }catch(Exception ee) {
                        insert_error(ee.toString());
                    }
                }
            }.start();            
        }catch(Exception ee){
            insert_error(ee.toString());
        }
    }                                          

    private void btn_sendActionPerformed(java.awt.event.ActionEvent e) {                                         
        if ( output == null ){
            insert_list("erro: nao conectado!");
        }else{
            try{
                String s=txt.getText();
                if ( s.length() == 0 )
                    return;
                byte [] bytes=s.getBytes();
                String d="enviado: " + s + " - bytes:";
                for ( int i=0;i<bytes.length;i++ ){
                    int t=(int)bytes[i];
                    if ( t < 0 )
                        t+=128;
                    d+=" "+t;
                }
                insert_list(d);
                output.write(txt.getText().getBytes());
            }catch(Exception ee){
                insert_list("erro: " + ee.toString());
            }
        }
    }                                        

    private void initComponents() {
        txt_ip = new javax.swing.JTextField();
        btn_connect = new javax.swing.JButton();
        btn_server = new javax.swing.JButton();
        txt_port = new javax.swing.JTextField();
        jScrollPane1 = new javax.swing.JScrollPane();
        list = new javax.swing.JList<>();
        txt = new javax.swing.JTextField();
        btn_send = new javax.swing.JButton();
        label_status = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        txt_ip.setText("127.0.0.1");

        btn_connect.setText("connect");
        btn_connect.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btn_connectActionPerformed(evt);
            }
        });

        btn_server.setText("server");
        btn_server.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btn_serverActionPerformed(evt);
            }
        });

        txt_port.setText("300");

        list.setModel(new javax.swing.AbstractListModel<String>() {
            String[] strings = { };
            public int getSize() { return strings.length; }
            public String getElementAt(int i) { return strings[i]; }
        });
        jScrollPane1.setViewportView(list);

        txt.setText("88");

        btn_send.setText("send");
        btn_send.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btn_sendActionPerformed(evt);
            }
        });

        label_status.setText("Status: ");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                        .addGroup(layout.createSequentialGroup()
                            .addComponent(txt_ip, javax.swing.GroupLayout.PREFERRED_SIZE, 220, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                            .addComponent(txt_port, javax.swing.GroupLayout.PREFERRED_SIZE, 220, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGroup(layout.createSequentialGroup()
                            .addComponent(btn_connect)
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                            .addComponent(btn_server)
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                            .addComponent(label_status, javax.swing.GroupLayout.PREFERRED_SIZE, 151, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addComponent(jScrollPane1))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(txt, javax.swing.GroupLayout.PREFERRED_SIZE, 357, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(btn_send)))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(txt_ip, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(txt_port, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(btn_connect)
                    .addComponent(btn_server)
                    .addComponent(label_status))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(txt, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(btn_send))
                .addContainerGap(24, Short.MAX_VALUE))
        );

        pack();
    }
    
    private javax.swing.JButton btn_connect;
    private javax.swing.JButton btn_send;
    private javax.swing.JButton btn_server;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JLabel label_status;
    private javax.swing.JList<String> list;
    private javax.swing.JTextField txt;
    private javax.swing.JTextField txt_ip;
    private javax.swing.JTextField txt_port;
}

@SuppressWarnings({"unchecked", "deprecation"})
class ProxyServer {
    private String host="localhost";
    private int PROXY_PORT = 8080;
    private boolean verbose = false; // Modo verbose desativado por padrão
    public ProxyServer(String host, int port, boolean verbose_){
        this.host=host;
        this.PROXY_PORT=port;
        this.verbose=verbose_;

        try (ServerSocket serverSocket = new ServerSocket(PROXY_PORT)) {
            System.out.println("Servidor Proxy escutando na porta " + PROXY_PORT);

            while (true) {
                Socket clientSocket = serverSocket.accept();
                System.out.println("Conexão recebida de: " + clientSocket.getInetAddress());

                // Cria uma thread para lidar com a requisição do cliente
                new Thread(() -> {
                    try {
                        handleClientRequest(clientSocket);
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }).start();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void handleClientRequest(Socket clientSocket) throws IOException {
        try (BufferedReader clientInput = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
             OutputStream clientOutput = clientSocket.getOutputStream()) {

            // Lê a primeira linha da requisição (ex: GET /path HTTP/1.1)
            String requestLine = clientInput.readLine();
            if (requestLine == null || requestLine.isEmpty()) {
                return; // Requisição inválida
            }

            // Extrai o método, caminho e versão HTTP
            String[] requestParts = requestLine.split(" ");
            if (requestParts.length < 3) {
                return; // Requisição malformada
            }

            String method = requestParts[0]; // Ex: GET
            String path = requestParts[1];  // Ex: /index.html
            String httpVersion = requestParts[2]; // Ex: HTTP/1.1

            // Lê o cabeçalho "Host" e outros cabeçalhos
            String hostHeader = "";
            StringBuilder requestHeaders = new StringBuilder();
            String line;
            while (!(line = clientInput.readLine()).isEmpty()) {
                requestHeaders.append(line).append("\r\n");
                if (line.startsWith("Host:")) {
                    hostHeader = line.substring("Host:".length()).trim();
                }
            }

            if (hostHeader.isEmpty()) {
                return; // Host não especificado
            }

            // Modo verbose: exibe os cabeçalhos da requisição
            if (verbose) {
                System.out.println("=== Request ===");
                System.out.println(requestLine);
                System.out.print(requestHeaders.toString());
                System.out.println("=========================================");
            }

            // Extrai o host e a porta do cabeçalho "Host"
            String host;
            int port;
            if (hostHeader.contains(":")) {
                String[] hostParts = hostHeader.split(":");
                host = hostParts[0];
                port = Integer.parseInt(hostParts[1]);
            } else {
                host = hostHeader;
                port = 80; // Porta padrão para HTTP
            }

            // Verifica se é uma requisição HTTPS (CONNECT)
            if (method.equalsIgnoreCase("CONNECT")) {
                // Requisição HTTPS (Tunelamento SSL/TLS)
                handleHttpsRequest(clientSocket, host, port, clientOutput);
            } else {
                // Requisição HTTP
                handleHttpRequest(clientSocket, host, port, method, path, httpVersion, requestHeaders.toString(), clientInput, clientOutput);
            }
        } finally {
            try {
                clientSocket.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private void handleHttpRequest(Socket clientSocket, String host, int port, String method, String path,
                                         String httpVersion, String requestHeaders, BufferedReader clientInput, OutputStream clientOutput) {
        try (Socket targetSocket = new Socket(host, port);
             BufferedReader targetInput = new BufferedReader(new InputStreamReader(targetSocket.getInputStream()));
             OutputStream targetOutput = targetSocket.getOutputStream()) {

            // Reconstroi a requisição para o servidor de destino
            StringBuilder requestBuilder = new StringBuilder();
            requestBuilder.append(method).append(" ").append(path).append(" ").append(httpVersion).append("\r\n");
            requestBuilder.append(requestHeaders); // Inclui os cabeçalhos originais
            requestBuilder.append("\r\n");

            // Modo verbose: exibe os cabeçalhos da requisição encaminhada
            if (verbose) {
                System.out.println("=== Requisicao Encaminhada ===");
                System.out.print(requestBuilder.toString());
                System.out.println("===========================================");
            }

            // Encaminha a requisição para o servidor de destino
            targetOutput.write(requestBuilder.toString().getBytes());
            targetOutput.flush();

            // Lê a resposta do servidor de destino
            StringBuilder responseHeaders = new StringBuilder();
            String responseLine;
            while ((responseLine = targetInput.readLine()) != null) {
                responseHeaders.append(responseLine).append("\r\n");
                if (responseLine.isEmpty()) {
                    break; // Fim dos cabeçalhos
                }
            }

            // Modo verbose: exibe os cabeçalhos da resposta
            if (verbose) {
                System.out.println("=== Response ===");
                System.out.print(responseHeaders.toString());
                System.out.println("========================================");
            }

            // Encaminha os cabeçalhos da resposta para o cliente
            clientOutput.write(responseHeaders.toString().getBytes());
            clientOutput.flush();

            // Encaminha o corpo da resposta para o cliente
            forwardData(targetSocket.getInputStream(), clientOutput, "Resposta HTTP", false); // false = HTTP
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void handleHttpsRequest(Socket clientSocket, String host, int port, OutputStream clientOutput) {
        try (Socket targetSocket = new Socket(host, port)) {
            // Envia uma resposta 200 para o cliente (indicando que o túnel foi estabelecido)
            String response = "HTTP/1.1 200 Connection Established\r\n\r\n";
            clientOutput.write(response.getBytes());
            clientOutput.flush();

            // Modo verbose: exibe os cabeçalhos da resposta de estabelecimento do túnel
            if (verbose) {
                System.out.println("=== Cabecalhos da Resposta (Tunel HTTPS) ===");
                System.out.print(response);
                System.out.println("===========================================");
            }

            // Estabelece o túnel entre o cliente e o servidor de destino
            InputStream clientInput = clientSocket.getInputStream();
            OutputStream targetOutput = targetSocket.getOutputStream();

            // Encaminha os dados entre o cliente e o servidor de destino
            Thread clientToTarget = new Thread(() -> {
                try {
                    forwardData(clientInput, targetOutput, "Cliente -> Servidor (HTTPS)", true); // true = HTTPS
                } catch (IOException e) {
                    e.printStackTrace();
                }
            });

            Thread targetToClient = new Thread(() -> {
                try {
                    forwardData(targetSocket.getInputStream(), clientOutput, "Servidor -> Cliente (HTTPS)", true); // true = HTTPS
                } catch (IOException e) {
                    e.printStackTrace();
                }
            });

            clientToTarget.start();
            targetToClient.start();

            clientToTarget.join();
            targetToClient.join();
        } catch (IOException | InterruptedException e) {
            e.printStackTrace();
        }
    }

    private void forwardData(InputStream input, OutputStream output, String description, boolean isHttps) throws IOException {
        byte[] buffer = new byte[4096];
        int bytesRead;
        while ((bytesRead = input.read(buffer)) != -1) {
            output.write(buffer, 0, bytesRead);
            output.flush();

            // Modo verbose: exibe os cabeçalhos (se não for HTTPS)
            if (verbose && !isHttps) {
                String data = new String(buffer, 0, bytesRead);
                if (data.contains("\r\n\r\n")) { // Verifica se há cabeçalhos
                    System.out.println("=== " + description + " ===");
                    System.out.print(data.substring(0, data.indexOf("\r\n\r\n"))); // Exibe apenas os cabeçalhos
                    System.out.println("=========================");
                }
            }
        }
    }
}

@SuppressWarnings({"unchecked", "deprecation"})
class DnsDoHClient extends Util{
    /* modelo de uso
    DnsDoHClient doh=new DnsDoHClient();

    // config
    String domain="google.com";
    String dns="https://dns.adguard.com/dns-query";
    boolean flag_ipv6=false;

    // comunicação completa
    byte [] request=doh.encodeRequest("google.com", flag_ipv6);
    byte [] response=doh.send(dns, request);
    doh.decodeResponse(response);
    String ip=doh.decodeResponse_ip;
    System.out.println(ip);

    // decodeRequest
    doh.decodeRequest(request);
    System.out.println(doh.decodeRequest_domain);

    // encodeResponse
    String ip_="142.251.134.142"; // "2800:03f0:4004:0801:0000:0000:0000:200e"; // ips do google
    byte [] response_=doh.encodeResponse(domain, ip_);
    // valida encodeResponse
    doh.decodeResponse(response_);
    System.out.println(doh.decodeResponse_ip);      
    */
    public String get(String domain, boolean flag_ipv6, String dohUrl){
        String retorno=null;
        try {
            byte[] dnsQuery = encodeRequest(domain, flag_ipv6);
            byte[] dnsResponse = send(dohUrl, dnsQuery);
            decodeResponse(dnsResponse);
            retorno=decodeResponse_ip;
        } catch (Exception e) {
            e.printStackTrace();
        }
        return retorno;
    }

    public byte[] encodeResponse(String domain, String ip) throws Exception{
        boolean flag_ipv6=ip.contains(":");
        int clazz=1;
        if ( flag_ipv6 ){
            int [] partes=ipv6ToIntArray(ip);
            byte [] partes2=new byte[partes.length];
            for ( int i=0;i<partes.length;i++ )
                partes2[i]=(byte)partes[i];
            return encodeResponse(domain, flag_ipv6, clazz, partes2);
        }
        String [] partes=ip.split("\\.");
        byte [] partes2=new byte[partes.length];
        for ( int i=0;i<partes.length;i++ )
            partes2[i]=(byte)Integer.parseInt(partes[i]);
        return encodeResponse(domain, flag_ipv6, clazz, partes2);
    }
    
    public int get_type_by_flag(boolean flag_ipv6){
        return flag_ipv6?28:1;
    }
    public byte[] encodeRequest(String domain, boolean flag_ipv6) throws Exception{
        int type=get_type_by_flag(flag_ipv6);
        java.io.ByteArrayOutputStream byteArrayOutputStream = new java.io.ByteArrayOutputStream();
        byte[] header = new byte[]{
                0x00, 0x00, // ID (16 bits) - Pode ser qualquer valor
                0x01, 0x00, // Flags (16 bits) - Consulta padrão
                0x00, 0x01, // Número de perguntas (16 bits) - 1 pergunta
                0x00, 0x00, // Número de respostas (16 bits) - 0 respostas
                0x00, 0x00, // Número de registros de autoridade (16 bits) - 0
                0x00, 0x00  // Número de registros adicionais (16 bits) - 0
        };
        byteArrayOutputStream.write(header);
        String[] labels = domain.split("\\.");
        for (String label : labels) {
            byteArrayOutputStream.write(label.length()); // Tamanho do rótulo
            byteArrayOutputStream.write(label.getBytes()); // Rótulo
        }
        byteArrayOutputStream.write(0x00);
        byteArrayOutputStream.write(new byte[]{0x00, (byte)type}); // Tipo A
        byteArrayOutputStream.write(new byte[]{0x00, 0x01}); // Classe IN

        return byteArrayOutputStream.toByteArray();
    }

    public String decodeRequest_domain=null;
    public Integer decodeRequest_type=null;
    public Integer decodeRequest_clazz=null;
    public void decodeRequest(byte[] dnsQuery) {
        java.io.ByteArrayInputStream inputStream = new java.io.ByteArrayInputStream(dnsQuery);
        try {
            inputStream.read(new byte[12]);
            StringBuilder domain = new StringBuilder();
            int labelLength;
            while ((labelLength = inputStream.read()) != 0) {
                if (domain.length() > 0)
                    domain.append(".");
                byte[] labelBytes = new byte[labelLength];
                inputStream.read(labelBytes);
                domain.append(new String(labelBytes));
            }
            decodeRequest_domain=domain.toString();
            byte[] typeBytes = new byte[2];
            inputStream.read(typeBytes);
            decodeRequest_type=((typeBytes[0] & 0xFF) << 8) | (typeBytes[1] & 0xFF);
            byte[] classBytes = new byte[2];
            inputStream.read(classBytes);
            decodeRequest_clazz=((classBytes[0] & 0xFF) << 8) | (classBytes[1] & 0xFF);
        }catch (Exception e) {
            e.printStackTrace();
        }
    }
    
    public byte[] send(String dohUrl, byte[] dnsQuery) throws Exception {
        URL url = new URL(dohUrl);
        HttpURLConnection connection = (HttpURLConnection) url.openConnection();

        // Configura a requisição HTTP
        connection.setRequestMethod("POST");
        connection.setRequestProperty("Content-Type", "application/dns-message");
        connection.setDoOutput(true);

        // Envia a consulta DNS
        try (OutputStream outputStream = connection.getOutputStream()) {
            outputStream.write(dnsQuery);
        }

        // Lê a resposta DNS
        try (InputStream inputStream = connection.getInputStream()) {
            java.io.ByteArrayOutputStream responseBuffer = new java.io.ByteArrayOutputStream();
            byte[] buffer = new byte[1024];
            int bytesRead;
            while ((bytesRead = inputStream.read(buffer)) != -1) {
                responseBuffer.write(buffer, 0, bytesRead);
            }
            return responseBuffer.toByteArray();
        }
    }

    public byte[] encodeResponse(String domain, boolean flag_ipv6, int clazz, byte[] responseData) throws Exception{
        int type=get_type_by_flag(flag_ipv6);
        java.io.ByteArrayOutputStream byteArrayOutputStream = new java.io.ByteArrayOutputStream();

        // Header DNS (12 bytes)
        byte[] header = new byte[]{
                0x00, 0x00, // ID (16 bits) - Pode ser qualquer valor
                (byte)0x81, (byte)0x80, // Flags (16 bits) - Resposta padrão
                0x00, 0x01, // Número de perguntas (16 bits) - 1 pergunta
                0x00, 0x01, // Número de respostas (16 bits) - 1 resposta
                0x00, 0x00, // Número de registros de autoridade (16 bits) - 0
                0x00, 0x00  // Número de registros adicionais (16 bits) - 0
        };
        byteArrayOutputStream.write(header);

        // Domínio (formato DNS)
        String[] labels = domain.split("\\.");
        for (String label : labels) {
            byteArrayOutputStream.write(label.length()); // Tamanho do rótulo
            byteArrayOutputStream.write(label.getBytes()); // Rótulo
        }
        byteArrayOutputStream.write(0x00); // Fim do domínio

        // Tipo e classe da pergunta (A - IPv4, IN - Internet)
        byteArrayOutputStream.write(ByteBuffer.allocate(2).putShort((short) type).array()); // Tipo
        byteArrayOutputStream.write(ByteBuffer.allocate(2).putShort((short) clazz).array()); // Classe

        // Resposta
        byteArrayOutputStream.write(new byte[]{(byte) 0xC0, 0x0C}); // Ponteiro para o nome (comprimido)
        byteArrayOutputStream.write(ByteBuffer.allocate(2).putShort((short) type).array()); // Tipo
        byteArrayOutputStream.write(ByteBuffer.allocate(2).putShort((short) clazz).array()); // Classe
        byteArrayOutputStream.write(ByteBuffer.allocate(4).putInt(300).array()); // TTL (300 segundos)
        byteArrayOutputStream.write(ByteBuffer.allocate(2).putShort((short) responseData.length).array()); // Tamanho dos dados
        byteArrayOutputStream.write(responseData); // Dados da resposta

        return byteArrayOutputStream.toByteArray();
    }
    
    String decodeResponse_ip=null;
    public void decodeResponse(byte[] dnsResponse) {
        ByteBuffer buffer = ByteBuffer.wrap(dnsResponse);
        buffer.position(12);
        while (buffer.get() != 0) {} // Domínio
        buffer.getShort(); // Tipo
        buffer.getShort(); // Classe
        while (buffer.hasRemaining()) {
            if ((buffer.get() & 0xC0) == 0xC0)
                buffer.get(); // Pula o ponteiro comprimido
            else
                while (buffer.get() != 0) {} // Domínio
            int type = buffer.getShort() & 0xFFFF;
            int clazz = buffer.getShort() & 0xFFFF;
            long ttl = buffer.getInt() & 0xFFFFFFFFL;
            int length = buffer.getShort() & 0xFFFF;

            // Verifica o tipo de resposta
            if (clazz == 1) { // Classe IN (Internet)
                if (type == 1 && length == 4) { // Tipo A (IPv4)
                    byte[] ipBytes = new byte[4];
                    buffer.get(ipBytes);
                    decodeResponse_ip=
                            (ipBytes[0] & 0xFF) + "." +
                            (ipBytes[1] & 0xFF) + "." +
                            (ipBytes[2] & 0xFF) + "." +
                            (ipBytes[3] & 0xFF);
                } else if (type == 28 && length == 16) { // Tipo AAAA (IPv6)
                    byte[] ipBytes = new byte[16];
                    buffer.get(ipBytes);
                    StringBuilder ipv6 = new StringBuilder();
                    for (int i = 0; i < 16; i += 2) {
                        if (i > 0)
                            ipv6.append(":");
                        ipv6.append(String.format("%02x%02x", ipBytes[i] & 0xFF, ipBytes[i + 1] & 0xFF));
                    }
                    decodeResponse_ip=ipv6.toString();
                }else{
                    buffer.position(buffer.position() + length);
                }
            }else{
                buffer.position(buffer.position() + length);
            }
        }
    }
    
    public void printHex(byte[] bytes) {
        for (byte b : bytes) {
            System.out.printf("%02x ", b);
        }
        System.out.println();
    }    

    public int[] ipv6ToIntArray(String ipv6) {
        String normalizedIPv6 = normalizeIPv6(ipv6);
        String[] hexGroups = normalizedIPv6.split(":");
        int[] intArray = new int[16]; // IPv6 tem 16 bytes
        int index = 0;
        for (String group : hexGroups) {
            // Divide o grupo em 2 partes de 2 caracteres hexadecimais cada
            String hexByte1 = group.substring(0, 2);
            String hexByte2 = group.substring(2, 4);

            // Converte cada parte em um inteiro
            intArray[index++] = hexToInt(hexByte1);
            intArray[index++] = hexToInt(hexByte2);
        }

        return intArray;
    }    

    public int hexToInt(String hex) {
        return Integer.parseInt(hex, 16); // Base 16 para hexadecimal
    }
    
    public String normalizeIPv6(String ipv6) {
        String[] groups = ipv6.split(":");
        StringBuilder normalized = new StringBuilder();
        for (String group : groups) {
            while (group.length() < 4)
                group = "0" + group; // Preenche com zeros à esquerda
            normalized.append(group).append(":");
        }
        return normalized.substring(0, normalized.length() - 1);
    }
}

@SuppressWarnings({"unchecked", "deprecation"})
class DoHServerRunnable implements Runnable {
    private final Socket clientSocket;
    private final String dns_;
    public DoHServerRunnable(Socket clientSocket, String dns) {
        this.clientSocket = clientSocket;
        this.dns_=dns;
    }

    @Override
    public void run() {
        try (InputStream in = clientSocket.getInputStream();
            OutputStream out = clientSocket.getOutputStream()) {
            final String dns=dns_;
            
            int len=0;
            byte [] buf=new byte[1024];
            ByteArrayOutputStream baos=new ByteArrayOutputStream();
            while( (len=in.read(buf, 0, buf.length)) != -1 )
                baos.write(buf, 0, len);
            
            DnsDoHClient doh=new DnsDoHClient();
            byte [] request=baos.toByteArray();
            doh.decodeRequest(request);
            String name=doh.decodeRequest_domain;
            
            byte [] response=doh.send(dns, request);
            doh.decodeResponse(response);
            String ip=doh.decodeResponse_ip;
            System.out.println(name + " " + ip);
            out.write(response);
             
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            try {
                clientSocket.close();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
}

@SuppressWarnings({"unchecked", "deprecation"})
class TabelaPrice {
    public TabelaPrice(Double valor, Double jurosAM, Double jurosAA, Integer parcelas){
        DecimalFormat df = new DecimalFormat("#,##0.00");
        if (parcelas < 1) {
            System.out.println("Número de parcelas inválido. Deve ser maior que zero.");
            return;
        }
        if (valor <= 0) {
            System.out.println("Montante inválido. Deve ser maior que zero.");
            return;
        }
        if (jurosAM < 0) {
            System.out.println("Taxa de juros inválida. Deve ser positiva.");
            return;
        }
        double valorParcela = calcularParcela(valor, jurosAM, parcelas);
        double totalPago = valorParcela * parcelas;
        double totalJuros = totalPago - valor;
        System.out.println("\n=== Tabela de Pagamento ===");
        System.out.println("Montante financiado: R$ " + df.format(valor));
        System.out.println("Taxa de juros mensal: " + (jurosAM * 100) + "%");
        System.out.println("Taxa de juros anual: " + (jurosAA * 100) + "%");
        System.out.println("Número de parcelas: " + parcelas);
        System.out.println("Valor da parcela: R$ " + df.format(valorParcela));
        System.out.println("Total a ser pago: R$ " + df.format(totalPago));
        System.out.println("Total de juros: R$ " + df.format(totalJuros));
        System.out.println("\nDetalhamento das Parcelas:");
        System.out.println("Parcela | Valor Parcela | Saldo Devedor");
        System.out.println("--------|---------------|--------------");
        double saldoDevedor = valor;
        for (int i = 1; i <= parcelas; i++) {
            double jurosParcela = saldoDevedor * jurosAM;
            double amortizacao = valorParcela - jurosParcela;
            saldoDevedor -= amortizacao;
            if (i == parcelas)
                saldoDevedor = 0;
            System.out.printf("%7d | R$ %9s | R$ %9s%n", i, df.format(valorParcela), df.format(saldoDevedor));
        }
    }
    private static double calcularParcela(double valor, double jurosAM, int parcelas) {
        if (jurosAM == 0)
            return valor / parcelas;
        double fator = Math.pow(1 + jurosAM, parcelas);
        return valor * jurosAM * fator / (fator - 1);
    }
}

@SuppressWarnings({"unchecked", "deprecation"})
class TabelaSAC {
    public TabelaSAC(Double valor, Double jurosAM, Double jurosAA, Integer parcelas){
        DecimalFormat df = new DecimalFormat("#,##0.00");
        if (valor <= 0 || jurosAM <= 0 || parcelas <= 0) {
            System.out.println("Todos os valores devem ser positivos!");
            return;
        }
        double amortizacaoConstante = valor / parcelas;
        double saldoDevedor = valor;
        double totalJuros = 0;
        System.out.println("\n=== TABELA DE AMORTIZAÇÃO SAC ===");
        System.out.println("Valor do empréstimo: R$ " + df.format(valor));
        System.out.println("Taxa de juros mensal: " + (jurosAM * 100) + "%");
        System.out.println("Taxa de juros anual: " + (jurosAA * 100) + "%");        
        System.out.println("Número de parcelas: " + parcelas);
        System.out.println("Amortização constante: R$ " + df.format(amortizacaoConstante));
        System.out.println("\nParcela | Saldo Devedor | Amortização | Juros | Prestação");
        System.out.println("--------|---------------|-------------|-------|----------");
        for (int i = 1; i <= parcelas; i++) {
            double jurosParcela = saldoDevedor * jurosAM;
            double prestacao = amortizacaoConstante + jurosParcela;
            if (i == parcelas){
                amortizacaoConstante = saldoDevedor;
                prestacao = amortizacaoConstante + jurosParcela;
            }
            System.out.printf("%6d  | R$ %10s | R$ %8s | R$ %5s | R$ %8s%n",i, 
                            df.format(saldoDevedor), df.format(amortizacaoConstante),
                            df.format(jurosParcela), df.format(prestacao));
            totalJuros += jurosParcela;
            saldoDevedor -= amortizacaoConstante;
        }
        System.out.println("\n=== RESUMO FINANCEIRO ===");
        System.out.println("Total de juros pagos: R$ " + df.format(totalJuros));
        System.out.println("Total pago (empréstimo + juros): R$ " + df.format(valor + totalJuros));
    }
}

/* class Wget */ // download do Wget muito instavel, melhor refatorar baseado no curl
/* class Wget */ //String [] args2 = {"-h"};               
/* class Wget */ //String [] args2 = {"-ban","%d0","-only_before","-list_mp3","-list_diretories","http://195.122.253.112/public/mp3/"};        
/* class Wget */ //String [] args2 = {"-list_files_and_diretories","http://www.dcbasso.rsn86.com/arquivos/Musicas/"};    
/* class Wget */ //String [] args2 = {"-accep_escape_host_mp3","-list_files_and_diretories","http://openwebindex.com/mp3/music/"};    
/* class Wget */ //String [] args2 = {"-accep_escape_host_mp3","-list_mp3","-list_diretories","http://www.brain-magazine.com"};    
/* class Wget */ //String [] args2 = {"-only_before","-list_mp3","-list_diretories","http://moransa.com/music/"};        
/* class Wget */ //String [] args2 = {"-r","http://www.blesscosmetics.com.br/","-list_files","-list_diretories","-output|C:\\Users\\ywanes\\Documents"};               
/* class Wget */ //String [] args2 = {"-r","http://www.blesscosmetics.com.br/","-output|C:\\Users\\ywanes\\Documents"};               
/* class Wget */ //String [] args2 = {"-r","http://www.naosalvo.com.br/","-output|C:\\Users\\ywanes\\Documents"};               
/* class Wget */ //String [] args2 = {"http://moransa.com/music/Guns%20N'%20Roses%20-%20Appetite%20for%20Destruction/","-only_before","-output|C:\\Users\\ywanes\\Documents","-tipo|.ini|.jpg"};               
/* class Wget */ //String [] args2 = {"-list_mp3","-only_before","http://jeankulle.free.fr/ftp/sons/"};
/* class Wget */ //String [] args2 = {"-list_mp3","-only_before","http://percyvanrijn.com/music/"};        
/* class Wget */ //String [] args2 = {"-list_mp3","-only_before","https://notendur.hi.is/gvr/music/Big%20Whiskey%20and%20the%20GrooGrux%20King/"};                                
/* class Wget */ 
@SuppressWarnings({"unchecked", "deprecation"})
class Wget {  public int cont; public boolean list_mp3=false; public String motor="";  Hashtable hashtable = new Hashtable(); int hash_cont=0; private boolean list_files=false; private boolean list_diretorios=false; public ArrayList<String> pilha=new ArrayList<String>(); private boolean accep_escape_host_mp3=false; private boolean only_before=false; private String string_only_before=null; private boolean ban=false; private String string_ban=null; private boolean recursive=false; private String string_output_dir=""; public String sep=""; private String tipo=""; public String proxy=""; public boolean legend=false;   public String parametros [][] = { {"-output|","pasta de arquivo de saida ex:-output|c:\\user\\usuario\\Documents"}, { "http://site.com.br","site da utilizacao"}, {"-r","recursivo, download do site todo"}, {"-h","help, mostra parametros"}, {"-list_mp3","listar as mp3s"}, {"-list_files","listar os arquivos"}, {"-list_diretories","listar os diretorios"}, {"-accep_escape_host_mp3","aceitar navegação de outro host por url mp3"}, {"-tipo|.mp3|.wma","baixar somente arquivos com estas extensoes"}, { "-only_before","somente navegação da url de uma ponto pra frente"} , { "-proxy|","ex: -proxy|endereco-proxy|80"}, {"-ban","palava ou caracter banido, ex -ban %d0"}, {"-legend","colocando 1 arquivo A, 2 arquivo B ... "}, };   String parametros() { String retorno=""; for ( int i=0;i<parametros.length;i++){ retorno+=parametros[i][0]+" => "+parametros[i][1]+"\n"; } return retorno; }  void comando(String comando) { if ( comando.startsWith("-output|")){ string_output_dir=comando.split("\\|")[1]; return; } if ( comando.startsWith("-tipo|")){ tipo=comando.replace("-tipo\\|",""); return; } if ( ban && string_ban == null ){ string_ban=comando; return; } if ( comando.equals("-ban") ){ ban=true; return; } if ( comando.equals("-r") ){ recursive=true; only_before=true; return; } if ( comando.equals("-list_mp3") ){ list_mp3=true; return; } if ( comando.equals("-list_files") ){ list_files=true; return; } if ( comando.equals("-list_diretories") ){ list_diretorios=true;             return; } if ( comando.equals("-accep_escape_host_mp3") ){ accep_escape_host_mp3=true; return; } if ( comando.equals("-only_before") ){ only_before=true; return; } if ( comando.equals("-legend") ){ legend=true; return; } if ( comando.startsWith("-proxy|") ){ comando=comando.replace("-proxy|",""); if ( comando.split("\\|").length != 2 ){ throw new Error("Comando "+comando+" invalido "+comando.split("|").length+" "+comando); } proxy=comando; return; }  if ( comando.contains("-h") ){       System.out.println("Parametros:"); System.out.println(parametros()); System.exit(0); }  if ( ! comando.startsWith("-")){ fix_barra_url(comando); return; } throw new Error("Comando "+comando+" invalido"); }  public void start_motor() throws Exception{ if ( ! motor.equals("")){ cont=0; if ( recursive || ! tipo.equals("")){ if (string_output_dir.equals("")){ throw new Exception("erro, falta do parametro -output|[dir], necessario com o parametro -r ou -tipo ");                 }else{ if ( ! new File(string_output_dir).exists() ){ throw new Exception("erro, o diretorio "+string_output_dir + " nao existe.");                 }else{ grava(get_raiz(motor),"dir"); } } } motor(motor);             } }  public void motor(String url) throws Exception{ if ( url_invalida(url) ){ return; } if ( only_before ){ if (  string_only_before == null ){ string_only_before=url; 
/* class Wget */ }else{ if ( ! url.contains(string_only_before)){ return; } }             } if ( url.contains("#")){ url=fix_sharp(url); } if ( url.contains("/../") ){ url=fix_dotdot(url); }    if ( ! url.endsWith("/") && ! get_life(url).contains(".")){ url+="/"; }     if ( url_de_request(url) ){  if ( list_diretorios && url.endsWith("/")){ if ( legend ){ System.out.println("pasta                  "+url); }else{ System.out.println(url); } } String html = getcode(url);   if ( ! html.equals("")){ boolean tmp_tipo=false; if ( ! tipo.equals("")){ for ( String ext : tipo.split("\\|")){ if ( url.toLowerCase().endsWith(ext)){ tmp_tipo=true; } } } if ( recursive || tmp_tipo ){ grava(url,"file"); } for ( String parametro : gethref(html) ){    if ( ! parametro.equals("") && ! parametro.contains("?") && ! parametro.contains(" ")){ if ( ban && string_ban != null && parametro.contains(string_ban)){ }else{ motor(monta_url(url,parametro)); } } } }             }else{ if (  (list_mp3 && url.toLowerCase().endsWith(".mp3")) || list_files                     ){ if ( legend ){ System.out.println(++cont+"           arquivo    "+url); }else{ System.out.println(url); } }   boolean tmp_tipo=false; if ( ! tipo.equals("")){ for ( String ext : tipo.split("\\|")){ if ( url.toLowerCase().endsWith(ext)){ tmp_tipo=true; } } } if ( recursive || tmp_tipo ){ grava(url,"file"); }             } }  public boolean url_invalida(String url) throws Exception{ if ( url.length() > 1000){ throw new Exception("erro inesperado ! "+url); }  url=url.trim();  if ( hashtable.contains(new String(url)) ){ return true;             } hashtable.put(hash_cont++,url);  if ( url.contains(";") && ! url.contains("&amp;")){ return true; }     return false; }  public ArrayList<String> gethref(String texto){ ArrayList<String> lista=new ArrayList<String>(); Matcher m; m = Pattern.compile(" href=\"([^\"])*").matcher(texto);  while ( m.find() ){ lista.add(m.group().substring(7)); } m = Pattern.compile(" HREF=\"([^\"])*").matcher(texto);  while ( m.find() ){ lista.add(m.group().substring(7)); } m = Pattern.compile(" href='([^'])*").matcher(texto);  while ( m.find() ){ lista.add(m.group().substring(7)); } m = Pattern.compile(" HREF='([^'])*").matcher(texto);  while ( m.find() ){ lista.add(m.group().substring(7)); } m = Pattern.compile(" src='([^'])*").matcher(texto);  while ( m.find() ){ lista.add(m.group().substring(6)); } m = Pattern.compile(" SRC='([^'])*").matcher(texto);  while ( m.find() ){ lista.add(m.group().substring(6)); } return lista; }  public String getcode(String url){  String texto=""; String inputLine="";         HttpURLConnection httpcon=null; BufferedReader in=null;  try{ URLConnection con=null; if ( proxy.equals("")){ con=new URL(url).openConnection();                 }else{ con=new URL(url).openConnection( new Proxy(Proxy.Type.HTTP, new InetSocketAddress( proxy.split("\\|")[0], Integer.parseInt(proxy.split("\\|")[1]))));                 }  con.setUseCaches(false);   (httpcon = (HttpURLConnection) con).addRequestProperty("User-Agent", "Mozilla/4.76"); if ( httpcon.getResponseCode() != 503 ){ in = new BufferedReader(new InputStreamReader(httpcon.getInputStream())); while ((inputLine = in.readLine()) != null) texto+=inputLine; in.close(); return texto; } return ""; }catch (Exception e){ if ( true )return ""; }  return texto; }
/* class Wget */ public boolean mp3_realmente(String url){ String inputLine;   int cont=0;  try{ URL UrL=new URL(url); URLConnection con; con=UrL.openConnection(); HttpURLConnection httpcon = (HttpURLConnection) con;  httpcon.addRequestProperty("User-Agent", "Mozilla/6.0");  
/* class Wget */ BufferedReader in = new BufferedReader(new InputStreamReader(httpcon.getInputStream())); cont=0; while ((inputLine = in.readLine()) != null && cont < 50){ cont++; } in.close(); }catch (Exception e){} if ( cont == 50 ){ return true; } return false; }  public void fix_barra_url(String comando){         if ( ! comando.toLowerCase().startsWith("http://") && ! comando.toLowerCase().startsWith("https://") ){ comando="http://"+comando; } if ( quantidade_de_barra(comando) == 0){ comando+="/";     } motor=comando;         }  private String fix_dotdot(String url2) { boolean final_com_barra=url2.endsWith("/"); reset_pilha(); for ( String pasta : url2.split("/")){ if ( pasta.equals("..") ){ resempilha(); }else{ empilha(pasta); } } String retorno=""; for ( String pasta : pilha ){ retorno+=pasta+"/"; } if ( ! final_com_barra ){ retorno=retorno.substring(0,retorno.length()-1); } return retorno; }  private void reset_pilha() { pilha=new ArrayList<String>(); }  private void resempilha() { if ( pilha.size() > 0 ){ pilha.remove(pilha.size()-1); } }  private void empilha(String pasta) { pilha.add(pasta); }  private String tira_file_da_url(String url2) { while ( ! url2.endsWith("/")){ url2=url2.substring(0,url2.length()-1); } return url2;      }  private String fix_sharp(String incremento) { if ( incremento.contains("#") ){ boolean ignore=false; String incremento_aux=""; for ( int i=0;i<incremento.length() && ! ignore;i++){ if ( incremento.substring(i,i+1).equals("#")){ ignore=true; }else{ incremento_aux+=incremento.substring(i,i+1); }                 } return incremento_aux; }         return incremento; }  private int quantidade_de_barra(String comando) { comando=tira_http(comando); int cont=0; for ( int i=0;i<comando.length();i++){ if ( comando.substring(i,i+1).equals("/")){ cont++; } } return cont; }  private boolean url_de_request(String url) { url=url.toLowerCase(); if ( url.endsWith("/") || url.contains(".asp")  || url.contains(".php") || url.contains(".html") || url.contains(".htm") || url.contains(".apsx") ){ return true; } if ( pasta(url) ){ return true; } return false; }  private boolean pasta(String url) { url=url.replace("http://",""); String u=""; for ( String p : url.split("/")) { u=p; } if ( ! u.contains(".")){ return true; } return false; }  private String get_raiz(String url) { url=tira_http(url); return "http://"+url.split("/")[0]; }  private String tira_http(String comando) { return comando.replace("http://",""); }  private String monta_url(String url, String parametro) { if ( parametro.startsWith("http://")){                         return parametro; }else{ if ( parametro.startsWith("/")){ return get_raiz(url)+parametro; }else{ if ( ! parametro.contains(".") && ! parametro.endsWith("/")){ parametro+="/"; } if ( url.endsWith("/")){ return url+parametro; }else{ if ( ! tira_file(url).equals("") ){ return tira_file(url)+parametro; } return url+"/"+parametro; } } } }  private String tira_file(String url) { url=tira_http(url); String tmp="",retorno="http://";         for ( String pasta : url.split("/")){ if ( ! tmp.equals("")){ if ( pasta.contains(".")){ return retorno; }                     }else{ tmp=pasta; } retorno+=pasta+"/"; } return ""; }  private void grava(String conteudo,String tipo) { if ( string_output_dir.contains("\\")){ sep="\\"; }else{ sep="/"; }  if ( tipo.equals("dir")){ conteudo=string_output_dir+sep+tira_http(conteudo);         if ( ! new File(conteudo).exists() ){ new File(conteudo).mkdir(); } }else{     download(conteudo); } }  
/* class Wget */ public void download(String conteudo) { String path=string_output_dir+sep;  String aux="";  for ( String pasta : tira_http(tira_file_da_url(conteudo)).split("/")){ path+=pasta+sep; aux=path.replace("%20"," ");  if ( ! new File(aux).exists() ){ new File(aux).mkdir(); } }     String file=get_life(conteudo);  if ( ! conteudo.contains("?")){ System.out.println("Salvando: "+conteudo); if ( file.equals("")){ file="index.html";  if ( ! new File(path+file).exists() ){                 String html = getcode(conteudo);              try{ aux=(path+file).replace("%20"," ");  FileWriter fstream = new FileWriter(aux);  BufferedWriter out = new BufferedWriter(fstream);  out.write(html); out.close(); }catch (Exception e){  System.err.println("Error: " + e.getMessage()); } } }else{  aux=(path+file).replace("%20"," "); if ( !  new File(aux).exists() ){  new UrlDownload().fileDownload(conteudo,path,proxy); } } } }
/* class Wget */ private String get_life(String url) { url=tira_http(url); String tmp="",retorno="http://";         for ( String pasta : url.split("/")){ if ( ! tmp.equals("")){ if ( pasta.contains(".")){ return pasta; }                     }else{ tmp=pasta; } retorno+=pasta+"/"; } return "";         }  
/* class Wget */ public static class UrlDownload { final static int size=1024; 
/* class Wget */  /* download de arquivo na internet retornando string - String texto=Wget.UrlDownload.stringDownloadUrl("[URL]", null); - muito instavel.. usar curl*/
/* class Wget */ public static void fileDownloadUrl(String fAddress, String localFileName, String destinationDir,String proxy){      if ((new File(destinationDir+"\\"+localFileName)).exists()) {  System.out.println("Arquivo " + localFileName + " ja exite.");  return;  }else{  String aux=(destinationDir+"\\"+localFileName).replace("%20"," ");  try{ fileDownloadUrl(fAddress, new FileOutputStream(aux), proxy); }catch(Exception e){ System.out.println(e.toString()); } }      }
/* class Wget */ public static String stringDownloadUrl(String fAddress, String proxy){      ByteArrayOutputStream baos=new ByteArrayOutputStream(); try{ fileDownloadUrl(fAddress, baos, proxy); }catch(Exception e){ System.out.println(e.toString()); } return baos.toString(); }
/* class Wget */ public static void fileDownloadUrl(String fAddress, OutputStream outStream,String proxy) { URLConnection  uCon = null;  InputStream is = null; try {  URL Url;  byte[] buf;  int len;                  if ( proxy == null || proxy.equals("") ){  uCon=new URL(fAddress).openConnection();  }else{  uCon=new URL(fAddress).openConnection( new Proxy(Proxy.Type.HTTP, new InetSocketAddress( proxy.split("\\|")[0], Integer.parseInt(proxy.split("\\|")[1])))); }   is = uCon.getInputStream();  buf = new byte[size];   while ((len = is.read(buf)) != -1){ outStream.write(buf, 0, len);  } is.close();  outStream.close();  }catch (Exception e) { System.out.println(e.toString()); }  }  
/* class Wget */ public static void fileDownload(String fAddress, String destinationDir,String proxy) {  int slashIndex =fAddress.lastIndexOf('/');  int periodIndex =fAddress.lastIndexOf('.');  String fileName=fAddress.substring(slashIndex + 1);  if (periodIndex >=1 &&  slashIndex >= 0 && slashIndex < fAddress.length()-1) { if(fileName.contains("?")){  String tmp []=fileName.split("=");  fileName=tmp[0]; fileName=fileName.substring(0, fileName.length()-2);  } fileDownloadUrl(fAddress,fileName,destinationDir,proxy);  }else{  System.err.println("path or file name."); }  }} 
/* class Wget */ } 

/* class Tar  */ // credits: https://github.com/kamranzafar/jtar/blob/master/src/test/java/org/kamranzafar/jtar/JTarTest.java 
/* class Tar  */ // tar("in");
/* class Tar  */ // tar("test.tar", "in"); 
/* class Tar  */ // untar("test.tar", null); 
/* class Tar  */ // untar("test.tar", "in/in2/only"); 
/* class Tar  */ // tarlist("test.tar"); 
/* class Tar  */ class Tar { String sep=System.getProperty("user.dir").contains("/")?"/":"\\"; public void tar(String target, String source) throws Exception{ String dir = System.getProperty("user.dir"); TarOutputStream out = null; if ( target == null ) out = new TarOutputStream(new BufferedOutputStream(System.out)); else out = new TarOutputStream(new BufferedOutputStream(new FileOutputStream(dir+sep+target))); tarRun(null, dir+sep+source, out, target == null); out.close();         } public void untar(String source, String only) throws Exception { String dir = System.getProperty("user.dir"); File zf = new File(dir+sep+source); TarInputStream tis = null; if ( source == null ) tis = new TarInputStream(new BufferedInputStream(System.in)); else tis = new TarInputStream(new BufferedInputStream(new FileInputStream(zf))); untarRun(tis, dir, only, source == null); tis.close(); } public void tarlist(String source) throws IOException { String dir = System.getProperty("user.dir"); File zf = new File(dir+sep+source); TarInputStream tis = new TarInputStream(new BufferedInputStream(new FileInputStream(zf))); TarEntry entry; while ((entry = tis.getNextEntry()) != null) System.out.println(entry.getName()); } public void tarRun(String parent, String path, TarOutputStream out, Boolean targetNull) throws Exception { final int BUFFER = 2048; BufferedInputStream origin = null; File f = new File(path); String [] files = new String[]{}; if ( f.isDirectory() ){ if ( parent == null && !targetNull ) System.out.println("a " + f.getName()); files = f.list(); }else if ( f.isFile() ) files = new String[]{f.getName()}; else throw new Exception(f.getName() + " not found!"); parent = ((parent == null) ? (f.isFile()) ? "" : f.getName() + "/" : parent + f.getName() + "/"); for (int i = 0; i < files.length; i++) { if ( !targetNull ) System.out.println("a " + parent + files[i]); File fe = f; byte data[] = new byte[BUFFER]; if (f.isDirectory()) { fe = new File(f, files[i]); } if (fe.isDirectory()) { String[] fl = fe.list(); if (fl != null && fl.length != 0) { tarRun(parent, fe.getPath(), out, targetNull); } else { TarEntry entry = new TarEntry(fe, parent + files[i] + "/"); out.putNextEntry(entry); } continue; } FileInputStream fi = new FileInputStream(fe); origin = new BufferedInputStream(fi); TarEntry entry = new TarEntry(fe, parent + files[i]); out.putNextEntry(entry); int count; while ((count = origin.read(data)) != -1) { out.write(data, 0, count); } out.flush(); origin.close(); } }  private void untarRun(TarInputStream tis, String destFolder, String only, Boolean sourceNull) throws IOException { final int BUFFER = 2048; BufferedOutputStream dest = null;  TarEntry entry; while ((entry = tis.getNextEntry()) != null) { if ( !sourceNull && only != null && ! entry.getName().equals(only) ) continue; if ( !sourceNull ) System.out.println("x " + entry.getName()); int count; byte data[] = new byte[BUFFER];  if (entry.isDirectory()) { new File(destFolder + sep + entry.getName()).mkdirs(); continue; } else { int di = entry.getName().lastIndexOf('/'); if (di != -1) { new File(destFolder + sep + entry.getName().substring(0, di)).mkdirs(); } }  FileOutputStream fos = new FileOutputStream(destFolder + sep + entry.getName()); dest = new BufferedOutputStream(fos);  while ((count = tis.read(data)) != -1) { dest.write(data, 0, count); }  dest.flush(); dest.close(); } }  }  class TarOutputStream extends OutputStream { private final OutputStream out; private long bytesWritten; private long currentFileSize; private TarEntry currentEntry;  
/* class Tar  */ public TarOutputStream(OutputStream out) { this.out = out; bytesWritten = 0; currentFileSize = 0; }  public TarOutputStream(final File fout) throws FileNotFoundException { this.out = new BufferedOutputStream(new FileOutputStream(fout)); bytesWritten = 0; currentFileSize = 0; }  public TarOutputStream(final File fout, final boolean append) throws IOException { @SuppressWarnings("resource") RandomAccessFile raf = new RandomAccessFile(fout, "rw"); final long fileSize = fout.length(); if (append && fileSize > TarConstants.EOF_BLOCK) { raf.seek(fileSize - TarConstants.EOF_BLOCK); } out = new BufferedOutputStream(new FileOutputStream(raf.getFD())); }  @Override public void close() throws IOException { closeCurrentEntry(); write( new byte[TarConstants.EOF_BLOCK] ); out.close(); }  @Override public void write(int b) throws IOException { out.write( b ); bytesWritten += 1;  if (currentEntry != null) { currentFileSize += 1; } }  @Override public void write(byte[] b, int off, int len) throws IOException { if (currentEntry != null && !currentEntry.isDirectory()) { if (currentEntry.getSize() < currentFileSize + len) { throw new IOException( "The current entry[" + currentEntry.getName() + "] size[" + currentEntry.getSize() + "] is smaller than the bytes[" + ( currentFileSize + len ) + "] being written." ); } }  out.write( b, off, len );  bytesWritten += len;  if (currentEntry != null) { currentFileSize += len; }         }  public void putNextEntry(TarEntry entry) throws IOException { closeCurrentEntry();  byte[] header = new byte[TarConstants.HEADER_BLOCK]; entry.writeEntryHeader( header );  write( header );  currentEntry = entry; }  protected void closeCurrentEntry() throws IOException { if (currentEntry != null) { if (currentEntry.getSize() > currentFileSize) { throw new IOException( "The current entry[" + currentEntry.getName() + "] of size[" + currentEntry.getSize() + "] has not been fully written." ); }  currentEntry = null; currentFileSize = 0;  pad(); } }  protected void pad() throws IOException { if (bytesWritten > 0) { int extra = (int) ( bytesWritten % TarConstants.DATA_BLOCK );  if (extra > 0) { write( new byte[TarConstants.DATA_BLOCK - extra] ); } } } }  class TarEntry { protected File file; protected TarHeader header;  private TarEntry() { this.file = null; header = new TarHeader(); }  public TarEntry(File file, String entryName) { this(); this.file = file; this.extractTarHeader(entryName); }  public TarEntry(byte[] headerBuf) { this(); this.parseTarHeader(headerBuf); }  public TarEntry(TarHeader header) { this.file = null; this.header = header; }  @Override public boolean equals(Object it) { if (!(it instanceof TarEntry)) { return false; } return header.name.toString().equals( ((TarEntry) it).header.name.toString()); }  @Override public int hashCode() { return header.name.hashCode(); }  public boolean isDescendent(TarEntry desc) { return desc.header.name.toString().startsWith(header.name.toString()); }  public TarHeader getHeader() { return header; }  public String getName() { String name = header.name.toString(); if (header.namePrefix != null && !header.namePrefix.toString().equals("")) { name = header.namePrefix.toString() + "/" + name; }  return name; }  public void setName(String name) { header.name = new StringBuffer(name); }  public int getUserId() { return header.userId; }  public void setUserId(int userId) { header.userId = userId; }  public int getGroupId() { return header.groupId; }  public void setGroupId(int groupId) { header.groupId = groupId; }  
/* class Tar  */ public String getUserName() { return header.userName.toString(); }  public void setUserName(String userName) { header.userName = new StringBuffer(userName); }  public String getGroupName() { return header.groupName.toString(); }  public void setGroupName(String groupName) { header.groupName = new StringBuffer(groupName); }  public void setIds(int userId, int groupId) { this.setUserId(userId); this.setGroupId(groupId); }  public void setModTime(long time) { header.modTime = time / 1000; }  public void setModTime(Date time) { header.modTime = time.getTime() / 1000; }  public Date getModTime() { return new Date(header.modTime * 1000); }  public File getFile() { return this.file; }  public long getSize() { return header.size; }  public void setSize(long size) { header.size = size; }  public boolean isDirectory() { if (this.file != null) return this.file.isDirectory();  if (header != null) { if (header.linkFlag == TarHeader.LF_DIR) return true;  if (header.name.toString().endsWith("/")) return true; }  return false; }  public void extractTarHeader(String entryName) { int permissions = PermissionUtils.permissions(file); header = TarHeader.createHeader(entryName, file.length(), file.lastModified() / 1000, file.isDirectory(), permissions); }  public long computeCheckSum(byte[] buf) { long sum = 0;  for (int i = 0; i < buf.length; ++i) { sum += 255 & buf[i]; }  return sum; }  public void writeEntryHeader(byte[] outbuf) { int offset = 0;  offset = TarHeader.getNameBytes(header.name, outbuf, offset, TarHeader.NAMELEN); offset = Octal.getOctalBytes(header.mode, outbuf, offset, TarHeader.MODELEN); offset = Octal.getOctalBytes(header.userId, outbuf, offset, TarHeader.UIDLEN); offset = Octal.getOctalBytes(header.groupId, outbuf, offset, TarHeader.GIDLEN);  long size = header.size;  offset = Octal.getLongOctalBytes(size, outbuf, offset, TarHeader.SIZELEN); offset = Octal.getLongOctalBytes(header.modTime, outbuf, offset, TarHeader.MODTIMELEN);  int csOffset = offset; for (int c = 0; c < TarHeader.CHKSUMLEN; ++c) outbuf[offset++] = (byte) ' ';  outbuf[offset++] = header.linkFlag;  offset = TarHeader.getNameBytes(header.linkName, outbuf, offset, TarHeader.NAMELEN); offset = TarHeader.getNameBytes(header.magic, outbuf, offset, TarHeader.USTAR_MAGICLEN); offset = TarHeader.getNameBytes(header.userName, outbuf, offset, TarHeader.USTAR_USER_NAMELEN); offset = TarHeader.getNameBytes(header.groupName, outbuf, offset, TarHeader.USTAR_GROUP_NAMELEN); offset = Octal.getOctalBytes(header.devMajor, outbuf, offset, TarHeader.USTAR_DEVLEN); offset = Octal.getOctalBytes(header.devMinor, outbuf, offset, TarHeader.USTAR_DEVLEN); offset = TarHeader.getNameBytes(header.namePrefix, outbuf, offset, TarHeader.USTAR_FILENAME_PREFIX);  for (; offset < outbuf.length;) outbuf[offset++] = 0;  long checkSum = this.computeCheckSum(outbuf);  Octal.getCheckSumOctalBytes(checkSum, outbuf, csOffset, TarHeader.CHKSUMLEN); }  public void parseTarHeader(byte[] bh) { int offset = 0;  header.name = TarHeader.parseName(bh, offset, TarHeader.NAMELEN); offset += TarHeader.NAMELEN;  header.mode = (int) Octal.parseOctal(bh, offset, TarHeader.MODELEN); offset += TarHeader.MODELEN;  header.userId = (int) Octal.parseOctal(bh, offset, TarHeader.UIDLEN); offset += TarHeader.UIDLEN;  header.groupId = (int) Octal.parseOctal(bh, offset, TarHeader.GIDLEN); offset += TarHeader.GIDLEN;  header.size = Octal.parseOctal(bh, offset, TarHeader.SIZELEN); offset += TarHeader.SIZELEN;  
/* class Tar  */ header.modTime = Octal.parseOctal(bh, offset, TarHeader.MODTIMELEN); offset += TarHeader.MODTIMELEN;  header.checkSum = (int) Octal.parseOctal(bh, offset, TarHeader.CHKSUMLEN); offset += TarHeader.CHKSUMLEN;  header.linkFlag = bh[offset++];  header.linkName = TarHeader.parseName(bh, offset, TarHeader.NAMELEN); offset += TarHeader.NAMELEN;  header.magic = TarHeader.parseName(bh, offset, TarHeader.USTAR_MAGICLEN); offset += TarHeader.USTAR_MAGICLEN;  header.userName = TarHeader.parseName(bh, offset, TarHeader.USTAR_USER_NAMELEN); offset += TarHeader.USTAR_USER_NAMELEN;  header.groupName = TarHeader.parseName(bh, offset, TarHeader.USTAR_GROUP_NAMELEN); offset += TarHeader.USTAR_GROUP_NAMELEN;  header.devMajor = (int) Octal.parseOctal(bh, offset, TarHeader.USTAR_DEVLEN); offset += TarHeader.USTAR_DEVLEN;  header.devMinor = (int) Octal.parseOctal(bh, offset, TarHeader.USTAR_DEVLEN); offset += TarHeader.USTAR_DEVLEN;  header.namePrefix = TarHeader.parseName(bh, offset, TarHeader.USTAR_FILENAME_PREFIX); } }  class TarConstants { public static final int EOF_BLOCK = 1024; public static final int DATA_BLOCK = 512; public static final int HEADER_BLOCK = 512; }  class TarHeader { public static final int NAMELEN = 100; public static final int MODELEN = 8; public static final int UIDLEN = 8; public static final int GIDLEN = 8; public static final int SIZELEN = 12; public static final int MODTIMELEN = 12; public static final int CHKSUMLEN = 8; public static final byte LF_OLDNORM = 0; public static final byte LF_NORMAL = (byte) '0'; public static final byte LF_LINK = (byte) '1'; public static final byte LF_SYMLINK = (byte) '2'; public static final byte LF_CHR = (byte) '3'; public static final byte LF_BLK = (byte) '4'; public static final byte LF_DIR = (byte) '5'; public static final byte LF_FIFO = (byte) '6'; public static final byte LF_CONTIG = (byte) '7';   public static final String USTAR_MAGIC = "ustar";  public static final int USTAR_MAGICLEN = 8; public static final int USTAR_USER_NAMELEN = 32; public static final int USTAR_GROUP_NAMELEN = 32; public static final int USTAR_DEVLEN = 8; public static final int USTAR_FILENAME_PREFIX = 155;  public StringBuffer name; public int mode; public int userId; public int groupId; public long size; public long modTime; public int checkSum; public byte linkFlag; public StringBuffer linkName; public StringBuffer magic; public StringBuffer userName; public StringBuffer groupName; public int devMajor; public int devMinor; public StringBuffer namePrefix;  public TarHeader() { this.magic = new StringBuffer(TarHeader.USTAR_MAGIC);  this.name = new StringBuffer(); this.linkName = new StringBuffer();  String user = System.getProperty("user.name", "");  if (user.length() > 31) user = user.substring(0, 31);  this.userId = 0; this.groupId = 0; this.userName = new StringBuffer(user); this.groupName = new StringBuffer(""); this.namePrefix = new StringBuffer(); }  public static StringBuffer parseName(byte[] header, int offset, int length) { StringBuffer result = new StringBuffer(length);  int end = offset + length; for (int i = offset; i < end; ++i) { if (header[i] == 0) break; result.append((char) header[i]); }  return result; }  public static int getNameBytes(StringBuffer name, byte[] buf, int offset, int length) { int i;  for (i = 0; i < length && i < name.length(); ++i) { buf[offset + i] = (byte) name.charAt(i); }  for (; i < length; ++i) { buf[offset + i] = 0; }  return offset + length; }  
/* class Tar  */ public static TarHeader createHeader(String entryName, long size, long modTime, boolean dir, int permissions) { String name = entryName; name = TarUtils.trim(name.replace(File.separatorChar, '/'), '/');  TarHeader header = new TarHeader(); header.linkName = new StringBuffer(""); header.mode = permissions;  if (name.length() > 100) { header.namePrefix = new StringBuffer(name.substring(0, name.lastIndexOf('/'))); header.name = new StringBuffer(name.substring(name.lastIndexOf('/') + 1)); } else { header.name = new StringBuffer(name); } if (dir) { header.linkFlag = TarHeader.LF_DIR; if (header.name.charAt(header.name.length() - 1) != '/') { header.name.append("/"); } header.size = 0; } else { header.linkFlag = TarHeader.LF_NORMAL; header.size = size; }  header.modTime = modTime; header.checkSum = 0; header.devMajor = 0; header.devMinor = 0;  return header; } }  class PermissionUtils { private static enum StandardFilePermission { EXECUTE(0110), WRITE(0220), READ(0440);  private int mode;  private StandardFilePermission(int mode) { this.mode = mode; } }  private static Map<PosixFilePermission, Integer> posixPermissionToInteger = new HashMap<>();  static { posixPermissionToInteger.put(PosixFilePermission.OWNER_EXECUTE, 0100); posixPermissionToInteger.put(PosixFilePermission.OWNER_WRITE, 0200); posixPermissionToInteger.put(PosixFilePermission.OWNER_READ, 0400);  posixPermissionToInteger.put(PosixFilePermission.GROUP_EXECUTE, 0010); posixPermissionToInteger.put(PosixFilePermission.GROUP_WRITE, 0020); posixPermissionToInteger.put(PosixFilePermission.GROUP_READ, 0040);  posixPermissionToInteger.put(PosixFilePermission.OTHERS_EXECUTE, 0001); posixPermissionToInteger.put(PosixFilePermission.OTHERS_WRITE, 0002); posixPermissionToInteger.put(PosixFilePermission.OTHERS_READ, 0004); }  public static int permissions(File f) { if(f == null) { throw new NullPointerException("File is null."); } if(!f.exists()) { throw new IllegalArgumentException("File " + f + " does not exist."); }  return isPosix ? posixPermissions(f) : standardPermissions(f); }  private static final boolean isPosix = FileSystems.getDefault().supportedFileAttributeViews().contains("posix");  private static int posixPermissions(File f) { int number = 0; try { Set<PosixFilePermission> permissions = Files.getPosixFilePermissions(f.toPath()); for (Map.Entry<PosixFilePermission, Integer> entry : posixPermissionToInteger.entrySet()) { if (permissions.contains(entry.getKey())) { number += entry.getValue(); } } } catch (IOException e) { throw new RuntimeException(e); } return number; }  private static Set<StandardFilePermission> readStandardPermissions(File f) { Set<StandardFilePermission> permissions = new HashSet<>(); if(f.canExecute()) { permissions.add(StandardFilePermission.EXECUTE); } if(f.canWrite()) { permissions.add(StandardFilePermission.WRITE); } if(f.canRead()) { permissions.add(StandardFilePermission.READ); } return permissions; }  private static Integer standardPermissions(File f) { int number = 0; Set<StandardFilePermission> permissions = readStandardPermissions(f); for (StandardFilePermission permission : permissions) { number += permission.mode; } return number; } }  class Octal { public static long parseOctal(byte[] header, int offset, int length) { long result = 0; boolean stillPadding = true;  int end = offset + length; for (int i = offset; i < end; ++i) { if (header[i] == 0) break;  if (header[i] == (byte) ' ' || header[i] == '0') { 
/* class Tar  */ if (stillPadding) continue;  if (header[i] == (byte) ' ') break; }  stillPadding = false;  result = ( result << 3 ) + ( header[i] - '0' ); }  return result; }  public static int getOctalBytes(long value, byte[] buf, int offset, int length) { int idx = length - 1;  buf[offset + idx] = 0; --idx; buf[offset + idx] = (byte) ' '; --idx;  if (value == 0) { buf[offset + idx] = (byte) '0'; --idx; } else { for (long val = value; idx >= 0 && val > 0; --idx) { buf[offset + idx] = (byte) ( (byte) '0' + (byte) ( val & 7 ) ); val = val >> 3; } }  for (; idx >= 0; --idx) { buf[offset + idx] = (byte) '0'; }  return offset + length; } public static int getCheckSumOctalBytes(long value, byte[] buf, int offset, int length) { getOctalBytes( value, buf, offset, length ); buf[offset + length - 1] = (byte) ' '; buf[offset + length - 2] = 0; return offset + length; }  public static int getLongOctalBytes(long value, byte[] buf, int offset, int length) { byte[] temp = new byte[length + 1]; getOctalBytes( value, temp, 0, length + 1 ); System.arraycopy( temp, 0, buf, offset, length ); return offset + length; }  }  class TarUtils { public static long calculateTarSize(File path) { return tarSize(path) + TarConstants.EOF_BLOCK; }  private static long tarSize(File dir) { long size = 0;  if (dir.isFile()) { return entrySize(dir.length()); } else { File[] subFiles = dir.listFiles();  if (subFiles != null && subFiles.length > 0) { for (File file : subFiles) { if (file.isFile()) { size += entrySize(file.length()); } else { size += tarSize(file); } } } else { return TarConstants.HEADER_BLOCK; } }  return size; }  private static long entrySize(long fileSize) { long size = 0; size += TarConstants.HEADER_BLOCK; size += fileSize;  long extra = size % TarConstants.DATA_BLOCK;  if (extra > 0) { size += (TarConstants.DATA_BLOCK - extra); }  return size; }  public static String trim(String s, char c) { StringBuffer tmp = new StringBuffer(s); for (int i = 0; i < tmp.length(); i++) { if (tmp.charAt(i) != c) { break; } else { tmp.deleteCharAt(i); } }  for (int i = tmp.length() - 1; i >= 0; i--) { if (tmp.charAt(i) != c) { break; } else { tmp.deleteCharAt(i); } }  return tmp.toString(); } }  class TarInputStream extends FilterInputStream {  private static final int SKIP_BUFFER_SIZE = 2048; private TarEntry currentEntry; private long currentFileSize; private long bytesRead; private boolean defaultSkip = false;  public TarInputStream(InputStream in) { super(in); currentFileSize = 0; bytesRead = 0; }  @Override public boolean markSupported() { return false; }  @Override public synchronized void mark(int readlimit) { }  @Override public synchronized void reset() throws IOException { throw new IOException("mark/reset not supported"); }  @Override public int read() throws IOException { byte[] buf = new byte[1];  int res = this.read(buf, 0, 1);  if (res != -1) { return 0xFF & buf[0]; }  return res; }  @Override public int read(byte[] b, int off, int len) throws IOException { if (currentEntry != null) { if (currentFileSize == currentEntry.getSize()) { return -1; } else if ((currentEntry.getSize() - currentFileSize) < len) { len = (int) (currentEntry.getSize() - currentFileSize); } }  int br = super.read(b, off, len);  if (br != -1) { if (currentEntry != null) { currentFileSize += br; }  bytesRead += br; }  return br; }  public TarEntry getNextEntry() throws IOException { closeCurrentEntry();  byte[] header = new byte[TarConstants.HEADER_BLOCK]; 
/* class Tar  */ byte[] theader = new byte[TarConstants.HEADER_BLOCK]; int tr = 0;  while (tr < TarConstants.HEADER_BLOCK) { int res = read(theader, 0, TarConstants.HEADER_BLOCK - tr);  if (res < 0) { break; }  System.arraycopy(theader, 0, header, tr, res); tr += res; }  boolean eof = true; for (byte b : header) { if (b != 0) { eof = false; break; } }  if (!eof) { currentEntry = new TarEntry(header); }  return currentEntry; }  public long getCurrentOffset() { return bytesRead; }  protected void closeCurrentEntry() throws IOException { if (currentEntry != null) { if (currentEntry.getSize() > currentFileSize) { long bs = 0; while (bs < currentEntry.getSize() - currentFileSize) { long res = skip(currentEntry.getSize() - currentFileSize - bs);  if (res == 0 && currentEntry.getSize() - currentFileSize > 0) { throw new IOException("Possible tar file corruption"); }  bs += res; } }  currentEntry = null; currentFileSize = 0L; skipPad(); } }  protected void skipPad() throws IOException { if (bytesRead > 0) { int extra = (int) (bytesRead % TarConstants.DATA_BLOCK);  if (extra > 0) { long bs = 0; while (bs < TarConstants.DATA_BLOCK - extra) { long res = skip(TarConstants.DATA_BLOCK - extra - bs); bs += res; } } } }  @Override public long skip(long n) throws IOException { if (defaultSkip) { long bs = super.skip(n); bytesRead += bs;  return bs; }  if (n <= 0) { return 0; }  long left = n; byte[] sBuff = new byte[SKIP_BUFFER_SIZE];  while (left > 0) { int res = read(sBuff, 0, (int) (left < SKIP_BUFFER_SIZE ? left : SKIP_BUFFER_SIZE)); if (res < 0) { break; } left -= res; }  return n - left; }  public boolean isDefaultSkip() { return defaultSkip; }  public void setDefaultSkip(boolean defaultSkip) { this.defaultSkip = defaultSkip; } }

/* class Diff  */ /* creditos - https://github.com/java-diff-utils/java-diff-utils */
/* class Diff  */ 
@SuppressWarnings({"unchecked", "deprecation"})
class Diff extends Util{ public Diff(String caminho_a, String caminho_b, Boolean flag_enable_equal, OutputStream out){ try{ byte [] bytes_write60="                                                            ".getBytes(); byte [] barra_n="\n".getBytes(); byte [] code_equal="   ".getBytes(); byte [] code_dif=" | ".getBytes(); byte [] code_dir=" > ".getBytes(); byte [] code_esq=" < ".getBytes(); Diff_DiffRowGenerator generator = Diff_DiffRowGenerator.create().showInlineDiffs(true).inlineDiffByWord(true).oldTag(f -> "").newTag(f -> "").build(); List<Diff_DiffRow> rows = generator.generateDiffRows(readAllLines(caminho_a), readAllLines(caminho_b)); for (Diff_DiffRow row : rows) { String old_=row.getOldLine(); String new_=row.getNewLine(); int tag_=row.getTag(); if ( tag_ == Diff_DiffRow.TAG_EQUAL && flag_enable_equal ){ write60(old_, out, bytes_write60); out.write(code_equal); write60(new_, out, bytes_write60); out.write(barra_n); } if ( tag_ == Diff_DiffRow.TAG_INSERT ){ write60(old_, out, bytes_write60); out.write(code_dir); write60(new_, out, bytes_write60); out.write(barra_n); } if ( tag_ == Diff_DiffRow.TAG_DELETE ){ write60(old_, out, bytes_write60); out.write(code_esq); write60(new_, out, bytes_write60); out.write(barra_n); } if ( tag_ == Diff_DiffRow.TAG_CHANGE ){ write60(old_, out, bytes_write60); out.write(code_dif); write60(new_, out, bytes_write60); out.write(barra_n); } }out.flush(); }catch(Exception e){ erroFatal(e); } }     public void write60(String a, OutputStream out, byte [] bytes_write60) throws Exception{ int len=a.length(); if ( len == 60 ){ out.write(a.getBytes()); return; } if ( len > 60 ){ out.write(a.substring(0, 60).getBytes()); return; } out.write(a.getBytes()); out.write(bytes_write60, 0, 60-len); } } 
@SuppressWarnings({"unchecked", "deprecation"})
abstract class Diff_AbstractDelta<T> { private final Diff_Chunk<T> source; 
/* class Diff  */ private final Diff_Chunk<T> target; private final int type; public Diff_AbstractDelta(int type, Diff_Chunk<T> source, Diff_Chunk<T> target) { Objects.requireNonNull(source); Objects.requireNonNull(target); Objects.requireNonNull(type); this.type = type; this.source = source; this.target = target; } public Diff_Chunk<T> getSource() { return source; } public Diff_Chunk<T> getTarget() { return target; } public int getType() { return type; } protected void verifyChunk(List<T> target) throws Exception { getSource().verify(target); } public abstract void applyTo(List<T> target) throws Exception; public abstract void restore(List<T> target); public int hashCode() { return Objects.hash(this.source, this.target, this.type); } public boolean equals(Object obj) { if (this == obj) { return true; } if (obj == null) { return false; } if (getClass() != obj.getClass()) { return false; } final Diff_AbstractDelta<?> other = (Diff_AbstractDelta<?>) obj; if (!Objects.equals(this.source, other.source)) { return false; } if (!Objects.equals(this.target, other.target)) { return false; } if (this.type != other.type) { return false; } return true; } } 
@SuppressWarnings({"unchecked", "deprecation"})
class Diff_Change { public final int deltaType; public final int startOriginal; public final int endOriginal; public final int startRevised; public final int endRevised; public Diff_Change(int deltaType, int startOriginal, int endOriginal, int startRevised, int endRevised) { this.deltaType = deltaType; this.startOriginal = startOriginal; this.endOriginal = endOriginal; this.startRevised = startRevised; this.endRevised = endRevised; } } 
@SuppressWarnings({"unchecked", "deprecation"})
class Diff_ChangeDelta<T> extends Diff_AbstractDelta<T> { public Diff_ChangeDelta(Diff_Chunk<T> source, Diff_Chunk<T> target) { super(Diff_DiffRow.TAG_CHANGE, source, target); Objects.requireNonNull(source, "source must not be null"); 
/* class Diff  */ Objects.requireNonNull(target, "target must not be null"); } public void applyTo(List<T> target) throws Exception { verifyChunk(target); int position = getSource().getPosition(); int size = getSource().size(); for (int i = 0; i < size; i++) { target.remove(position); } int i = 0; for (T line : getTarget().getLines()) { target.add(position + i, line); i++; } } public void restore(List<T> target) { int position = getTarget().getPosition(); int size = getTarget().size(); for (int i = 0; i < size; i++) { target.remove(position); } int i = 0; for (T line : getSource().getLines()) { target.add(position + i, line); i++; } } public String toString() { return "[ChangeDelta, position: " + getSource().getPosition() + ", lines: " + getSource().getLines() + " to " + getTarget().getLines() + "]"; } } 
@SuppressWarnings({"unchecked", "deprecation"})
class Diff_Chunk<T> { private final int position; private List<T> lines; public Diff_Chunk(int position, List<T> lines) { this.position = position; this.lines = lines; } public Diff_Chunk(int position, T[] lines) { this.position = position; this.lines = Arrays.asList(lines); } public void verify(List<T> target) throws Exception { if (position > target.size() || last() > target.size()) { throw new Exception("Incorrect Chunk: the position of chunk > target size"); } for (int i = 0; i < size(); i++) { if (!target.get(position + i).equals(lines.get(i))) { throw new Exception( "Incorrect Chunk: the chunk content doesn't match the target"); } } } public int getPosition() { return position; } public void setLines(List<T> lines) { this.lines = lines; } public List<T> getLines() { return lines; } public int size() { return lines.size(); } public int last() { return getPosition() + size() - 1; } public int hashCode() { return Objects.hash(lines, position, size()); } 
/* class Diff  */ public boolean equals(Object obj) { if (this == obj) { return true; } if (obj == null) { return false; } if (getClass() != obj.getClass()) { return false; } Diff_Chunk<T> other = (Diff_Chunk) obj; if (lines == null) { if (other.lines != null) { return false; } } else if (!lines.equals(other.lines)) { return false; } return position == other.position; } public String toString() { return "[position: " + position + ", size: " + size() + ", lines: " + lines + "]"; } } 
@SuppressWarnings({"unchecked", "deprecation"})
class Diff_DeleteDelta<T> extends Diff_AbstractDelta<T> { public Diff_DeleteDelta(Diff_Chunk<T> original, Diff_Chunk<T> revised) { super(Diff_DiffRow.TAG_DELETE, original, revised); } public void applyTo(List<T> target) throws Exception { verifyChunk(target); int position = getSource().getPosition(); int size = getSource().size(); for (int i = 0; i < size; i++) { target.remove(position); } } public void restore(List<T> target) { int position = this.getTarget().getPosition(); List<T> lines = this.getSource().getLines(); for (int i = 0; i < lines.size(); i++) { target.add(position + i, lines.get(i)); } } public String toString() { return "[DeleteDelta, position: " + getSource().getPosition() + ", lines: " + getSource().getLines() + "]"; } } 
@SuppressWarnings({"unchecked", "deprecation"})
class Diff_DiffRow implements Serializable {     public int tag = 0;     public static final int TAG_EQUAL = 0;     public static final int TAG_DELETE = 1;     public static final int TAG_CHANGE = 2;     public static final int TAG_INSERT = 3;     private final String oldLine; private final String newLine; public Diff_DiffRow(int tag, String oldLine, String newLine) { this.tag = tag; this.oldLine = oldLine; this.newLine = newLine; } 
/* class Diff  */ public int getTag() { return tag;} public void setTag(int tag) { this.tag = tag; } public String getOldLine() { return oldLine; } public String getNewLine() { return newLine; } public int hashCode() { return Objects.hash(newLine, oldLine, tag); } public boolean equals(Object obj) { if (this == obj) { return true; } if (obj == null) { return false; } if (getClass() != obj.getClass()) { return false; } Diff_DiffRow other = (Diff_DiffRow) obj; if (newLine == null) { if (other.newLine != null) { return false; } } else if (!newLine.equals(other.newLine)) { return false; } if (oldLine == null) { if (other.oldLine != null) { return false; } } else if (!oldLine.equals(other.oldLine)) { return false; } if (tag == -1) { if (other.tag != -1) { return false; } } else if (tag != other.tag) { return false; } return true; } public String toString() { return "[" + this.tag + "," + this.oldLine + "," + this.newLine + "]"; } } 
@SuppressWarnings({"unchecked", "deprecation"})
class Diff_DiffRowGenerator { public static final BiPredicate<String, String> DEFAULT_EQUALIZER = Object::equals; public static final BiPredicate<String, String> IGNORE_WHITESPACE_EQUALIZER = (original, revised) -> adjustWhitespace(original).equals(adjustWhitespace(revised)); public static final Function<String, List<String>> SPLITTER_BY_CHARACTER = line -> { List<String> list = new ArrayList<>(line.length()); for (Character character : line.toCharArray()) { list.add(character.toString()); } return list; }; public static final Pattern SPLIT_BY_WORD_PATTERN = Pattern.compile("\\s+|[,.\\[\\](){}/\\\\*+\\-#]"); 
/* class Diff  */ public static final Function<String, List<String>> SPLITTER_BY_WORD = line -> splitStringPreserveDelimiter(line, SPLIT_BY_WORD_PATTERN); public static final Pattern WHITESPACE_PATTERN = Pattern.compile("\\s+"); public static Diff_Builder create() { return new Diff_Builder(); } private static String adjustWhitespace(String raw) { return WHITESPACE_PATTERN.matcher(raw.trim()).replaceAll(" "); } protected final static List<String> splitStringPreserveDelimiter(String str, Pattern SPLIT_PATTERN) { List<String> list = new ArrayList<>(); if (str != null) { Matcher matcher = SPLIT_PATTERN.matcher(str); int pos = 0; while (matcher.find()) { if (pos < matcher.start()) { list.add(str.substring(pos, matcher.start())); } list.add(matcher.group()); pos = matcher.end(); } if (pos < str.length()) { list.add(str.substring(pos)); } } return list; } static void wrapInTag(List<String> sequence, int startPosition, int endPosition, Function<Boolean, String> tagGenerator) { int endPos = endPosition; while (endPos >= startPosition) { while (endPos > startPosition) { if (!"\n".equals(sequence.get(endPos - 1))) { break; } endPos--; } if (endPos == startPosition) { break; } sequence.add(endPos, tagGenerator.apply(false)); endPos--; while (endPos > startPosition) { if ("\n".equals(sequence.get(endPos - 1))) { break; } endPos--; } sequence.add(endPos, tagGenerator.apply(true)); endPos--; } } private final int columnWidth; private final BiPredicate<String, String> equalizer; private final boolean ignoreWhiteSpaces; private final Function<String, List<String>> inlineDiffSplitter; private final boolean mergeOriginalRevised; private final Function<Boolean, String> newTag; private final Function<Boolean, String> oldTag; 
/* class Diff  */ private final boolean reportLinesUnchanged; private final boolean showInlineDiffs; private Diff_DiffRowGenerator(Diff_Builder builder) { showInlineDiffs = builder.showInlineDiffs; ignoreWhiteSpaces = builder.ignoreWhiteSpaces; oldTag = builder.oldTag; newTag = builder.newTag; columnWidth = builder.columnWidth; mergeOriginalRevised = builder.mergeOriginalRevised; inlineDiffSplitter = builder.inlineDiffSplitter; equalizer = ignoreWhiteSpaces ? IGNORE_WHITESPACE_EQUALIZER : DEFAULT_EQUALIZER; reportLinesUnchanged = builder.reportLinesUnchanged; Objects.requireNonNull(inlineDiffSplitter); } public List<Diff_DiffRow> generateDiffRows(List<String> original, List<String> revised) throws Exception { return generateDiffRows(original, Diff_Patch.generate(original, revised)); } public List<Diff_DiffRow> generateDiffRows(final List<String> original, Diff_Patch<String> patch) throws Exception { List<Diff_DiffRow> diffRows = new ArrayList<>(); int endPos = 0; final List<Diff_AbstractDelta<String>> deltaList = patch.getDeltas(); for (int i = 0; i < deltaList.size(); i++) { Diff_AbstractDelta<String> delta = deltaList.get(i); Diff_Chunk<String> orig = delta.getSource(); Diff_Chunk<String> rev = delta.getTarget(); for (String line : original.subList(endPos, orig.getPosition())) { diffRows.add(buildDiffRow(Diff_DiffRow.TAG_EQUAL, line, line)); } if (delta instanceof Diff_InsertDelta) { endPos = orig.last() + 1; for (String line : (List<String>) rev.getLines()) { diffRows.add(buildDiffRow(Diff_DiffRow.TAG_INSERT, "", line)); } continue; } if (delta instanceof Diff_DeleteDelta) { endPos = orig.last() + 1; for (String line : (List<String>) orig.getLines()) { diffRows.add(buildDiffRow(Diff_DiffRow.TAG_DELETE, line, "")); } continue; 
/* class Diff  */ } if (showInlineDiffs) { diffRows.addAll(generateInlineDiffs(delta)); } else { for (int j = 0; j < Math.max(orig.size(), rev.size()); j++) { diffRows.add(buildDiffRow(Diff_DiffRow.TAG_CHANGE, orig.getLines().size() > j ? orig.getLines().get(j) : "", rev.getLines().size() > j ? rev.getLines().get(j) : "")); } } endPos = orig.last() + 1; } for (String line : original.subList(endPos, original.size())) { diffRows.add(buildDiffRow(Diff_DiffRow.TAG_EQUAL, line, line)); } return diffRows; } private Diff_DiffRow buildDiffRow(int type, String orgline, String newline) { if (reportLinesUnchanged) { return new Diff_DiffRow(type, orgline, newline); } else { String wrapOrg = preprocessLine(orgline); if (Diff_DiffRow.TAG_DELETE == type) { if (mergeOriginalRevised || showInlineDiffs) { wrapOrg = oldTag.apply(true) + wrapOrg + oldTag.apply(false); } } String wrapNew = preprocessLine(newline); if (Diff_DiffRow.TAG_INSERT == type) { if (mergeOriginalRevised) { wrapOrg = newTag.apply(true) + wrapNew + newTag.apply(false); } else if (showInlineDiffs) { wrapNew = newTag.apply(true) + wrapNew + newTag.apply(false); } } return new Diff_DiffRow(type, wrapOrg, wrapNew); } } private Diff_DiffRow buildDiffRowWithoutNormalizing(int type, String orgline, String newline) { return new Diff_DiffRow(type, Diff_StringUtils.wrapText(orgline, columnWidth), Diff_StringUtils.wrapText(newline, columnWidth)); } private List<Diff_DiffRow> generateInlineDiffs(Diff_AbstractDelta<String> delta) throws Exception { List<String> orig = Diff_StringUtils.normalize(delta.getSource().getLines()); List<String> rev = Diff_StringUtils.normalize(delta.getTarget().getLines()); List<String> origList; 
/* class Diff  */ List<String> revList; String joinedOrig = String.join("\n", orig); String joinedRev = String.join("\n", rev); origList = inlineDiffSplitter.apply(joinedOrig); revList = inlineDiffSplitter.apply(joinedRev); List<Diff_AbstractDelta<String>> inlineDeltas = Diff_Patch.generate(origList, revList).getDeltas(); Collections.reverse(inlineDeltas); for (Diff_AbstractDelta<String> inlineDelta : inlineDeltas) { Diff_Chunk<String> inlineOrig = inlineDelta.getSource(); Diff_Chunk<String> inlineRev = inlineDelta.getTarget(); if (inlineDelta instanceof Diff_DeleteDelta) { wrapInTag(origList, inlineOrig.getPosition(), inlineOrig .getPosition() + inlineOrig.size(), oldTag); } else if (inlineDelta instanceof Diff_InsertDelta) { if (mergeOriginalRevised) { origList.addAll(inlineOrig.getPosition(), revList.subList(inlineRev.getPosition(), inlineRev.getPosition() + inlineRev.size())); wrapInTag(origList, inlineOrig.getPosition(), inlineOrig.getPosition() + inlineRev.size(), newTag); } else { wrapInTag(revList, inlineRev.getPosition(), inlineRev.getPosition() + inlineRev.size(), newTag); } } else if (inlineDelta instanceof Diff_ChangeDelta) { if (mergeOriginalRevised) { origList.addAll(inlineOrig.getPosition() + inlineOrig.size(), revList.subList(inlineRev.getPosition(), inlineRev.getPosition() + inlineRev.size())); wrapInTag(origList, inlineOrig.getPosition() + inlineOrig.size(), inlineOrig.getPosition() + inlineOrig.size() + inlineRev.size(), newTag); } else { wrapInTag(revList, inlineRev.getPosition(), inlineRev.getPosition() + inlineRev.size(), newTag); } wrapInTag(origList, inlineOrig.getPosition(), inlineOrig .getPosition() + inlineOrig.size(), oldTag); } } 
/* class Diff  */ StringBuilder origResult = new StringBuilder(); StringBuilder revResult = new StringBuilder(); for (String character : origList) { origResult.append(character); } for (String character : revList) { revResult.append(character); } List<String> original = Arrays.asList(origResult.toString().split("\n")); List<String> revised = Arrays.asList(revResult.toString().split("\n")); List<Diff_DiffRow> diffRows = new ArrayList<>(); for (int j = 0; j < Math.max(original.size(), revised.size()); j++) { diffRows. add(buildDiffRowWithoutNormalizing(Diff_DiffRow.TAG_CHANGE, original.size() > j ? original.get(j) : "", revised.size() > j ? revised.get(j) : "")); } return diffRows; } private String preprocessLine(String line) { if (columnWidth == 0) { return Diff_StringUtils.normalize(line); } else { return Diff_StringUtils.wrapText(Diff_StringUtils.normalize(line), columnWidth); } } 
@SuppressWarnings({"unchecked", "deprecation"})
static class Diff_Builder { private boolean showInlineDiffs = false; private boolean ignoreWhiteSpaces = false; private Function<Boolean, String> oldTag = f -> f ? "<span class=\"editOldInline\">" : "</span>"; private Function<Boolean, String> newTag = f -> f ? "<span class=\"editNewInline\">" : "</span>"; private int columnWidth = 0; private boolean mergeOriginalRevised = false; private boolean reportLinesUnchanged = false; private Function<String, List<String>> inlineDiffSplitter = SPLITTER_BY_CHARACTER; private Diff_Builder() { } public Diff_Builder showInlineDiffs(boolean val) { showInlineDiffs = val; return this; } public Diff_Builder ignoreWhiteSpaces(boolean val) { ignoreWhiteSpaces = val; return this; } public Diff_Builder reportLinesUnchanged(final boolean val) { reportLinesUnchanged = val; return this; } public Diff_Builder oldTag(Function<Boolean, String> generator) { 
/* class Diff  */ this.oldTag = generator; return this; } public Diff_Builder newTag(Function<Boolean, String> generator) { this.newTag = generator; return this; } public Diff_Builder columnWidth(int width) { if (width >= 0) { columnWidth = width; } return this; } public Diff_DiffRowGenerator build() { return new Diff_DiffRowGenerator(this); } public Diff_Builder mergeOriginalRevised(boolean mergeOriginalRevised) { this.mergeOriginalRevised = mergeOriginalRevised; return this; } public Diff_Builder inlineDiffByWord(boolean inlineDiffByWord) { inlineDiffSplitter = inlineDiffByWord ? SPLITTER_BY_WORD : SPLITTER_BY_CHARACTER; return this; } public Diff_Builder inlineDiffBySplitter(Function<String, List<String>> inlineDiffSplitter) { this.inlineDiffSplitter = inlineDiffSplitter; return this; } } } 
@SuppressWarnings({"unchecked", "deprecation"})
class Diff_StringUtils { public static String htmlEntites(String str) { return str.replace("<", "&lt;").replace(">", "&gt;"); } public static String normalize(String str) { return htmlEntites(str).replace("\t", "    "); } public static List<String> normalize(List<String> list) { return list.stream() .map(Diff_StringUtils::normalize) .collect(java.util.stream.Collectors.toList()); } public static List<String> wrapText(List<String> list, int columnWidth) { return list.stream() .map(line -> wrapText(line, columnWidth)) .collect(java.util.stream.Collectors.toList()); } public static String wrapText(String line, int columnWidth) { if (columnWidth < 0) { throw new IllegalArgumentException("columnWidth may not be less 0"); } if (columnWidth == 0) { return line; } int length = line.length(); int delimiter = "<br/>".length(); int widthIndex = columnWidth; StringBuilder b = new StringBuilder(line); for (int count = 0; length > widthIndex; count++) { 
/* class Diff  */ b.insert(widthIndex + delimiter * count, "<br/>"); widthIndex += columnWidth; } return b.toString(); } private Diff_StringUtils() { } } 
@SuppressWarnings({"unchecked", "deprecation"})
class Diff_DiffUtils { private static List<String> compressLines(List<String> lines, String delimiter) { if (lines.isEmpty()) { return Collections.emptyList(); } return Collections.singletonList(lines.stream().collect(java.util.stream.Collectors.joining(delimiter))); } public static <T> List<T> patch(List<T> original, Diff_Patch<T> patch) throws Exception { return patch.applyTo(original); } public static <T> List<T> unpatch(List<T> revised, Diff_Patch<T> patch) { return patch.restore(revised); } private Diff_DiffUtils() { } } 
@SuppressWarnings({"unchecked", "deprecation"})
class Diff_InsertDelta<T> extends Diff_AbstractDelta<T> { public Diff_InsertDelta(Diff_Chunk<T> original, Diff_Chunk<T> revised) { super(Diff_DiffRow.TAG_INSERT, original, revised); } public void applyTo(List<T> target) throws Exception { verifyChunk(target); int position = this.getSource().getPosition(); List<T> lines = this.getTarget().getLines(); for (int i = 0; i < lines.size(); i++) { target.add(position + i, lines.get(i)); } } public void restore(List<T> target) { int position = getTarget().getPosition(); int size = getTarget().size(); for (int i = 0; i < size; i++) { target.remove(position); } } public String toString() { return "[InsertDelta, position: " + getSource().getPosition() + ", lines: " + getTarget().getLines() + "]"; } } 
@SuppressWarnings({"unchecked", "deprecation"})
class Diff_MyersDiff<T>{ private final BiPredicate<T, T> DEFAULT_EQUALIZER = Object::equals; private final BiPredicate<T, T> equalizer; public Diff_MyersDiff() { equalizer = DEFAULT_EQUALIZER; } public Diff_MyersDiff(final BiPredicate<T, T> equalizer) { Objects.requireNonNull(equalizer, "equalizer must not be null"); this.equalizer = equalizer; } 
/* class Diff  */ public List<Diff_Change> computeDiff(final List<T> source, final List<T> target) throws Exception { Objects.requireNonNull(source, "source list must not be null"); Objects.requireNonNull(target, "target list must not be null"); Diff_PathNode path = buildPath(source, target); List<Diff_Change> result = buildRevision(path, source, target); return result; } private Diff_PathNode buildPath(final List<T> orig, final List<T> rev) throws Exception { Objects.requireNonNull(orig, "original sequence is null"); Objects.requireNonNull(rev, "revised sequence is null"); final int N = orig.size(); final int M = rev.size(); final int MAX = N + M + 1; final int size = 1 + 2 * MAX; final int middle = size / 2; final Diff_PathNode diagonal[] = new Diff_PathNode[size]; diagonal[middle + 1] = new Diff_PathNode(0, -1, true, true, null); for (int d = 0; d < MAX; d++) { for (int k = -d; k <= d; k += 2) { final int kmiddle = middle + k; final int kplus = kmiddle + 1; final int kminus = kmiddle - 1; Diff_PathNode prev; int i; if ((k == -d) || (k != d && diagonal[kminus].i < diagonal[kplus].i)) { i = diagonal[kplus].i; prev = diagonal[kplus]; } else { i = diagonal[kminus].i + 1; prev = diagonal[kminus]; } diagonal[kminus] = null; int j = i - k; Diff_PathNode node = new Diff_PathNode(i, j, false, false, prev); while (i < N && j < M && equalizer.test(orig.get(i), rev.get(j))) { i++; j++; } if (i != node.i) { node = new Diff_PathNode(i, j, true, false, node); } diagonal[kmiddle] = node; if (i >= N && j >= M) { return diagonal[kmiddle]; } } diagonal[middle + d - 1] = null; } throw new Exception("could not find a diff path"); } 
/* class Diff  */ private List<Diff_Change> buildRevision(Diff_PathNode actualPath, List<T> orig, List<T> rev) { Objects.requireNonNull(actualPath, "path is null"); Objects.requireNonNull(orig, "original sequence is null"); Objects.requireNonNull(rev, "revised sequence is null"); Diff_PathNode path = actualPath; List<Diff_Change> changes = new ArrayList<>(); if (path.isSnake()) { path = path.prev; } while (path != null && path.prev != null && path.prev.j >= 0) { if (path.isSnake()) { throw new IllegalStateException("bad diffpath: found snake when looking for diff"); } int i = path.i; int j = path.j; path = path.prev; int ianchor = path.i; int janchor = path.j; if (ianchor == i && janchor != j) { changes.add(new Diff_Change(Diff_DiffRow.TAG_INSERT, ianchor, i, janchor, j)); } else if (ianchor != i && janchor == j) { changes.add(new Diff_Change(Diff_DiffRow.TAG_DELETE, ianchor, i, janchor, j)); } else { changes.add(new Diff_Change(Diff_DiffRow.TAG_CHANGE, ianchor, i, janchor, j)); } if (path.isSnake()) { path = path.prev; } } return changes; } } 
@SuppressWarnings({"unchecked", "deprecation"})
class Diff_PathNode { public final int i; public final int j; public final Diff_PathNode prev; public final boolean snake; public final boolean bootstrap; public Diff_PathNode(int i, int j, boolean snake, boolean bootstrap, Diff_PathNode prev) { this.i = i; this.j = j; this.bootstrap = bootstrap; if (snake) { this.prev = prev; } else { this.prev = prev == null ? null : prev.previousSnake(); } this.snake = snake; } public boolean isSnake() { return snake; } public boolean isBootstrap() { return bootstrap; } 
/* class Diff  */ public final Diff_PathNode previousSnake() { if (isBootstrap()) { return null; } if (!isSnake() && prev != null) { return prev.previousSnake(); } return this; } public String toString() { StringBuilder buf = new StringBuilder("["); Diff_PathNode node = this; while (node != null) { buf.append("("); buf.append(Integer.toString(node.i)); buf.append(","); buf.append(Integer.toString(node.j)); buf.append(")"); node = node.prev; } buf.append("]"); return buf.toString(); } } 
@SuppressWarnings({"unchecked", "deprecation"})
class Diff_Patch<T> { private final List<Diff_AbstractDelta<T>> deltas; public Diff_Patch() { this(10); } public Diff_Patch(int estimatedPatchSize) { deltas = new ArrayList<>(estimatedPatchSize); } public List<T> applyTo(List<T> target) throws Exception { List<T> result = new ArrayList<>(target); ListIterator<Diff_AbstractDelta<T>> it = getDeltas().listIterator(deltas.size()); while (it.hasPrevious()) { Diff_AbstractDelta<T> delta = it.previous(); delta.applyTo(result); } return result; } public List<T> restore(List<T> target) { List<T> result = new ArrayList<>(target); ListIterator<Diff_AbstractDelta<T>> it = getDeltas().listIterator(deltas.size()); while (it.hasPrevious()) { Diff_AbstractDelta<T> delta = it.previous(); delta.restore(result); } return result; } public void addDelta(Diff_AbstractDelta<T> delta) { deltas.add(delta); } public List<Diff_AbstractDelta<T>> getDeltas() { Collections.sort(deltas, java.util.Comparator.comparing(d -> d.getSource().getPosition())); return deltas; } public String toString() { return "Patch{" + "deltas=" + deltas + '}'; } public static <T> Diff_Patch<T> generate(List<T> original, List<T> revised) throws Exception { Diff_MyersDiff m=new Diff_MyersDiff<>(); List<Diff_Change> changes=m.computeDiff(original, revised); 
/* class Diff  */ Diff_Patch<T> patch = new Diff_Patch<>(changes.size()); for (Diff_Change change : changes) { Diff_Chunk<T> orgChunk = new Diff_Chunk<>(change.startOriginal, new ArrayList<>(original.subList(change.startOriginal, change.endOriginal))); Diff_Chunk<T> revChunk = new Diff_Chunk<>(change.startRevised, new ArrayList<>(revised.subList(change.startRevised, change.endRevised))); switch (change.deltaType) { case Diff_DiffRow.TAG_DELETE: patch.addDelta(new Diff_DeleteDelta<>(orgChunk, revChunk)); break; case Diff_DiffRow.TAG_INSERT: patch.addDelta(new Diff_InsertDelta<>(orgChunk, revChunk)); break; case Diff_DiffRow.TAG_CHANGE: patch.addDelta(new Diff_ChangeDelta<>(orgChunk, revChunk)); break; } } return patch; } } 

















@SuppressWarnings({"unchecked", "deprecation"})
class Arquivos{
    public String lendo_arquivo_pacote(String caminho){
        if ( caminho.equals("/y/manual") )
return """
usage:
  [y daemon]
  [y take]
  [y banco fromCSV -outTable tabelaA selectInsert]
  [y banco conn,hash [select|selectInsert|selectCSV] [|select..]]
  [y banco conn,hash executeInsert]
  [y banco conn,hash execute [|execute..]]
  [y banco conn,hash createjobexecute]
  [y banco [connIn,hash|fileCSV,file] connOut,hash -outTable tabelaA [|trunc|createTable] [carga|createjobcarga]]
  [y banco executejob]
  [y banco buffer [|-n_lines 4000] [|-log buffer.log]]
  [y selectCSV]
  [y xlsxToCSV]
  [y token]
  [y gettoken]
  [y json]
  [y zip]
  [y gzip]
  [y gunzip]
  [y tar]
  [y untar]
  [y tarlist]
  [y echo]
  [y printf]
  [y sdiff]
  [y progressBar]
  [y xargs]
  [y cat]
  [y redis]
  [y sort]
  [y sorte
  [y iso]
  [y [juros|emprestimo]]
  [y terminal]
  [y dotaMutandoAll]
  [y audio]
  [y isWindowsAdm]
  [y devices]
  [y cep]
  [y users]
  [y disconnect]
  [y dns|host]
  [y lower]
  [y upper]
  [y removeAcentos]
  [y xor]
  [y md5]
  [y sha1]
  [y sha256]
  [y aes]
  [y base64]
  [y grep]
  [y wc]
  [y len]
  [y head]
  [y tail]
  [y cut]
  [y yt]
  [y curl]
  [y cors]
  [y [sed|tr]]
  [y n]
  [y rn]
  [y [bytesToInts|bi]]
  [y [intsToBytes|ib]]
  [y od]
  [y touch]
  [y rm]
  [y cp]
  [y mv]
  [y cd]
  [y iconv]
  [y tee]
  [y uniq]
  [y quebra]
  [y seq]
  [y tr]
  [y add]
  [y awk print]
  [y dev_null]
  [y dev_in]
  [y scp]
  [y execSsh]
  [y ssh]
  [y sshinfo]
  [y sftp]
  [y [serverRouter|sr]]
  [y [httpServer|hs]]
  [y [httpProxy|hp]]
  [y wget]
  [y pwd]
  [y find]
  [y ls]
  [y lss]
  [y du]
  [y split]
  [y regua]
  [y link]
  [y os]
  [y pss]
  [y pid]
  [y date]
  [y cronometro]
  [y steam]
  [y [cls|clear|clean]]
  [y ping]
  [y pings]
  [y pingMine]
  [y ips]
  [y mouse]  
  [y mixer]
  [y gravador]
  [y play]
  [y call]
  [y remote]
  [y injectMicLine]
  [y kill]
  [y win]
  [y speed]
  [y lock]
  [y monitor]
  [y printScreen]
  [y ocr]
  [y paste]
  [y mkv]
  [y [thumbnail|tn]]
  [y insta]
  [y bmp]
  [y decodeUrl]
  [y encodeUrl]
  [y test]
  [y tests]
  [y controlc]
  [y random]
  [y talk]
  [y sign]
  [y [overflix|of]]
  [y connGui]
  [y var]
  [y cotacao]
  [y [update|u]]
  [y help]

Exemplos...

[y daemon]
    y daemon
    y daemon -server
    y d r a
    y d list
    y d tail AA
    y d restart AA
[y take]
    y take
    y take file1 pasta2
    Obs: envia o conteudo desta para para outro computador ou pasta
    Obs2: após digitar y take, ele irá mostrar o comando que será utilizado na outra ponta
[y banco fromCSV -outTable tabelaA selectInsert]
    cat arquivo.csv | y banco fromCSV -outTable tabelaA selectInsert
[y banco conn,hash [select|selectInsert|selectCSV] [|select..]]
    echo "select 1 from dual" | y banco conn,hash select
    y banco conn,hash select "select 1 from dual"
    echo "select * from tabela1" | y banco conn,hash selectInsert
    cat select.sql | y banco conn,hash selectCSV
    y banco -conn conn.. selectInsert
[y banco conn,hash executeInsert]
    cat listaDeInsert.sql | y banco conn,hash executeInsert
    echo "insert into tabela1 values(1,2,3)" | y banco conn,hash executeInsert
    echo "insert into tabela1 values(1,2,3);" | y banco conn,hash executeInsert
    obs: bug?. Use execute
[y banco conn,hash execute [|execute..]]
    echo "truncate table tabela1" | y banco conn,hash execute
    y banco conn,hash execute "drop table tabela1"
    cat blocoAnonimo | y banco conn,hash execute
[y banco conn,hash createjobexecute]
    echo "truncate table tabela1" | y banco conn,hash createjobexecute
[y banco [connIn,hash|fileCSV,file] connOut,hash -outTable tabelaA [|trunc|createTable] [carga|createjobcarga]]
    echo "select * from TABELA_AAA" | y banco connIn,hash connOut,hash -outTable TABELA_BBB carga
    echo "select * from TABELA_AAA" | y banco connIn,hash connOut,hash -outTable TABELA_BBB trunc carga
    echo "select * from TABELA_AAA" | y banco connIn,hash connOut,hash -outTable TABELA_BBB createTable carga
    y banco -fileCSV arquivo.csv connOut,hash -outTable TABELA_CCC carga
    y banco -fileCSV arquivo.csv connOut,hash -outTable TABELA_CCC trunc carga
    y banco -fileCSV arquivo.csv connOut,hash -outTable TABELA_CCC createTable carga
[y banco executejob]
    (
        echo "select * from TABELA_AAA" | y banco connIn,hash connOut,hash -outTable TABELA_BBB trunc createjobcarga
        echo "select * from TABELA_CCC" | y banco connIn,hash connOut,hash -outTable TABELA_CCC trunc createjobcarga
    ) | y banco executejob
[y banco buffer [|-n_lines 4000] [|-log buffer.log]]    
    echo "select * from TABELA1 | y banco conn,hash selectInsert | y banco buffer -n_lines 4000 -log buffer.log | y banco conn,hash executeInsert
[y selectCSV]
    y cat file.csv | y selectCSV "select * from this"
    y cat file.csv | y selectCSV "select rownum seq,* from this"
    y cat file.csv | y selectCSV "select * from this where a = '3'"
    y cat file.csv | y selectCSV "select * from this limit 10"
    y cat file.csv | y selectCSV "select * from this limit 10" -outJson
    echo '[{"a":"3" },{"a": "4"}]' | y json "[elem for elem in data]" | y selectCSV "select * from this where a = '3'"
    y selectCSV -csv file.csv "select * from this"
    y selectCSV -csv file.csv -sql consulta.sql
    obs: alguns comandos => valor_int*valor_int | (valor_int) | valor_txt in (valor_txt ...) | if( boolean, valor_int, valor_int) | if( boolean, valor_txt, valor_txt) | parseInt(valor_txt) | substr( valor_txt, valor_int ) | substr( valor_txt, valor_int, valor_int ) | not boolean
    obs2: se usar rownum com where ele poderá mostrar o numero errado! esse bug será corrigido depois
[y xlsxToCSV]
    xlsxToCSV arquivo.xlsx mostraEstrutura
    xlsxToCSV arquivo.xlsx listaAbas
    xlsxToCSV arquivo.xlsx numeroAba 1
    xlsxToCSV arquivo.xlsx nomeAba Planilha1
    xlsxToCSV arquivo.xlsx exportAll
    obs: pegando a primeira aba => xlsxToCSV arquivo.xlsx numeroAba 1
[y xml]
    cat arquivo.xml | y xml mostraEstrutura
    xml arquivo.xml mostraEstrutura
    cat arquivo.xml | y xml mostraTags
[y token]
    y token value
    obs: y token value -> retorna o hash
    obs2: é preciso ja ter o TOKEN_Y definido
[y gettoken]
    y gettoken hash
[y json]
   y cat file.json | y json mostraEstrutura
   y cat file.json | y json mostraTabela
   y cat file.json | y json "[elem for elem in data['items']]"
   y cat file.json | y json "[elem['id'] for elem in data['items']]"
   y cat file.json | y json "[elem['id'] for elem in data]"
   obs: parametro de apoio => mostraEstruturaDebug
   obs2: exemplo com lista, representada por '_':
         y echo '{"folders": [{"id": 1, "lists":[{"id": 11},{"id": 12}] },{"id": 2, "lists":[{"id": 21},{"id": 22}] }] }' | y json "[elem for elem in data['folders']['_']['lists']]"
   obs3: selecionando alguns campos:
         y echo '{"folders": {"id1":11, "id2": 22, "id3": 33} }' | y json "[[elem['id1'],elem['id3']] for elem in data['folders']]"
   obs4: parametro noHeader => tira o header
   obs5: parametro list => resultado em forma de lista sem o header
[y zip]
    y zip add File1.txt > saida.zip
    cat File1.txt | y zip add -name File1.txt > saida.zip
    y zip add /pasta1/pasta2 > saida.zip
    y zip add pasta2 -lvlStore > saida.zip
    y zip add pasta1 pasta2 file3 -lvlStore > saida.zip
    y zip list arquivo.zip
    cat arquivo.zip | y zip list
    y zip extract entrada.zip
    cat entrada.zip | y zip extract
    y zip extract entrada.zip -out /destino
    cat entrada.zip | y zip extract -out /destino
    y zip extractSelected entrada.zip pasta1/unicoArquivoParaExtrair.txt -out /destino
    cat entrada.zip | y zip extractSelected pasta1/unicoArquivoParaExtrair.txt -out /destino
    y zip extractSelected entrada.zip pasta1/unicoArquivoParaExtrair.txt > /destino/unicoArquivoParaExtrair.txt
    cat entrada.zip | y zip extractSelected pasta1/unicoArquivoParaExtrair.txt > /destino/unicoArquivoParaExtrair.txt
    obs: se add pasta e a descricao de pasta tem "/" ou "\\" então o pacote terá o conteudo da pasta, caso contrário terá a pasta citada+conteudo.
[y gzip]
    cat arquivo | y gzip > arquivo.gz
[y gunzip]
    cat arquivo.gz | y gunzip > arquivo
[y tar]
    y tar in > test.tar
    y tar test.tar in
    obs: suporta arquivo com ateh 8 gigas
[y untar]
    y cat test.tar | y untar
    y untar test.tar
    y untar test.tar in/in2/only
[y tarlist]
    y tarlist test.tar
[y echo]
    echo a b c
    echo "a b c"
    echo "a*"
[y printf]
    y printf a b c
    y printf a b c
    y printf [COR/VERDE] oi
    y printf [COR/VERMELHO] oi
    y printf [COR/AZUL] oi
    y printf [COR/BRANCO] oi
    y printf [COR/VERDE/CINZA] oi
    y printf [COR/VERDE/BRANCO] oi
    y printf [COR/VERMELHO/CINZA] oi
    y printf [COR/VERMELHO/BRANCO] oi
    y printf [COR/AZUL/CINZA] oi
    y printf [COR/AZUL/BRANCO] oi
    y printf [COR/BRANCO/CINZA] oi
    y printf [COR] => lista as cores disponiveis ja colorindo
    obs: diferente do echo, o printf nao gera \n no final
    obs2: echo -n AA gera o mesmo efeito que, printf AA
[y sdiff]
    y sdiff file1.txt file2.txt
    y sdiff file1.txt file2.txt -onlyDiff
[y progressBar]
    ( echo 1 text1; sleep 1; echo 2 text2; sleep 1; echo 1 text1 updated; sleep 1; echo done; ) | y progressBar
    ( echo 1 text1; sleep 1; echo 2 text2; sleep 1; echo 1 text1 updated; sleep 1; echo done; ) | y progressBar -uniqLine
[y xargs]
    y echo a | y xargs echo
    y echo a | y xargs echo "{}" "{}"
""" +                
"    y cls && y find | y grep \".\" | y tr \\\"\"\"\" \"\" | y xargs echo \"y printf \\\"\\\" | ffmpeg -i \\\"{}\\\"  -max_muxing_queue_size 1024 \\\"{}.mp4\\\" && y rm \\\"{}\\\"\" | y tr \"rmvb.mp4\" \"mp4\" | y tr \"mpg.mp4\" \"mp4\"\n" +
"    y find | y tr \\\"\"\"\" \"\" | y xargs echo \"\\\"{}\\\"\" | y xargs echo \"y mv {} {}\" | y tr \"-dublado-www.encontrei.tv.mp4\\\"\\n\" \".mp4\\\"\\n\"\n" +
"""  
    obs: ffmpeg precisa de stdin para nao bugar em lista cmd, porisso usar y printf "" | ffmpeg...
[y cat]
    y cat arquivo
    y cat "<<EOF>" file1.txt
    y cat "<<EOF>>" file1.txt
    y cat ">" file1.txt
    y cat ">>" file1.txt
    y cat
    obs: pode ser outra tag, não precisa ser EOF
    obs2: até o momento o codigo "<<EOF>" só esta liberado para windows!
[y redis]
    procure por y help httpServer
    na parte -redisDir
[y sort]
    y cat file | y sort > file_ordenado
[y sorte]
    y sorte
[y iso]
    y iso win11.iso source
    y iso source win11.iso
    obs: detalhes build na pasta sources, cmd admin:
    dism /Get-WimInfo /WimFile:"install.wim"
    obs: criar iso do tipo linux pode dar ruim
[y [juros|emprestimo]]
    y juros price valor 15000 juros 1.0 a.m 10 parcelas
    y juros sac valor 15000 juros 1.0 a.m 10 parcelas
    referencia: https://calculojuridico.com.br/calculadora-price-sac/
[y terminal]
    y terminal
[y dotaMutandoAll]
    y dotaMutandoAll -sleep 3 -nicks "ynet,Analista de Sistema,neBullet"
    y dotaMutandoAll -sleep 3 -nicks "no_ocr"
[y audio]
    y audio vol
    y audio mute
    y audio setvol 0.02 # 2%
    y audio setvol 1    # 100%
    y audio setvol 0.00109509244794026029 # menor valor do windows saindo som -> ≈ -59.2 dB
    y audio setmute true
    y audio mutingWhileProgramInPrincipalMonitor WorldOfTanks.exe
    obs: setvol e setmute precisa ser adm
    obs2: verificando se esta adm: y isWindowsAdm
[y isWindowsAdm]
    y isWindowsAdm
[y devices]
    y devices
    y devices "-classe" "AudioEndpoint" "-classe" "Net"
    obs: pnputil /disable-device [id]
         pnputil /disable-device "USB\\VID_045E&PID_00DB\6&870CE29&0&1"
         pnputil /enable-device "USB\\VID_045E&PID_00DB\6&870CE29&0&1"
    obs2: comando para windows
[y cep]
    y cep /sp/campinas/almeida prado
    y cep 13083-750
    y cep 13083750
[y users]
    y users
[y disconnect]
    y disconnect
    y disconnect seAtivoDesconectaLoop1Segundo
[y dns|host]
    y host examplo.com
    y dns example.com
    y dns example.com 8.8.8.8
    nslookup exemple.com # ipconfig /flushdns
    alguns dns's:
      dns.adguard.com # 94.140.14.14 94.140.15.15 # complemento mumu player x com app dns changer
      dns.sse.cisco.com
      dns.google # google 8.8.8.8 8.8.4.4 2001:4860:4860::8888 2001:4860:4860::8844
      one.one.one.one # Cloudflare, muito lento # 1.1.1.1 1.0.0.1 2606:4700:4700::1001 2606:4700:4700::1111
      dns.opendns.com # usado pela claro
      dns9.quad9.net
      security-filter-dns.cleanbrowsing.org
      resolver1.telesp.net.br # usado pela vivo
      resolver2.telesp.net.br # usado pela vivo
    obs: O adguard responde 0.0.0.0 para o nomes que pretende bloquear, comando para teste: y dns googleadservices.com dns.adguard.com
[y lower]
    y echo AA | y lower
[y upper]
    y echo aa | y upper
[y removeAcentos]
    y cat file | y removeAcentos
[y xor]
    y cat file | y xor 100
    y cat beltmatic_002.sav | y xor 104948 "7,215,169,11,62,56,139,40,128,196,29,36,86,12,244,116,175,83,57,142,3,255,249,75,208,143,44,62,165,92,216,64,24,1,125,20,82,107,43,11,123,121,31,99,250,252,15,214,90,234,96,112,163" > source.zip
    obs: 104948 sendo o length do file beltmatic_002.sav
    logica interna:
    for (let i = 0; i < bytes.length; i++)
      bytes[i] ^= key[(i + bytes.length) % 53];
    obs2: valor entre 0 e 255. Por padrao 100
[y md5]
    cat arquivo | y md5
    cat md5 arquivo
[y sha1]
    cat arquivo | y sha1
    cat sha1 arquivo
[y sha256]
    cat arquivo | y sha256
    cat sha256 arquivo
[y aes]
    cat arquivo | y aes SENHA | y base64
    cat arquivo | y aes -e SENHA | y base64
    cat arquivo | y aes -d SENHA | y base64
    cat arquivo | y aes -e SENHA -md MD5 | y base64
    cat arquivo | y aes -e SENHA -md SHA256 | y base64
    cat arquivo | y aes -e SENHA -md SHA-256 | y base64
    cat arquivo | y aes -e SENHA -md MD5 -S AAAAAAAAAAAAAAAA | y base64
    obs: O comando "y aes -e SENHA -md MD5 -S AAAAAAAAAAAAAAAA" equivale à "openssl aes-256-cbc -e -k SENHA -md MD5 -S AAAAAAAAAAAAAAAA"
    obs2: O valor de salt(-S) deverá contér 16 hexas maiúsculos, ex: AAAAAAAAAAAAAAAA
    obs3: Se utilizar o salt na encriptacao, entao devera utilizar o mesmo salt na decriptacao
[y base64]
    cat arquivo | y base64
    cat arquivo | y base64 -d
    y base64 -e "texto"
    y base64 -d "YQ=="
    y printf "texto" | base64 -e 
    obs: -e para encode e -d para decode
[y grep]
    cat arquivo | y grep ^Texto$
    cat arquivo | y grep AB
    cat arquivo | y grep -i -v aa bb cc
[y wc]
    cat arquivo | y wc -l
    cat arquivo | y wc -w
    cat arquivo | y wc -c
    obs: conta. 
         l -> lines, w -> words, c -> chars
[y len]
    cat arquivo | y len
    obs: echo aabaa | tr b "\n" | y len
    result: 2
            2
[y head]
    cat arquivo | y head
    cat arquivo | y head -30
[y tail]
    cat arquivo | y tail
    cat arquivo | y tail -30
[y cut]
    cat arquivo | y cut -c-10
    cat arquivo | y cut -c5-10
    cat arquivo | y cut -c5-
    cat arquivo | y cut -c5
    cat arquivo | y cut -c5-10,15-17
[y yt]
    y yt
    obs: irá exibir a msg:
    cd D:\\ProgramFiles && python3 yt-dlp/yt_dlp/__main__.py http...
[y curl]
    echo '{"id":1}' | y curl \
        -H "Content-Type: application/json" \
        -H "other: other" \
        -X POST http://localhost:8080/v1/movies
    cat file | y curl \
        -H "Content-Type: application/json" \
        -X POST http://localhost:8080/v1/movies
    curl http://localhost:8080/v1/movies
    curl http://localhost:8080/v1/movies --limit-rate 20M
    obs: -v => verbose
    obs2: --header é o mesmo que -H
    obs3: -L segue location
    obs4: curl -s para silent. no y curl ele já é silencioso por padrao
    modelo com cookie: y curl -H "cookie: ips4_device_key=311a4bbe7ff5706d42ecc82e640ab727; ips4_member_id=178526; ips4_login_key=74e18a46894d354f5adfa7dc881de6d7;" example.com
[y cors]
    y cors
    y cors -port 4000
    y cors -ip 200.200.200.200 -port 4000
    y cors -sw "https://super" -sw "https://teste"
    obs: -sw significa startWith
    obs2: cors serve como bypass de "blocked by CORS policy"
    obs3: -sw é opcional, mas uma vez utilizado, só permitirá os valores informados pelos -sw
    obs4: o cors não usa stream, ou seja, captura 100% da resposta para depois transmitir.
    obs5: local host de ip classe C não funciona no browser
    exemplo de requisição js:
    var b_status=0;
    function b(url){
      if(location.href.indexOf('http://')!= 0){alert('cors nao pode ser executado nessa aba! somente em http://');return;}
      if(url.indexOf('?')>-1) url=url.split('?')[0]+'?base64?'+btoa(url);
      var xhr = new XMLHttpRequest();
      xhr.withCredentials = false;
      xhr.open("GET", url, false);
      xhr.overrideMimeType("text/plain; charset=x-user-defined");
      xhr.send(null);
      b_status=xhr.status;
      return xhr.responseText;
    }
    b('http://200.200.200.200:4000?https://site.com');
[y curlJson]
    y curlJson \
        -H "Content-Type: application/json" \
        -H "other: other" \
        http://localhost:8080/v1/movies \
        "[elem['id'] for elem in data]"
    obs: mistura de curl com json
[y [sed|tr]]
    cat arquivo | y sed A B
    cat arquivo | y sed A B E F
    obs: sed com dois parametros é performatico e aceita por exemplo \n como quebra
[y n]
    cat arquivo | y n
    obs: modifica arquivo \r\n para \n(se ja tiver \n nao tem problema)
[y rn]
    cat arquivo | y rn
    obs: modifica arquivo \n para \r\n(se ja tiver \r\n nao tem problema)
[y [bytesToInts|bi]]
    cat arquivo | y bytesToInts
    cat arquivo | y bi
    cat arquivo | y bi -128
    obs entrada: arquivo binario
    obs saida: lista de numeros bytes(0..255)
    obs2 bi == bytesToInts
[y [intsToBytes|ib]]
    echo 55 | y intsToBytes
    cat arquivo | y intsToBytes
    cat arquivo | y ib
    y intsToBytes 20 20
    y ib 20 20
    obs entrada: lista de numeros bytes(0..255)
    obs saida: arquivo binario
    obs2 por conceito, os bytes variam entre -128..127, mas aqui usaremos 0..255
    obs3 ib == intsToBytes
[y od]
    cat arquivo | od
    cat arquivo | od -bc
    cat arquivo | od -bcr
    obs: -r mostra numero bytes
         -b octal bytes
         -c character
[y touch]
    y touch fileA
    y touch fileA -3600
    y touch fileA 60
    y touch fileA 20210128235959
    y touch fileA fileB fileC
    y -p a/b/c
    obs: 60(60 segundos a frente)
    obs2: -3600(3600 segundos atrás)
    obs3: 20210128235959(setando em 28/01/2021 23:59:59)
    obs4: -p indica touch de pasta
    obs5: caminho superior será criado se nao existir, exemplo: pasta final existe como /a/b e touch file pedido é /a/b/c/d/e, as pastas intermediarias serao criadas.
[y rm]
    y rm file1 file2
    y rm -R pasta
    y rm -R pasta1 file1
    obs: por questão de segurança, link simbolico não pode ser apagado recursivamente com "-R", essa etapa é ignorada
    obs2: item simbolico pode ser apagado de modo comum, sem recursão. ex: y rm elemento
[y cp]
    y cp file1 file2
    y cp -R pasta1 pasta2
    obs: se a pasta2 nao existir entao é criado a cópia com o nome pasta2, se existir é copiado dentro da pasta(se dentro da pasta existir ai eh feito overwrite)
[y mv]
    y mv file1 file2
    y mv pasta1 pasta2
[y cd]
    y cd
    obs: equivalente a cd $HOME no linux e cd %userprofile% no windows
[y mkdir]
    y mkdir pasta1
[y iconv]
    y iconv -f UTF-8 -t ISO-8859-1 file
    cat file | y iconv -f UTF-8 -t ISO-8859-1 
    cat file | y i1
    cat file | y iconv -f ISO-8859-1 -t UTF-8
    cat file | y i2
    obs: tipos suportados: "ISO-8859-1","UTF-8","UTF-8BOM","UCS-2LE","UCS-2LEBOM"
    obs2: convert UTF-8 para ISO-8859-1(padrao windows, equivalente ao ANSI do notepad e equivalente ao windows-1252)
    obs3: BOM do UTF-8 em numerico => 239 187 191
    obs4: BOM do UCS-2LE em numerico => 255 254
[y tee]
    cat arquivo | y tee saida.txt
    programa.exe | y tee 2 # produz Stdout e Stderr
[y uniq]
    cat arquivo | y uniq
[y quebra]
    cat arquivo | y quebra
    cat arquivo | y quebra -len 5
[y seq]
    y seq 1 10 2
    y seq 5 7
    y seq 9 -10
    y seq 2022-09-19 2022-11-19
    y seq 19/11/2022 19/09/2022
[y tr]
    echo a a | y tr "a" "bb"
""" +
"Obs: no windows, usar \\\"\"\"\" ao invés de \"\\\"\"" +
"""
[y add]
    y add 2022-09-19
    y add 19/09/2022
[y awk]
    cat arquivo | y awk print 1 3 "5,6"
    cat arquivo | y awk print -1
    cat arquivo | y awk start AAA end BBB    
    cat arquivo | y awk start AAA
    cat arquivo | y awk end BBB    
    cat arquivo | y awk -v start AAA end BBB    
    cat arquivo | y awk -v start AAA
    cat arquivo | y awk -v end BBB    
    y cls && y cotacao BTC_BRL | y awk "{} {date} MAX {max-num} {date-max-num} {text ######################### in max-num}"
    alguns comandos:
        y cls && y cotacao BTC_BRL | y awk "{} {date} MAX {max-num} {date-max-num} {text ######################### in max-num}"
        y cls && y cotacao BTC_BRL | y awk "{} {date} MIN {min-num} {date-min-num} {text ######################### in min-num}"
        y cls && y cotacao BTC_BRL | y awk "{} MAX {date in max-num} {max-num}"
        y cls && y cotacao BTC_BRL | y awk "{text MIN in min-num} {min-num in min-num} {date in min-num}"
        y cls && y cotacao BTC_BRL | y awk "{text MAX in max-num} {max-num in max-num} {date in max-num}"
    obs: "-v" é a negativa
    obs2: start e end pode ocorrer varias vezes no texto
    obs3: -1 significa o ultimo
[y dev_null]
    cat arquivo | y banco buffer -n_lines 4000 -log buffer.log | y dev_null
    cat arquivo | y banco buffer -n_lines 4000 -log buffer.log > /dev/null
[y dev_in]
    y dev_in | y banco buffer -n_lines 4000 -log buffer.log | y dev_null
    y dev_in | y banco buffer -n_lines 4000 -log buffer.log > /dev/null
    obs: ref. a dd if e dd of
[y scp]
    y scp file1 user,pass@servidor:file2
    y scp file1 user,pass@servidor:file2 22
    y scp user,pass@servidor:file1 file2
    y scp user,pass@servidor:file1 file2 22
    comando windows:
    y scp user,pass@servidor:c:/tmp file2 22
    obs: user,pass ou user
[y execSsh]
    y execSsh user,pass@servidor command
    y execSsh user,pass@servidor command 22
    obs: user,pass ou user
[y ssh]
    y ssh user,pass@servidor
    y ssh user,pass@servidor 22
    obs: user,pass ou user(dependendo da origem e destino windows buga)
[y sshinfo]
    y sshinfo
    y sshinfo 192.168.0.100
    y sshinfo 192.168.0.100 22
[y sftp]
    y sftp user,pass@servidor
    y sftp user,pass@servidor 22
    obs: user,pass ou user
[y [serverRouter|sr]]
    y serverRouter [ipA] 8080 [ipB] 9090
    y serverRouter 192.168.0.100 8080 127.0.0.1 9090
    y serverRouter 192.168.0.100 8080 127.0.0.1 9090 show
    y serverRouter 192.168.0.100 8080 127.0.0.1 9090 showOnlySend
    y serverRouter 192.168.0.100 8080 127.0.0.1 9090 showOnlyReceive
    y serverRouter 192.168.0.100 8080 127.0.0.1 9090 showSimple
    y serverRouter 192.168.0.100 8080 127.0.0.1 9090 -log_ips d:/ProgramFiles/log_ips/log_8080.txt
    y serverRouter 192.168.0.100 8080 127.0.0.1 9090 -log_ips d:/ProgramFiles/log_ips/log_8080.txt -noLogLocal
    y serverRouter 127.0.0.1 8080 127.0.0.1 9090
    y serverRouter 127.0.0.1 8080 127.0.0.1 9090 show
    y serverRouter 127.0.0.1 8080 127.0.0.1 9090 showOnlySend
    y serverRouter 127.0.0.1 8080 127.0.0.1 9090 showOnlyReceive
    y serverRouter 127.0.0.1 8080 127.0.0.1 9090 showSimple
    obs:
        [ipA] -> Router -> [ipB]
        [ipA] conecta no router que conecta no [ipB]
   obs2, mais atributos opcionais:
        "-decodeSend" "12 0 26 6 0 0 0 0 0 0 0 0 0" "15 0 3 12 119 119 32 103 105 118 101 32 116 97 105 108"
        "-decodeReceive" "3 0 0 0 ..." "4 0 0 0"
        "-suprimeSend" "5 0 0 0"
        "-suprimeReceive" "5 0 0 0"
        -ips_banidos 2804:14d:ac80:8889::
        -xor 100
[y [httpServer|hs]]
    y httpServer
    set var="httpServer" "-mode" "playlist" "-host" "192.168.0.100" "-port" "8888" "-log_ips" "d:/ProgramFiles/log_ips/log_8888.txt" && y var
    set var="httpServer" "-mode" "playlist" "-host" "192.168.0.100" "-port" "8888" "-log_ips" "d:/ProgramFiles/log_ips/log_8888.txt" "-noLogLocal" && y var
    set var="httpServer" "-mode" "playlistmovie" "-host" "192.168.0.100" "-port" "8888" "-log_ips" "d:/ProgramFiles/log_ips/log_8888.txt" && y var
    set var="httpServer" "-mode" "playlistserver" "-host" "192.168.0.100" "-port" "8888" "-cfg" "d:/ProgramFiles/playlistserver.cfg" && y var
    set var="httpServer" "-mode" "webdav" "-port" "8888" "-pass" "admin,admin123,user,user123" && y var
    set var="httpServer" "-host" "192.168.0.100" "-port" "8100" "-redisDir" "D:\\ProgramFiles\redis" "-redisSeconds" "60" "-redisAll" "[ALL]" && y var
    windows:
    set var="httpServer" "-host" "127.0.0.1" "-port" "8888" "-titulo_url_token" "" "-titulo" "titulo" "-dir" "." "-endsWith" "" "-ips_banidos" "" "-log_ips" "" && y var
    linux:
    export var='"httpServer" "-host" "127.0.0.1" "-port" "8888" "-titulo_url_token" "" "-titulo" "titulo" "-dir" "." "-endsWith" "" "-ips_banidos" "" "-log_ips" ""' && y var
    Obs, valores padroes:
    host: 127.0.0.1
    port: 8888
    titulo_url_token: ""
    titulo: titulo
    Exemplo de endsWith: "jar,zip"
    Exemplo de ips_banidos: "8.8.8.8,4.4.4.4"
    Exemplo de log_ips: "c:\tmp\\ips.log"
    -redisDir ""
    -redisDir "c:\tmp\tmp" -redisSeconds "600" -redisAll "[ALL]" -redisLike "-playlistmovie-"
    -redisLike significa que consultas deverao ter esse prefixo, senao serao negados.    
    curl redis:
    y curl "http://site:1000/" -H "Redis-KEY: [ALL]"
    y curl "http://site:1000/" -H "Redis-KEY: user-playlistmovie-z2-*"
    y curl "http://site:1000/" -H "Redis-KEY: A" -H "Redis-VALUE: B"
    y curl "http://site:1000/" -H "Redis-DEL: A"
    y curl "http://site:1000/" -H "Redis-KEY: A" -H "Redis-VALUE: B" -H "Redis-ID: C" -H "Redis-SIGN: Y" # retorna 200 ou 203
    obs, como funciona o SIGN(add key value concorrente):
      Em caso de =>                   -H "Redis-KEY: A" -H "Redis-VALUE: B" -H "Redis-ID: C" -H "Redis-SIGN: Y" # ele retorna 200. "Redis-SIGN: Y" força o valor "C" para SIGN
      Em caso de um sign diferente => -H "Redis-KEY: A" -H "Redis-VALUE: B" -H "Redis-ID: C2"                   # ele retorna 203 negando a gravação, pois KEY A está com SIGN C e não C2.
    obs2: key iniciada com 'secret-' não é exibida nem com o comando configurado [ALL]
    obs3: -mode webdav só suporta os parametros -host, -port e -pass. No preenchimento de -pass é separado por virgula a cadeia user,senha,user,senha...
    obs4: o parametro -pass só esta implementado para o -mode webdav
[y [httpProxy|hp]]
    y httpProxy -ip localhost -port 8080 -verbose
[y wget]
    y wget -h
[y pwd]
    y pwd
[y find]
    y find
    y find .
    y find /
    y find . -mtime -1  # arquivos recentes de 1 dia para menos
    y find . -mtime 0.5 # arquivos recentes a mais de 12 horas
    y find . -type f # somente Files    
    y find -type f -pre "y cat" -pos "| y grep 'PESQUISA AQUI'" 
    obs: -L para navegar dentro do SymbolicLink, ex: y find / -L
    obs2: -type contem as opcoes f e d
[y ls]
    y ls
    y ls pasta1
    y ls "pas*"
[y lss]
    y lss
    y lss parta1
[y du]
    y du
    y du . -g
    ex: guia para limpeza de disco: D:\\>y du -g | y tr ".\\" "" | y grep -v "\\"
[y sleep]
    y sleep
    y sleep 0.22 # 0.22 seconds
    y sleep infinity
[y split]
    y cat fileA | y split -b 22
    y cat fileA | y split -l 22
    y cat fileA | y split --lines=22
    y cat fileA | y split --bytes=22
    y split --lines=22 --prefix=AA fileA # AAxxa
[y regua]
    y regua
    y regua 90
[y link]
    y link "source" "new_"
    y link "c:\\tmp\\source" "new_"
    comando windows: mklink /j "new_" "c:\\tmp\\source"
    comando nao windows: ln -s '/opt/source' 'new_'
    obs: se o volume nao for local, exemplo drive mapeado então deverá ser usado /D ao invés de /j do windows
[y os]
    y os
    obs: exibe informacoes do sistema operacional[windows/mac/linux/unix]
    obs2: whoami funciona no windows e linux
[y pss]
    y pss
    y pss " y lock "
    y pss "buscando" "nao buscando" "nao buscando"
[y pid]
    y pid 222
    Obs: onde 222 é o processId encontrado em y pss
[y date]
    y date
    y date "+%s" # epoch
    y date "+%s%N" # epochmili
    y date "+%Y%m%d_%H%M%S"
    y date "+%d/%m/%Y %H:%M:%S:%N %Z %s"
    y date "+%d/%m/%Y %H:%M:%S:%N %Z %s%N"    
    y date from "20240625_102251_345_America/Sao_Paulo" mask "+%Y%m%d_%H%M%S_%N_%z"
    y date "+%s%N" from "20240625_102251_345_America/Sao_Paulo" mask "+%Y%m%d_%H%M%S_%N_%z"
    y date "+%s%N" from "20240625_102251_345_UTC" mask "+%Y%m%d_%H%M%S_%N_%z"
    y date "+%s%N" from "20240625_102251_345_-03" mask "+%Y%m%d_%H%M%S_%N_%Z"
    y date "+%d/%m/%Y %H:%M:%S" from "20250525_230000_-05" mask "+%Y%m%d_%H%M%S_%z" # ET(Eastern Time) - America/New_York    - UTC−5/UTC−4 DST(Daylight Saving Time - algumas usam)
    y date "+%d/%m/%Y %H:%M:%S" from "20250525_230000_-08" mask "+%Y%m%d_%H%M%S_%z" # PT(Pacific Time) - America/Los_Angeles - UTC−8/UTC−7 DST(Daylight Saving Time - algumas usam)
    y date "+%d/%m/%Y %H:%M:%S" from "20250525_230000_-06" mask "+%Y%m%d_%H%M%S_%z" # CT(Central Time) - America/Mexico_City - UTC−6/UTC−5 DST(Daylight Saving Time - algumas usam)
    y date "+%d/%m/%Y %H:%M:%S:%N %Z %s%N" fromNTP time.google.com
    y date fromNTP _ && y date
    fromNTP's:
        y date fromNTP pool.ntp.org
        y date fromNTP time.google.com
        y date fromNTP time.windows.com
        y date fromNTP time.apple.com
        y date fromNTP ntp.ubuntu.com
        y date fromNTP time.nist.gov
        y date fromNTP ntp.br # NTP mantido pelo NIC.br (Núcleo de Informação e Coordenação do Ponto BR), ideal para usuários no Brasil.
        y date fromNTP ntp.pt
        y date fromNTP ntp.org
        y date fromNTP 0.africa.pool.ntp.org #(África)
        y date fromNTP 0.asia.pool.ntp.org #(Ásia)
        y date fromNTP 0.europe.pool.ntp.org #(Europa)
        y date fromNTP 0.north-america.pool.ntp.org #(América do Norte)
        y date fromNTP 0.oceania.pool.ntp.org #(Oceania)
        y date fromNTP 0.south-america.pool.ntp.org #(América do Sul)
        y date fromNTP 0.br.pool.ntp.org #(Brasil)
        y date fromNTP 0.us.pool.ntp.org #(Estados Unidos)
        y date fromNTP 0.de.pool.ntp.org #(Alemanha)
        y date fromNTP 0.fr.pool.ntp.org #(França)
        y date fromNTP 0.uk.pool.ntp.org #(Reino Unido)
        y date fromNTP 0.jp.pool.ntp.org #(Japão)
        y date fromNTP 0.au.pool.ntp.org #(Austrália)
        y date fromNTP 0.ca.pool.ntp.org #(Canadá)
        y date fromNTP 0.pt.pool.ntp.org #(Portugal)
        y date fromNTP 0.es.pool.ntp.org #(Espanha)
        y date fromNTP 0.it.pool.ntp.org #(Itália)
        y date fromNTP 0.ru.pool.ntp.org #(Rússia)
        y date fromNTP 0.cn.pool.ntp.org #(China)
        y date fromNTP 0.in.pool.ntp.org #(Índia)
        SET FDATE=%date:~-4,4%%date:~-10,2%%date:~-7,2%
[y uptime]
    y uptime
    y uptime -ms
[y cronometro]
    y cronometro
    y cronometro start
    y cronometro flag
    y cronometro end
    obs: "y cronometro" dispara o comando equivalente a flag a cada enter pressionado.
[y steam]
    y steam friends
    y steam friends status
    y steam friends clan status
    y steam status 232323
    y steam flag 76561198010207122 40
    y steam flag 76561198010207122 40 D:\\daemon\\scripts_geral\\steam_flag_1.bat
    obs: exige estar com o path TOKEN_Y configurado e o arquivo de nome steam contendo STEAM_API_KEY:STEAM_ID exemplo 123:232323
    obs2: cria sua STEAM_API_KEY aqui -> https://steamcommunity.com/dev/apikey -> 123
    obs3: pegue seu STEAM_ID no profile, exemplo -> https://steamcommunity.com/profiles/232323/ -> 232323
    modelo steam_flag_1.bat:
      d:
      cd D:\\daemon\\scripts_geral
      set tmp=audio.wav
      y mixer " TV " | y xargs echo "cmd /c \\"C:\\Program Files\\VideoLAN\\VLC\\vlc.exe\\" --mmdevice-audio-device={} --start-time=0 --gain=0.50 -Incurse --play-and-exit --no-video D:\\ProgramFiles\\musicas_soundPad_custom\\%tmp%" > steam_flag_2.bat
      call steam_flag_2.bat
[y clear]
    y clear
    obs: alternativa y cls
[y cls]
    y cls
    obs: alternativa y clear
[y ping]
    y ping 192.168.0.100
    y ping 192.168.0.100 -t 15
    obs: -t 15 => timeout 15 segundos
[y pings]
    y pings
    y pings -t 15
    obs: lista os ips ja fazendo ping
    obs2: -t 15 => timeout 15 segundos
[y pingMine]
    y pingMine mc.gladmc.com
    y pingMine mc.gladmc.com 25565
    y pingMine your_site -tray
    obs: autostart tray:
        criar atalho javaw em %appdata%\\..\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup
        e colocar no atalho -Dfile.encoding=UTF-8 -cp c:\\y;c:\\y\\ojdbc6.jar;c:\\y\\sqljdbc4-3.0.jar;c:\\y\\mysql-connector-java-8.0.26.jar;c:\\y\\jsch-0.1.55.jar Y pingMine your_site -tray
    obs2: o tray não mostra numeros acima de 9
[y ips]
    y ips
    y ips list
    obs: mostra ips da maquina
    obs2: list -> monta uma shell de verificacao de ips para outra maquina
[y mouse]
    y mouse # mostra as coordenadas do mouse
    y mouse "m 32 1009 c c m 927 467 cD cD s 2 cD cD s 9 m 64 1043 c c m 927 467 cD cD s 2 cD cD s 9" # away dota base baixa - Os Iluminados
    y mouse "m 177 879 c c m 927 467 cD cD s 2 cD cD s 9 m 209 910 c c m 927 467 cD cD s 2 cD cD s 9" # away dota base alta - Os Temidos
    y mouse "dontMove c s 0.01"
    y mouse f5 # click em alta velocidade 0.01 s
    obs: bloquear a tela faz o programa sair imediatamente
    mais opcoes:
    key w
    k w
    keypress w
    kp w
    keyrelease w
    kr w
[y mixer]
    y mixer
    y mixer " TV "
    obs: lista os mixers
    obs2: comandos parecidos:
    gravador, play, call, injectMicLine
[y gravador]
    y gravador file.wav
    y gravador > file.wav
    y gravador -mixer "-" -f file.wav
    y gravador -mixer "-" -line > fileLine
    y gravador -mixer "-" -line | y play -line    
    obs: formatos: -line, -wav e -mp3
    obs2: por padrão ele tentar ler wav
[y play]
    y play file.wav -volume 0.5
    y play -f file.wav
    y cat file.wav | y play
    y cat fileLine | y play -mixer "-" -line
    obs: formatos: -line, -wave e -mp3
    obs2: -mp3 ainda não implementado
    obs3: -volume varia entra 0 e 1 mas de acordo com o volume ja setado, ou seja, se ja tiver em 10% e o comando colocar 0.5 então seria equivalente a 5%
[y call]
    y call
    obs: ligação entra pessoas
[y remote]
    y remote
    y remote -ip localhost
    y remote -ip localhost -port 7777 -fps 30
    obs: fps pode conter 30 e 60. 30 é o padrão
[y injectMicLine]
    y cat file.line | y injectMicLine
    obs: not work
[y kill]
    y kill 3434
    y kill 3434 3435
    y kill -9 3434 3435
    y kill -2 3434 3435
    y kill text -Dnetbeans netbeans
    y kill "D:\\ProgramFiles\\site\\musicas\\cry"
    y kill "D:\\ProgramFiles\\site\\musicas\\cry\\Thomas Bergersen - Cry (Sun).mkv"
    obs: o kill de path só foi implementado para o windows
[y win]
    y win
    obs: mostra se o windows e office estão ativado
    obs2: outra forma de verificar pelo cmd -> slmgr -dli
[y speed]
    y speed
    y speed -ip 192.168.0.100
    Obs: -ip -port -server -client -send -receive|-r
[y lock]
    y lock
    y lock w
    y lock 0 -> desliga lock
    obs: gera black screen
    obs2: y lock w -> white screen
[y monitor]
    y monitor cpu
    y monitor cpu oneLine
[y printScreen]
    y printScreen
    y printScreen 2
    obs: pasta padrão: d:/ProgramFiles/screens
[y ocr]
    y ocr D:\\ProgramFiles\\screens\\sc_20250307_223317_533_3950.bmp
    y cat D:\\ProgramFiles\\screens\\sc_20250307_223317_533_3950.bmp | y ocr
    obs: é preciso instalar o programa tesseract
    download: https://github.com/tesseract-ocr/tesseract/releases/
    pasta instalado: "D:\\ProgramFiles\\Tesseract-OCR"
[y paste]
    y paste file1 file2
[y mkv]
    y mkv
    y mkv -v
    y mkv -force
    y mkv -lento
    exemplos: ffmpeg -i "A.mkv" -qscale 0 -max_muxing_queue_size 1024 "A.mp4"
              ffmpeg -i "A.wav" -qscale 0 -max_muxing_queue_size 1024 -af "volume=20dB" "A.mp4"
    obs: -lento tem outro algotirmo de conversão, as vezes é necessario e tudo tiver bugando
    dica rmvb para mp4: y ls | y grep .rmvb | y xargs echo "y echo 1 | ffmpeg -i {} -qscale 0 -max_muxing_queue_size 1024 {}Z" | y tr "rmvb\"Z" "mp4\""
    aviso: "Audio: ac3 (ac-3" de mp4 não funciona na web
    checando:
    cd d:\\ProgramFiles\\site\\series && y find | y grep mp4 | y grep -v png | y xargs ffmpeg -i | y grep "Input #0" "(por): Audio: ac3"
[y [thumbnail|tn]]
    y thumbnail
[y insta]
    y insta [url]
[y bmp]
    y cat img.bmp | y bmp
    y bmp -file a.bmp -len 64
    y cat img.bmp | y bmp -len 64 # modo assinatura de 64 ponto de largura, uso para comparação entre imagens
    # primeira linha x, segunda y, demais r g b
[y decodeUrl]
    echo T%C3%B3quio | y decodeUrl
[y encodeUrl]
    echo Tóquio | y encodeUrl
    obs: o espaço esta sendo representado como +, o que é uma tradução obsoleta.
[y test]
    y test
[y tests]
    y tests
[y controlc]
    y controlc
[y random]
    y random 1 2
[y talk]
    y talk list
    y talk -tts list
    y talk -textToSpeech list
    y talk -stt list
    y talk -speechToText list
    y talk oi
    y talk -lang Brazilian_Portuguese_Ricardo -msg oi
    y talk -lang Brazilian_Portuguese_Vitoria -msg "desliga esse computador, agora!" -o "d:/ProgramFiles/musicas_ia/talk.wav"
    y echo oi | y talk
    y talk -stt
    y talk -stt -lang English
    oi 1
    oi 2
    oi 3
    echo "一 二 三 四 五 六 七 八 九 十" | y talk -tts -lang Chinese_Mandarin_Zhiyu
    y talk -stt -lang Chinese -b | y talk -tts -lang Chinese_Mandarin_Zhiyu -b
    y talk -stt -lang Chinese
    obs: funções -tts => -textToSpeech #padrao #função acessa internet e faz cache na maquina por texto e voz
                 -stt => -speechToText
         -lang padrões:
                 Brazilian_Portuguese_Ricardo para -tts
                 Portugues para -stt
         -b:
                 mostra int-bytes no final da frase
[y sign]
    y sign -msg "Hello" -pass "My passphrase"
    y sign -verify -msg "Hello" -publicKey "MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAECA0o3fwUI5SpIb7sJjAeZsNzME2PsstRLerQyqRKKDKakcZYIWY+BOAhlakJROiKQoZn3JOO5UljNkFY2VwrWg==" -signature "MEQCIGfX7zpNdjcy5mtO53YZ43Ff2v5j9s8i2VykEVnyV1tCAiBEONmNS3ATFRN4MZ7/4u52jnIcBxJYcD606KcKT3T4oA=="
    obs: retornando true, significa assinatura ok
    obs2: Informações técnicas => SPEC "secp256r1" ALGO = "SHA256withECDSA"
    obs3: Não confundir com secp256k1 do bitcoin
[y [overflix|of]]
    y overflix "https://overflix.bar/assistir-rick-e-morty-dublado-online-3296/"
    y overflix -onlyLink "https://overflix.bar/assistir-rick-e-morty-dublado-online-3296/"
    y overflix -onlyPreLink "https://overflix.bar/assistir-rick-e-morty-dublado-online-3296/"    
    y overflix -v -onlyLink "https://overflix.bar/assistir-rick-e-morty-dublado-online-3296/?temporada=2"
    y overflix "https://encontre.us/assistir-ruptura-2x4-dublado-online-46643/" -outPath "D:\\ProgramFiles\\site\\series\\Ruptura"
    y overflix "https://encontre.us/assistir-anne-com-um-e-dublado-online-49039/" "getScriptRenameBySkip,7,10,10"
    obs: getScriptRenameBySkip só interpreta comandos skip, caso contrario baixa
    obs2: -vToken => mostra iexplorer.exe e não fecha.
         -o => force out path
         -tags => verbose profundo
         -i => libera token pelo chrome
[y connGui]
    connGui
    obs: teste de conexao(server e client)
[y var]
    y var
    Obs: execução por parametro de variavel
    windows:
    set var="cat" "a" && y var
    linux:
    export var='"cat" "a"' && y var
    export var='"cat" "a"' && y var -ignore FLAG_HERE
[y cotacao]
    y cotacao
    y cotacao BTC_BRL
    y cotacao BTC_BRL | y awk "{} {date} {max-num} {max-num in max-num}"
    obs: y cotacao BTC_BRL fica mostrando a cada 1 min
    obs2: veja também y help awk
    fonte: BTCBRL https://api.binance.com/api/v3/ticker/price
[y help]
    y help <command>
    y help router

Exemplos de conn: 
    y banco -conn "jdbc:oracle:thin:@//host_name:1521/service_name|login|senha" select "select 1"
    y banco -conn "jdbc:oracle:thin:@host_name:1566:sid_name|login|senha" select "select 1"
    y banco -conn "jdbc:sqlserver://localhost:1433;databaseName=MyDatabase;user=myUsername;password=myPassword;" select "select 1"
    y banco -conn "jdbc:mysql://localhost:3306|login|senha" select "select 1"
    y banco -conn "jdbc:postgresql://localhost:5432/|login|senha" select "select 1"

Observações:
entrada de dados pode ser feito por |
export STATUS_FIM_Y=path/fim.log para receber a confirmação de fim de processamento de selectCSV
export COUNT_Y=path/count.log para receber a quantidade de linhas geradas no CSV(sem o header) do comando selectCSV
export CSV_SEP_Y="|" para utilizar um separador diferente, pode ser usado tanto em leitura de csv quanto gravação
export CSV_ONLYCHAR_Y="S" usado para nao imprimir aspas duplas em numericos, pode ser usado na gravação de csv, quanto a leitura de csv nao precisa, a leitura ja interpreta automaticamente isso
export FORMAT_DATA_Y="TZ" deixando a data 10/10/2010T10:10:10Z
export FORMAT_DATA_Y="UTC" deixando a data 10/10/2010 10:10:10 UTC
export FORMAT_DATA_Y="NATAL" toda data será na data do natal ex 25/12/2010 10:10:15
export FORMAT_DATA_Y="YYYY-MM-DD" 2010-07-07 12:12:12
export COM_SEPARADOR_FINAL_CSV_Y="S" ex: "a";"a"; o padrao seria "a";"a"
export SEM_HEADER_CSV_Y="S"
todos os comandos acima podem ser usados como parametro, ex: -CSV_SEP_Y ","

Dica: copiar o arquivo hash do token pra o nome do banco. cd $TOKEN_Y;cp 38b3492c4405f98972ba17c0a3dc072d servidor;
Dica2: vendo os tokens: grep ":" $TOKEN_Y/*
Dica3: vendo warnnings ORA: cat $ORAs_Y
""";
        
        if ( caminho.equals("/y/ORAs") )
            return """
ORA-00911
ORA-00913
ORA-00917
ORA-00928
ORA-00933
ORA-00936
ORA-00947
ORA-00972
ORA-01756
ORA-01742
ORA-01747
ORA-01438
""";

        if ( caminho.equals("/y/sql_get_ddl_createtable") )
            return """
 with
        FUNCTION func_fix_create_table(p_campo CLOB) RETURN CLOB AS 
          vCampo     CLOB;
          vResultado CLOB;
          vC         VARCHAR2(2);
          vStart     VARCHAR2(1);
          vContador  number;
          
        BEGIN
          vCampo := p_campo;
          vStart := 'N';
          vResultado := '';
          vContador := 0;
        
          FOR i IN 1..LENGTH(vCampo)
          LOOP    
            vC := substr(vCampo,i,1);
            
            IF ( vC = '(' OR vC = 'C' OR vC = 'c' ) THEN
              vStart := 'S';
            END IF;
            
            IF ( vC = '(' ) THEN
              vContador := vContador + 1;
            END IF;
            
            IF ( vStart = 'S' ) THEN
              vResultado := vResultado || vC;
            END IF;
            
            IF ( vC = ')' ) THEN
              vContador := vContador - 1;
              IF ( vContador = 0 ) THEN          
                EXIT;
              END IF;
            END IF;
          END LOOP;
          
          return vResultado || ';';
          
        END func_fix_create_table;
        select func_fix_create_table(dbms_metadata.get_ddl('TABLE',UPPER('[TABELA]'),UPPER('[SCHEMA]'))) TXT from dual
""";

        if ( caminho.equals("/y/versao") )
            return "0.2.0";
        return "";
    }
}


